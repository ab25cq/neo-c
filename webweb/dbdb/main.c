/// typedef definition ///
typedef unsigned long size_t;

typedef char* string;

typedef unsigned long  long   ;

typedef __builtin_va_list __gnuc_va_list;

typedef unsigned char __u_char;

typedef unsigned short int __u_short;

typedef unsigned int __u_int;

typedef unsigned long  int __u_long;

typedef char __int8_t;

typedef unsigned char __uint8_t;

typedef short int __int16_t;

typedef unsigned short int __uint16_t;

typedef int __int32_t;

typedef unsigned int __uint32_t;

typedef long  int __int64_t;

typedef unsigned long  int __uint64_t;

typedef char __int_least8_t  ;

typedef unsigned char __uint_least8_t  ;

typedef short int __int_least16_t  ;

typedef unsigned short int __uint_least16_t  ;

typedef int __int_least32_t  ;

typedef unsigned int __uint_least32_t  ;

typedef long  int __int_least64_t  ;

typedef unsigned long  int __uint_least64_t  ;

typedef long  int __quad_t;

typedef unsigned long  int __u_quad_t;

typedef long  int __intmax_t;

typedef unsigned long  int __uintmax_t;

typedef unsigned long  int __dev_t;

typedef unsigned int __uid_t;

typedef unsigned int __gid_t;

typedef unsigned long  int __ino_t;

typedef unsigned long  int __ino64_t;

typedef unsigned int __mode_t;

typedef unsigned long  int __nlink_t;

typedef long  int __off_t;

typedef long  int __off64_t;

typedef int __pid_t;

typedef struct __fsid_t __fsid_t  ;

typedef long  int __clock_t;

typedef unsigned long  int __rlim_t;

typedef unsigned long  int __rlim64_t;

typedef unsigned int __id_t;

typedef long  int __time_t;

typedef unsigned int __useconds_t;

typedef long  int __suseconds_t;

typedef long  int __suseconds64_t;

typedef int __daddr_t;

typedef int __key_t;

typedef int __clockid_t;

typedef void* __timer_t;

typedef long  int __blksize_t;

typedef long  int __blkcnt_t;

typedef long  int __blkcnt64_t;

typedef unsigned long  int __fsblkcnt_t;

typedef unsigned long  int __fsblkcnt64_t;

typedef unsigned long  int __fsfilcnt_t;

typedef unsigned long  int __fsfilcnt64_t;

typedef long  int __fsword_t;

typedef long  int __ssize_t;

typedef long  int __syscall_slong_t;

typedef unsigned long  int __syscall_ulong_t;

typedef long  int __loff_t  ;

typedef char* __caddr_t;

typedef long  int __intptr_t;

typedef unsigned int __socklen_t;

typedef int __sig_atomic_t;

typedef struct anonymous_typeX1 __mbstate_t;

typedef struct _G_fpos_t __fpos_t  ;

typedef struct _G_fpos64_t __fpos64_t  ;

typedef struct _IO_FILE __FILE  ;

typedef struct _IO_FILE FILE  ;

typedef void _IO_lock_t;

typedef long  int (*cookie_read_function_t)(void*,char*,unsigned long);

typedef long  int (*cookie_write_function_t)(void*,const char*,unsigned long);

typedef int (*cookie_seek_function_t)(void*,long  int*,int);

typedef int (*cookie_close_function_t)(void*);

typedef struct _IO_cookie_io_functions_t cookie_io_functions_t  ;

typedef long  int off_t  ;

typedef long  int off64_t  ;

typedef long  int ssize_t  ;

typedef struct _G_fpos_t fpos_t  ;

typedef struct _G_fpos64_t fpos64_t  ;

typedef int wchar_t;

typedef struct anonymous_typeX4 div_t;

typedef struct anonymous_typeX5 ldiv_t;

typedef struct anonymous_typeX6 lldiv_t;

typedef struct __locale_struct* __locale_t  ;

typedef struct __locale_struct* locale_t  ;

typedef unsigned char u_char  ;

typedef unsigned short int u_short  ;

typedef unsigned int u_int  ;

typedef unsigned long  int u_long  ;

typedef long  int quad_t  ;

typedef unsigned long  int u_quad_t  ;

typedef struct __fsid_t fsid_t  ;

typedef long  int loff_t  ;

typedef unsigned long  int ino_t  ;

typedef unsigned long  int ino64_t  ;

typedef unsigned long  int dev_t  ;

typedef unsigned int gid_t  ;

typedef unsigned int mode_t  ;

typedef unsigned long  int nlink_t  ;

typedef unsigned int uid_t  ;

typedef int pid_t  ;

typedef unsigned int id_t  ;

typedef int daddr_t  ;

typedef char* caddr_t  ;

typedef int key_t  ;

typedef long  int clock_t  ;

typedef int clockid_t  ;

typedef long  int time_t  ;

typedef void* timer_t  ;

typedef unsigned int useconds_t  ;

typedef long  int suseconds_t  ;

typedef unsigned long  int ulong;

typedef unsigned short int ushort;

typedef unsigned int uint;

typedef char int8_t  ;

typedef short int int16_t  ;

typedef int int32_t  ;

typedef long  int int64_t  ;

typedef unsigned char u_int8_t  ;

typedef unsigned short int u_int16_t  ;

typedef unsigned int u_int32_t  ;

typedef unsigned long  int u_int64_t  ;

typedef int register_t __attribute__ ((__mode__ (__word__)));

typedef struct anonymous_typeX7 __sigset_t;

typedef struct anonymous_typeX7 sigset_t  ;

typedef long  int __fd_mask;

typedef struct anonymous_typeX8 fd_set;

typedef long  int fd_mask  ;

typedef long  int blksize_t  ;

typedef long  int blkcnt_t  ;

typedef unsigned long  int fsblkcnt_t  ;

typedef unsigned long  int fsfilcnt_t  ;

typedef long  int blkcnt64_t  ;

typedef unsigned long  int fsblkcnt64_t  ;

typedef unsigned long  int fsfilcnt64_t  ;

typedef union anonymous_typeZ9 __atomic_wide_counter;

typedef struct __pthread_internal_list __pthread_list_t  ;

typedef struct __pthread_internal_slist __pthread_slist_t  ;

typedef unsigned int __tss_t;

typedef unsigned long  int __thrd_t;

typedef struct anonymous_typeX11 __once_flag;

typedef unsigned long  int pthread_t;

typedef union anonymous_typeZ12 pthread_mutexattr_t;

typedef union anonymous_typeZ13 pthread_condattr_t;

typedef unsigned int pthread_key_t;

typedef int pthread_once_t;

typedef union pthread_attr_t pthread_attr_t  ;

typedef union anonymous_typeZ14 pthread_mutex_t;

typedef union anonymous_typeZ15 pthread_cond_t;

typedef union anonymous_typeZ16 pthread_rwlock_t;

typedef union anonymous_typeZ17 pthread_rwlockattr_t;

typedef int pthread_spinlock_t;

typedef union anonymous_typeZ18 pthread_barrier_t;

typedef union anonymous_typeZ19 pthread_barrierattr_t;

typedef int (*__compar_fn_t)(const void*,const void*);

typedef int (*comparison_fn_t)(const void*,const void*)  ;

typedef int (*__compar_d_fn_t)(const void*,const void*,void*);

typedef __builtin_va_list va_list;

typedef int error_t;

typedef struct re_program* re_t  ;

typedef struct re_capture re_capture  ;

typedef struct regex_t regex_t;

typedef struct re_program regex_program_t  ;

typedef struct anonymous_typeX24 compiler_state;

typedef struct anonymous_typeX25 match_context;

typedef unsigned int wint_t;

typedef struct anonymous_typeX1 mbstate_t  ;

typedef int* wstring  ;

typedef long  int intptr_t  ;

typedef unsigned int socklen_t  ;

typedef unsigned char uint8_t  ;

typedef unsigned short int uint16_t  ;

typedef unsigned int uint32_t  ;

typedef unsigned long  int uint64_t  ;

typedef unsigned short int sa_family_t;

typedef struct anonymous_typeX26 __kernel_fd_set;

typedef void (*__kernel_sighandler_t)(int);

typedef int __kernel_key_t;

typedef int __kernel_mqd_t;

typedef unsigned short int __kernel_old_uid_t;

typedef unsigned short int __kernel_old_gid_t;

typedef unsigned long  int __kernel_old_dev_t;

typedef long __kernel_long_t;

typedef unsigned long  int __kernel_ulong_t;

typedef unsigned long  int __kernel_ino_t  ;

typedef unsigned int __kernel_mode_t;

typedef int __kernel_pid_t;

typedef int __kernel_ipc_pid_t;

typedef unsigned int __kernel_uid_t;

typedef unsigned int __kernel_gid_t;

typedef long __kernel_suseconds_t  ;

typedef int __kernel_daddr_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_gid32_t;

typedef unsigned long  int __kernel_size_t  ;

typedef long __kernel_ssize_t  ;

typedef long __kernel_ptrdiff_t  ;

typedef struct anonymous_typeX27 __kernel_fsid_t;

typedef long __kernel_off_t  ;

typedef long long __kernel_loff_t;

typedef long __kernel_old_time_t  ;

typedef long __kernel_time_t  ;

typedef long long __kernel_time64_t;

typedef long __kernel_clock_t  ;

typedef int __kernel_timer_t;

typedef int __kernel_clockid_t;

typedef char* __kernel_caddr_t;

typedef unsigned short int __kernel_uid16_t;

typedef unsigned short int __kernel_gid16_t;

typedef struct sockaddr* __SOCKADDR_ARG  ;

typedef const struct sockaddr* __CONST_SOCKADDR_ARG  ;

typedef unsigned int in_addr_t  ;

typedef unsigned short int in_port_t  ;

typedef enum __itimer_which __itimer_which_t;

typedef struct stack_st OPENSSL_STACK;

typedef int (*OPENSSL_sk_compfunc)(const void*,const void*);

typedef void (*OPENSSL_sk_freefunc)(void*);

typedef void* (*OPENSSL_sk_copyfunc)(const void*);

typedef char* OPENSSL_STRING;

typedef const char* OPENSSL_CSTRING;

typedef int (*sk_OPENSSL_STRING_compfunc)(const char**,const char**);

typedef void (*sk_OPENSSL_STRING_freefunc)(char*);

typedef char* (*sk_OPENSSL_STRING_copyfunc)(const char*);

typedef int (*sk_OPENSSL_CSTRING_compfunc)(const char**,const char**);

typedef void (*sk_OPENSSL_CSTRING_freefunc)(char*);

typedef char* (*sk_OPENSSL_CSTRING_copyfunc)(const char*);

typedef void* OPENSSL_BLOCK;

typedef int (*sk_OPENSSL_BLOCK_compfunc)(const void**,const void**);

typedef void (*sk_OPENSSL_BLOCK_freefunc)(void*);

typedef void* (*sk_OPENSSL_BLOCK_copyfunc)(const void*);

typedef struct ossl_provider_st OSSL_PROVIDER;

typedef struct asn1_string_st ASN1_INTEGER;

typedef struct asn1_string_st ASN1_ENUMERATED;

typedef struct asn1_string_st ASN1_BIT_STRING;

typedef struct asn1_string_st ASN1_OCTET_STRING;

typedef struct asn1_string_st ASN1_PRINTABLESTRING;

typedef struct asn1_string_st ASN1_T61STRING;

typedef struct asn1_string_st ASN1_IA5STRING;

typedef struct asn1_string_st ASN1_GENERALSTRING;

typedef struct asn1_string_st ASN1_UNIVERSALSTRING;

typedef struct asn1_string_st ASN1_BMPSTRING;

typedef struct asn1_string_st ASN1_UTCTIME;

typedef struct asn1_string_st ASN1_TIME;

typedef struct asn1_string_st ASN1_GENERALIZEDTIME;

typedef struct asn1_string_st ASN1_VISIBLESTRING;

typedef struct asn1_string_st ASN1_UTF8STRING;

typedef struct asn1_string_st ASN1_STRING;

typedef int ASN1_BOOLEAN;

typedef int ASN1_NULL;

typedef struct asn1_type_st ASN1_TYPE;

typedef struct asn1_object_st ASN1_OBJECT;

typedef struct asn1_string_table_st ASN1_STRING_TABLE;

typedef struct ASN1_ITEM_st ASN1_ITEM;

typedef struct asn1_pctx_st ASN1_PCTX;

typedef struct asn1_sctx_st ASN1_SCTX;

typedef struct bio_st BIO;

typedef struct bignum_st BIGNUM;

typedef struct bignum_ctx BN_CTX;

typedef struct bn_blinding_st BN_BLINDING;

typedef struct bn_mont_ctx_st BN_MONT_CTX;

typedef struct bn_recp_ctx_st BN_RECP_CTX;

typedef struct bn_gencb_st BN_GENCB;

typedef struct buf_mem_st BUF_MEM;

typedef struct err_state_st ERR_STATE;

typedef struct evp_cipher_st EVP_CIPHER;

typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;

typedef struct evp_md_st EVP_MD;

typedef struct evp_md_ctx_st EVP_MD_CTX;

typedef struct evp_mac_st EVP_MAC;

typedef struct evp_mac_ctx_st EVP_MAC_CTX;

typedef struct evp_pkey_st EVP_PKEY;

typedef struct evp_skey_st EVP_SKEY;

typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;

typedef struct evp_pkey_method_st EVP_PKEY_METHOD;

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef struct evp_keymgmt_st EVP_KEYMGMT;

typedef struct evp_kdf_st EVP_KDF;

typedef struct evp_kdf_ctx_st EVP_KDF_CTX;

typedef struct evp_rand_st EVP_RAND;

typedef struct evp_rand_ctx_st EVP_RAND_CTX;

typedef struct evp_keyexch_st EVP_KEYEXCH;

typedef struct evp_signature_st EVP_SIGNATURE;

typedef struct evp_skeymgmt_st EVP_SKEYMGMT;

typedef struct evp_asym_cipher_st EVP_ASYM_CIPHER;

typedef struct evp_kem_st EVP_KEM;

typedef struct evp_Encode_Ctx_st EVP_ENCODE_CTX;

typedef struct hmac_ctx_st HMAC_CTX;

typedef struct dh_st DH;

typedef struct dh_method DH_METHOD;

typedef struct dsa_st DSA;

typedef struct dsa_method DSA_METHOD;

typedef struct rsa_st RSA;

typedef struct rsa_meth_st RSA_METHOD;

typedef struct rsa_pss_params_st RSA_PSS_PARAMS;

typedef struct ec_key_st EC_KEY;

typedef struct ec_key_method_st EC_KEY_METHOD;

typedef struct rand_meth_st RAND_METHOD;

typedef struct rand_drbg_st RAND_DRBG;

typedef struct ssl_dane_st SSL_DANE;

typedef struct x509_st X509;

typedef struct X509_algor_st X509_ALGOR;

typedef struct X509_crl_st X509_CRL;

typedef struct x509_crl_method_st X509_CRL_METHOD;

typedef struct x509_revoked_st X509_REVOKED;

typedef struct X509_name_st X509_NAME;

typedef struct X509_pubkey_st X509_PUBKEY;

typedef struct x509_store_st X509_STORE;

typedef struct x509_store_ctx_st X509_STORE_CTX;

typedef struct x509_object_st X509_OBJECT;

typedef struct x509_lookup_st X509_LOOKUP;

typedef struct x509_lookup_method_st X509_LOOKUP_METHOD;

typedef struct X509_VERIFY_PARAM_st X509_VERIFY_PARAM;

typedef struct x509_sig_info_st X509_SIG_INFO;

typedef struct pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;

typedef struct v3_ext_ctx X509V3_CTX;

typedef struct conf_st CONF;

typedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;

typedef struct ui_st UI;

typedef struct ui_method_st UI_METHOD;

typedef struct engine_st ENGINE;

typedef struct ssl_st SSL;

typedef struct ssl_ctx_st SSL_CTX;

typedef struct comp_ctx_st COMP_CTX;

typedef struct comp_method_st COMP_METHOD;

typedef struct X509_POLICY_NODE_st X509_POLICY_NODE;

typedef struct X509_POLICY_LEVEL_st X509_POLICY_LEVEL;

typedef struct X509_POLICY_TREE_st X509_POLICY_TREE;

typedef struct X509_POLICY_CACHE_st X509_POLICY_CACHE;

typedef struct AUTHORITY_KEYID_st AUTHORITY_KEYID;

typedef struct DIST_POINT_st DIST_POINT;

typedef struct ISSUING_DIST_POINT_st ISSUING_DIST_POINT;

typedef struct NAME_CONSTRAINTS_st NAME_CONSTRAINTS;

typedef struct crypto_ex_data_st CRYPTO_EX_DATA;

typedef struct ossl_http_req_ctx_st OSSL_HTTP_REQ_CTX;

typedef struct ocsp_response_st OCSP_RESPONSE;

typedef struct ocsp_responder_id_st OCSP_RESPID;

typedef struct sct_st SCT;

typedef struct sct_ctx_st SCT_CTX;

typedef struct ctlog_st CTLOG;

typedef struct ctlog_store_st CTLOG_STORE;

typedef struct ct_policy_eval_ctx_st CT_POLICY_EVAL_CTX;

typedef struct ossl_store_info_st OSSL_STORE_INFO;

typedef struct ossl_store_search_st OSSL_STORE_SEARCH;

typedef struct ossl_lib_ctx_st OSSL_LIB_CTX;

typedef struct ossl_dispatch_st OSSL_DISPATCH;

typedef struct ossl_item_st OSSL_ITEM;

typedef struct ossl_algorithm_st OSSL_ALGORITHM;

typedef struct ossl_param_st OSSL_PARAM;

typedef struct ossl_param_bld_st OSSL_PARAM_BLD;

typedef int (*pem_password_cb)(char*,int,int,void*);

typedef struct ossl_encoder_st OSSL_ENCODER;

typedef struct ossl_encoder_ctx_st OSSL_ENCODER_CTX;

typedef struct ossl_decoder_st OSSL_DECODER;

typedef struct ossl_decoder_ctx_st OSSL_DECODER_CTX;

typedef struct ossl_self_test_st OSSL_SELF_TEST;

typedef long ptrdiff_t;

typedef struct anonymous_typeX30 max_align_t;

typedef struct ossl_core_handle_st OSSL_CORE_HANDLE;

typedef struct openssl_core_ctx_st OPENSSL_CORE_CTX;

typedef struct ossl_core_bio_st OSSL_CORE_BIO;

typedef void (*OSSL_thread_stop_handler_fn)(void*);

typedef int (*OSSL_provider_init_fn)(const struct ossl_core_handle_st*,const struct ossl_dispatch_st*,const struct ossl_dispatch_st**,void**);

typedef int (*OSSL_CALLBACK)(const struct ossl_param_st,void*);

typedef int (*OSSL_INOUT_CALLBACK)(const struct ossl_param_st,struct ossl_param_st,void*);

typedef int (*OSSL_PASSPHRASE_CALLBACK)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*);

typedef struct anonymous_typeX31 CRYPTO_dynlock;

typedef void CRYPTO_RWLOCK;

typedef int (*sk_void_compfunc)(const void**,const void**);

typedef void (*sk_void_freefunc)(void*);

typedef void* (*sk_void_copyfunc)(const void*);

typedef void (*CRYPTO_EX_new)(void*,void*,struct crypto_ex_data_st*,int,long,void*);

typedef void (*CRYPTO_EX_free)(void*,void*,struct crypto_ex_data_st*,int,long,void*);

typedef int (*CRYPTO_EX_dup)(struct crypto_ex_data_st*,const struct crypto_ex_data_st*,void**,int,long,void*);

typedef struct crypto_threadid_st CRYPTO_THREADID  ;

typedef void* (*CRYPTO_malloc_fn)(unsigned long,const char*,int);

typedef void* (*CRYPTO_realloc_fn)(void*,unsigned long,const char*,int);

typedef void (*CRYPTO_free_fn)(void*,const char*,int);

typedef char __s8;

typedef unsigned char __u8;

typedef short __s16;

typedef unsigned short int __u16;

typedef int __s32;

typedef unsigned int __u32;

typedef long long __s64;

typedef unsigned long  long __u64;

typedef unsigned short int __le16  ;

typedef unsigned short int __be16  ;

typedef unsigned int __le32  ;

typedef unsigned int __be32  ;

typedef unsigned long  long __le64  ;

typedef unsigned long  long __be64  ;

typedef unsigned short int __sum16  ;

typedef unsigned int __wsum  ;

typedef unsigned int __poll_t;

typedef unsigned long  int __cpu_mask;

typedef struct anonymous_typeX32 cpu_set_t;

typedef struct anonymous_typeX33 __pthread_unwind_buf_t __attribute__ ((__aligned__));

typedef int CRYPTO_ONCE  ;

typedef unsigned int CRYPTO_THREAD_LOCAL  ;

typedef unsigned long  int CRYPTO_THREAD_ID  ;

typedef struct ssl_comp_st SSL_COMP;

typedef int (*sk_SSL_COMP_compfunc)(const struct ssl_comp_st**,const struct ssl_comp_st**);

typedef void (*sk_SSL_COMP_freefunc)(struct ssl_comp_st*);

typedef struct ssl_comp_st* (*sk_SSL_COMP_copyfunc)(const struct ssl_comp_st*);

typedef union bio_addr_st BIO_ADDR;

typedef struct bio_addrinfo_st BIO_ADDRINFO;

typedef long (*BIO_callback_fn)(struct bio_st*,int,const char*,int,long,long);

typedef long (*BIO_callback_fn_ex)(struct bio_st*,int,const char*,unsigned long,int,long,int,unsigned long*);

typedef struct bio_method_st BIO_METHOD;

typedef int (*BIO_info_cb)(struct bio_st*,int,int);

typedef int (*bio_info_cb)(struct bio_st*,int,int)  ;

typedef int (*sk_BIO_compfunc)(const struct bio_st**,const struct bio_st**);

typedef void (*sk_BIO_freefunc)(struct bio_st*);

typedef struct bio_st* (*sk_BIO_copyfunc)(const struct bio_st*);

typedef int (*asn1_ps_func)(struct bio_st*,unsigned char**,int*,void*);

typedef void (*BIO_dgram_sctp_notification_handler_fn)(struct bio_st*,void*,void*);

typedef struct bio_msg_st BIO_MSG  ;

typedef struct bio_mmsg_cb_args_st BIO_MMSG_CB_ARGS  ;

typedef struct bio_poll_descriptor_st BIO_POLL_DESCRIPTOR  ;

typedef int (*OSSL_INDICATOR_CALLBACK)(const char*,const char*,const struct ossl_param_st);

typedef void (*OSSL_FUNC)();

typedef const struct ossl_param_st* (*OSSL_FUNC_core_gettable_params_fn)(const struct ossl_core_handle_st*);

typedef int (*OSSL_FUNC_core_get_params_fn)(const struct ossl_core_handle_st*,struct ossl_param_st);

typedef int (*OSSL_FUNC_core_thread_start_fn)(const struct ossl_core_handle_st*,void (*)(void*),void*);

typedef struct openssl_core_ctx_st* (*OSSL_FUNC_core_get_libctx_fn)(const struct ossl_core_handle_st*);

typedef void (*OSSL_FUNC_core_new_error_fn)(const struct ossl_core_handle_st*);

typedef void (*OSSL_FUNC_core_set_error_debug_fn)(const struct ossl_core_handle_st*,const char*,int,const char*);

typedef void (*OSSL_FUNC_core_vset_error_fn)(const struct ossl_core_handle_st*,unsigned int,const char*,__builtin_va_list);

typedef int (*OSSL_FUNC_core_set_error_mark_fn)(const struct ossl_core_handle_st*);

typedef int (*OSSL_FUNC_core_clear_last_error_mark_fn)(const struct ossl_core_handle_st*);

typedef int (*OSSL_FUNC_core_pop_error_to_mark_fn)(const struct ossl_core_handle_st*);

typedef int (*OSSL_FUNC_core_obj_add_sigid_fn)(const struct ossl_core_handle_st*,const char*,const char*,const char*);

typedef int (*OSSL_FUNC_core_obj_create_fn)(const struct ossl_core_handle_st*,const char*,const char*,const char*);

typedef void* (*OSSL_FUNC_CRYPTO_malloc_fn)(unsigned long,const char*,int);

typedef void* (*OSSL_FUNC_CRYPTO_zalloc_fn)(unsigned long,const char*,int);

typedef void (*OSSL_FUNC_CRYPTO_free_fn)(void*,const char*,int);

typedef void (*OSSL_FUNC_CRYPTO_clear_free_fn)(void*,unsigned long,const char*,int);

typedef void* (*OSSL_FUNC_CRYPTO_realloc_fn)(void*,unsigned long,const char*,int);

typedef void* (*OSSL_FUNC_CRYPTO_clear_realloc_fn)(void*,unsigned long,unsigned long,const char*,int);

typedef void* (*OSSL_FUNC_CRYPTO_secure_malloc_fn)(unsigned long,const char*,int);

typedef void* (*OSSL_FUNC_CRYPTO_secure_zalloc_fn)(unsigned long,const char*,int);

typedef void (*OSSL_FUNC_CRYPTO_secure_free_fn)(void*,const char*,int);

typedef void (*OSSL_FUNC_CRYPTO_secure_clear_free_fn)(void*,unsigned long,const char*,int);

typedef int (*OSSL_FUNC_CRYPTO_secure_allocated_fn)(const void*);

typedef void (*OSSL_FUNC_OPENSSL_cleanse_fn)(void*,unsigned long);

typedef struct ossl_core_bio_st* (*OSSL_FUNC_BIO_new_file_fn)(const char*,const char*);

typedef struct ossl_core_bio_st* (*OSSL_FUNC_BIO_new_membuf_fn)(const void*,int);

typedef int (*OSSL_FUNC_BIO_read_ex_fn)(struct ossl_core_bio_st*,void*,unsigned long,unsigned long*);

typedef int (*OSSL_FUNC_BIO_write_ex_fn)(struct ossl_core_bio_st*,const void*,unsigned long,unsigned long*);

typedef int (*OSSL_FUNC_BIO_gets_fn)(struct ossl_core_bio_st*,char*,int);

typedef int (*OSSL_FUNC_BIO_puts_fn)(struct ossl_core_bio_st*,const char*);

typedef int (*OSSL_FUNC_BIO_up_ref_fn)(struct ossl_core_bio_st*);

typedef int (*OSSL_FUNC_BIO_free_fn)(struct ossl_core_bio_st*);

typedef int (*OSSL_FUNC_BIO_vprintf_fn)(struct ossl_core_bio_st*,const char*,__builtin_va_list);

typedef int (*OSSL_FUNC_BIO_vsnprintf_fn)(char*,unsigned long,const char*,__builtin_va_list);

typedef int (*OSSL_FUNC_BIO_ctrl_fn)(struct ossl_core_bio_st*,int,long,void*);

typedef void (*OSSL_FUNC_indicator_cb_fn)(struct openssl_core_ctx_st*,int (*)(const char*,const char*,const struct ossl_param_st));

typedef void (*OSSL_FUNC_self_test_cb_fn)(struct openssl_core_ctx_st*,int (*)(const struct ossl_param_st,void*),void**);

typedef unsigned long (*OSSL_FUNC_get_entropy_fn)(const struct ossl_core_handle_st*,unsigned char**,int,unsigned long,unsigned long);

typedef unsigned long (*OSSL_FUNC_get_user_entropy_fn)(const struct ossl_core_handle_st*,unsigned char**,int,unsigned long,unsigned long);

typedef void (*OSSL_FUNC_cleanup_entropy_fn)(const struct ossl_core_handle_st*,unsigned char*,unsigned long);

typedef void (*OSSL_FUNC_cleanup_user_entropy_fn)(const struct ossl_core_handle_st*,unsigned char*,unsigned long);

typedef unsigned long (*OSSL_FUNC_get_nonce_fn)(const struct ossl_core_handle_st*,unsigned char**,unsigned long,unsigned long,const void*,unsigned long);

typedef unsigned long (*OSSL_FUNC_get_user_nonce_fn)(const struct ossl_core_handle_st*,unsigned char**,unsigned long,unsigned long,const void*,unsigned long);

typedef void (*OSSL_FUNC_cleanup_nonce_fn)(const struct ossl_core_handle_st*,unsigned char*,unsigned long);

typedef void (*OSSL_FUNC_cleanup_user_nonce_fn)(const struct ossl_core_handle_st*,unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_provider_register_child_cb_fn)(const struct ossl_core_handle_st*,int (*)(const struct ossl_core_handle_st*,void*),int (*)(const struct ossl_core_handle_st*,void*),int (*)(const char*,void*),void*);

typedef void (*OSSL_FUNC_provider_deregister_child_cb_fn)(const struct ossl_core_handle_st*);

typedef const char* (*OSSL_FUNC_provider_name_fn)(const struct ossl_core_handle_st*);

typedef void* (*OSSL_FUNC_provider_get0_provider_ctx_fn)(const struct ossl_core_handle_st*);

typedef const struct ossl_dispatch_st* (*OSSL_FUNC_provider_get0_dispatch_fn)(const struct ossl_core_handle_st*);

typedef int (*OSSL_FUNC_provider_up_ref_fn)(const struct ossl_core_handle_st*,int);

typedef int (*OSSL_FUNC_provider_free_fn)(const struct ossl_core_handle_st*,int);

typedef int (*OSSL_FUNC_core_count_to_mark_fn)(const struct ossl_core_handle_st*);

typedef void (*OSSL_FUNC_provider_teardown_fn)(void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_provider_gettable_params_fn)(void*);

typedef int (*OSSL_FUNC_provider_get_params_fn)(void*,struct ossl_param_st);

typedef const struct ossl_algorithm_st* (*OSSL_FUNC_provider_query_operation_fn)(void*,int,int*);

typedef void (*OSSL_FUNC_provider_unquery_operation_fn)(void*,int,const struct ossl_algorithm_st*);

typedef const struct ossl_item_st* (*OSSL_FUNC_provider_get_reason_strings_fn)(void*);

typedef int (*OSSL_FUNC_provider_get_capabilities_fn)(void*,const char*,int (*)(const struct ossl_param_st,void*),void*);

typedef int (*OSSL_FUNC_provider_self_test_fn)(void*);

typedef int (*OSSL_FUNC_provider_random_bytes_fn)(void*,int,void*,unsigned long,unsigned int);

typedef int (*OSSL_FUNC_SSL_QUIC_TLS_crypto_send_fn)(struct ssl_st*,const unsigned char*,unsigned long,unsigned long*,void*);

typedef int (*OSSL_FUNC_SSL_QUIC_TLS_crypto_recv_rcd_fn)(struct ssl_st*,const unsigned char**,unsigned long*,void*);

typedef int (*OSSL_FUNC_SSL_QUIC_TLS_crypto_release_rcd_fn)(struct ssl_st*,unsigned long,void*);

typedef int (*OSSL_FUNC_SSL_QUIC_TLS_yield_secret_fn)(struct ssl_st*,unsigned int,int,const unsigned char*,unsigned long,void*);

typedef int (*OSSL_FUNC_SSL_QUIC_TLS_got_transport_params_fn)(struct ssl_st*,const unsigned char*,unsigned long,void*);

typedef int (*OSSL_FUNC_SSL_QUIC_TLS_alert_fn)(struct ssl_st*,unsigned char,void*);

typedef void* (*OSSL_FUNC_digest_newctx_fn)(void*);

typedef int (*OSSL_FUNC_digest_init_fn)(void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_digest_update_fn)(void*,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_digest_final_fn)(void*,unsigned char*,unsigned long*,unsigned long);

typedef int (*OSSL_FUNC_digest_squeeze_fn)(void*,unsigned char*,unsigned long*,unsigned long);

typedef int (*OSSL_FUNC_digest_digest_fn)(void*,const unsigned char*,unsigned long,unsigned char*,unsigned long*,unsigned long);

typedef void (*OSSL_FUNC_digest_freectx_fn)(void*);

typedef void* (*OSSL_FUNC_digest_dupctx_fn)(void*);

typedef void (*OSSL_FUNC_digest_copyctx_fn)(void*,void*);

typedef int (*OSSL_FUNC_digest_get_params_fn)(struct ossl_param_st);

typedef int (*OSSL_FUNC_digest_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_digest_get_ctx_params_fn)(void*,struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_digest_gettable_params_fn)(void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_digest_settable_ctx_params_fn)(void*,void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_digest_gettable_ctx_params_fn)(void*,void*);

typedef void* (*OSSL_FUNC_cipher_newctx_fn)(void*);

typedef int (*OSSL_FUNC_cipher_encrypt_init_fn)(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long,const struct ossl_param_st);

typedef int (*OSSL_FUNC_cipher_decrypt_init_fn)(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long,const struct ossl_param_st);

typedef int (*OSSL_FUNC_cipher_update_fn)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_cipher_final_fn)(void*,unsigned char*,unsigned long*,unsigned long);

typedef int (*OSSL_FUNC_cipher_cipher_fn)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_cipher_pipeline_encrypt_init_fn)(void*,const unsigned char*,unsigned long,unsigned long,const unsigned char**,unsigned long,const struct ossl_param_st);

typedef int (*OSSL_FUNC_cipher_pipeline_decrypt_init_fn)(void*,const unsigned char*,unsigned long,unsigned long,const unsigned char**,unsigned long,const struct ossl_param_st);

typedef int (*OSSL_FUNC_cipher_pipeline_update_fn)(void*,unsigned long,unsigned char**,unsigned long*,const unsigned long*,const unsigned char**,const unsigned long*);

typedef int (*OSSL_FUNC_cipher_pipeline_final_fn)(void*,unsigned long,unsigned char**,unsigned long*,const unsigned long*);

typedef void (*OSSL_FUNC_cipher_freectx_fn)(void*);

typedef void* (*OSSL_FUNC_cipher_dupctx_fn)(void*);

typedef int (*OSSL_FUNC_cipher_get_params_fn)(struct ossl_param_st);

typedef int (*OSSL_FUNC_cipher_get_ctx_params_fn)(void*,struct ossl_param_st);

typedef int (*OSSL_FUNC_cipher_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_cipher_gettable_params_fn)(void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_cipher_settable_ctx_params_fn)(void*,void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_cipher_gettable_ctx_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_cipher_encrypt_skey_init_fn)(void*,void*,const unsigned char*,unsigned long,const struct ossl_param_st);

typedef int (*OSSL_FUNC_cipher_decrypt_skey_init_fn)(void*,void*,const unsigned char*,unsigned long,const struct ossl_param_st);

typedef void* (*OSSL_FUNC_mac_newctx_fn)(void*);

typedef void* (*OSSL_FUNC_mac_dupctx_fn)(void*);

typedef void (*OSSL_FUNC_mac_freectx_fn)(void*);

typedef int (*OSSL_FUNC_mac_init_fn)(void*,const unsigned char*,unsigned long,const struct ossl_param_st);

typedef int (*OSSL_FUNC_mac_update_fn)(void*,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_mac_final_fn)(void*,unsigned char*,unsigned long*,unsigned long);

typedef const struct ossl_param_st* (*OSSL_FUNC_mac_gettable_params_fn)(void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_mac_gettable_ctx_params_fn)(void*,void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_mac_settable_ctx_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_mac_get_params_fn)(struct ossl_param_st);

typedef int (*OSSL_FUNC_mac_get_ctx_params_fn)(void*,struct ossl_param_st);

typedef int (*OSSL_FUNC_mac_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_mac_init_skey_fn)(void*,void*,const struct ossl_param_st);

typedef void* (*OSSL_FUNC_kdf_newctx_fn)(void*);

typedef void* (*OSSL_FUNC_kdf_dupctx_fn)(void*);

typedef void (*OSSL_FUNC_kdf_freectx_fn)(void*);

typedef void (*OSSL_FUNC_kdf_reset_fn)(void*);

typedef int (*OSSL_FUNC_kdf_derive_fn)(void*,unsigned char*,unsigned long,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_kdf_gettable_params_fn)(void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_kdf_gettable_ctx_params_fn)(void*,void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_kdf_settable_ctx_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_kdf_get_params_fn)(struct ossl_param_st);

typedef int (*OSSL_FUNC_kdf_get_ctx_params_fn)(void*,struct ossl_param_st);

typedef int (*OSSL_FUNC_kdf_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef void* (*OSSL_FUNC_rand_newctx_fn)(void*,void*,const struct ossl_dispatch_st*);

typedef void (*OSSL_FUNC_rand_freectx_fn)(void*);

typedef int (*OSSL_FUNC_rand_instantiate_fn)(void*,unsigned int,int,const unsigned char*,unsigned long,const struct ossl_param_st);

typedef int (*OSSL_FUNC_rand_uninstantiate_fn)(void*);

typedef int (*OSSL_FUNC_rand_generate_fn)(void*,unsigned char*,unsigned long,unsigned int,int,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_rand_reseed_fn)(void*,int,const unsigned char*,unsigned long,const unsigned char*,unsigned long);

typedef unsigned long (*OSSL_FUNC_rand_nonce_fn)(void*,unsigned char*,unsigned int,unsigned long,unsigned long);

typedef int (*OSSL_FUNC_rand_enable_locking_fn)(void*);

typedef int (*OSSL_FUNC_rand_lock_fn)(void*);

typedef void (*OSSL_FUNC_rand_unlock_fn)(void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_rand_gettable_params_fn)(void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_rand_gettable_ctx_params_fn)(void*,void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_rand_settable_ctx_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_rand_get_params_fn)(struct ossl_param_st);

typedef int (*OSSL_FUNC_rand_get_ctx_params_fn)(void*,struct ossl_param_st);

typedef int (*OSSL_FUNC_rand_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef void (*OSSL_FUNC_rand_set_callbacks_fn)(void*,int (*)(const struct ossl_param_st,struct ossl_param_st,void*),int (*)(const struct ossl_param_st,void*),int (*)(const struct ossl_param_st,struct ossl_param_st,void*),int (*)(const struct ossl_param_st,void*),void*);

typedef int (*OSSL_FUNC_rand_verify_zeroization_fn)(void*);

typedef unsigned long (*OSSL_FUNC_rand_get_seed_fn)(void*,unsigned char**,int,unsigned long,unsigned long,int,const unsigned char*,unsigned long);

typedef void (*OSSL_FUNC_rand_clear_seed_fn)(void*,unsigned char*,unsigned long);

typedef void* (*OSSL_FUNC_keymgmt_new_fn)(void*);

typedef void* (*OSSL_FUNC_keymgmt_gen_init_fn)(void*,int,const struct ossl_param_st);

typedef int (*OSSL_FUNC_keymgmt_gen_set_template_fn)(void*,void*);

typedef int (*OSSL_FUNC_keymgmt_gen_set_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_keymgmt_gen_settable_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_keymgmt_gen_get_params_fn)(void*,struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_keymgmt_gen_gettable_params_fn)(void*,void*);

typedef void* (*OSSL_FUNC_keymgmt_gen_fn)(void*,int (*)(const struct ossl_param_st,void*),void*);

typedef void (*OSSL_FUNC_keymgmt_gen_cleanup_fn)(void*);

typedef void* (*OSSL_FUNC_keymgmt_load_fn)(const void*,unsigned long);

typedef void (*OSSL_FUNC_keymgmt_free_fn)(void*);

typedef int (*OSSL_FUNC_keymgmt_get_params_fn)(void*,struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_keymgmt_gettable_params_fn)(void*);

typedef int (*OSSL_FUNC_keymgmt_set_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_keymgmt_settable_params_fn)(void*);

typedef const char* (*OSSL_FUNC_keymgmt_query_operation_name_fn)(int);

typedef int (*OSSL_FUNC_keymgmt_has_fn)(const void*,int);

typedef int (*OSSL_FUNC_keymgmt_validate_fn)(const void*,int,int);

typedef int (*OSSL_FUNC_keymgmt_match_fn)(const void*,const void*,int);

typedef int (*OSSL_FUNC_keymgmt_import_fn)(void*,int,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_keymgmt_import_types_fn)(int);

typedef int (*OSSL_FUNC_keymgmt_export_fn)(void*,int,int (*)(const struct ossl_param_st,void*),void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_keymgmt_export_types_fn)(int);

typedef void* (*OSSL_FUNC_keymgmt_dup_fn)(const void*,int);

typedef const struct ossl_param_st* (*OSSL_FUNC_keymgmt_import_types_ex_fn)(void*,int);

typedef const struct ossl_param_st* (*OSSL_FUNC_keymgmt_export_types_ex_fn)(void*,int);

typedef void* (*OSSL_FUNC_keyexch_newctx_fn)(void*);

typedef int (*OSSL_FUNC_keyexch_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_keyexch_derive_fn)(void*,unsigned char*,unsigned long*,unsigned long);

typedef int (*OSSL_FUNC_keyexch_set_peer_fn)(void*,void*);

typedef void (*OSSL_FUNC_keyexch_freectx_fn)(void*);

typedef void* (*OSSL_FUNC_keyexch_dupctx_fn)(void*);

typedef int (*OSSL_FUNC_keyexch_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_keyexch_settable_ctx_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_keyexch_get_ctx_params_fn)(void*,struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_keyexch_gettable_ctx_params_fn)(void*,void*);

typedef void* (*OSSL_FUNC_signature_newctx_fn)(void*,const char*);

typedef int (*OSSL_FUNC_signature_sign_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_signature_sign_fn)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_signature_sign_message_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_signature_sign_message_update_fn)(void*,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_signature_sign_message_final_fn)(void*,unsigned char*,unsigned long*,unsigned long);

typedef int (*OSSL_FUNC_signature_verify_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_signature_verify_fn)(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_signature_verify_message_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_signature_verify_message_update_fn)(void*,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_signature_verify_message_final_fn)(void*);

typedef int (*OSSL_FUNC_signature_verify_recover_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_signature_verify_recover_fn)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_signature_digest_sign_init_fn)(void*,const char*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_signature_digest_sign_update_fn)(void*,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_signature_digest_sign_final_fn)(void*,unsigned char*,unsigned long*,unsigned long);

typedef int (*OSSL_FUNC_signature_digest_sign_fn)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_signature_digest_verify_init_fn)(void*,const char*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_signature_digest_verify_update_fn)(void*,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_signature_digest_verify_final_fn)(void*,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_signature_digest_verify_fn)(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long);

typedef void (*OSSL_FUNC_signature_freectx_fn)(void*);

typedef void* (*OSSL_FUNC_signature_dupctx_fn)(void*);

typedef int (*OSSL_FUNC_signature_get_ctx_params_fn)(void*,struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_signature_gettable_ctx_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_signature_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_signature_settable_ctx_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_signature_get_ctx_md_params_fn)(void*,struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_signature_gettable_ctx_md_params_fn)(void*);

typedef int (*OSSL_FUNC_signature_set_ctx_md_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_signature_settable_ctx_md_params_fn)(void*);

typedef const char** (*OSSL_FUNC_signature_query_key_types_fn)();

typedef void (*OSSL_FUNC_skeymgmt_free_fn)(void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_skeymgmt_imp_settable_params_fn)(void*);

typedef void* (*OSSL_FUNC_skeymgmt_import_fn)(void*,int,const struct ossl_param_st);

typedef int (*OSSL_FUNC_skeymgmt_export_fn)(void*,int,int (*)(const struct ossl_param_st,void*),void*);

typedef const struct ossl_param_st* (*OSSL_FUNC_skeymgmt_gen_settable_params_fn)(void*);

typedef void* (*OSSL_FUNC_skeymgmt_generate_fn)(void*,const struct ossl_param_st);

typedef const char* (*OSSL_FUNC_skeymgmt_get_key_id_fn)(void*);

typedef void* (*OSSL_FUNC_asym_cipher_newctx_fn)(void*);

typedef int (*OSSL_FUNC_asym_cipher_encrypt_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_asym_cipher_encrypt_fn)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long);

typedef int (*OSSL_FUNC_asym_cipher_decrypt_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_asym_cipher_decrypt_fn)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long);

typedef void (*OSSL_FUNC_asym_cipher_freectx_fn)(void*);

typedef void* (*OSSL_FUNC_asym_cipher_dupctx_fn)(void*);

typedef int (*OSSL_FUNC_asym_cipher_get_ctx_params_fn)(void*,struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_asym_cipher_gettable_ctx_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_asym_cipher_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_asym_cipher_settable_ctx_params_fn)(void*,void*);

typedef void* (*OSSL_FUNC_kem_newctx_fn)(void*);

typedef int (*OSSL_FUNC_kem_encapsulate_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_kem_auth_encapsulate_init_fn)(void*,void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_kem_encapsulate_fn)(void*,unsigned char*,unsigned long*,unsigned char*,unsigned long*);

typedef int (*OSSL_FUNC_kem_decapsulate_init_fn)(void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_kem_auth_decapsulate_init_fn)(void*,void*,void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_kem_decapsulate_fn)(void*,unsigned char*,unsigned long*,const unsigned char*,unsigned long);

typedef void (*OSSL_FUNC_kem_freectx_fn)(void*);

typedef void* (*OSSL_FUNC_kem_dupctx_fn)(void*);

typedef int (*OSSL_FUNC_kem_get_ctx_params_fn)(void*,struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_kem_gettable_ctx_params_fn)(void*,void*);

typedef int (*OSSL_FUNC_kem_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_kem_settable_ctx_params_fn)(void*,void*);

typedef void* (*OSSL_FUNC_encoder_newctx_fn)(void*);

typedef void (*OSSL_FUNC_encoder_freectx_fn)(void*);

typedef int (*OSSL_FUNC_encoder_get_params_fn)(struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_encoder_gettable_params_fn)(void*);

typedef int (*OSSL_FUNC_encoder_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_encoder_settable_ctx_params_fn)(void*);

typedef int (*OSSL_FUNC_encoder_does_selection_fn)(void*,int);

typedef int (*OSSL_FUNC_encoder_encode_fn)(void*,struct ossl_core_bio_st*,const void*,const struct ossl_param_st,int,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*);

typedef void* (*OSSL_FUNC_encoder_import_object_fn)(void*,int,const struct ossl_param_st);

typedef void (*OSSL_FUNC_encoder_free_object_fn)(void*);

typedef void* (*OSSL_FUNC_decoder_newctx_fn)(void*);

typedef void (*OSSL_FUNC_decoder_freectx_fn)(void*);

typedef int (*OSSL_FUNC_decoder_get_params_fn)(struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_decoder_gettable_params_fn)(void*);

typedef int (*OSSL_FUNC_decoder_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef const struct ossl_param_st* (*OSSL_FUNC_decoder_settable_ctx_params_fn)(void*);

typedef int (*OSSL_FUNC_decoder_does_selection_fn)(void*,int);

typedef int (*OSSL_FUNC_decoder_decode_fn)(void*,struct ossl_core_bio_st*,int,int (*)(const struct ossl_param_st,void*),void*,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*);

typedef int (*OSSL_FUNC_decoder_export_object_fn)(void*,const void*,unsigned long,int (*)(const struct ossl_param_st,void*),void*);

typedef void* (*OSSL_FUNC_store_open_fn)(void*,const char*);

typedef void* (*OSSL_FUNC_store_attach_fn)(void*,struct ossl_core_bio_st*);

typedef const struct ossl_param_st* (*OSSL_FUNC_store_settable_ctx_params_fn)(void*);

typedef int (*OSSL_FUNC_store_set_ctx_params_fn)(void*,const struct ossl_param_st);

typedef int (*OSSL_FUNC_store_load_fn)(void*,int (*)(const struct ossl_param_st,void*),void*,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*);

typedef int (*OSSL_FUNC_store_eof_fn)(void*);

typedef int (*OSSL_FUNC_store_close_fn)(void*);

typedef int (*OSSL_FUNC_store_export_object_fn)(void*,const void*,unsigned long,int (*)(const struct ossl_param_st,void*),void*);

typedef int (*OSSL_FUNC_store_delete_fn)(void*,const char*,const struct ossl_param_st,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*);

typedef void* (*OSSL_FUNC_store_open_ex_fn)(void*,const char*,const struct ossl_param_st,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*);

typedef int (*sk_X509_ALGOR_compfunc)(const struct X509_algor_st**,const struct X509_algor_st**);

typedef void (*sk_X509_ALGOR_freefunc)(struct X509_algor_st*);

typedef struct X509_algor_st* (*sk_X509_ALGOR_copyfunc)(const struct X509_algor_st*);

typedef struct ASN1_ENCODING_st ASN1_ENCODING  ;

typedef int (*sk_ASN1_STRING_TABLE_compfunc)(const struct asn1_string_table_st**,const struct asn1_string_table_st**);

typedef void (*sk_ASN1_STRING_TABLE_freefunc)(struct asn1_string_table_st*);

typedef struct asn1_string_table_st* (*sk_ASN1_STRING_TABLE_copyfunc)(const struct asn1_string_table_st*);

typedef struct ASN1_TEMPLATE_st ASN1_TEMPLATE;

typedef struct ASN1_TLC_st ASN1_TLC;

typedef struct ASN1_VALUE_st ASN1_VALUE;

typedef void* (*d2i_of_void)(void**,const unsigned char**,long);

typedef int (*i2d_of_void)(const void*,unsigned char**);

typedef int (*OSSL_i2d_of_void_ctx)(const void*,unsigned char**,void*);

typedef const struct ASN1_ITEM_st* (*ASN1_ITEM_EXP)();

typedef int (*sk_ASN1_TYPE_compfunc)(const struct asn1_type_st**,const struct asn1_type_st**);

typedef void (*sk_ASN1_TYPE_freefunc)(struct asn1_type_st*);

typedef struct asn1_type_st* (*sk_ASN1_TYPE_copyfunc)(const struct asn1_type_st*);

typedef struct stack_st_ASN1_TYPE ASN1_SEQUENCE_ANY  ;

typedef struct BIT_STRING_BITNAME_st BIT_STRING_BITNAME  ;

typedef int (*sk_ASN1_OBJECT_compfunc)(const struct asn1_object_st**,const struct asn1_object_st**);

typedef void (*sk_ASN1_OBJECT_freefunc)(struct asn1_object_st*);

typedef struct asn1_object_st* (*sk_ASN1_OBJECT_copyfunc)(const struct asn1_object_st*);

typedef int (*sk_ASN1_INTEGER_compfunc)(const struct asn1_string_st**,const struct asn1_string_st**);

typedef void (*sk_ASN1_INTEGER_freefunc)(struct asn1_string_st*);

typedef struct asn1_string_st* (*sk_ASN1_INTEGER_copyfunc)(const struct asn1_string_st*);

typedef int (*sk_ASN1_UTF8STRING_compfunc)(const struct asn1_string_st**,const struct asn1_string_st**);

typedef void (*sk_ASN1_UTF8STRING_freefunc)(struct asn1_string_st*);

typedef struct asn1_string_st* (*sk_ASN1_UTF8STRING_copyfunc)(const struct asn1_string_st*);

typedef int (*sk_ASN1_GENERALSTRING_compfunc)(const struct asn1_string_st**,const struct asn1_string_st**);

typedef void (*sk_ASN1_GENERALSTRING_freefunc)(struct asn1_string_st*);

typedef struct asn1_string_st* (*sk_ASN1_GENERALSTRING_copyfunc)(const struct asn1_string_st*);

typedef struct obj_name_st OBJ_NAME  ;

typedef struct anonymous_typeX38 EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM;

typedef struct evp_cipher_info_st EVP_CIPHER_INFO  ;

typedef int (*EVP_PBE_KEYGEN)(struct evp_cipher_ctx_st*,const char*,int,struct asn1_type_st*,const struct evp_cipher_st*,const struct evp_md_st*,int);

typedef int (*EVP_PBE_KEYGEN_EX)(struct evp_cipher_ctx_st*,const char*,int,struct asn1_type_st*,const struct evp_cipher_st*,const struct evp_md_st*,int,struct ossl_lib_ctx_st*,const char*);

typedef int (*EVP_PKEY_gen_cb)(struct evp_pkey_ctx_st*);

typedef enum anonymous_typeY38 point_conversion_form_t;

typedef struct ec_method_st EC_METHOD;

typedef struct ec_group_st EC_GROUP;

typedef struct ec_point_st EC_POINT;

typedef struct ecpk_parameters_st ECPKPARAMETERS;

typedef struct ec_parameters_st ECPARAMETERS;

typedef struct anonymous_typeX39 EC_builtin_curve;

typedef struct ECDSA_SIG_st ECDSA_SIG;

typedef struct rsa_oaep_params_st RSA_OAEP_PARAMS  ;

typedef struct DSA_SIG_st DSA_SIG;

typedef struct SHAstate_st SHA_CTX  ;

typedef struct SHA256state_st SHA256_CTX  ;

typedef struct SHA512state_st SHA512_CTX  ;

typedef int (*sk_X509_NAME_compfunc)(const struct X509_name_st**,const struct X509_name_st**);

typedef void (*sk_X509_NAME_freefunc)(struct X509_name_st*);

typedef struct X509_name_st* (*sk_X509_NAME_copyfunc)(const struct X509_name_st*);

typedef int (*sk_X509_compfunc)(const struct x509_st**,const struct x509_st**);

typedef void (*sk_X509_freefunc)(struct x509_st*);

typedef struct x509_st* (*sk_X509_copyfunc)(const struct x509_st*);

typedef int (*sk_X509_REVOKED_compfunc)(const struct x509_revoked_st**,const struct x509_revoked_st**);

typedef void (*sk_X509_REVOKED_freefunc)(struct x509_revoked_st*);

typedef struct x509_revoked_st* (*sk_X509_REVOKED_copyfunc)(const struct x509_revoked_st*);

typedef int (*sk_X509_CRL_compfunc)(const struct X509_crl_st**,const struct X509_crl_st**);

typedef void (*sk_X509_CRL_freefunc)(struct X509_crl_st*);

typedef struct X509_crl_st* (*sk_X509_CRL_copyfunc)(const struct X509_crl_st*);

typedef struct stack_st_X509_ALGOR X509_ALGORS  ;

typedef struct X509_val_st X509_VAL  ;

typedef struct X509_sig_st X509_SIG;

typedef struct X509_name_entry_st X509_NAME_ENTRY;

typedef int (*sk_X509_NAME_ENTRY_compfunc)(const struct X509_name_entry_st**,const struct X509_name_entry_st**);

typedef void (*sk_X509_NAME_ENTRY_freefunc)(struct X509_name_entry_st*);

typedef struct X509_name_entry_st* (*sk_X509_NAME_ENTRY_copyfunc)(const struct X509_name_entry_st*);

typedef struct X509_extension_st X509_EXTENSION;

typedef int (*sk_X509_EXTENSION_compfunc)(const struct X509_extension_st**,const struct X509_extension_st**);

typedef void (*sk_X509_EXTENSION_freefunc)(struct X509_extension_st*);

typedef struct X509_extension_st* (*sk_X509_EXTENSION_copyfunc)(const struct X509_extension_st*);

typedef struct stack_st_X509_EXTENSION X509_EXTENSIONS  ;

typedef struct x509_attributes_st X509_ATTRIBUTE;

typedef int (*sk_X509_ATTRIBUTE_compfunc)(const struct x509_attributes_st**,const struct x509_attributes_st**);

typedef void (*sk_X509_ATTRIBUTE_freefunc)(struct x509_attributes_st*);

typedef struct x509_attributes_st* (*sk_X509_ATTRIBUTE_copyfunc)(const struct x509_attributes_st*);

typedef struct X509_req_info_st X509_REQ_INFO;

typedef struct X509_req_st X509_REQ;

typedef struct x509_cert_aux_st X509_CERT_AUX;

typedef struct x509_cinf_st X509_CINF;

typedef struct X509_crl_info_st X509_CRL_INFO;

typedef struct private_key_st X509_PKEY  ;

typedef struct X509_info_st X509_INFO  ;

typedef int (*sk_X509_INFO_compfunc)(const struct X509_info_st**,const struct X509_info_st**);

typedef void (*sk_X509_INFO_freefunc)(struct X509_info_st*);

typedef struct X509_info_st* (*sk_X509_INFO_copyfunc)(const struct X509_info_st*);

typedef struct Netscape_spkac_st NETSCAPE_SPKAC  ;

typedef struct Netscape_spki_st NETSCAPE_SPKI  ;

typedef struct Netscape_certificate_sequence NETSCAPE_CERT_SEQUENCE  ;

typedef struct PBEPARAM_st PBEPARAM  ;

typedef struct PBE2PARAM_st PBE2PARAM  ;

typedef struct PBKDF2PARAM_st PBKDF2PARAM  ;

typedef struct anonymous_typeX42 PBMAC1PARAM;

typedef struct SCRYPT_PARAMS_st SCRYPT_PARAMS  ;

typedef struct lhash_node_st OPENSSL_LH_NODE;

typedef int (*OPENSSL_LH_COMPFUNC)(const void*,const void*);

typedef int (*OPENSSL_LH_COMPFUNCTHUNK)(const void*,const void*,int (*)(const void*,const void*));

typedef unsigned long  int (*OPENSSL_LH_HASHFUNC)(const void*);

typedef unsigned long  int (*OPENSSL_LH_HASHFUNCTHUNK)(const void*,unsigned long  int (*)(const void*));

typedef void (*OPENSSL_LH_DOALL_FUNC)(void*);

typedef void (*OPENSSL_LH_DOALL_FUNC_THUNK)(void*,void (*)(void*));

typedef void (*OPENSSL_LH_DOALL_FUNCARG)(void*,void*);

typedef void (*OPENSSL_LH_DOALL_FUNCARG_THUNK)(void*,void*,void (*)(void*,void*));

typedef struct lhash_st OPENSSL_LHASH;

typedef int (*lh_OPENSSL_STRING_compfunc)(const char**,const char**);

typedef unsigned long  int (*lh_OPENSSL_STRING_hashfunc)(const char**);

typedef void (*lh_OPENSSL_STRING_doallfunc)(char**);

typedef int (*lh_OPENSSL_CSTRING_compfunc)(const char**,const char**);

typedef unsigned long  int (*lh_OPENSSL_CSTRING_hashfunc)(const char**);

typedef void (*lh_OPENSSL_CSTRING_doallfunc)(const char**);

typedef enum anonymous_typeY42 X509_LOOKUP_TYPE;

typedef int (*sk_X509_LOOKUP_compfunc)(const struct x509_lookup_st**,const struct x509_lookup_st**);

typedef void (*sk_X509_LOOKUP_freefunc)(struct x509_lookup_st*);

typedef struct x509_lookup_st* (*sk_X509_LOOKUP_copyfunc)(const struct x509_lookup_st*);

typedef int (*sk_X509_OBJECT_compfunc)(const struct x509_object_st**,const struct x509_object_st**);

typedef void (*sk_X509_OBJECT_freefunc)(struct x509_object_st*);

typedef struct x509_object_st* (*sk_X509_OBJECT_copyfunc)(const struct x509_object_st*);

typedef int (*sk_X509_VERIFY_PARAM_compfunc)(const struct X509_VERIFY_PARAM_st**,const struct X509_VERIFY_PARAM_st**);

typedef void (*sk_X509_VERIFY_PARAM_freefunc)(struct X509_VERIFY_PARAM_st*);

typedef struct X509_VERIFY_PARAM_st* (*sk_X509_VERIFY_PARAM_copyfunc)(const struct X509_VERIFY_PARAM_st*);

typedef struct x509_trust_st X509_TRUST  ;

typedef int (*sk_X509_TRUST_compfunc)(const struct x509_trust_st**,const struct x509_trust_st**);

typedef void (*sk_X509_TRUST_freefunc)(struct x509_trust_st*);

typedef struct x509_trust_st* (*sk_X509_TRUST_copyfunc)(const struct x509_trust_st*);

typedef int (*X509_STORE_CTX_verify_cb)(int,struct x509_store_ctx_st*);

typedef int (*X509_STORE_CTX_verify_fn)(struct x509_store_ctx_st*);

typedef int (*X509_STORE_CTX_get_issuer_fn)(struct x509_st**,struct x509_store_ctx_st*,struct x509_st*);

typedef int (*X509_STORE_CTX_check_issued_fn)(struct x509_store_ctx_st*,struct x509_st*,struct x509_st*);

typedef int (*X509_STORE_CTX_check_revocation_fn)(struct x509_store_ctx_st*);

typedef int (*X509_STORE_CTX_get_crl_fn)(struct x509_store_ctx_st*,struct X509_crl_st**,struct x509_st*);

typedef int (*X509_STORE_CTX_check_crl_fn)(struct x509_store_ctx_st*,struct X509_crl_st*);

typedef int (*X509_STORE_CTX_cert_crl_fn)(struct x509_store_ctx_st*,struct X509_crl_st*,struct x509_st*);

typedef int (*X509_STORE_CTX_check_policy_fn)(struct x509_store_ctx_st*);

typedef struct stack_st_X509* (*X509_STORE_CTX_lookup_certs_fn)(struct x509_store_ctx_st*,const struct X509_name_st*);

typedef struct stack_st_X509_CRL* (*X509_STORE_CTX_lookup_crls_fn)(const struct x509_store_ctx_st*,const struct X509_name_st*);

typedef int (*X509_STORE_CTX_cleanup_fn)(struct x509_store_ctx_st*);

typedef int (*X509_LOOKUP_ctrl_fn)(struct x509_lookup_st*,int,const char*,long,char**);

typedef int (*X509_LOOKUP_ctrl_ex_fn)(struct x509_lookup_st*,int,const char*,long,char**,struct ossl_lib_ctx_st*,const char*);

typedef int (*X509_LOOKUP_get_by_subject_fn)(struct x509_lookup_st*,enum anonymous_typeY42,const struct X509_name_st*,struct x509_object_st*);

typedef int (*X509_LOOKUP_get_by_subject_ex_fn)(struct x509_lookup_st*,enum anonymous_typeY42,const struct X509_name_st*,struct x509_object_st*,struct ossl_lib_ctx_st*,const char*);

typedef int (*X509_LOOKUP_get_by_issuer_serial_fn)(struct x509_lookup_st*,enum anonymous_typeY42,const struct X509_name_st*,const struct asn1_string_st*,struct x509_object_st*);

typedef int (*X509_LOOKUP_get_by_fingerprint_fn)(struct x509_lookup_st*,enum anonymous_typeY42,const unsigned char*,int,struct x509_object_st*);

typedef int (*X509_LOOKUP_get_by_alias_fn)(struct x509_lookup_st*,enum anonymous_typeY42,const char*,int,struct x509_object_st*);

typedef struct PKCS7_CTX_st PKCS7_CTX  ;

typedef struct pkcs7_issuer_and_serial_st PKCS7_ISSUER_AND_SERIAL  ;

typedef struct pkcs7_signer_info_st PKCS7_SIGNER_INFO  ;

typedef int (*sk_PKCS7_SIGNER_INFO_compfunc)(const struct pkcs7_signer_info_st**,const struct pkcs7_signer_info_st**);

typedef void (*sk_PKCS7_SIGNER_INFO_freefunc)(struct pkcs7_signer_info_st*);

typedef struct pkcs7_signer_info_st* (*sk_PKCS7_SIGNER_INFO_copyfunc)(const struct pkcs7_signer_info_st*);

typedef struct pkcs7_recip_info_st PKCS7_RECIP_INFO  ;

typedef int (*sk_PKCS7_RECIP_INFO_compfunc)(const struct pkcs7_recip_info_st**,const struct pkcs7_recip_info_st**);

typedef void (*sk_PKCS7_RECIP_INFO_freefunc)(struct pkcs7_recip_info_st*);

typedef struct pkcs7_recip_info_st* (*sk_PKCS7_RECIP_INFO_copyfunc)(const struct pkcs7_recip_info_st*);

typedef struct pkcs7_signed_st PKCS7_SIGNED  ;

typedef struct pkcs7_enc_content_st PKCS7_ENC_CONTENT  ;

typedef struct pkcs7_enveloped_st PKCS7_ENVELOPE  ;

typedef struct pkcs7_signedandenveloped_st PKCS7_SIGN_ENVELOPE  ;

typedef struct pkcs7_digest_st PKCS7_DIGEST  ;

typedef struct pkcs7_encrypted_st PKCS7_ENCRYPT  ;

typedef struct pkcs7_st PKCS7  ;

typedef int (*sk_PKCS7_compfunc)(const struct pkcs7_st**,const struct pkcs7_st**);

typedef void (*sk_PKCS7_freefunc)(struct pkcs7_st*);

typedef struct pkcs7_st* (*sk_PKCS7_copyfunc)(const struct pkcs7_st*);

typedef struct anonymous_typeX45 CONF_VALUE;

typedef int (*sk_CONF_VALUE_compfunc)(const struct anonymous_typeX45**,const struct anonymous_typeX45**);

typedef void (*sk_CONF_VALUE_freefunc)(struct anonymous_typeX45*);

typedef struct anonymous_typeX45* (*sk_CONF_VALUE_copyfunc)(const struct anonymous_typeX45*);

typedef int (*lh_CONF_VALUE_compfunc)(const struct anonymous_typeX45*,const struct anonymous_typeX45*);

typedef unsigned long  int (*lh_CONF_VALUE_hashfunc)(const struct anonymous_typeX45*);

typedef void (*lh_CONF_VALUE_doallfunc)(struct anonymous_typeX45*);

typedef struct conf_method_st CONF_METHOD  ;

typedef struct conf_imodule_st CONF_IMODULE;

typedef struct conf_module_st CONF_MODULE;

typedef int (*conf_init_func)(struct conf_imodule_st*,const struct conf_st*);

typedef void (*conf_finish_func)(struct conf_imodule_st*);

typedef struct bio_st* (*OSSL_HTTP_bio_cb_t)(struct bio_st*,void*,int,int);

typedef struct async_job_st ASYNC_JOB;

typedef struct async_wait_ctx_st ASYNC_WAIT_CTX;

typedef int (*ASYNC_callback_fn)(void*);

typedef void* (*ASYNC_stack_alloc_fn)(unsigned long*);

typedef void (*ASYNC_stack_free_fn)(void*);

typedef int (*sk_SCT_compfunc)(const struct sct_st**,const struct sct_st**);

typedef void (*sk_SCT_freefunc)(struct sct_st*);

typedef struct sct_st* (*sk_SCT_copyfunc)(const struct sct_st*);

typedef int (*sk_CTLOG_compfunc)(const struct ctlog_st**,const struct ctlog_st**);

typedef void (*sk_CTLOG_freefunc)(struct ctlog_st*);

typedef struct ctlog_st* (*sk_CTLOG_copyfunc)(const struct ctlog_st*);

typedef enum anonymous_typeY45 ct_log_entry_type_t;

typedef enum anonymous_typeY45 sct_version_t;

typedef enum anonymous_typeY45 sct_source_t;

typedef enum anonymous_typeY45 sct_validation_status_t;

typedef struct ssl_st* ssl_crock_st;

typedef struct tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;

typedef struct ssl_method_st SSL_METHOD;

typedef struct ssl_cipher_st SSL_CIPHER;

typedef struct ssl_session_st SSL_SESSION;

typedef struct tls_sigalgs_st TLS_SIGALGS;

typedef struct ssl_conf_ctx_st SSL_CONF_CTX;

typedef struct srtp_protection_profile_st SRTP_PROTECTION_PROFILE  ;

typedef int (*sk_SRTP_PROTECTION_PROFILE_compfunc)(const struct srtp_protection_profile_st**,const struct srtp_protection_profile_st**);

typedef void (*sk_SRTP_PROTECTION_PROFILE_freefunc)(struct srtp_protection_profile_st*);

typedef struct srtp_protection_profile_st* (*sk_SRTP_PROTECTION_PROFILE_copyfunc)(const struct srtp_protection_profile_st*);

typedef int (*tls_session_ticket_ext_cb_fn)(struct ssl_st*,const unsigned char*,int,void*);

typedef int (*tls_session_secret_cb_fn)(struct ssl_st*,void*,int*,struct stack_st_SSL_CIPHER*,const struct ssl_cipher_st**,void*);

typedef int (*custom_ext_add_cb)(struct ssl_st*,unsigned int,const unsigned char**,unsigned long*,int*,void*);

typedef void (*custom_ext_free_cb)(struct ssl_st*,unsigned int,const unsigned char*,void*);

typedef int (*custom_ext_parse_cb)(struct ssl_st*,unsigned int,const unsigned char*,unsigned long,int*,void*);

typedef int (*SSL_custom_ext_add_cb_ex)(struct ssl_st*,unsigned int,unsigned int,const unsigned char**,unsigned long*,struct x509_st*,unsigned long,int*,void*);

typedef void (*SSL_custom_ext_free_cb_ex)(struct ssl_st*,unsigned int,unsigned int,const unsigned char*,void*);

typedef int (*SSL_custom_ext_parse_cb_ex)(struct ssl_st*,unsigned int,unsigned int,const unsigned char*,unsigned long,struct x509_st*,unsigned long,int*,void*);

typedef int (*SSL_verify_cb)(int,struct x509_store_ctx_st*);

typedef int (*SSL_async_callback_fn)(struct ssl_st*,void*);

typedef int (*GEN_SESSION_CB)(struct ssl_st*,unsigned char*,unsigned int*);

typedef int (*SSL_CTX_npn_advertised_cb_func)(struct ssl_st*,const unsigned char**,unsigned int*,void*);

typedef int (*SSL_CTX_npn_select_cb_func)(struct ssl_st*,unsigned char**,unsigned char*,const unsigned char*,unsigned int,void*);

typedef int (*SSL_CTX_alpn_select_cb_func)(struct ssl_st*,const unsigned char**,unsigned char*,const unsigned char*,unsigned int,void*);

typedef unsigned int (*SSL_psk_client_cb_func)(struct ssl_st*,const char*,char*,unsigned int,unsigned char*,unsigned int);

typedef unsigned int (*SSL_psk_server_cb_func)(struct ssl_st*,const char*,unsigned char*,unsigned int);

typedef int (*SSL_psk_find_session_cb_func)(struct ssl_st*,const unsigned char*,unsigned long,struct ssl_session_st**);

typedef int (*SSL_psk_use_session_cb_func)(struct ssl_st*,const struct evp_md_st*,const unsigned char**,unsigned long*,struct ssl_session_st**);

typedef void (*SSL_CTX_keylog_cb_func)(const struct ssl_st*,const char*);

typedef int (*sk_SSL_CIPHER_compfunc)(const struct ssl_cipher_st**,const struct ssl_cipher_st**);

typedef void (*sk_SSL_CIPHER_freefunc)(struct ssl_cipher_st*);

typedef struct ssl_cipher_st* (*sk_SSL_CIPHER_copyfunc)(const struct ssl_cipher_st*);

typedef enum anonymous_typeY45 OSSL_HANDSHAKE_STATE;

typedef int (*SSL_client_hello_cb_fn)(struct ssl_st*,int*,void*);

typedef int (*SSL_new_pending_conn_cb_fn)(struct ssl_ctx_st*,struct ssl_st*,void*);

typedef struct ssl_shutdown_ex_args_st SSL_SHUTDOWN_EX_ARGS  ;

typedef struct ssl_stream_reset_args_st SSL_STREAM_RESET_ARGS  ;

typedef struct ssl_conn_close_info_st SSL_CONN_CLOSE_INFO  ;

typedef struct ssl_poll_item_st SSL_POLL_ITEM  ;

typedef int (*ssl_ct_validation_cb)(const struct ct_policy_eval_ctx_st*,const struct stack_st_SCT*,void*);

typedef int SSL_TICKET_STATUS;

typedef int SSL_TICKET_RETURN;

typedef int (*SSL_CTX_generate_session_ticket_fn)(struct ssl_st*,void*);

typedef int (*SSL_CTX_decrypt_session_ticket_fn)(struct ssl_st*,struct ssl_session_st*,const unsigned char*,unsigned long,int,void*);

typedef unsigned int (*DTLS_timer_cb)(struct ssl_st*,unsigned int);

typedef int (*SSL_allow_early_data_cb_fn)(struct ssl_st*,void*);

typedef struct ERR_string_data_st ERR_STRING_DATA  ;

typedef int (*lh_ERR_STRING_DATA_compfunc)(const struct ERR_string_data_st*,const struct ERR_string_data_st*);

typedef unsigned long  int (*lh_ERR_STRING_DATA_hashfunc)(const struct ERR_string_data_st*);

typedef void (*lh_ERR_STRING_DATA_doallfunc)(struct ERR_string_data_st*);

typedef int socket_fd;

typedef char int_least8_t  ;

typedef short int int_least16_t  ;

typedef int int_least32_t  ;

typedef long  int int_least64_t  ;

typedef unsigned char uint_least8_t  ;

typedef unsigned short int uint_least16_t  ;

typedef unsigned int uint_least32_t  ;

typedef unsigned long  int uint_least64_t  ;

typedef char int_fast8_t;

typedef long  int int_fast16_t;

typedef long  int int_fast32_t;

typedef long  int int_fast64_t;

typedef unsigned char uint_fast8_t;

typedef unsigned long  int uint_fast16_t;

typedef unsigned long  int uint_fast32_t;

typedef unsigned long  int uint_fast64_t;

typedef unsigned long  int uintptr_t;

typedef long  int intmax_t  ;

typedef unsigned long  int uintmax_t  ;

/// previous struct definition ///
struct _IO_FILE;

struct _IO_marker;

struct _IO_codecvt;

struct _IO_wide_data;

struct obstack;

#include <assert.h>
struct re_program;

struct tm;

struct cmsghdr;

struct sigevent;

struct stack_st_OPENSSL_STRING;

struct stack_st_OPENSSL_CSTRING;

struct stack_st_OPENSSL_BLOCK;

struct stack_st_BIGNUM;

struct stack_st_BIGNUM_const;

struct stack_st_void;

struct stack_st_SSL_COMP;

struct stack_st_BIO;

struct stack_st_X509_ALGOR;

struct stack_st_ASN1_STRING_TABLE;

struct stack_st_ASN1_TYPE;

struct stack_st_ASN1_OBJECT;

struct stack_st_ASN1_INTEGER;

struct stack_st_ASN1_UTF8STRING;

struct stack_st_ASN1_GENERALSTRING;

struct rsa_st;

struct dsa_st;

struct dh_st;

struct ec_key_st;

struct stack_st_X509_NAME;

struct stack_st_X509;

struct stack_st_X509_REVOKED;

struct stack_st_X509_CRL;

struct stack_st_X509_NAME_ENTRY;

struct stack_st_X509_EXTENSION;

struct stack_st_X509_ATTRIBUTE;

struct stack_st_X509_INFO;

struct lhash_st_OPENSSL_STRING;

struct lhash_st_OPENSSL_CSTRING;

struct stack_st_X509_LOOKUP;

struct stack_st_X509_OBJECT;

struct stack_st_X509_VERIFY_PARAM;

struct stack_st_X509_TRUST;

struct stack_st_PKCS7_SIGNER_INFO;

struct stack_st_PKCS7_RECIP_INFO;

struct stack_st_PKCS7;

struct stack_st_CONF_VALUE;

struct lhash_st_CONF_VALUE;

struct conf_st;

struct conf_method_st;

struct stack_st_CONF_MODULE;

struct stack_st_CONF_IMODULE;

struct stack_st_SCT;

struct stack_st_CTLOG;

struct stack_st_SRTP_PROTECTION_PROFILE;

struct stack_st_SSL_CIPHER;

struct lhash_st_ERR_STRING_DATA;

struct WhereNode;

/// struct definition ///
struct __fsid_t
{
    int __val[2];
};

union anonymous_typeZ2
{
unsigned int __wch;
char __wchb[4];
};

union anonymous_typeZ3
{
unsigned int __wch;
char __wchb[4];
};

struct anonymous_typeX1
{
    int __count;
    union {
        unsigned int __wch;
        char __wchb[4];
    } __value;
};

struct _G_fpos_t
{
    long  int __pos  ;
    struct {
        int __count;
        union {
            unsigned int __wch;
            char __wchb[4];
        } __value;
    } __state;
};

struct _G_fpos64_t
{
    long  int __pos  ;
    struct {
        int __count;
        union {
            unsigned int __wch;
            char __wchb[4];
        } __value;
    } __state;
};

struct _IO_FILE
{
    int _flags;
    char* _IO_read_ptr;
    char* _IO_read_end;
    char* _IO_read_base;
    char* _IO_write_base;
    char* _IO_write_ptr;
    char* _IO_write_end;
    char* _IO_buf_base;
    char* _IO_buf_end;
    char* _IO_save_base;
    char* _IO_backup_base;
    char* _IO_save_end;
    struct _IO_marker* _markers  ;
    struct _IO_FILE* _chain  ;
    int _fileno;
    int _flags2:24;
    char _short_backupbuf[1];
    long  int _old_offset  ;
    unsigned short int _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    void* _lock  ;
    long  int _offset  ;
    struct _IO_codecvt* _codecvt  ;
    struct _IO_wide_data* _wide_data  ;
    struct _IO_FILE* _freeres_list  ;
    void* _freeres_buf;
    struct _IO_FILE** _prevchain  ;
    int _mode;
    int _unused3;
    unsigned long  int _total_written  ;
    char _unused2[12*sizeof(int)-5*sizeof(void*)];
};

struct _IO_cookie_io_functions_t
{
    long  int (*(*read))(void*,char*,unsigned long)  ;
    long  int (*(*write))(void*,const char*,unsigned long)  ;
    int (*(*seek))(void*,long  int*,int)  ;
    int (*(*close))(void*)  ;
};

struct anonymous_typeX4
{
    int quot;
    int rem;
};

struct anonymous_typeX5
{
    long  int quot;
    long  int rem;
};

struct anonymous_typeX6
{
    long long int quot;
    long long int rem;
};

struct __locale_struct
{
    struct __locale_data* __locales[13];
    const unsigned short int* __ctype_b;
    const int* __ctype_tolower;
    const int* __ctype_toupper;
    const char* __names[13];
};

struct anonymous_typeX7
{
    unsigned long  int __val[(1024/(8*sizeof(unsigned long  int)))];
};

struct timeval
{
    long  int tv_sec  ;
    long  int tv_usec  ;
};

struct timespec
{
    long  int tv_sec  ;
    long  int tv_nsec  ;
};

struct anonymous_typeX8
{
    long  int fds_bits[1024/(8*(int)sizeof(long  int))]  ;
};

struct anonymous_typeX10
{
    unsigned int __low;
    unsigned int __high;
};

union anonymous_typeZ9
{
unsigned long long int __value64;
    struct {
        unsigned int __low;
        unsigned int __high;
    } __value32;
};

struct __pthread_internal_list
{
    struct __pthread_internal_list* __prev  ;
    struct __pthread_internal_list* __next  ;
};

struct __pthread_internal_slist
{
    struct __pthread_internal_slist* __next  ;
};

struct __pthread_mutex_s
{
    int __lock;
    unsigned int __count;
    int __owner;
    unsigned int __nusers;
    int __kind;
    short __spins;
    short __elision;
    struct __pthread_internal_list __list  ;
};

struct __pthread_rwlock_arch_t
{
    unsigned int __readers;
    unsigned int __writers;
    unsigned int __wrphase_futex;
    unsigned int __writers_futex;
    unsigned int __pad3;
    unsigned int __pad4;
    int __cur_writer;
    int __shared;
    char __rwelision;
    unsigned char __pad1[7];
    unsigned long  int __pad2;
    unsigned int __flags;
};

struct __pthread_cond_s
{
    union {
        unsigned long long int __value64;
        struct {
            unsigned int __low;
            unsigned int __high;
        } __value32;
    } __wseq;
    union {
        unsigned long long int __value64;
        struct {
            unsigned int __low;
            unsigned int __high;
        } __value32;
    } __g1_start;
    unsigned int __g_size[2];
    unsigned int __g1_orig_size;
    unsigned int __wrefs;
    unsigned int __g_signals[2];
    unsigned int __unused_initialized_1;
    unsigned int __unused_initialized_2;
};

struct anonymous_typeX11
{
    int __data;
};

union anonymous_typeZ12
{
char __size[4];
int __align;
};

union anonymous_typeZ13
{
char __size[4];
int __align;
};

union pthread_attr_t
{
char __size[56];
long  int __align;
};

union anonymous_typeZ14
{
struct __pthread_mutex_s __data  ;
char __size[40];
long  int __align;
};

union anonymous_typeZ15
{
struct __pthread_cond_s __data  ;
char __size[48];
long long int __align;
};

union anonymous_typeZ16
{
struct __pthread_rwlock_arch_t __data  ;
char __size[56];
long  int __align;
};

union anonymous_typeZ17
{
char __size[8];
long  int __align;
};

union anonymous_typeZ18
{
char __size[32];
long  int __align;
};

union anonymous_typeZ19
{
char __size[4];
int __align;
};

struct random_data
{
    int* fptr  ;
    int* rptr  ;
    int* state  ;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int* end_ptr  ;
};

struct drand48_data
{
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
};

struct lconv
{
    char* decimal_point;
    char* thousands_sep;
    char* grouping;
    char* int_curr_symbol;
    char* currency_symbol;
    char* mon_decimal_point;
    char* mon_thousands_sep;
    char* mon_grouping;
    char* positive_sign;
    char* negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};

struct buffer
{
    char* buf;
    int len;
    int size;
};

struct sMemHeaderTiny
{
    long size;
    int allocated;
    struct sMemHeaderTiny* next  ;
    struct sMemHeaderTiny* prev  ;
    struct sMemHeaderTiny* free_next  ;
    char* class_name;
    char* sname;
    int sline;
};

struct sMemHeader
{
    long size;
    int allocated;
    struct sMemHeader* next  ;
    struct sMemHeader* prev  ;
    struct sMemHeader* free_next  ;
    char* sname[16];
    int sline[16];
    int id[16];
    char* class_name;
};

struct list_item$1char$
{
    char item;
    struct list_item$1char$* prev;
    struct list_item$1char$* next;
};

struct list$1char$
{
    struct list_item$1char$* head;
    struct list_item$1char$* tail;
    int len;
    struct list_item$1char$* it;
};

struct list_item$1char$p
{
    char* item;
    struct list_item$1char$p* prev;
    struct list_item$1char$p* next;
};

struct list$1char$p
{
    struct list_item$1char$p* head;
    struct list_item$1char$p* tail;
    int len;
    struct list_item$1char$p* it;
};

struct list_item$1short$
{
    short item;
    struct list_item$1short$* prev;
    struct list_item$1short$* next;
};

struct list$1short$
{
    struct list_item$1short$* head;
    struct list_item$1short$* tail;
    int len;
    struct list_item$1short$* it;
};

struct list_item$1int$
{
    int item;
    struct list_item$1int$* prev;
    struct list_item$1int$* next;
};

struct list$1int$
{
    struct list_item$1int$* head;
    struct list_item$1int$* tail;
    int len;
    struct list_item$1int$* it;
};

struct list_item$1long$
{
    long item;
    struct list_item$1long$* prev;
    struct list_item$1long$* next;
};

struct list$1long$
{
    struct list_item$1long$* head;
    struct list_item$1long$* tail;
    int len;
    struct list_item$1long$* it;
};

struct list_item$1float$
{
    float item;
    struct list_item$1float$* prev;
    struct list_item$1float$* next;
};

struct list$1float$
{
    struct list_item$1float$* head;
    struct list_item$1float$* tail;
    int len;
    struct list_item$1float$* it;
};

struct list_item$1double$
{
    double item;
    struct list_item$1double$* prev;
    struct list_item$1double$* next;
};

struct list$1double$
{
    struct list_item$1double$* head;
    struct list_item$1double$* tail;
    int len;
    struct list_item$1double$* it;
};

struct list_item$1char$ph
{
    char* item  ;
    struct list_item$1char$ph* prev;
    struct list_item$1char$ph* next;
};

struct list$1char$ph
{
    struct list_item$1char$ph* head;
    struct list_item$1char$ph* tail;
    int len;
    struct list_item$1char$ph* it;
};

struct re_capture
{
    int start;
    int length;
};

enum { RE_UNUSED 
,RE_DOT 
,RE_BEGIN 
,RE_END 
,RE_QUESTIONMARK 
,RE_STAR 
,RE_PLUS 
,RE_CHAR 
,RE_CHAR_CLASS 
,RE_INV_CHAR_CLASS 
,RE_DIGIT 
,RE_NOT_DIGIT 
,RE_ALPHA 
,RE_NOT_ALPHA 
,RE_WHITESPACE 
,RE_NOT_WHITESPACE 
,RE_GROUP 
,RE_GROUP_END 
};

struct anonymous_typeX21
{
    struct regex_t* first  ;
    struct regex_t* last  ;
    int id;
};

union anonymous_typeZ20
{
unsigned char ch;
unsigned char* ccl;
    struct {
        struct regex_t* first  ;
        struct regex_t* last  ;
        int id;
    } group;
};

struct anonymous_typeX23
{
    struct regex_t* first  ;
    struct regex_t* last  ;
    int id;
};

union anonymous_typeZ22
{
unsigned char ch;
unsigned char* ccl;
    struct {
        struct regex_t* first  ;
        struct regex_t* last  ;
        int id;
    } group;
};

struct regex_t
{
    unsigned char type;
    union {
        unsigned char ch;
        unsigned char* ccl;
        struct {
            struct regex_t* first  ;
            struct regex_t* last  ;
            int id;
        } group;
    } u;
    struct regex_t* next  ;
};

struct re_program
{
    struct regex_t* start  ;
    int group_count;
};

struct anonymous_typeX24
{
    struct regex_t* pool  ;
    int pool_capacity;
    int pool_size;
    unsigned char* ccl_buf;
    int ccl_capacity;
    int ccl_idx;
    int group_count;
};

struct anonymous_typeX25
{
    const char* base;
    struct re_capture* captures  ;
    int capture_capacity;
    int total_groups;
    _Bool ignore_case;
};

enum { _PC_LINK_MAX 
,_PC_MAX_CANON 
,_PC_MAX_INPUT 
,_PC_NAME_MAX 
,_PC_PATH_MAX 
,_PC_PIPE_BUF 
,_PC_CHOWN_RESTRICTED 
,_PC_NO_TRUNC 
,_PC_VDISABLE 
,_PC_SYNC_IO 
,_PC_ASYNC_IO 
,_PC_PRIO_IO 
,_PC_SOCK_MAXBUF 
,_PC_FILESIZEBITS 
,_PC_REC_INCR_XFER_SIZE 
,_PC_REC_MAX_XFER_SIZE 
,_PC_REC_MIN_XFER_SIZE 
,_PC_REC_XFER_ALIGN 
,_PC_ALLOC_SIZE_MIN 
,_PC_SYMLINK_MAX 
,_PC_2_SYMLINKS 
};

enum { _SC_ARG_MAX 
,_SC_CHILD_MAX 
,_SC_CLK_TCK 
,_SC_NGROUPS_MAX 
,_SC_OPEN_MAX 
,_SC_STREAM_MAX 
,_SC_TZNAME_MAX 
,_SC_JOB_CONTROL 
,_SC_SAVED_IDS 
,_SC_REALTIME_SIGNALS 
,_SC_PRIORITY_SCHEDULING 
,_SC_TIMERS 
,_SC_ASYNCHRONOUS_IO 
,_SC_PRIORITIZED_IO 
,_SC_SYNCHRONIZED_IO 
,_SC_FSYNC 
,_SC_MAPPED_FILES 
,_SC_MEMLOCK 
,_SC_MEMLOCK_RANGE 
,_SC_MEMORY_PROTECTION 
,_SC_MESSAGE_PASSING 
,_SC_SEMAPHORES 
,_SC_SHARED_MEMORY_OBJECTS 
,_SC_AIO_LISTIO_MAX 
,_SC_AIO_MAX 
,_SC_AIO_PRIO_DELTA_MAX 
,_SC_DELAYTIMER_MAX 
,_SC_MQ_OPEN_MAX 
,_SC_MQ_PRIO_MAX 
,_SC_VERSION 
,_SC_PAGESIZE 
,_SC_RTSIG_MAX 
,_SC_SEM_NSEMS_MAX 
,_SC_SEM_VALUE_MAX 
,_SC_SIGQUEUE_MAX 
,_SC_TIMER_MAX 
,_SC_BC_BASE_MAX 
,_SC_BC_DIM_MAX 
,_SC_BC_SCALE_MAX 
,_SC_BC_STRING_MAX 
,_SC_COLL_WEIGHTS_MAX 
,_SC_EQUIV_CLASS_MAX 
,_SC_EXPR_NEST_MAX 
,_SC_LINE_MAX 
,_SC_RE_DUP_MAX 
,_SC_CHARCLASS_NAME_MAX 
,_SC_2_VERSION 
,_SC_2_C_BIND 
,_SC_2_C_DEV 
,_SC_2_FORT_DEV 
,_SC_2_FORT_RUN 
,_SC_2_SW_DEV 
,_SC_2_LOCALEDEF 
,_SC_PII 
,_SC_PII_XTI 
,_SC_PII_SOCKET 
,_SC_PII_INTERNET 
,_SC_PII_OSI 
,_SC_POLL 
,_SC_SELECT 
,_SC_UIO_MAXIOV 
,_SC_IOV_MAX=((60)),
_SC_PII_INTERNET_STREAM 
,_SC_PII_INTERNET_DGRAM 
,_SC_PII_OSI_COTS 
,_SC_PII_OSI_CLTS 
,_SC_PII_OSI_M 
,_SC_T_IOV_MAX 
,_SC_THREADS 
,_SC_THREAD_SAFE_FUNCTIONS 
,_SC_GETGR_R_SIZE_MAX 
,_SC_GETPW_R_SIZE_MAX 
,_SC_LOGIN_NAME_MAX 
,_SC_TTY_NAME_MAX 
,_SC_THREAD_DESTRUCTOR_ITERATIONS 
,_SC_THREAD_KEYS_MAX 
,_SC_THREAD_STACK_MIN 
,_SC_THREAD_THREADS_MAX 
,_SC_THREAD_ATTR_STACKADDR 
,_SC_THREAD_ATTR_STACKSIZE 
,_SC_THREAD_PRIORITY_SCHEDULING 
,_SC_THREAD_PRIO_INHERIT 
,_SC_THREAD_PRIO_PROTECT 
,_SC_THREAD_PROCESS_SHARED 
,_SC_NPROCESSORS_CONF 
,_SC_NPROCESSORS_ONLN 
,_SC_PHYS_PAGES 
,_SC_AVPHYS_PAGES 
,_SC_ATEXIT_MAX 
,_SC_PASS_MAX 
,_SC_XOPEN_VERSION 
,_SC_XOPEN_XCU_VERSION 
,_SC_XOPEN_UNIX 
,_SC_XOPEN_CRYPT 
,_SC_XOPEN_ENH_I18N 
,_SC_XOPEN_SHM 
,_SC_2_CHAR_TERM 
,_SC_2_C_VERSION 
,_SC_2_UPE 
,_SC_XOPEN_XPG2 
,_SC_XOPEN_XPG3 
,_SC_XOPEN_XPG4 
,_SC_CHAR_BIT 
,_SC_CHAR_MAX 
,_SC_CHAR_MIN 
,_SC_INT_MAX 
,_SC_INT_MIN 
,_SC_LONG_BIT 
,_SC_WORD_BIT 
,_SC_MB_LEN_MAX 
,_SC_NZERO 
,_SC_SSIZE_MAX 
,_SC_SCHAR_MAX 
,_SC_SCHAR_MIN 
,_SC_SHRT_MAX 
,_SC_SHRT_MIN 
,_SC_UCHAR_MAX 
,_SC_UINT_MAX 
,_SC_ULONG_MAX 
,_SC_USHRT_MAX 
,_SC_NL_ARGMAX 
,_SC_NL_LANGMAX 
,_SC_NL_MSGMAX 
,_SC_NL_NMAX 
,_SC_NL_SETMAX 
,_SC_NL_TEXTMAX 
,_SC_XBS5_ILP32_OFF32 
,_SC_XBS5_ILP32_OFFBIG 
,_SC_XBS5_LP64_OFF64 
,_SC_XBS5_LPBIG_OFFBIG 
,_SC_XOPEN_LEGACY 
,_SC_XOPEN_REALTIME 
,_SC_XOPEN_REALTIME_THREADS 
,_SC_ADVISORY_INFO 
,_SC_BARRIERS 
,_SC_BASE 
,_SC_C_LANG_SUPPORT 
,_SC_C_LANG_SUPPORT_R 
,_SC_CLOCK_SELECTION 
,_SC_CPUTIME 
,_SC_THREAD_CPUTIME 
,_SC_DEVICE_IO 
,_SC_DEVICE_SPECIFIC 
,_SC_DEVICE_SPECIFIC_R 
,_SC_FD_MGMT 
,_SC_FIFO 
,_SC_PIPE 
,_SC_FILE_ATTRIBUTES 
,_SC_FILE_LOCKING 
,_SC_FILE_SYSTEM 
,_SC_MONOTONIC_CLOCK 
,_SC_MULTI_PROCESS 
,_SC_SINGLE_PROCESS 
,_SC_NETWORKING 
,_SC_READER_WRITER_LOCKS 
,_SC_SPIN_LOCKS 
,_SC_REGEXP 
,_SC_REGEX_VERSION 
,_SC_SHELL 
,_SC_SIGNALS 
,_SC_SPAWN 
,_SC_SPORADIC_SERVER 
,_SC_THREAD_SPORADIC_SERVER 
,_SC_SYSTEM_DATABASE 
,_SC_SYSTEM_DATABASE_R 
,_SC_TIMEOUTS 
,_SC_TYPED_MEMORY_OBJECTS 
,_SC_USER_GROUPS 
,_SC_USER_GROUPS_R 
,_SC_2_PBS 
,_SC_2_PBS_ACCOUNTING 
,_SC_2_PBS_LOCATE 
,_SC_2_PBS_MESSAGE 
,_SC_2_PBS_TRACK 
,_SC_SYMLOOP_MAX 
,_SC_STREAMS 
,_SC_2_PBS_CHECKPOINT 
,_SC_V6_ILP32_OFF32 
,_SC_V6_ILP32_OFFBIG 
,_SC_V6_LP64_OFF64 
,_SC_V6_LPBIG_OFFBIG 
,_SC_HOST_NAME_MAX 
,_SC_TRACE 
,_SC_TRACE_EVENT_FILTER 
,_SC_TRACE_INHERIT 
,_SC_TRACE_LOG 
,_SC_LEVEL1_ICACHE_SIZE 
,_SC_LEVEL1_ICACHE_ASSOC 
,_SC_LEVEL1_ICACHE_LINESIZE 
,_SC_LEVEL1_DCACHE_SIZE 
,_SC_LEVEL1_DCACHE_ASSOC 
,_SC_LEVEL1_DCACHE_LINESIZE 
,_SC_LEVEL2_CACHE_SIZE 
,_SC_LEVEL2_CACHE_ASSOC 
,_SC_LEVEL2_CACHE_LINESIZE 
,_SC_LEVEL3_CACHE_SIZE 
,_SC_LEVEL3_CACHE_ASSOC 
,_SC_LEVEL3_CACHE_LINESIZE 
,_SC_LEVEL4_CACHE_SIZE 
,_SC_LEVEL4_CACHE_ASSOC 
,_SC_LEVEL4_CACHE_LINESIZE 
,_SC_IPV6=(((60)+125)+50),
_SC_RAW_SOCKETS 
,_SC_V7_ILP32_OFF32 
,_SC_V7_ILP32_OFFBIG 
,_SC_V7_LP64_OFF64 
,_SC_V7_LPBIG_OFFBIG 
,_SC_SS_REPL_MAX 
,_SC_TRACE_EVENT_NAME_MAX 
,_SC_TRACE_NAME_MAX 
,_SC_TRACE_SYS_MAX 
,_SC_TRACE_USER_EVENT_MAX 
,_SC_XOPEN_STREAMS 
,_SC_THREAD_ROBUST_PRIO_INHERIT 
,_SC_THREAD_ROBUST_PRIO_PROTECT 
,_SC_MINSIGSTKSZ 
,_SC_SIGSTKSZ 
};

enum { _CS_PATH 
,_CS_V6_WIDTH_RESTRICTED_ENVS 
,_CS_GNU_LIBC_VERSION 
,_CS_GNU_LIBPTHREAD_VERSION 
,_CS_V5_WIDTH_RESTRICTED_ENVS 
,_CS_V7_WIDTH_RESTRICTED_ENVS 
,_CS_LFS_CFLAGS=(1000),
_CS_LFS_LDFLAGS 
,_CS_LFS_LIBS 
,_CS_LFS_LINTFLAGS 
,_CS_LFS64_CFLAGS 
,_CS_LFS64_LDFLAGS 
,_CS_LFS64_LIBS 
,_CS_LFS64_LINTFLAGS 
,_CS_XBS5_ILP32_OFF32_CFLAGS=(1100),
_CS_XBS5_ILP32_OFF32_LDFLAGS 
,_CS_XBS5_ILP32_OFF32_LIBS 
,_CS_XBS5_ILP32_OFF32_LINTFLAGS 
,_CS_XBS5_ILP32_OFFBIG_CFLAGS 
,_CS_XBS5_ILP32_OFFBIG_LDFLAGS 
,_CS_XBS5_ILP32_OFFBIG_LIBS 
,_CS_XBS5_ILP32_OFFBIG_LINTFLAGS 
,_CS_XBS5_LP64_OFF64_CFLAGS 
,_CS_XBS5_LP64_OFF64_LDFLAGS 
,_CS_XBS5_LP64_OFF64_LIBS 
,_CS_XBS5_LP64_OFF64_LINTFLAGS 
,_CS_XBS5_LPBIG_OFFBIG_CFLAGS 
,_CS_XBS5_LPBIG_OFFBIG_LDFLAGS 
,_CS_XBS5_LPBIG_OFFBIG_LIBS 
,_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS 
,_CS_POSIX_V6_ILP32_OFF32_CFLAGS 
,_CS_POSIX_V6_ILP32_OFF32_LDFLAGS 
,_CS_POSIX_V6_ILP32_OFF32_LIBS 
,_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS 
,_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS 
,_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS 
,_CS_POSIX_V6_ILP32_OFFBIG_LIBS 
,_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS 
,_CS_POSIX_V6_LP64_OFF64_CFLAGS 
,_CS_POSIX_V6_LP64_OFF64_LDFLAGS 
,_CS_POSIX_V6_LP64_OFF64_LIBS 
,_CS_POSIX_V6_LP64_OFF64_LINTFLAGS 
,_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS 
,_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS 
,_CS_POSIX_V6_LPBIG_OFFBIG_LIBS 
,_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS 
,_CS_POSIX_V7_ILP32_OFF32_CFLAGS 
,_CS_POSIX_V7_ILP32_OFF32_LDFLAGS 
,_CS_POSIX_V7_ILP32_OFF32_LIBS 
,_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS 
,_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS 
,_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS 
,_CS_POSIX_V7_ILP32_OFFBIG_LIBS 
,_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS 
,_CS_POSIX_V7_LP64_OFF64_CFLAGS 
,_CS_POSIX_V7_LP64_OFF64_LDFLAGS 
,_CS_POSIX_V7_LP64_OFF64_LIBS 
,_CS_POSIX_V7_LP64_OFF64_LINTFLAGS 
,_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS 
,_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS 
,_CS_POSIX_V7_LPBIG_OFFBIG_LIBS 
,_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS 
,_CS_V6_ENV 
,_CS_V7_ENV 
};

struct iovec
{
    void* iov_base;
    unsigned long iov_len  ;
};

enum  __socket_type { SOCK_STREAM=(1),
SOCK_DGRAM=(2),
SOCK_RAW=(3),
SOCK_RDM=(4),
SOCK_SEQPACKET=(5),
SOCK_DCCP=(6),
SOCK_PACKET=(10),
SOCK_CLOEXEC=(02000000),
SOCK_NONBLOCK=(00004000)
};

struct sockaddr
{
    unsigned short int sa_family  ;
    char sa_data[14];
} __attribute__ ((__may_alias__)) ;

struct sockaddr_storage
{
    unsigned short int ss_family  ;
    char __ss_padding[(128-(sizeof(unsigned short int))-sizeof(unsigned long  int))];
    unsigned long  int __ss_align;
} __attribute__ ((__may_alias__)) ;

enum { MSG_OOB=(0x01),
MSG_PEEK=(0x02),
MSG_DONTROUTE=(0x04),
MSG_TRYHARD=((0x04)),
MSG_CTRUNC=(0x08),
MSG_PROXY=(0x10),
MSG_TRUNC=(0x20),
MSG_DONTWAIT=(0x40),
MSG_EOR=(0x80),
MSG_WAITALL=(0x100),
MSG_FIN=(0x200),
MSG_SYN=(0x400),
MSG_CONFIRM=(0x800),
MSG_RST=(0x1000),
MSG_ERRQUEUE=(0x2000),
MSG_NOSIGNAL=(0x4000),
MSG_MORE=(0x8000),
MSG_WAITFORONE=(0x10000),
MSG_BATCH=(0x40000),
MSG_SOCK_DEVMEM=(0x2000000),
MSG_ZEROCOPY=(0x4000000),
MSG_FASTOPEN=(0x20000000),
MSG_CMSG_CLOEXEC=(0x40000000)
};

struct msghdr
{
    void* msg_name;
    unsigned int msg_namelen  ;
    struct iovec* msg_iov  ;
    unsigned long msg_iovlen  ;
    void* msg_control;
    unsigned long msg_controllen  ;
    int msg_flags;
};

struct cmsghdr
{
    unsigned long cmsg_len  ;
    int cmsg_level;
    int cmsg_type;
    unsigned char __cmsg_data[];
};

enum { SCM_RIGHTS=(0x01),
SCM_CREDENTIALS=(0x02),
SCM_SECURITY=(0x03),
SCM_PIDFD=(0x04)
};

struct ucred
{
    int pid  ;
    unsigned int uid  ;
    unsigned int gid  ;
};

struct anonymous_typeX26
{
    unsigned long  int fds_bits[1024/(8*sizeof(long))];
};

struct anonymous_typeX27
{
    int val[2];
};

struct linger
{
    int l_onoff;
    int l_linger;
};

struct osockaddr
{
    unsigned short int sa_family;
    unsigned char sa_data[14];
};

enum { SHUT_RD=(0),
SHUT_WR 
,SHUT_RDWR 
};

struct mmsghdr
{
    struct msghdr msg_hdr  ;
    unsigned int msg_len;
};

struct in_addr
{
    unsigned int s_addr  ;
};

struct ip_opts
{
    struct in_addr ip_dst  ;
    char ip_opts[40];
};

struct in_pktinfo
{
    int ipi_ifindex;
    struct in_addr ipi_spec_dst  ;
    struct in_addr ipi_addr  ;
};

enum { IPPROTO_IP=(0),
IPPROTO_ICMP=(1),
IPPROTO_IGMP=(2),
IPPROTO_IPIP=(4),
IPPROTO_TCP=(6),
IPPROTO_EGP=(8),
IPPROTO_PUP=(12),
IPPROTO_UDP=(17),
IPPROTO_IDP=(22),
IPPROTO_TP=(29),
IPPROTO_DCCP=(33),
IPPROTO_IPV6=(41),
IPPROTO_RSVP=(46),
IPPROTO_GRE=(47),
IPPROTO_ESP=(50),
IPPROTO_AH=(51),
IPPROTO_MTP=(92),
IPPROTO_BEETPH=(94),
IPPROTO_ENCAP=(98),
IPPROTO_PIM=(103),
IPPROTO_COMP=(108),
IPPROTO_L2TP=(115),
IPPROTO_SCTP=(132),
IPPROTO_UDPLITE=(136),
IPPROTO_MPLS=(137),
IPPROTO_ETHERNET=(143),
IPPROTO_RAW=(255),
IPPROTO_SMC=(256),
IPPROTO_MPTCP=(262),
IPPROTO_MAX 
};

enum { IPPROTO_HOPOPTS=(0),
IPPROTO_ROUTING=(43),
IPPROTO_FRAGMENT=(44),
IPPROTO_ICMPV6=(58),
IPPROTO_NONE=(59),
IPPROTO_DSTOPTS=(60),
IPPROTO_MH=(135)
};

enum { IPPORT_ECHO=(7),
IPPORT_DISCARD=(9),
IPPORT_SYSTAT=(11),
IPPORT_DAYTIME=(13),
IPPORT_NETSTAT=(15),
IPPORT_FTP=(21),
IPPORT_TELNET=(23),
IPPORT_SMTP=(25),
IPPORT_TIMESERVER=(37),
IPPORT_NAMESERVER=(42),
IPPORT_WHOIS=(43),
IPPORT_MTP=(57),
IPPORT_TFTP=(69),
IPPORT_RJE=(77),
IPPORT_FINGER=(79),
IPPORT_TTYLINK=(87),
IPPORT_SUPDUP=(95),
IPPORT_EXECSERVER=(512),
IPPORT_LOGINSERVER=(513),
IPPORT_CMDSERVER=(514),
IPPORT_EFSSERVER=(520),
IPPORT_BIFFUDP=(512),
IPPORT_WHOSERVER=(513),
IPPORT_ROUTESERVER=(520),
IPPORT_RESERVED=(1024),
IPPORT_USERRESERVED=(5000)
};

union anonymous_typeZ28
{
unsigned char __u6_addr8[16]  ;
unsigned short int __u6_addr16[8]  ;
unsigned int __u6_addr32[4]  ;
};

union anonymous_typeZ29
{
unsigned char __u6_addr8[16]  ;
unsigned short int __u6_addr16[8]  ;
unsigned int __u6_addr32[4]  ;
};

struct in6_addr
{
    union {
        unsigned char __u6_addr8[16]  ;
        unsigned short int __u6_addr16[8]  ;
        unsigned int __u6_addr32[4]  ;
    } __in6_u;
};

struct sockaddr_in
{
    unsigned short int sin_family  ;
    unsigned short int sin_port  ;
    struct in_addr sin_addr  ;
    unsigned char sin_zero[sizeof(struct sockaddr)-(sizeof(unsigned short int))-sizeof(unsigned short int)-sizeof(struct in_addr)];
} __attribute__ ((__may_alias__)) ;

struct sockaddr_in6
{
    unsigned short int sin6_family  ;
    unsigned short int sin6_port  ;
    unsigned int sin6_flowinfo  ;
    struct in6_addr sin6_addr  ;
    unsigned int sin6_scope_id  ;
} __attribute__ ((__may_alias__)) ;

struct ip_mreq
{
    struct in_addr imr_multiaddr  ;
    struct in_addr imr_interface  ;
};

struct ip_mreqn
{
    struct in_addr imr_multiaddr  ;
    struct in_addr imr_address  ;
    int imr_ifindex;
};

struct ip_mreq_source
{
    struct in_addr imr_multiaddr  ;
    struct in_addr imr_interface  ;
    struct in_addr imr_sourceaddr  ;
};

struct ipv6_mreq
{
    struct in6_addr ipv6mr_multiaddr  ;
    unsigned int ipv6mr_interface;
};

struct group_req
{
    unsigned int gr_interface  ;
    struct sockaddr_storage gr_group  ;
};

struct group_source_req
{
    unsigned int gsr_interface  ;
    struct sockaddr_storage gsr_group  ;
    struct sockaddr_storage gsr_source  ;
};

struct ip_msfilter
{
    struct in_addr imsf_multiaddr  ;
    struct in_addr imsf_interface  ;
    unsigned int imsf_fmode  ;
    unsigned int imsf_numsrc  ;
    struct in_addr imsf_slist[1]  ;
};

struct group_filter
{
    unsigned int gf_interface  ;
    struct sockaddr_storage gf_group  ;
    unsigned int gf_fmode  ;
    unsigned int gf_numsrc  ;
    struct sockaddr_storage gf_slist[1]  ;
};

struct in6_pktinfo
{
    struct in6_addr ipi6_addr  ;
    unsigned int ipi6_ifindex;
};

struct ip6_mtuinfo
{
    struct sockaddr_in6 ip6m_addr  ;
    unsigned int ip6m_mtu  ;
};

struct timezone
{
    int tz_minuteswest;
    int tz_dsttime;
};

enum  __itimer_which { ITIMER_REAL=(0),
ITIMER_VIRTUAL=(1),
ITIMER_PROF=(2)
};

struct itimerval
{
    struct timeval it_interval  ;
    struct timeval it_value  ;
};

struct timex
{
    unsigned int modes;
    long  int offset  ;
    long  int freq  ;
    long  int maxerror  ;
    long  int esterror  ;
    int status;
    long  int constant  ;
    long  int precision  ;
    long  int tolerance  ;
    struct timeval time  ;
    long  int tick  ;
    long  int ppsfreq  ;
    long  int jitter  ;
    int shift;
    long  int stabil  ;
    long  int jitcnt  ;
    long  int calcnt  ;
    long  int errcnt  ;
    long  int stbcnt  ;
    int tai;
    int :32;
    int :32;
    int :32;
    int :32;
    int :32;
    int :32;
    int :32;
    int :32;
    int :32;
    int :32;
    int :32;
};

struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long  int tm_gmtoff;
    const char* tm_zone;
};

struct itimerspec
{
    struct timespec it_interval  ;
    struct timespec it_value  ;
};

struct anonymous_typeX30
{
    long long __clang_max_align_nonce1 __attribute__((__aligned__(__alignof__(long long))));
    long  double __clang_max_align_nonce2 __attribute__((__aligned__(__alignof__(long double))));
};

struct ossl_dispatch_st
{
    int function_id;
    void (*function)();
};

struct ossl_item_st
{
    unsigned int id;
    void* ptr;
};

struct ossl_algorithm_st
{
    const char* algorithm_names;
    const char* property_definition;
    const struct ossl_dispatch_st* implementation  ;
    const char* algorithm_description;
};

struct ossl_param_st
{
    const char* key;
    unsigned int data_type;
    void* data;
    unsigned long data_size  ;
    unsigned long return_size  ;
};

struct anonymous_typeX31
{
    int dummy;
};

struct crypto_ex_data_st
{
    struct ossl_lib_ctx_st* ctx  ;
    struct stack_st_void* sk;
};

struct crypto_threadid_st
{
    int dummy;
};

struct sched_attr
{
    unsigned int size  ;
    unsigned int sched_policy  ;
    unsigned long  long sched_flags  ;
    int sched_nice  ;
    unsigned int sched_priority  ;
    unsigned long  long sched_runtime  ;
    unsigned long  long sched_deadline  ;
    unsigned long  long sched_period  ;
    unsigned int sched_util_min  ;
    unsigned int sched_util_max  ;
};

struct sched_param
{
    int sched_priority;
};

struct anonymous_typeX32
{
    unsigned long  int __bits[1024/(8*sizeof(unsigned long  int))]  ;
};

typedef long  int __jmp_buf[8];

struct __jmp_buf_tag
{
    long  int __jmpbuf[8]  ;
    int __mask_was_saved;
    struct {
        unsigned long  int __val[(1024/(8*sizeof(unsigned long  int)))];
    } __saved_mask;
};

enum { PTHREAD_CREATE_JOINABLE 
,PTHREAD_CREATE_DETACHED 
};

enum { PTHREAD_MUTEX_TIMED_NP 
,PTHREAD_MUTEX_RECURSIVE_NP 
,PTHREAD_MUTEX_ERRORCHECK_NP 
,PTHREAD_MUTEX_ADAPTIVE_NP 
,PTHREAD_MUTEX_NORMAL=((0)),
PTHREAD_MUTEX_RECURSIVE=((1)),
PTHREAD_MUTEX_ERRORCHECK=((2)),
PTHREAD_MUTEX_DEFAULT=(((0))),
PTHREAD_MUTEX_FAST_NP=((0))
};

enum { PTHREAD_MUTEX_STALLED 
,PTHREAD_MUTEX_STALLED_NP=((0)),
PTHREAD_MUTEX_ROBUST 
,PTHREAD_MUTEX_ROBUST_NP=(((0)+1))
};

enum { PTHREAD_PRIO_NONE 
,PTHREAD_PRIO_INHERIT 
,PTHREAD_PRIO_PROTECT 
};

enum { PTHREAD_RWLOCK_PREFER_READER_NP 
,PTHREAD_RWLOCK_PREFER_WRITER_NP 
,PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP 
,PTHREAD_RWLOCK_DEFAULT_NP=((0))
};

enum { PTHREAD_INHERIT_SCHED 
,PTHREAD_EXPLICIT_SCHED 
};

enum { PTHREAD_SCOPE_SYSTEM 
,PTHREAD_SCOPE_PROCESS 
};

enum { PTHREAD_PROCESS_PRIVATE 
,PTHREAD_PROCESS_SHARED 
};

struct _pthread_cleanup_buffer
{
    void (*__routine)(void*);
    void* __arg;
    int __canceltype;
    struct _pthread_cleanup_buffer* __prev  ;
};

enum { PTHREAD_CANCEL_ENABLE 
,PTHREAD_CANCEL_DISABLE 
};

enum { PTHREAD_CANCEL_DEFERRED 
,PTHREAD_CANCEL_ASYNCHRONOUS 
};

struct __cancel_jmp_buf_tag
{
    long  int __cancel_jmp_buf[8]  ;
    int __mask_was_saved;
};

struct anonymous_typeX33
{
    struct __cancel_jmp_buf_tag __cancel_jmp_buf[1]  ;
    void* __pad[4];
};

struct __pthread_cleanup_frame
{
    void (*__cancel_routine)(void*);
    void* __cancel_arg;
    int __do_it;
    int __cancel_type;
};

struct bio_dgram_sctp_sndinfo
{
    unsigned short int snd_sid  ;
    unsigned short int snd_flags  ;
    unsigned int snd_ppid  ;
    unsigned int snd_context  ;
};

struct bio_dgram_sctp_rcvinfo
{
    unsigned short int rcv_sid  ;
    unsigned short int rcv_ssn  ;
    unsigned short int rcv_flags  ;
    unsigned int rcv_ppid  ;
    unsigned int rcv_tsn  ;
    unsigned int rcv_cumtsn  ;
    unsigned int rcv_context  ;
};

struct bio_dgram_sctp_prinfo
{
    unsigned short int pr_policy  ;
    unsigned int pr_value  ;
};

struct bio_msg_st
{
    void* data;
    unsigned long data_len  ;
    union bio_addr_st* peer  ;
    union bio_addr_st* local  ;
    unsigned long  int flags  ;
};

struct bio_mmsg_cb_args_st
{
    struct bio_msg_st* msg  ;
    unsigned long stride  ;
    unsigned long num_msg  ;
    unsigned long  int flags  ;
    unsigned long* msgs_processed  ;
};

union anonymous_typeZ34
{
int fd;
void* custom;
uintptr_t custom_ui;
struct ssl_st* ssl  ;
};

union anonymous_typeZ35
{
int fd;
void* custom;
uintptr_t custom_ui;
struct ssl_st* ssl  ;
};

struct bio_poll_descriptor_st
{
    unsigned int type  ;
    union {
        int fd;
        void* custom;
        uintptr_t custom_ui;
        struct ssl_st* ssl  ;
    } value;
};

enum  BIO_hostserv_priorities { BIO_PARSE_PRIO_HOST 
,BIO_PARSE_PRIO_SERV 
};

enum  BIO_lookup_type { BIO_LOOKUP_CLIENT 
,BIO_LOOKUP_SERVER 
};

union BIO_sock_info_u
{
union bio_addr_st* addr  ;
};

enum  BIO_sock_info_type { BIO_SOCK_INFO_ADDRESS 
};

struct buf_mem_st
{
    unsigned long length  ;
    char* data;
    unsigned long max  ;
    unsigned long  int flags;
};

struct asn1_string_st
{
    int length;
    int type;
    unsigned char* data;
    long flags;
};

struct ASN1_ENCODING_st
{
    unsigned char* enc;
    long len;
    int modified;
};

struct asn1_string_table_st
{
    int nid;
    long minsize;
    long maxsize;
    unsigned long  int mask;
    unsigned long  int flags;
};

union anonymous_typeZ36
{
char* ptr;
int boolean  ;
struct asn1_string_st* asn1_string  ;
struct asn1_object_st* object  ;
struct asn1_string_st* integer  ;
struct asn1_string_st* enumerated  ;
struct asn1_string_st* bit_string  ;
struct asn1_string_st* octet_string  ;
struct asn1_string_st* printablestring  ;
struct asn1_string_st* t61string  ;
struct asn1_string_st* ia5string  ;
struct asn1_string_st* generalstring  ;
struct asn1_string_st* bmpstring  ;
struct asn1_string_st* universalstring  ;
struct asn1_string_st* utctime  ;
struct asn1_string_st* generalizedtime  ;
struct asn1_string_st* visiblestring  ;
struct asn1_string_st* utf8string  ;
struct asn1_string_st* set  ;
struct asn1_string_st* sequence  ;
struct ASN1_VALUE_st* asn1_value  ;
};

union anonymous_typeZ37
{
char* ptr;
int boolean  ;
struct asn1_string_st* asn1_string  ;
struct asn1_object_st* object  ;
struct asn1_string_st* integer  ;
struct asn1_string_st* enumerated  ;
struct asn1_string_st* bit_string  ;
struct asn1_string_st* octet_string  ;
struct asn1_string_st* printablestring  ;
struct asn1_string_st* t61string  ;
struct asn1_string_st* ia5string  ;
struct asn1_string_st* generalstring  ;
struct asn1_string_st* bmpstring  ;
struct asn1_string_st* universalstring  ;
struct asn1_string_st* utctime  ;
struct asn1_string_st* generalizedtime  ;
struct asn1_string_st* visiblestring  ;
struct asn1_string_st* utf8string  ;
struct asn1_string_st* set  ;
struct asn1_string_st* sequence  ;
struct ASN1_VALUE_st* asn1_value  ;
};

struct asn1_type_st
{
    int type;
    union {
        char* ptr;
        int boolean  ;
        struct asn1_string_st* asn1_string  ;
        struct asn1_object_st* object  ;
        struct asn1_string_st* integer  ;
        struct asn1_string_st* enumerated  ;
        struct asn1_string_st* bit_string  ;
        struct asn1_string_st* octet_string  ;
        struct asn1_string_st* printablestring  ;
        struct asn1_string_st* t61string  ;
        struct asn1_string_st* ia5string  ;
        struct asn1_string_st* generalstring  ;
        struct asn1_string_st* bmpstring  ;
        struct asn1_string_st* universalstring  ;
        struct asn1_string_st* utctime  ;
        struct asn1_string_st* generalizedtime  ;
        struct asn1_string_st* visiblestring  ;
        struct asn1_string_st* utf8string  ;
        struct asn1_string_st* set  ;
        struct asn1_string_st* sequence  ;
        struct ASN1_VALUE_st* asn1_value  ;
    } value;
};

struct BIT_STRING_BITNAME_st
{
    int bitnum;
    const char* lname;
    const char* sname;
};

struct obj_name_st
{
    int type;
    int alias;
    const char* name;
    const char* data;
};

struct anonymous_typeX38
{
    unsigned char* out;
    const unsigned char* inp;
    unsigned long len  ;
    unsigned int interleave;
};

struct evp_cipher_info_st
{
    const struct evp_cipher_st* cipher  ;
    unsigned char iv[16];
};

enum   anonymous_typeY38 { POINT_CONVERSION_COMPRESSED=(2),
POINT_CONVERSION_UNCOMPRESSED=(4),
POINT_CONVERSION_HYBRID=(6)
};

struct anonymous_typeX39
{
    int nid;
    const char* comment;
};

struct rsa_pss_params_st
{
    struct X509_algor_st* hashAlgorithm  ;
    struct X509_algor_st* maskGenAlgorithm  ;
    struct asn1_string_st* saltLength  ;
    struct asn1_string_st* trailerField  ;
    struct X509_algor_st* maskHash  ;
};

struct rsa_oaep_params_st
{
    struct X509_algor_st* hashFunc  ;
    struct X509_algor_st* maskGenFunc  ;
    struct X509_algor_st* pSourceFunc  ;
    struct X509_algor_st* maskHash  ;
};

struct SHAstate_st
{
    unsigned int h0;
    unsigned int h1;
    unsigned int h2;
    unsigned int h3;
    unsigned int h4;
    unsigned int Nl;
    unsigned int Nh;
    unsigned int data[16];
    unsigned int num;
};

struct SHA256state_st
{
    unsigned int h[8];
    unsigned int Nl;
    unsigned int Nh;
    unsigned int data[16];
    unsigned int num;
    unsigned int md_len;
};

union anonymous_typeZ40
{
unsigned long  long d[16];
unsigned char p[(16*8)];
};

union anonymous_typeZ41
{
unsigned long  long d[16];
unsigned char p[(16*8)];
};

struct SHA512state_st
{
    unsigned long  long h[8];
    unsigned long  long Nl;
    unsigned long  long Nh;
    union {
        unsigned long  long d[16];
        unsigned char p[(16*8)];
    } u;
    unsigned int num;
    unsigned int md_len;
};

struct X509_algor_st
{
    struct asn1_object_st* algorithm  ;
    struct asn1_type_st* parameter  ;
};

struct X509_val_st
{
    struct asn1_string_st* notBefore  ;
    struct asn1_string_st* notAfter  ;
};

struct private_key_st
{
    int version;
    struct X509_algor_st* enc_algor  ;
    struct asn1_string_st* enc_pkey  ;
    struct evp_pkey_st* dec_pkey  ;
    int key_length;
    char* key_data;
    int key_free;
    struct evp_cipher_info_st cipher  ;
};

struct X509_info_st
{
    struct x509_st* x509  ;
    struct X509_crl_st* crl  ;
    struct private_key_st* x_pkey  ;
    struct evp_cipher_info_st enc_cipher  ;
    int enc_len;
    char* enc_data;
};

struct Netscape_spkac_st
{
    struct X509_pubkey_st* pubkey  ;
    struct asn1_string_st* challenge  ;
};

struct Netscape_spki_st
{
    struct Netscape_spkac_st* spkac  ;
    struct X509_algor_st sig_algor  ;
    struct asn1_string_st* signature  ;
};

struct Netscape_certificate_sequence
{
    struct asn1_object_st* type  ;
    struct stack_st_X509* certs  ;
};

struct PBEPARAM_st
{
    struct asn1_string_st* salt  ;
    struct asn1_string_st* iter  ;
};

struct PBE2PARAM_st
{
    struct X509_algor_st* keyfunc  ;
    struct X509_algor_st* encryption  ;
};

struct PBKDF2PARAM_st
{
    struct asn1_type_st* salt  ;
    struct asn1_string_st* iter  ;
    struct asn1_string_st* keylength  ;
    struct X509_algor_st* prf  ;
};

struct anonymous_typeX42
{
    struct X509_algor_st* keyDerivationFunc  ;
    struct X509_algor_st* messageAuthScheme  ;
};

struct SCRYPT_PARAMS_st
{
    struct asn1_string_st* salt  ;
    struct asn1_string_st* costParameter  ;
    struct asn1_string_st* blockSize  ;
    struct asn1_string_st* parallelizationParameter  ;
    struct asn1_string_st* keyLength  ;
};

struct lhash_st_OPENSSL_STRING
{
    union lh_OPENSSL_STRING_dummy {
        void* d1;
        unsigned long  int d2;
        int d3;
    } dummy;
};

struct lhash_st_OPENSSL_CSTRING
{
    union lh_OPENSSL_CSTRING_dummy {
        void* d1;
        unsigned long  int d2;
        int d3;
    } dummy;
};

enum   anonymous_typeY42 { X509_LU_NONE=(0),
X509_LU_X509 
,X509_LU_CRL 
};

struct x509_trust_st
{
    int trust;
    int flags;
    int (*check_trust)(struct x509_trust_st*,struct x509_st*,int);
    char* name;
    int arg1;
    void* arg2;
};

struct PKCS7_CTX_st
{
    struct ossl_lib_ctx_st* libctx  ;
    char* propq;
};

struct pkcs7_issuer_and_serial_st
{
    struct X509_name_st* issuer  ;
    struct asn1_string_st* serial  ;
};

struct pkcs7_signer_info_st
{
    struct asn1_string_st* version  ;
    struct pkcs7_issuer_and_serial_st* issuer_and_serial  ;
    struct X509_algor_st* digest_alg  ;
    struct stack_st_X509_ATTRIBUTE* auth_attr  ;
    struct X509_algor_st* digest_enc_alg  ;
    struct asn1_string_st* enc_digest  ;
    struct stack_st_X509_ATTRIBUTE* unauth_attr  ;
    struct evp_pkey_st* pkey  ;
    const struct PKCS7_CTX_st* ctx  ;
};

struct pkcs7_recip_info_st
{
    struct asn1_string_st* version  ;
    struct pkcs7_issuer_and_serial_st* issuer_and_serial  ;
    struct X509_algor_st* key_enc_algor  ;
    struct asn1_string_st* enc_key  ;
    struct x509_st* cert  ;
    const struct PKCS7_CTX_st* ctx  ;
};

struct pkcs7_signed_st
{
    struct asn1_string_st* version  ;
    struct stack_st_X509_ALGOR* md_algs  ;
    struct stack_st_X509* cert  ;
    struct stack_st_X509_CRL* crl  ;
    struct stack_st_PKCS7_SIGNER_INFO* signer_info  ;
    struct pkcs7_st* contents;
};

struct pkcs7_enc_content_st
{
    struct asn1_object_st* content_type  ;
    struct X509_algor_st* algorithm  ;
    struct asn1_string_st* enc_data  ;
    const struct evp_cipher_st* cipher  ;
    const struct PKCS7_CTX_st* ctx  ;
};

struct pkcs7_enveloped_st
{
    struct asn1_string_st* version  ;
    struct stack_st_PKCS7_RECIP_INFO* recipientinfo  ;
    struct pkcs7_enc_content_st* enc_data  ;
};

struct pkcs7_signedandenveloped_st
{
    struct asn1_string_st* version  ;
    struct stack_st_X509_ALGOR* md_algs  ;
    struct stack_st_X509* cert  ;
    struct stack_st_X509_CRL* crl  ;
    struct stack_st_PKCS7_SIGNER_INFO* signer_info  ;
    struct pkcs7_enc_content_st* enc_data  ;
    struct stack_st_PKCS7_RECIP_INFO* recipientinfo  ;
};

struct pkcs7_digest_st
{
    struct asn1_string_st* version  ;
    struct X509_algor_st* md  ;
    struct pkcs7_st* contents;
    struct asn1_string_st* digest  ;
};

struct pkcs7_encrypted_st
{
    struct asn1_string_st* version  ;
    struct pkcs7_enc_content_st* enc_data  ;
};

union anonymous_typeZ43
{
char* ptr;
struct asn1_string_st* data  ;
struct pkcs7_signed_st* sign  ;
struct pkcs7_enveloped_st* enveloped  ;
struct pkcs7_signedandenveloped_st* signed_and_enveloped  ;
struct pkcs7_digest_st* digest  ;
struct pkcs7_encrypted_st* encrypted  ;
struct asn1_type_st* other  ;
};

union anonymous_typeZ44
{
char* ptr;
struct asn1_string_st* data  ;
struct pkcs7_signed_st* sign  ;
struct pkcs7_enveloped_st* enveloped  ;
struct pkcs7_signedandenveloped_st* signed_and_enveloped  ;
struct pkcs7_digest_st* digest  ;
struct pkcs7_encrypted_st* encrypted  ;
struct asn1_type_st* other  ;
};

struct pkcs7_st
{
    unsigned char* asn1;
    long length;
    int state;
    int detached;
    struct asn1_object_st* type  ;
    union {
        char* ptr;
        struct asn1_string_st* data  ;
        struct pkcs7_signed_st* sign  ;
        struct pkcs7_enveloped_st* enveloped  ;
        struct pkcs7_signedandenveloped_st* signed_and_enveloped  ;
        struct pkcs7_digest_st* digest  ;
        struct pkcs7_encrypted_st* encrypted  ;
        struct asn1_type_st* other  ;
    } d;
    struct PKCS7_CTX_st ctx  ;
};

struct anonymous_typeX45
{
    char* section;
    char* name;
    char* value;
};

struct lhash_st_CONF_VALUE
{
    union lh_CONF_VALUE_dummy {
        void* d1;
        unsigned long  int d2;
        int d3;
    } dummy;
};

struct conf_method_st
{
    const char* name;
    struct conf_st* (*create)(struct conf_method_st*);
    int (*init)(struct conf_st*);
    int (*destroy)(struct conf_st*);
    int (*destroy_data)(struct conf_st*);
    int (*load_bio)(struct conf_st*,struct bio_st*,long*);
    int (*dump)(const struct conf_st*,struct bio_st*);
    int (*is_number)(const struct conf_st*,char);
    int (*to_int)(const struct conf_st*,char);
    int (*load)(struct conf_st*,const char*,long*);
};

struct conf_st
{
    struct conf_method_st* meth  ;
    void* meth_data;
    struct lhash_st_CONF_VALUE* data  ;
    int flag_dollarid;
    int flag_abspath;
    char* includedir;
    struct ossl_lib_ctx_st* libctx  ;
};

enum   anonymous_typeY45 { CT_LOG_ENTRY_TYPE_NOT_SET=(-1),
CT_LOG_ENTRY_TYPE_X509=(0),
CT_LOG_ENTRY_TYPE_PRECERT=(1)
};

struct srtp_protection_profile_st
{
    const char* name;
    unsigned long  int id;
};

struct tls_session_ticket_ext_st
{
    unsigned short int length;
    void* data;
};

struct ssl_shutdown_ex_args_st
{
    unsigned long  int quic_error_code  ;
    const char* quic_reason;
};

struct ssl_stream_reset_args_st
{
    unsigned long  int quic_error_code  ;
};

struct ssl_conn_close_info_st
{
    unsigned long  int error_code  ;
    unsigned long  int frame_type  ;
    const char* reason;
    unsigned long reason_len  ;
    unsigned int flags  ;
};

struct ssl_poll_item_st
{
    struct bio_poll_descriptor_st desc  ;
    unsigned long  int events  ;
    unsigned long  int revents  ;
};

enum { SSL_CT_VALIDATION_PERMISSIVE=(0),
SSL_CT_VALIDATION_STRICT 
};

struct err_state_st
{
    int err_flags[16];
    int err_marks[16];
    unsigned long  int err_buffer[16];
    char* err_data[16];
    unsigned long err_data_size[16]  ;
    int err_data_flags[16];
    char* err_file[16];
    int err_line[16];
    char* err_func[16];
    int top;
    int bottom;
};

struct ERR_string_data_st
{
    unsigned long  int error;
    const char* string;
};

struct lhash_st_ERR_STRING_DATA
{
    union lh_ERR_STRING_DATA_dummy {
        void* d1;
        unsigned long  int d2;
        int d3;
    } dummy;
};

struct sType
{
    char* class_name  ;
    int array_num;
    _Bool auto_increment;
    _Bool primary_key;
    _Bool not_null;
};

struct map$2char$phchar$ph
{
    char** keys  ;
    _Bool* item_existance;
    char** items  ;
    int size;
    int len;
    struct list$1char$ph* key_list;
    int it;
};

struct list_item$1map$2char$phchar$ph$ph
{
    struct map$2char$phchar$ph* item;
    struct list_item$1map$2char$phchar$ph$ph* prev;
    struct list_item$1map$2char$phchar$ph$ph* next;
};

struct list$1map$2char$phchar$ph$ph
{
    struct list_item$1map$2char$phchar$ph$ph* head;
    struct list_item$1map$2char$phchar$ph$ph* tail;
    int len;
    struct list_item$1map$2char$phchar$ph$ph* it;
};

struct tuple2$2char$phsType$ph
{
    char* v1  ;
    struct sType* v2  ;
};

struct list_item$1tuple2$2char$phsType$ph$ph
{
    struct tuple2$2char$phsType$ph* item;
    struct list_item$1tuple2$2char$phsType$ph$ph* prev;
    struct list_item$1tuple2$2char$phsType$ph$ph* next;
};

struct list$1tuple2$2char$phsType$ph$ph
{
    struct list_item$1tuple2$2char$phsType$ph$ph* head;
    struct list_item$1tuple2$2char$phsType$ph$ph* tail;
    int len;
    struct list_item$1tuple2$2char$phsType$ph$ph* it;
};

struct Table
{
    char* name  ;
    struct list$1map$2char$phchar$ph$ph* rows;
    struct list$1tuple2$2char$phsType$ph$ph* types;
};

struct map$2char$phTable$ph
{
    char** keys  ;
    _Bool* item_existance;
    struct Table** items  ;
    int size;
    int len;
    struct list$1char$ph* key_list;
    int it;
};

struct Database
{
    char* name  ;
    struct map$2char$phTable$ph* tables;
};

struct map$2char$phDatabase$ph
{
    char** keys  ;
    _Bool* item_existance;
    struct Database** items  ;
    int size;
    int len;
    struct list$1char$ph* key_list;
    int it;
};

struct sInfo
{
    char* p;
    int socket;
    char* current_db_name  ;
};

struct tuple3$3char$phsType$ph_Bool$
{
    char* v1  ;
    struct sType* v2  ;
    _Bool v3;
};

struct tuple3$3char$phsType$phint$
{
    char* v1  ;
    struct sType* v2  ;
    int v3;
};

struct tuple1$1WhereNode$ph
{
    struct WhereNode* v1  ;
};

struct WhereNode
{
    enum anonymous_typeY45 op;
    struct tuple1$1WhereNode$ph* left;
    struct tuple1$1WhereNode$ph* right;
    char* data  ;
};

struct map$2char$ph_Bool$
{
    char** keys  ;
    _Bool* item_existance;
    _Bool* items;
    int size;
    int len;
    struct list$1char$ph* key_list;
    int it;
};

struct tuple2$2char$phchar$ph
{
    char* v1  ;
    char* v2  ;
};

struct __current_stack1__
{
    struct sInfo* info  ;
};

/// variable definition ///
extern struct _IO_FILE* stdin  ;
extern struct _IO_FILE* stdout  ;
extern struct _IO_FILE* stderr  ;
extern char* program_invocation_name;
extern char* program_invocation_short_name;
extern char* gComeStackFrameSName[128];

extern int gComeStackFrameSLine[128];

extern int gComeStackFrameID[128];

extern int gNumComeStackFrame;

extern char* gComeStackFrameBuffer;

extern struct sMemHeader* gAllocMem  ;

extern int gComeDebugLib;

extern int gNumAlloc;

extern int gNumFree;

extern char** __environ;
extern char** environ;
extern char* optarg;
extern int optind;
extern int opterr;
extern int optopt;
extern const struct in6_addr in6addr_any  ;
extern const struct in6_addr in6addr_loopback  ;
extern char* __tzname[2];
extern int __daylight;
extern long  int __timezone;
extern char* tzname[2];
extern int daylight;
extern long  int timezone;
extern int getdate_err;
int (*OSSL_provider_init)(const struct ossl_core_handle_st*,const struct ossl_dispatch_st*,const struct ossl_dispatch_st**,void**)  ;
struct map$2char$phDatabase$ph* gDatabases;
// source head

// header function
int remove(const char* __filename);
int rename(const char* __old, const char* __new);
int renameat(int __oldfd, const char* __old, int __newfd, const char* __new);
int renameat2(int __oldfd, const char* __old, int __newfd, const char* __new, unsigned int __flags);
int fclose(struct _IO_FILE* __stream  );
struct _IO_FILE* tmpfile();
struct _IO_FILE* tmpfile64();
char* tmpnam(char [20]);
char* tmpnam_r(char __s[20]);
char* tempnam(const char* __dir, const char* __pfx);
int fflush(struct _IO_FILE* __stream  );
int fflush_unlocked(struct _IO_FILE* __stream  );
int fcloseall();
struct _IO_FILE* fopen(const char* __filename, const char* __modes);
struct _IO_FILE* freopen(const char* __filename, const char* __modes, struct _IO_FILE* __stream  );
struct _IO_FILE* fopen64(const char* __filename, const char* __modes);
struct _IO_FILE* freopen64(const char* __filename, const char* __modes, struct _IO_FILE* __stream  );
struct _IO_FILE* fdopen(int __fd, const char* __modes);
struct _IO_FILE* fopencookie(void* __magic_cookie, const char* __modes, struct _IO_cookie_io_functions_t __io_funcs  );
struct _IO_FILE* fmemopen(void* __s, unsigned long __len  , const char* __modes);
struct _IO_FILE* open_memstream(char** __bufloc, unsigned long* __sizeloc  );
void setbuf(struct _IO_FILE* __stream  , char* __buf);
int setvbuf(struct _IO_FILE* __stream  , char* __buf, int __modes, unsigned long __n  );
void setbuffer(struct _IO_FILE* __stream  , char* __buf, unsigned long __size  );
void setlinebuf(struct _IO_FILE* __stream  );
int fprintf(struct _IO_FILE* __stream  , const char* __format, ...);
int printf(const char* __format, ...);
int sprintf(char* __s, const char* __format, ...);
int vfprintf(struct _IO_FILE* __s  , const char* __format, __builtin_va_list __arg  );
int vprintf(const char* __format, __builtin_va_list __arg  );
int vsprintf(char* __s, const char* __format, __builtin_va_list __arg  );
int snprintf(char* __s, unsigned long __maxlen  , const char* __format, ...);
int vsnprintf(char* __s, unsigned long __maxlen  , const char* __format, __builtin_va_list __arg  );
int vasprintf(char** __ptr, const char* __f, __builtin_va_list __arg  );
int __asprintf(char** __ptr, const char* __fmt, ...);
int asprintf(char** __ptr, const char* __fmt, ...);
int vdprintf(int __fd, const char* __fmt, __builtin_va_list __arg  );
int dprintf(int __fd, const char* __fmt, ...);
int fscanf(struct _IO_FILE* __stream  , const char* __format, ...);
int scanf(const char* __format, ...);
int sscanf(const char* __s, const char* __format, ...);
int __isoc23_fscanf(struct _IO_FILE* __stream  , const char* __format, ...);
int __isoc23_scanf(const char* __format, ...);
int __isoc23_sscanf(const char* __s, const char* __format, ...);
int vfscanf(struct _IO_FILE* __s  , const char* __format, __builtin_va_list __arg  );
int vscanf(const char* __format, __builtin_va_list __arg  );
int vsscanf(const char* __s, const char* __format, __builtin_va_list __arg  );
int __isoc23_vfscanf(struct _IO_FILE* __s  , const char* __format, __builtin_va_list __arg  );
int __isoc23_vscanf(const char* __format, __builtin_va_list __arg  );
int __isoc23_vsscanf(const char* __s, const char* __format, __builtin_va_list __arg  );
int fgetc(struct _IO_FILE* __stream  );
int getc(struct _IO_FILE* __stream  );
int getchar();
int getc_unlocked(struct _IO_FILE* __stream  );
int getchar_unlocked();
int fgetc_unlocked(struct _IO_FILE* __stream  );
int fputc(int __c, struct _IO_FILE* __stream  );
int putc(int __c, struct _IO_FILE* __stream  );
int putchar(int __c);
int fputc_unlocked(int __c, struct _IO_FILE* __stream  );
int putc_unlocked(int __c, struct _IO_FILE* __stream  );
int putchar_unlocked(int __c);
int getw(struct _IO_FILE* __stream  );
int putw(int __w, struct _IO_FILE* __stream  );
char* fgets(char* __s, int __n, struct _IO_FILE* __stream  );
char* fgets_unlocked(char* __s, int __n, struct _IO_FILE* __stream  );
long  int __getdelim(char** __lineptr, unsigned long* __n  , int __delimiter, struct _IO_FILE* __stream  );
long  int getdelim(char** __lineptr, unsigned long* __n  , int __delimiter, struct _IO_FILE* __stream  );
long  int getline(char** __lineptr, unsigned long* __n  , struct _IO_FILE* __stream  );
int fputs(const char* __s, struct _IO_FILE* __stream  );
int puts(const char* __s);
int ungetc(int __c, struct _IO_FILE* __stream  );
unsigned long fread(void* __ptr, unsigned long __size  , unsigned long __n  , struct _IO_FILE* __stream  );
unsigned long fwrite(const void* __ptr, unsigned long __size  , unsigned long __n  , struct _IO_FILE* __s  );
int fputs_unlocked(const char* __s, struct _IO_FILE* __stream  );
unsigned long fread_unlocked(void* __ptr, unsigned long __size  , unsigned long __n  , struct _IO_FILE* __stream  );
unsigned long fwrite_unlocked(const void* __ptr, unsigned long __size  , unsigned long __n  , struct _IO_FILE* __stream  );
int fseek(struct _IO_FILE* __stream  , long  int __off, int __whence);
long  int ftell(struct _IO_FILE* __stream  );
void rewind(struct _IO_FILE* __stream  );
int fseeko(struct _IO_FILE* __stream  , long  int __off  , int __whence);
long  int ftello(struct _IO_FILE* __stream  );
int fgetpos(struct _IO_FILE* __stream  , struct _G_fpos_t* __pos  );
int fsetpos(struct _IO_FILE* __stream  , const struct _G_fpos_t* __pos  );
int fseeko64(struct _IO_FILE* __stream  , long  int __off  , int __whence);
long  int ftello64(struct _IO_FILE* __stream  );
int fgetpos64(struct _IO_FILE* __stream  , struct _G_fpos64_t* __pos  );
int fsetpos64(struct _IO_FILE* __stream  , const struct _G_fpos64_t* __pos  );
void clearerr(struct _IO_FILE* __stream  );
int feof(struct _IO_FILE* __stream  );
int ferror(struct _IO_FILE* __stream  );
void clearerr_unlocked(struct _IO_FILE* __stream  );
int feof_unlocked(struct _IO_FILE* __stream  );
int ferror_unlocked(struct _IO_FILE* __stream  );
void perror(const char* __s);
int fileno(struct _IO_FILE* __stream  );
int fileno_unlocked(struct _IO_FILE* __stream  );
int pclose(struct _IO_FILE* __stream  );
struct _IO_FILE* popen(const char* __command, const char* __modes);
char* ctermid(char* __s);
char* cuserid(char* __s);
int obstack_printf(struct obstack* __obstack  , const char* __format, ...);
int obstack_vprintf(struct obstack* __obstack  , const char* __format, __builtin_va_list __args  );
void flockfile(struct _IO_FILE* __stream  );
int ftrylockfile(struct _IO_FILE* __stream  );
void funlockfile(struct _IO_FILE* __stream  );
int __uflow(struct _IO_FILE*   );
int __overflow(struct _IO_FILE*   , int );
unsigned long __ctype_get_mb_cur_max();
double atof(const char* __nptr);
int atoi(const char* __nptr);
long  int atol(const char* __nptr);
long long int atoll(const char* __nptr);
double strtod(const char* __nptr, char** __endptr);
float strtof(const char* __nptr, char** __endptr);
long  double strtold(const char* __nptr, char** __endptr);
float strtof32(const char* __nptr, char** __endptr);
double strtof64(const char* __nptr, char** __endptr);
double strtof32x(const char* __nptr, char** __endptr);
long  double strtof64x(const char* __nptr, char** __endptr);
long  int strtol(const char* __nptr, char** __endptr, int __base);
unsigned long  int strtoul(const char* __nptr, char** __endptr, int __base);
long long int strtoq(const char* __nptr, char** __endptr, int __base);
unsigned long long int strtouq(const char* __nptr, char** __endptr, int __base);
long long int strtoll(const char* __nptr, char** __endptr, int __base);
unsigned long long int strtoull(const char* __nptr, char** __endptr, int __base);
long  int __isoc23_strtol(const char* __nptr, char** __endptr, int __base);
unsigned long  int __isoc23_strtoul(const char* __nptr, char** __endptr, int __base);
long long int __isoc23_strtoll(const char* __nptr, char** __endptr, int __base);
unsigned long long int __isoc23_strtoull(const char* __nptr, char** __endptr, int __base);
int strfromd(char* __dest, unsigned long __size  , const char* __format, double __f);
int strfromf(char* __dest, unsigned long __size  , const char* __format, float __f);
int strfroml(char* __dest, unsigned long __size  , const char* __format, long  double __f);
int strfromf32(char* __dest, unsigned long __size  , const char* __format, float __f  );
int strfromf64(char* __dest, unsigned long __size  , const char* __format, double __f  );
int strfromf32x(char* __dest, unsigned long __size  , const char* __format, double __f  );
int strfromf64x(char* __dest, unsigned long __size  , const char* __format, long  double __f  );
long  int strtol_l(const char* __nptr, char** __endptr, int __base, struct __locale_struct* __loc  );
unsigned long  int strtoul_l(const char* __nptr, char** __endptr, int __base, struct __locale_struct* __loc  );
long long int strtoll_l(const char* __nptr, char** __endptr, int __base, struct __locale_struct* __loc  );
unsigned long long int strtoull_l(const char* __nptr, char** __endptr, int __base, struct __locale_struct* __loc  );
long  int __isoc23_strtol_l(const char* __nptr, char** __endptr, int __base, struct __locale_struct* __loc  );
unsigned long  int __isoc23_strtoul_l(const char* __nptr, char** __endptr, int __base, struct __locale_struct* __loc  );
long long int __isoc23_strtoll_l(const char* __nptr, char** __endptr, int __base, struct __locale_struct* __loc  );
unsigned long long int __isoc23_strtoull_l(const char* __nptr, char** __endptr, int __base, struct __locale_struct* __loc  );
double strtod_l(const char* __nptr, char** __endptr, struct __locale_struct* __loc  );
float strtof_l(const char* __nptr, char** __endptr, struct __locale_struct* __loc  );
long  double strtold_l(const char* __nptr, char** __endptr, struct __locale_struct* __loc  );
float strtof32_l(const char* __nptr, char** __endptr, struct __locale_struct* __loc  );
double strtof64_l(const char* __nptr, char** __endptr, struct __locale_struct* __loc  );
double strtof32x_l(const char* __nptr, char** __endptr, struct __locale_struct* __loc  );
long  double strtof64x_l(const char* __nptr, char** __endptr, struct __locale_struct* __loc  );
char* l64a(long  int __n);
long  int a64l(const char* __s);
int select(int __nfds, struct anonymous_typeX8* __readfds  , struct anonymous_typeX8* __writefds  , struct anonymous_typeX8* __exceptfds  , struct timeval* __timeout  );
int pselect(int __nfds, struct anonymous_typeX8* __readfds  , struct anonymous_typeX8* __writefds  , struct anonymous_typeX8* __exceptfds  , const struct timespec* __timeout  , const struct anonymous_typeX7* __sigmask  );
long  int random();
void srandom(unsigned int __seed);
char* initstate(unsigned int __seed, char* __statebuf, unsigned long __statelen  );
char* setstate(char* __statebuf);
int random_r(struct random_data* __buf  , int* __result  );
int srandom_r(unsigned int __seed, struct random_data* __buf  );
int initstate_r(unsigned int __seed, char* __statebuf, unsigned long __statelen  , struct random_data* __buf  );
int setstate_r(char* __statebuf, struct random_data* __buf  );
int rand();
void srand(unsigned int __seed);
int rand_r(unsigned int* __seed);
double drand48();
double erand48(unsigned short int __xsubi[3]);
long  int lrand48();
long  int nrand48(unsigned short int __xsubi[3]);
long  int mrand48();
long  int jrand48(unsigned short int __xsubi[3]);
void srand48(long  int __seedval);
unsigned short int* seed48(unsigned short int __seed16v[3]);
void lcong48(unsigned short int __param[7]);
int drand48_r(struct drand48_data* __buffer  , double* __result);
int erand48_r(unsigned short int __xsubi[3], struct drand48_data* __buffer  , double* __result);
int lrand48_r(struct drand48_data* __buffer  , long  int* __result);
int nrand48_r(unsigned short int __xsubi[3], struct drand48_data* __buffer  , long  int* __result);
int mrand48_r(struct drand48_data* __buffer  , long  int* __result);
int jrand48_r(unsigned short int __xsubi[3], struct drand48_data* __buffer  , long  int* __result);
int srand48_r(long  int __seedval, struct drand48_data* __buffer  );
int seed48_r(unsigned short int __seed16v[3], struct drand48_data* __buffer  );
int lcong48_r(unsigned short int __param[7], struct drand48_data* __buffer  );
unsigned int arc4random();
void arc4random_buf(void* __buf, unsigned long __size  );
unsigned int arc4random_uniform(unsigned int __upper_bound  );
void* malloc(unsigned long __size  );
void* calloc(unsigned long __nmemb  , unsigned long __size  );
void* realloc(void* __ptr, unsigned long __size  );
void free(void* __ptr);
void* reallocarray(void* __ptr, unsigned long __nmemb  , unsigned long __size  );
void* alloca(unsigned long __size  );
void* valloc(unsigned long __size  );
int posix_memalign(void** __memptr, unsigned long __alignment  , unsigned long __size  );
void* aligned_alloc(unsigned long __alignment  , unsigned long __size  );
void abort();
int atexit(void (*__func)());
int at_quick_exit(void (*__func)());
int on_exit(void (*__func)(int,void*), void* __arg);
void exit(int __status);
void quick_exit(int __status);
void _Exit(int __status);
char* getenv(const char* __name);
char* secure_getenv(const char* __name);
int putenv(char* __string);
int setenv(const char* __name, const char* __value, int __replace);
int unsetenv(const char* __name);
int clearenv();
char* mktemp(char* __template);
int mkstemp(char* __template);
int mkstemp64(char* __template);
int mkstemps(char* __template, int __suffixlen);
int mkstemps64(char* __template, int __suffixlen);
char* mkdtemp(char* __template);
int mkostemp(char* __template, int __flags);
int mkostemp64(char* __template, int __flags);
int mkostemps(char* __template, int __suffixlen, int __flags);
int mkostemps64(char* __template, int __suffixlen, int __flags);
int system(const char* __command);
char* canonicalize_file_name(const char* __name);
char* realpath(const char* __name, char* __resolved);
void* bsearch(const void* __key, const void* __base, unsigned long __nmemb  , unsigned long __size  , int (*__compar)(const void*,const void*)  );
void qsort(void* __base, unsigned long __nmemb  , unsigned long __size  , int (*__compar)(const void*,const void*)  );
void qsort_r(void* __base, unsigned long __nmemb  , unsigned long __size  , int (*__compar)(const void*,const void*,void*)  , void* __arg);
int abs(int __x);
long  int labs(long  int __x);
long long int llabs(long long int __x);
unsigned int uabs(int __x);
unsigned long  int ulabs(long  int __x);
unsigned long long int ullabs(long long int __x);
struct anonymous_typeX4 div(int __numer, int __denom);
struct anonymous_typeX5 ldiv(long  int __numer, long  int __denom);
struct anonymous_typeX6 lldiv(long long int __numer, long long int __denom);
char* ecvt(double __value, int __ndigit, int* __decpt, int* __sign);
char* fcvt(double __value, int __ndigit, int* __decpt, int* __sign);
char* gcvt(double __value, int __ndigit, char* __buf);
char* qecvt(long  double __value, int __ndigit, int* __decpt, int* __sign);
char* qfcvt(long  double __value, int __ndigit, int* __decpt, int* __sign);
char* qgcvt(long  double __value, int __ndigit, char* __buf);
int ecvt_r(double __value, int __ndigit, int* __decpt, int* __sign, char* __buf, unsigned long __len  );
int fcvt_r(double __value, int __ndigit, int* __decpt, int* __sign, char* __buf, unsigned long __len  );
int qecvt_r(long  double __value, int __ndigit, int* __decpt, int* __sign, char* __buf, unsigned long __len  );
int qfcvt_r(long  double __value, int __ndigit, int* __decpt, int* __sign, char* __buf, unsigned long __len  );
int mblen(const char* __s, unsigned long __n  );
int mbtowc(int* __pwc  , const char* __s, unsigned long __n  );
int wctomb(char* __s, int __wchar  );
unsigned long mbstowcs(int* __pwcs  , const char* __s, unsigned long __n  );
unsigned long wcstombs(char* __s, const int* __pwcs  , unsigned long __n  );
int rpmatch(const char* __response);
int getsubopt(char** __optionp, char** __tokens, char** __valuep);
int posix_openpt(int __oflag);
int grantpt(int __fd);
int unlockpt(int __fd);
char* ptsname(int __fd);
int ptsname_r(int __fd, char* __buf, unsigned long __buflen  );
int getpt();
int getloadavg(double __loadavg[], int __nelem);
void* memcpy(void* __dest, const void* __src, unsigned long __n  );
void* memmove(void* __dest, const void* __src, unsigned long __n  );
void* memccpy(void* __dest, const void* __src, int __c, unsigned long __n  );
void* memset(void* __s, int __c, unsigned long __n  );
int memcmp(const void* __s1, const void* __s2, unsigned long __n  );
int __memcmpeq(const void* __s1, const void* __s2, unsigned long __n  );
void* memchr(const void* __s, int __c, unsigned long __n  );
void* rawmemchr(const void* __s, int __c);
void* memrchr(const void* __s, int __c, unsigned long __n  );
char* strcpy(char* __dest, const char* __src);
char* strncpy(char* __dest, const char* __src, unsigned long __n  );
char* strcat(char* __dest, const char* __src);
char* strncat(char* __dest, const char* __src, unsigned long __n  );
int strcmp(const char* __s1, const char* __s2);
int strncmp(const char* __s1, const char* __s2, unsigned long __n  );
int strcoll(const char* __s1, const char* __s2);
unsigned long strxfrm(char* __dest, const char* __src, unsigned long __n  );
int strcoll_l(const char* __s1, const char* __s2, struct __locale_struct* __l  );
unsigned long strxfrm_l(char* __dest, const char* __src, unsigned long __n  , struct __locale_struct* __l  );
char* strdup(const char* __s);
char* strndup(const char* __string, unsigned long __n  );
char* strchr(const char* __s, int __c);
char* strrchr(const char* __s, int __c);
char* strchrnul(const char* __s, int __c);
unsigned long strcspn(const char* __s, const char* __reject);
unsigned long strspn(const char* __s, const char* __accept);
char* strpbrk(const char* __s, const char* __accept);
char* strstr(const char* __haystack, const char* __needle);
char* strtok(char* __s, const char* __delim);
char* __strtok_r(char* __s, const char* __delim, char** __save_ptr);
char* strtok_r(char* __s, const char* __delim, char** __save_ptr);
char* strcasestr(const char* __haystack, const char* __needle);
void* memmem(const void* __haystack, unsigned long __haystacklen  , const void* __needle, unsigned long __needlelen  );
void* __mempcpy(void* __dest, const void* __src, unsigned long __n  );
void* mempcpy(void* __dest, const void* __src, unsigned long __n  );
unsigned long strlen(const char* __s);
unsigned long strnlen(const char* __string, unsigned long __maxlen  );
char* strerror(int __errnum);
char* strerror_r(int __errnum, char* __buf, unsigned long __buflen  );
const char* strerrordesc_np(int __err);
const char* strerrorname_np(int __err);
char* strerror_l(int __errnum, struct __locale_struct* __l  );
int bcmp(const void* __s1, const void* __s2, unsigned long __n  );
void bcopy(const void* __src, void* __dest, unsigned long __n  );
void bzero(void* __s, unsigned long __n  );
char* index(const char* __s, int __c);
char* rindex(const char* __s, int __c);
int ffs(int __i);
int ffsl(long  int __l);
int ffsll(long long int __ll);
int strcasecmp(const char* __s1, const char* __s2);
int strncasecmp(const char* __s1, const char* __s2, unsigned long __n  );
int strcasecmp_l(const char* __s1, const char* __s2, struct __locale_struct* __loc  );
int strncasecmp_l(const char* __s1, const char* __s2, unsigned long __n  , struct __locale_struct* __loc  );
void explicit_bzero(void* __s, unsigned long __n  );
char* strsep(char** __stringp, const char* __delim);
char* strsignal(int __sig);
const char* sigabbrev_np(int __sig);
const char* sigdescr_np(int __sig);
char* __stpcpy(char* __dest, const char* __src);
char* stpcpy(char* __dest, const char* __src);
char* __stpncpy(char* __dest, const char* __src, unsigned long __n  );
char* stpncpy(char* __dest, const char* __src, unsigned long __n  );
unsigned long strlcpy(char* __dest, const char* __src, unsigned long __n  );
unsigned long strlcat(char* __dest, const char* __src, unsigned long __n  );
int strverscmp(const char* __s1, const char* __s2);
char* strfry(char* __string);
void* memfrob(void* __s, unsigned long __n  );
char* basename(const char* __filename);
long  int __sysconf(int __name);
char* setlocale(int __category, const char* __locale);
struct lconv* localeconv();
struct __locale_struct* newlocale(int __category_mask, const char* __locale, struct __locale_struct* __base  );
struct __locale_struct* duplocale(struct __locale_struct* __dataset  );
void freelocale(struct __locale_struct* __dataset  );
struct __locale_struct* uselocale(struct __locale_struct* __dataset  );
int* __errno_location();
int* wcscpy(int* __dest  , const int* __src  );
int* wcsncpy(int* __dest  , const int* __src  , unsigned long __n  );
unsigned long wcslcpy(int* __dest  , const int* __src  , unsigned long __n  );
unsigned long wcslcat(int* __dest  , const int* __src  , unsigned long __n  );
int* wcscat(int* __dest  , const int* __src  );
int* wcsncat(int* __dest  , const int* __src  , unsigned long __n  );
int wcscmp(const int* __s1  , const int* __s2  );
int wcsncmp(const int* __s1  , const int* __s2  , unsigned long __n  );
int wcscasecmp(const int* __s1  , const int* __s2  );
int wcsncasecmp(const int* __s1  , const int* __s2  , unsigned long __n  );
int wcscasecmp_l(const int* __s1  , const int* __s2  , struct __locale_struct* __loc  );
int wcsncasecmp_l(const int* __s1  , const int* __s2  , unsigned long __n  , struct __locale_struct* __loc  );
int wcscoll(const int* __s1  , const int* __s2  );
unsigned long wcsxfrm(int* __s1  , const int* __s2  , unsigned long __n  );
int wcscoll_l(const int* __s1  , const int* __s2  , struct __locale_struct* __loc  );
unsigned long wcsxfrm_l(int* __s1  , const int* __s2  , unsigned long __n  , struct __locale_struct* __loc  );
int* wcsdup(const int* __s  );
int* wcschr(const int* __wcs  , int __wc  );
int* wcsrchr(const int* __wcs  , int __wc  );
int* wcschrnul(const int* __s  , int __wc  );
unsigned long wcscspn(const int* __wcs  , const int* __reject  );
unsigned long wcsspn(const int* __wcs  , const int* __accept  );
int* wcspbrk(const int* __wcs  , const int* __accept  );
int* wcsstr(const int* __haystack  , const int* __needle  );
int* wcstok(int* __s  , const int* __delim  , int** __ptr  );
unsigned long wcslen(const int* __s  );
int* wcswcs(const int* __haystack  , const int* __needle  );
unsigned long wcsnlen(const int* __s  , unsigned long __maxlen  );
int* wmemchr(const int* __s  , int __c  , unsigned long __n  );
int wmemcmp(const int* __s1  , const int* __s2  , unsigned long __n  );
int* wmemcpy(int* __s1  , const int* __s2  , unsigned long __n  );
int* wmemmove(int* __s1  , const int* __s2  , unsigned long __n  );
int* wmemset(int* __s  , int __c  , unsigned long __n  );
int* wmempcpy(int* __s1  , const int* __s2  , unsigned long __n  );
unsigned int btowc(int __c);
int wctob(unsigned int __c  );
int mbsinit(const struct anonymous_typeX1* __ps  );
unsigned long mbrtowc(int* __pwc  , const char* __s, unsigned long __n  , struct anonymous_typeX1* __p  );
unsigned long wcrtomb(char* __s, int __wc  , struct anonymous_typeX1* __ps  );
unsigned long __mbrlen(const char* __s, unsigned long __n  , struct anonymous_typeX1* __ps  );
unsigned long mbrlen(const char* __s, unsigned long __n  , struct anonymous_typeX1* __ps  );
unsigned long mbsrtowcs(int* __dst  , const char** __src, unsigned long __len  , struct anonymous_typeX1* __ps  );
unsigned long wcsrtombs(char* __dst, const int** __src  , unsigned long __len  , struct anonymous_typeX1* __ps  );
unsigned long mbsnrtowcs(int* __dst  , const char** __src, unsigned long __nmc  , unsigned long __len  , struct anonymous_typeX1* __ps  );
unsigned long wcsnrtombs(char* __dst, const int** __src  , unsigned long __nwc  , unsigned long __len  , struct anonymous_typeX1* __ps  );
int wcwidth(int __c  );
int wcswidth(const int* __s  , unsigned long __n  );
double wcstod(const int* __nptr  , int** __endptr  );
float wcstof(const int* __nptr  , int** __endptr  );
long  double wcstold(const int* __nptr  , int** __endptr  );
float wcstof32(const int* __nptr  , int** __endptr  );
double wcstof64(const int* __nptr  , int** __endptr  );
double wcstof32x(const int* __nptr  , int** __endptr  );
long  double wcstof64x(const int* __nptr  , int** __endptr  );
long  int wcstol(const int* __nptr  , int** __endptr  , int __base);
unsigned long  int wcstoul(const int* __nptr  , int** __endptr  , int __base);
long long int wcstoll(const int* __nptr  , int** __endptr  , int __base);
unsigned long long int wcstoull(const int* __nptr  , int** __endptr  , int __base);
long long int wcstoq(const int* __nptr  , int** __endptr  , int __base);
unsigned long long int wcstouq(const int* __nptr  , int** __endptr  , int __base);
long  int __isoc23_wcstol(const int* __nptr  , int** __endptr  , int __base);
unsigned long  int __isoc23_wcstoul(const int* __nptr  , int** __endptr  , int __base);
long long int __isoc23_wcstoll(const int* __nptr  , int** __endptr  , int __base);
unsigned long long int __isoc23_wcstoull(const int* __nptr  , int** __endptr  , int __base);
long  int wcstol_l(const int* __nptr  , int** __endptr  , int __base, struct __locale_struct* __loc  );
unsigned long  int wcstoul_l(const int* __nptr  , int** __endptr  , int __base, struct __locale_struct* __loc  );
long long int wcstoll_l(const int* __nptr  , int** __endptr  , int __base, struct __locale_struct* __loc  );
unsigned long long int wcstoull_l(const int* __nptr  , int** __endptr  , int __base, struct __locale_struct* __loc  );
long  int __isoc23_wcstol_l(const int* __nptr  , int** __endptr  , int __base, struct __locale_struct* __loc  );
unsigned long  int __isoc23_wcstoul_l(const int* __nptr  , int** __endptr  , int __base, struct __locale_struct* __loc  );
long long int __isoc23_wcstoll_l(const int* __nptr  , int** __endptr  , int __base, struct __locale_struct* __loc  );
unsigned long long int __isoc23_wcstoull_l(const int* __nptr  , int** __endptr  , int __base, struct __locale_struct* __loc  );
double wcstod_l(const int* __nptr  , int** __endptr  , struct __locale_struct* __loc  );
float wcstof_l(const int* __nptr  , int** __endptr  , struct __locale_struct* __loc  );
long  double wcstold_l(const int* __nptr  , int** __endptr  , struct __locale_struct* __loc  );
float wcstof32_l(const int* __nptr  , int** __endptr  , struct __locale_struct* __loc  );
double wcstof64_l(const int* __nptr  , int** __endptr  , struct __locale_struct* __loc  );
double wcstof32x_l(const int* __nptr  , int** __endptr  , struct __locale_struct* __loc  );
long  double wcstof64x_l(const int* __nptr  , int** __endptr  , struct __locale_struct* __loc  );
int* wcpcpy(int* __dest  , const int* __src  );
int* wcpncpy(int* __dest  , const int* __src  , unsigned long __n  );
struct _IO_FILE* open_wmemstream(int** __bufloc  , unsigned long* __sizeloc  );
int fwide(struct _IO_FILE* __fp  , int __mode);
int fwprintf(struct _IO_FILE* __stream  , const int* __format  , ...);
int wprintf(const int* __format  , ...);
int swprintf(int* __s  , unsigned long __n  , const int* __format  , ...);
int vfwprintf(struct _IO_FILE* __s  , const int* __format  , __builtin_va_list __arg  );
int vwprintf(const int* __format  , __builtin_va_list __arg  );
int vswprintf(int* __s  , unsigned long __n  , const int* __format  , __builtin_va_list __arg  );
int fwscanf(struct _IO_FILE* __stream  , const int* __format  , ...);
int wscanf(const int* __format  , ...);
int swscanf(const int* __s  , const int* __format  , ...);
int __isoc23_fwscanf(struct _IO_FILE* __stream  , const int* __format  , ...);
int __isoc23_wscanf(const int* __format  , ...);
int __isoc23_swscanf(const int* __s  , const int* __format  , ...);
int vfwscanf(struct _IO_FILE* __s  , const int* __format  , __builtin_va_list __arg  );
int vwscanf(const int* __format  , __builtin_va_list __arg  );
int vswscanf(const int* __s  , const int* __format  , __builtin_va_list __arg  );
int __isoc23_vfwscanf(struct _IO_FILE* __s  , const int* __format  , __builtin_va_list __arg  );
int __isoc23_vwscanf(const int* __format  , __builtin_va_list __arg  );
int __isoc23_vswscanf(const int* __s  , const int* __format  , __builtin_va_list __arg  );
unsigned int fgetwc(struct _IO_FILE* __stream  );
unsigned int getwc(struct _IO_FILE* __stream  );
unsigned int getwchar();
unsigned int fputwc(int __wc  , struct _IO_FILE* __stream  );
unsigned int putwc(int __wc  , struct _IO_FILE* __stream  );
unsigned int putwchar(int __wc  );
int* fgetws(int* __ws  , int __n, struct _IO_FILE* __stream  );
int fputws(const int* __ws  , struct _IO_FILE* __stream  );
unsigned int ungetwc(unsigned int __wc  , struct _IO_FILE* __stream  );
unsigned int getwc_unlocked(struct _IO_FILE* __stream  );
unsigned int getwchar_unlocked();
unsigned int fgetwc_unlocked(struct _IO_FILE* __stream  );
unsigned int fputwc_unlocked(int __wc  , struct _IO_FILE* __stream  );
unsigned int putwc_unlocked(int __wc  , struct _IO_FILE* __stream  );
unsigned int putwchar_unlocked(int __wc  );
int* fgetws_unlocked(int* __ws  , int __n, struct _IO_FILE* __stream  );
int fputws_unlocked(const int* __ws  , struct _IO_FILE* __stream  );
unsigned long wcsftime(int* __s  , unsigned long __maxsize  , const int* __format  , const struct tm* __tp  );
unsigned long wcsftime_l(int* __s  , unsigned long __maxsize  , const int* __format  , const struct tm* __tp  , struct __locale_struct* __loc  );
char* dirname(char* __path);
char* __xpg_basename(char* __path);
int access(const char* __name, int __type);
int euidaccess(const char* __name, int __type);
int eaccess(const char* __name, int __type);
int execveat(int __fd, const char* __path, char* __argv[], char* __envp[], int __flags);
int faccessat(int __fd, const char* __file, int __type, int __flag);
long  int lseek(int __fd, long  int __offset  , int __whence);
long  int lseek64(int __fd, long  int __offset  , int __whence);
int close(int __fd);
void closefrom(int __lowfd);
long  int read(int __fd, void* __buf, unsigned long __nbytes  );
long  int write(int __fd, const void* __buf, unsigned long __n  );
long  int pread(int __fd, void* __buf, unsigned long __nbytes  , long  int __offset  );
long  int pwrite(int __fd, const void* __buf, unsigned long __n  , long  int __offset  );
long  int pread64(int __fd, void* __buf, unsigned long __nbytes  , long  int __offset  );
long  int pwrite64(int __fd, const void* __buf, unsigned long __n  , long  int __offset  );
int pipe(int __pipedes[2]);
int pipe2(int __pipedes[2], int __flags);
unsigned int alarm(unsigned int __seconds);
unsigned int sleep(unsigned int __seconds);
unsigned int ualarm(unsigned int __value  , unsigned int __interval  );
int usleep(unsigned int __useconds  );
int pause();
int chown(const char* __file, unsigned int __owner  , unsigned int __group  );
int fchown(int __fd, unsigned int __owner  , unsigned int __group  );
int lchown(const char* __file, unsigned int __owner  , unsigned int __group  );
int fchownat(int __fd, const char* __file, unsigned int __owner  , unsigned int __group  , int __flag);
int chdir(const char* __path);
int fchdir(int __fd);
char* getcwd(char* __buf, unsigned long __size  );
char* get_current_dir_name();
char* getwd(char* __buf);
int dup(int __fd);
int dup2(int __fd, int __fd2);
int dup3(int __fd, int __fd2, int __flags);
int execve(const char* __path, char* __argv[], char* __envp[]);
int fexecve(int __fd, char* __argv[], char* __envp[]);
int execv(const char* __path, char* __argv[]);
int execle(const char* __path, const char* __arg, ...);
int execl(const char* __path, const char* __arg, ...);
int execvp(const char* __file, char* __argv[]);
int execlp(const char* __file, const char* __arg, ...);
int execvpe(const char* __file, char* __argv[], char* __envp[]);
int nice(int __inc);
void _exit(int __status);
long  int pathconf(const char* __path, int __name);
long  int fpathconf(int __fd, int __name);
long  int sysconf(int __name);
unsigned long confstr(int __name, char* __buf, unsigned long __len  );
int getpid();
int getppid();
int getpgrp();
int __getpgid(int __pid  );
int getpgid(int __pid  );
int setpgid(int __pid  , int __pgid  );
int setpgrp();
int setsid();
int getsid(int __pid  );
unsigned int getuid();
unsigned int geteuid();
unsigned int getgid();
unsigned int getegid();
int getgroups(int __size, unsigned int __list[]  );
int group_member(unsigned int __gid  );
int setuid(unsigned int __uid  );
int setreuid(unsigned int __ruid  , unsigned int __euid  );
int seteuid(unsigned int __uid  );
int setgid(unsigned int __gid  );
int setregid(unsigned int __rgid  , unsigned int __egid  );
int setegid(unsigned int __gid  );
int getresuid(unsigned int* __ruid  , unsigned int* __euid  , unsigned int* __suid  );
int getresgid(unsigned int* __rgid  , unsigned int* __egid  , unsigned int* __sgid  );
int setresuid(unsigned int __ruid  , unsigned int __euid  , unsigned int __suid  );
int setresgid(unsigned int __rgid  , unsigned int __egid  , unsigned int __sgid  );
int fork();
int vfork();
int _Fork();
char* ttyname(int __fd);
int ttyname_r(int __fd, char* __buf, unsigned long __buflen  );
int isatty(int __fd);
int ttyslot();
int link(const char* __from, const char* __to);
int linkat(int __fromfd, const char* __from, int __tofd, const char* __to, int __flags);
int symlink(const char* __from, const char* __to);
long  int readlink(const char* __path, char* __buf, unsigned long __len  );
int symlinkat(const char* __from, int __tofd, const char* __to);
long  int readlinkat(int __fd, const char* __path, char* __buf, unsigned long __len  );
int unlink(const char* __name);
int unlinkat(int __fd, const char* __name, int __flag);
int rmdir(const char* __path);
int tcgetpgrp(int __fd);
int tcsetpgrp(int __fd, int __pgrp_id  );
char* getlogin();
int getlogin_r(char* __name, unsigned long __name_len  );
int setlogin(const char* __name);
int getopt(int ___argc, char** ___argv, const char* __shortopts);
int gethostname(char* __name, unsigned long __len  );
int sethostname(const char* __name, unsigned long __len  );
int sethostid(long  int __id);
int getdomainname(char* __name, unsigned long __len  );
int setdomainname(const char* __name, unsigned long __len  );
int vhangup();
int revoke(const char* __file);
int profil(unsigned short int* __sample_buffer, unsigned long __size  , unsigned long __offset  , unsigned int __scale);
int acct(const char* __name);
char* getusershell();
void endusershell();
void setusershell();
int daemon(int __nochdir, int __noclose);
int chroot(const char* __path);
char* getpass(const char* __prompt);
int fsync(int __fd);
int syncfs(int __fd);
long  int gethostid();
void sync();
int getpagesize();
int getdtablesize();
int truncate(const char* __file, long  int __length  );
int truncate64(const char* __file, long  int __length  );
int ftruncate(int __fd, long  int __length  );
int ftruncate64(int __fd, long  int __length  );
int brk(void* __addr);
void* sbrk(long  int __delta  );
long  int syscall(long  int __sysno, ...);
int lockf(int __fd, int __cmd, long  int __len  );
int lockf64(int __fd, int __cmd, long  int __len  );
long  int copy_file_range(int __infd, long  int* __pinoff  , int __outfd, long  int* __poutoff  , unsigned long __length  , unsigned int __flags);
int fdatasync(int __fildes);
char* crypt(const char* __key, const char* __salt);
void swab(const void* __from, void* __to, long  int __n  );
int getentropy(void* __buffer, unsigned long __length  );
int close_range(unsigned int __fd, unsigned int __max_fd, int __flags);
int gettid();
struct cmsghdr* __cmsg_nxthdr(struct msghdr* __mhdr  , struct cmsghdr* __cmsg  );
int socket(int __domain, int __type, int __protocol);
int socketpair(int __domain, int __type, int __protocol, int __fds[2]);
int bind(int __fd, const struct sockaddr* __addr  , unsigned int __len  );
int getsockname(int __fd, struct sockaddr* __addr  , unsigned int* __len  );
int connect(int __fd, const struct sockaddr* __addr  , unsigned int __len  );
int getpeername(int __fd, struct sockaddr* __addr  , unsigned int* __len  );
long  int send(int __fd, const void* __buf, unsigned long __n  , int __flags);
long  int recv(int __fd, void* __buf, unsigned long __n  , int __flags);
long  int sendto(int __fd, const void* __buf, unsigned long __n  , int __flags, const struct sockaddr* __addr  , unsigned int __addr_len  );
long  int recvfrom(int __fd, void* __buf, unsigned long __n  , int __flags, struct sockaddr* __addr  , unsigned int* __addr_len  );
long  int sendmsg(int __fd, const struct msghdr* __message  , int __flags);
int sendmmsg(int __fd, struct mmsghdr* __vmessages  , unsigned int __vlen, int __flags);
long  int recvmsg(int __fd, struct msghdr* __message  , int __flags);
int recvmmsg(int __fd, struct mmsghdr* __vmessages  , unsigned int __vlen, int __flags, struct timespec* __tmo  );
int getsockopt(int __fd, int __level, int __optname, void* __optval, unsigned int* __optlen  );
int setsockopt(int __fd, int __level, int __optname, const void* __optval, unsigned int __optlen  );
int listen(int __fd, int __n);
int accept(int __fd, struct sockaddr* __addr  , unsigned int* __addr_len  );
int accept4(int __fd, struct sockaddr* __addr  , unsigned int* __addr_len  , int __flags);
int shutdown(int __fd, int __how);
int sockatmark(int __fd);
int isfdtype(int __fd, int __fdtype);
unsigned int ntohl(unsigned int __netlong  );
unsigned short int ntohs(unsigned short int __netshort  );
unsigned int htonl(unsigned int __hostlong  );
unsigned short int htons(unsigned short int __hostshort  );
int bindresvport(int __sockfd, struct sockaddr_in* __sock_in  );
int bindresvport6(int __sockfd, struct sockaddr_in6* __sock_in  );
int inet6_option_space(int __nbytes);
int inet6_option_init(void* __bp, struct cmsghdr** __cmsgp  , int __type);
int inet6_option_append(struct cmsghdr* __cmsg  , const unsigned char* __typep  , int __multx, int __plusy);
unsigned char* inet6_option_alloc(struct cmsghdr* __cmsg  , int __datalen, int __multx, int __plusy);
int inet6_option_next(const struct cmsghdr* __cmsg  , unsigned char** __tptrp  );
int inet6_option_find(const struct cmsghdr* __cmsg  , unsigned char** __tptrp  , int __type);
int inet6_opt_init(void* __extbuf, unsigned int __extlen  );
int inet6_opt_append(void* __extbuf, unsigned int __extlen  , int __offset, unsigned char __type  , unsigned int __len  , unsigned char __align  , void** __databufp);
int inet6_opt_finish(void* __extbuf, unsigned int __extlen  , int __offset);
int inet6_opt_set_val(void* __databuf, int __offset, void* __val, unsigned int __vallen  );
int inet6_opt_next(void* __extbuf, unsigned int __extlen  , int __offset, unsigned char* __typep  , unsigned int* __lenp  , void** __databufp);
int inet6_opt_find(void* __extbuf, unsigned int __extlen  , int __offset, unsigned char __type  , unsigned int* __lenp  , void** __databufp);
int inet6_opt_get_val(void* __databuf, int __offset, void* __val, unsigned int __vallen  );
unsigned int inet6_rth_space(int __type, int __segments);
void* inet6_rth_init(void* __bp, unsigned int __bp_len  , int __type, int __segments);
int inet6_rth_add(void* __bp, const struct in6_addr* __addr  );
int inet6_rth_reverse(const void* __in, void* __out);
int inet6_rth_segments(const void* __bp);
struct in6_addr* inet6_rth_getaddr(const void* __bp, int __index);
int getipv4sourcefilter(int __s, struct in_addr __interface_addr  , struct in_addr __group  , unsigned int* __fmode  , unsigned int* __numsrc  , struct in_addr* __slist  );
int setipv4sourcefilter(int __s, struct in_addr __interface_addr  , struct in_addr __group  , unsigned int __fmode  , unsigned int __numsrc  , const struct in_addr* __slist  );
int getsourcefilter(int __s, unsigned int __interface_addr  , const struct sockaddr* __group  , unsigned int __grouplen  , unsigned int* __fmode  , unsigned int* __numsrc  , struct sockaddr_storage* __slist  );
int setsourcefilter(int __s, unsigned int __interface_addr  , const struct sockaddr* __group  , unsigned int __grouplen  , unsigned int __fmode  , unsigned int __numsrc  , const struct sockaddr_storage* __slist  );
unsigned int inet_addr(const char* __cp);
unsigned int inet_lnaof(struct in_addr __in  );
struct in_addr inet_makeaddr(unsigned int __net  , unsigned int __host  );
unsigned int inet_netof(struct in_addr __in  );
unsigned int inet_network(const char* __cp);
char* inet_ntoa(struct in_addr __in  );
int inet_pton(int __af, const char* __cp, void* __buf);
const char* inet_ntop(int __af, const void* __cp, char* __buf, unsigned int __len  );
int inet_aton(const char* __cp, struct in_addr* __inp  );
char* inet_neta(unsigned int __net  , char* __buf, unsigned long __len  );
char* inet_net_ntop(int __af, const void* __cp, int __bits, char* __buf, unsigned long __len  );
int inet_net_pton(int __af, const char* __cp, void* __buf, unsigned long __len  );
unsigned int inet_nsap_addr(const char* __cp, unsigned char* __buf, int __len);
char* inet_nsap_ntoa(int __len, const unsigned char* __cp, char* __buf);
int gettimeofday(struct timeval* __tv  , void* __tz);
int settimeofday(const struct timeval* __tv  , const struct timezone* __tz  );
int adjtime(const struct timeval* __delta  , struct timeval* __olddelta  );
int getitimer(enum __itimer_which __which  , struct itimerval* __value  );
int setitimer(enum __itimer_which __which  , const struct itimerval* __new  , struct itimerval* __old  );
int utimes(const char* __file, const struct timeval __tvp[2]  );
int lutimes(const char* __file, const struct timeval __tvp[2]  );
int futimes(int __fd, const struct timeval __tvp[2]  );
int futimesat(int __fd, const char* __file, const struct timeval __tvp[2]  );
int clock_adjtime(int __clock_id  , struct timex* __utx  );
long  int clock();
long  int time(long  int* __timer  );
double difftime(long  int __time1  , long  int __time0  );
long  int mktime(struct tm* __tp  );
unsigned long strftime(char* __s, unsigned long __maxsize  , const char* __format, const struct tm* __tp  );
char* strptime(const char* __s, const char* __fmt, struct tm* __tp  );
unsigned long strftime_l(char* __s, unsigned long __maxsize  , const char* __format, const struct tm* __tp  , struct __locale_struct* __loc  );
char* strptime_l(const char* __s, const char* __fmt, struct tm* __tp  , struct __locale_struct* __loc  );
struct tm* gmtime(const long  int* __timer  );
struct tm* localtime(const long  int* __timer  );
struct tm* gmtime_r(const long  int* __timer  , struct tm* __tp  );
struct tm* localtime_r(const long  int* __timer  , struct tm* __tp  );
char* asctime(const struct tm* __tp  );
char* ctime(const long  int* __timer  );
char* asctime_r(const struct tm* __tp  , char* __buf);
char* ctime_r(const long  int* __timer  , char* __buf);
void tzset();
long  int timegm(struct tm* __tp  );
long  int timelocal(struct tm* __tp  );
int dysize(int __year);
int nanosleep(const struct timespec* __requested_time  , struct timespec* __remaining  );
int clock_getres(int __clock_id  , struct timespec* __res  );
int clock_gettime(int __clock_id  , struct timespec* __tp  );
int clock_settime(int __clock_id  , const struct timespec* __tp  );
int clock_nanosleep(int __clock_id  , int __flags, const struct timespec* __req  , struct timespec* __rem  );
int clock_getcpuclockid(int __pid  , int* __clock_id  );
int timer_create(int __clock_id  , struct sigevent* __evp  , void** __timerid  );
int timer_delete(void* __timerid  );
int timer_settime(void* __timerid  , int __flags, const struct itimerspec* __value  , struct itimerspec* __ovalue  );
int timer_gettime(void* __timerid  , struct itimerspec* __value  );
int timer_getoverrun(void* __timerid  );
int timespec_get(struct timespec* __ts  , int __base);
int timespec_getres(struct timespec* __ts  , int __base);
struct tm* getdate(const char* __string);
int getdate_r(const char* __string, struct tm* __resbufp  );
int OPENSSL_sk_num(const struct stack_st*   );
void* OPENSSL_sk_value(const struct stack_st*   , int );
void* OPENSSL_sk_set(struct stack_st* st  , int i, const void* data);
struct stack_st* OPENSSL_sk_new(int (*cmp)(const void*,const void*)  );
struct stack_st* OPENSSL_sk_new_null();
struct stack_st* OPENSSL_sk_new_reserve(int (*c)(const void*,const void*)  , int n);
int OPENSSL_sk_reserve(struct stack_st* st  , int n);
void OPENSSL_sk_free(struct stack_st*   );
void OPENSSL_sk_pop_free(struct stack_st* st  , void (*func)(void*));
struct stack_st* OPENSSL_sk_deep_copy(const struct stack_st*   , void* (*c)(const void*)  , void (*f)(void*)  );
int OPENSSL_sk_insert(struct stack_st* sk  , const void* data, int where);
void* OPENSSL_sk_delete(struct stack_st* st  , int loc);
void* OPENSSL_sk_delete_ptr(struct stack_st* st  , const void* p);
int OPENSSL_sk_find(struct stack_st* st  , const void* data);
int OPENSSL_sk_find_ex(struct stack_st* st  , const void* data);
int OPENSSL_sk_find_all(struct stack_st* st  , const void* data, int* pnum);
int OPENSSL_sk_push(struct stack_st* st  , const void* data);
int OPENSSL_sk_unshift(struct stack_st* st  , const void* data);
void* OPENSSL_sk_shift(struct stack_st* st  );
void* OPENSSL_sk_pop(struct stack_st* st  );
void OPENSSL_sk_zero(struct stack_st* st  );
int (*OPENSSL_sk_set_cmp_func(struct stack_st* sk  , int (*cmp)(const void*,const void*)  ))(const void*,const void*) ;
struct stack_st* OPENSSL_sk_dup(const struct stack_st* st  );
void OPENSSL_sk_sort(struct stack_st* st  );
int OPENSSL_sk_is_sorted(const struct stack_st* st  );
static char* ossl_check_OPENSSL_STRING_type(char* ptr);
static const struct stack_st* ossl_check_const_OPENSSL_STRING_sk_type(const struct stack_st_OPENSSL_STRING* sk  );
static struct stack_st* ossl_check_OPENSSL_STRING_sk_type(struct stack_st_OPENSSL_STRING* sk  );
static int (*ossl_check_OPENSSL_STRING_compfunc_type(int (*cmp)(const char**,const char**)  ))(const void*,const void*) ;
static void* (*ossl_check_OPENSSL_STRING_copyfunc_type(char* (*cpy)(const char*)  ))(const void*) ;
static void (*ossl_check_OPENSSL_STRING_freefunc_type(void (*fr)(char*)  ))(void*) ;
static const char* ossl_check_OPENSSL_CSTRING_type(const char* ptr);
static const struct stack_st* ossl_check_const_OPENSSL_CSTRING_sk_type(const struct stack_st_OPENSSL_CSTRING* sk  );
static struct stack_st* ossl_check_OPENSSL_CSTRING_sk_type(struct stack_st_OPENSSL_CSTRING* sk  );
static int (*ossl_check_OPENSSL_CSTRING_compfunc_type(int (*cmp)(const char**,const char**)  ))(const void*,const void*) ;
static void* (*ossl_check_OPENSSL_CSTRING_copyfunc_type(char* (*cpy)(const char*)  ))(const void*) ;
static void (*ossl_check_OPENSSL_CSTRING_freefunc_type(void (*fr)(char*)  ))(void*) ;
static void* ossl_check_OPENSSL_BLOCK_type(void* ptr);
static const struct stack_st* ossl_check_const_OPENSSL_BLOCK_sk_type(const struct stack_st_OPENSSL_BLOCK* sk  );
static struct stack_st* ossl_check_OPENSSL_BLOCK_sk_type(struct stack_st_OPENSSL_BLOCK* sk  );
static int (*ossl_check_OPENSSL_BLOCK_compfunc_type(int (*cmp)(const void**,const void**)  ))(const void*,const void*) ;
static void* (*ossl_check_OPENSSL_BLOCK_copyfunc_type(void* (*cpy)(const void*)  ))(const void*) ;
static void (*ossl_check_OPENSSL_BLOCK_freefunc_type(void (*fr)(void*)  ))(void*) ;
int ERR_load_ASN1_strings();
int ERR_load_ASYNC_strings();
int ERR_load_BIO_strings();
int ERR_load_BN_strings();
int ERR_load_BUF_strings();
int ERR_load_CMS_strings();
int ERR_load_COMP_strings();
int ERR_load_CONF_strings();
int ERR_load_CRYPTO_strings();
int ERR_load_CT_strings();
int ERR_load_DH_strings();
int ERR_load_DSA_strings();
int ERR_load_EC_strings();
int ERR_load_ERR_strings();
int ERR_load_EVP_strings();
int ERR_load_KDF_strings();
int ERR_load_OBJ_strings();
int ERR_load_OCSP_strings();
int ERR_load_PEM_strings();
int ERR_load_PKCS12_strings();
int ERR_load_PKCS7_strings();
int ERR_load_RAND_strings();
int ERR_load_RSA_strings();
int ERR_load_OSSL_STORE_strings();
int ERR_load_TS_strings();
int ERR_load_UI_strings();
int ERR_load_X509_strings();
int ERR_load_X509V3_strings();
void* CRYPTO_THREAD_lock_new();
int CRYPTO_THREAD_read_lock(void* lock  );
int CRYPTO_THREAD_write_lock(void* lock  );
int CRYPTO_THREAD_unlock(void* lock  );
void CRYPTO_THREAD_lock_free(void* lock  );
int CRYPTO_atomic_add(int* val, int amount, int* ret, void* lock  );
int CRYPTO_atomic_add64(unsigned long  int* val  , unsigned long  int op  , unsigned long  int* ret  , void* lock  );
int CRYPTO_atomic_and(unsigned long  int* val  , unsigned long  int op  , unsigned long  int* ret  , void* lock  );
int CRYPTO_atomic_or(unsigned long  int* val  , unsigned long  int op  , unsigned long  int* ret  , void* lock  );
int CRYPTO_atomic_load(unsigned long  int* val  , unsigned long  int* ret  , void* lock  );
int CRYPTO_atomic_load_int(int* val, int* ret, void* lock  );
int CRYPTO_atomic_store(unsigned long  int* dst  , unsigned long  int val  , void* lock  );
unsigned long OPENSSL_strlcpy(char* dst, const char* src, unsigned long siz  );
unsigned long OPENSSL_strlcat(char* dst, const char* src, unsigned long siz  );
unsigned long OPENSSL_strnlen(const char* str, unsigned long maxlen  );
int OPENSSL_strtoul(const char* str, char** endptr, int base, unsigned long  int* num);
int OPENSSL_buf2hexstr_ex(char* str, unsigned long str_n  , unsigned long* strlength  , const unsigned char* buf, unsigned long buflen  , const char sep);
char* OPENSSL_buf2hexstr(const unsigned char* buf, long buflen);
int OPENSSL_hexstr2buf_ex(unsigned char* buf, unsigned long buf_n  , unsigned long* buflen  , const char* str, const char sep);
unsigned char* OPENSSL_hexstr2buf(const char* str, long* buflen);
int OPENSSL_hexchar2int(unsigned char c);
int OPENSSL_strcasecmp(const char* s1, const char* s2);
int OPENSSL_strncasecmp(const char* s1, const char* s2, unsigned long n  );
unsigned int OPENSSL_version_major();
unsigned int OPENSSL_version_minor();
unsigned int OPENSSL_version_patch();
const char* OPENSSL_version_pre_release();
const char* OPENSSL_version_build_metadata();
unsigned long  int OpenSSL_version_num();
const char* OpenSSL_version(int type);
const char* OPENSSL_info(int type);
int OPENSSL_issetugid();
static void* ossl_check_void_type(void* ptr);
static const struct stack_st* ossl_check_const_void_sk_type(const struct stack_st_void* sk  );
static struct stack_st* ossl_check_void_sk_type(struct stack_st_void* sk  );
static int (*ossl_check_void_compfunc_type(int (*cmp)(const void**,const void**)  ))(const void*,const void*) ;
static void* (*ossl_check_void_copyfunc_type(void* (*cpy)(const void*)  ))(const void*) ;
static void (*ossl_check_void_freefunc_type(void (*fr)(void*)  ))(void*) ;
int CRYPTO_get_ex_new_index(int class_index, long argl, void* argp, void (*(*new_func))(void*,void*,struct crypto_ex_data_st*,int,long,void*)  , int (*(*dup_func))(struct crypto_ex_data_st*,const struct crypto_ex_data_st*,void**,int,long,void*)  , void (*(*free_func))(void*,void*,struct crypto_ex_data_st*,int,long,void*)  );
int CRYPTO_free_ex_index(int class_index, int idx);
int CRYPTO_new_ex_data(int class_index, void* obj, struct crypto_ex_data_st* ad  );
int CRYPTO_dup_ex_data(int class_index, struct crypto_ex_data_st* to  , const struct crypto_ex_data_st* from  );
void CRYPTO_free_ex_data(int class_index, void* obj, struct crypto_ex_data_st* ad  );
int CRYPTO_alloc_ex_data(int class_index, void* obj, struct crypto_ex_data_st* ad  , int idx);
int CRYPTO_set_ex_data(struct crypto_ex_data_st* ad  , int idx, void* val);
void* CRYPTO_get_ex_data(const struct crypto_ex_data_st* ad  , int idx);
int CRYPTO_set_mem_functions(void* (*malloc_fn)(unsigned long,const char*,int)  , void* (*realloc_fn)(void*,unsigned long,const char*,int)  , void (*free_fn)(void*,const char*,int)  );
void CRYPTO_get_mem_functions(void* (*(*malloc_fn))(unsigned long,const char*,int)  , void* (*(*realloc_fn))(void*,unsigned long,const char*,int)  , void (*(*free_fn))(void*,const char*,int)  );
void* CRYPTO_malloc(unsigned long num  , const char* file, int line);
void* CRYPTO_zalloc(unsigned long num  , const char* file, int line);
void* CRYPTO_aligned_alloc(unsigned long num  , unsigned long align  , void** freeptr, const char* file, int line);
void* CRYPTO_memdup(const void* str, unsigned long siz  , const char* file, int line);
char* CRYPTO_strdup(const char* str, const char* file, int line);
char* CRYPTO_strndup(const char* str, unsigned long s  , const char* file, int line);
void CRYPTO_free(void* ptr, const char* file, int line);
void CRYPTO_clear_free(void* ptr, unsigned long num  , const char* file, int line);
void* CRYPTO_realloc(void* addr, unsigned long num  , const char* file, int line);
void* CRYPTO_clear_realloc(void* addr, unsigned long old_num  , unsigned long num  , const char* file, int line);
int CRYPTO_secure_malloc_init(unsigned long sz  , unsigned long minsize  );
int CRYPTO_secure_malloc_done();
void* CRYPTO_secure_malloc(unsigned long num  , const char* file, int line);
void* CRYPTO_secure_zalloc(unsigned long num  , const char* file, int line);
void CRYPTO_secure_free(void* ptr, const char* file, int line);
void CRYPTO_secure_clear_free(void* ptr, unsigned long num  , const char* file, int line);
int CRYPTO_secure_allocated(const void* ptr);
int CRYPTO_secure_malloc_initialized();
unsigned long CRYPTO_secure_actual_size(void* ptr);
unsigned long CRYPTO_secure_used();
void OPENSSL_cleanse(void* ptr, unsigned long len  );
void OPENSSL_die(const char* assertion, const char* file, int line);
int OPENSSL_isservice();
void OPENSSL_init();
void OPENSSL_fork_prepare();
void OPENSSL_fork_parent();
void OPENSSL_fork_child();
struct tm* OPENSSL_gmtime(const long  int* timer  , struct tm* result  );
int OPENSSL_gmtime_adj(struct tm* tm  , int offset_day, long offset_sec);
int OPENSSL_gmtime_diff(int* pday, int* psec, const struct tm* from  , const struct tm* to  );
int CRYPTO_memcmp(const void* in_a, const void* in_b, unsigned long len  );
void OPENSSL_cleanup();
int OPENSSL_init_crypto(unsigned long  int opts  , const struct ossl_init_settings_st* settings  );
int OPENSSL_atexit(void (*handler)());
void OPENSSL_thread_stop();
void OPENSSL_thread_stop_ex(struct ossl_lib_ctx_st* ctx  );
struct ossl_init_settings_st* OPENSSL_INIT_new();
int OPENSSL_INIT_set_config_filename(struct ossl_init_settings_st* settings  , const char* config_filename);
void OPENSSL_INIT_set_config_file_flags(struct ossl_init_settings_st* settings  , unsigned long  int flags);
int OPENSSL_INIT_set_config_appname(struct ossl_init_settings_st* settings  , const char* config_appname);
void OPENSSL_INIT_free(struct ossl_init_settings_st* settings  );
int clone(int (*__fn)(void*), void* __child_stack, int __flags, void* __arg, ...);
int unshare(int __flags);
int sched_getcpu();
int getcpu(unsigned int* , unsigned int* );
int setns(int __fd, int __nstype);
int sched_setattr(int tid  , struct sched_attr* attr  , unsigned int flags);
int sched_getattr(int tid  , struct sched_attr* attr  , unsigned int size, unsigned int flags);
int __sched_cpucount(unsigned long __setsize  , const struct anonymous_typeX32* __setp  );
struct anonymous_typeX32* __sched_cpualloc(unsigned long __count  );
void __sched_cpufree(struct anonymous_typeX32* __set  );
int sched_setparam(int __pid  , const struct sched_param* __param  );
int sched_getparam(int __pid  , struct sched_param* __param  );
int sched_setscheduler(int __pid  , int __policy, const struct sched_param* __param  );
int sched_getscheduler(int __pid  );
int sched_yield();
int sched_get_priority_max(int __algorithm);
int sched_get_priority_min(int __algorithm);
int sched_rr_get_interval(int __pid  , struct timespec* __t  );
int sched_setaffinity(int __pid  , unsigned long __cpusetsize  , const struct anonymous_typeX32* __cpuset  );
int sched_getaffinity(int __pid  , unsigned long __cpusetsize  , struct anonymous_typeX32* __cpuset  );
int pthread_create(unsigned long  int* __newthread  , const union pthread_attr_t* __attr  , void* (*__start_routine)(void*), void* __arg);
void pthread_exit(void* __retval);
int pthread_join(unsigned long  int __th  , void** __thread_return);
int pthread_tryjoin_np(unsigned long  int __th  , void** __thread_return);
int pthread_timedjoin_np(unsigned long  int __th  , void** __thread_return, const struct timespec* __abstime  );
int pthread_clockjoin_np(unsigned long  int __th  , void** __thread_return, int __clockid  , const struct timespec* __abstime  );
int pthread_detach(unsigned long  int __th  );
unsigned long  int pthread_self();
int pthread_equal(unsigned long  int __thread1  , unsigned long  int __thread2  );
int pthread_attr_init(union pthread_attr_t* __attr  );
int pthread_attr_destroy(union pthread_attr_t* __attr  );
int pthread_attr_getdetachstate(const union pthread_attr_t* __attr  , int* __detachstate);
int pthread_attr_setdetachstate(union pthread_attr_t* __attr  , int __detachstate);
int pthread_attr_getguardsize(const union pthread_attr_t* __attr  , unsigned long* __guardsize  );
int pthread_attr_setguardsize(union pthread_attr_t* __attr  , unsigned long __guardsize  );
int pthread_attr_getschedparam(const union pthread_attr_t* __attr  , struct sched_param* __param  );
int pthread_attr_setschedparam(union pthread_attr_t* __attr  , const struct sched_param* __param  );
int pthread_attr_getschedpolicy(const union pthread_attr_t* __attr  , int* __policy);
int pthread_attr_setschedpolicy(union pthread_attr_t* __attr  , int __policy);
int pthread_attr_getinheritsched(const union pthread_attr_t* __attr  , int* __inherit);
int pthread_attr_setinheritsched(union pthread_attr_t* __attr  , int __inherit);
int pthread_attr_getscope(const union pthread_attr_t* __attr  , int* __scope);
int pthread_attr_setscope(union pthread_attr_t* __attr  , int __scope);
int pthread_attr_getstackaddr(const union pthread_attr_t* __attr  , void** __stackaddr);
int pthread_attr_setstackaddr(union pthread_attr_t* __attr  , void* __stackaddr);
int pthread_attr_getstacksize(const union pthread_attr_t* __attr  , unsigned long* __stacksize  );
int pthread_attr_setstacksize(union pthread_attr_t* __attr  , unsigned long __stacksize  );
int pthread_attr_getstack(const union pthread_attr_t* __attr  , void** __stackaddr, unsigned long* __stacksize  );
int pthread_attr_setstack(union pthread_attr_t* __attr  , void* __stackaddr, unsigned long __stacksize  );
int pthread_attr_setaffinity_np(union pthread_attr_t* __attr  , unsigned long __cpusetsize  , const struct anonymous_typeX32* __cpuset  );
int pthread_attr_getaffinity_np(const union pthread_attr_t* __attr  , unsigned long __cpusetsize  , struct anonymous_typeX32* __cpuset  );
int pthread_getattr_default_np(union pthread_attr_t* __attr  );
int pthread_attr_setsigmask_np(union pthread_attr_t* __attr  , const struct anonymous_typeX7* sigmask  );
int pthread_attr_getsigmask_np(const union pthread_attr_t* __attr  , struct anonymous_typeX7* sigmask  );
int pthread_setattr_default_np(const union pthread_attr_t* __attr  );
int pthread_getattr_np(unsigned long  int __th  , union pthread_attr_t* __attr  );
int pthread_setschedparam(unsigned long  int __target_thread  , int __policy, const struct sched_param* __param  );
int pthread_getschedparam(unsigned long  int __target_thread  , int* __policy, struct sched_param* __param  );
int pthread_setschedprio(unsigned long  int __target_thread  , int __prio);
int pthread_getname_np(unsigned long  int __target_thread  , char* __buf, unsigned long __buflen  );
int pthread_setname_np(unsigned long  int __target_thread  , const char* __name);
int pthread_getconcurrency();
int pthread_setconcurrency(int __level);
int pthread_yield();
int pthread_setaffinity_np(unsigned long  int __th  , unsigned long __cpusetsize  , const struct anonymous_typeX32* __cpuset  );
int pthread_getaffinity_np(unsigned long  int __th  , unsigned long __cpusetsize  , struct anonymous_typeX32* __cpuset  );
int pthread_once(int* __once_control  , void (*__init_routine)());
int pthread_setcancelstate(int __state, int* __oldstate);
int pthread_setcanceltype(int __type, int* __oldtype);
int pthread_cancel(unsigned long  int __th  );
void pthread_testcancel();
void __pthread_register_cancel(struct anonymous_typeX33* __buf  );
void __pthread_unregister_cancel(struct anonymous_typeX33* __buf  );
void __pthread_register_cancel_defer(struct anonymous_typeX33* __buf  );
void __pthread_unregister_cancel_restore(struct anonymous_typeX33* __buf  );
void __pthread_unwind_next(struct anonymous_typeX33* __buf  );
int __sigsetjmp(struct __jmp_buf_tag __env[1]  , int __savemask);
int pthread_mutex_init(union anonymous_typeZ14* __mutex  , const union anonymous_typeZ12* __mutexattr  );
int pthread_mutex_destroy(union anonymous_typeZ14* __mutex  );
int pthread_mutex_trylock(union anonymous_typeZ14* __mutex  );
int pthread_mutex_lock(union anonymous_typeZ14* __mutex  );
int pthread_mutex_timedlock(union anonymous_typeZ14* __mutex  , const struct timespec* __abstime  );
int pthread_mutex_clocklock(union anonymous_typeZ14* __mutex  , int __clockid  , const struct timespec* __abstime  );
int pthread_mutex_unlock(union anonymous_typeZ14* __mutex  );
int pthread_mutex_getprioceiling(const union anonymous_typeZ14* __mutex  , int* __prioceiling);
int pthread_mutex_setprioceiling(union anonymous_typeZ14* __mutex  , int __prioceiling, int* __old_ceiling);
int pthread_mutex_consistent(union anonymous_typeZ14* __mutex  );
int pthread_mutexattr_init(union anonymous_typeZ12* __attr  );
int pthread_mutexattr_destroy(union anonymous_typeZ12* __attr  );
int pthread_mutexattr_getpshared(const union anonymous_typeZ12* __attr  , int* __pshared);
int pthread_mutexattr_setpshared(union anonymous_typeZ12* __attr  , int __pshared);
int pthread_mutexattr_gettype(const union anonymous_typeZ12* __attr  , int* __kind);
int pthread_mutexattr_settype(union anonymous_typeZ12* __attr  , int __kind);
int pthread_mutexattr_getprotocol(const union anonymous_typeZ12* __attr  , int* __protocol);
int pthread_mutexattr_setprotocol(union anonymous_typeZ12* __attr  , int __protocol);
int pthread_mutexattr_getprioceiling(const union anonymous_typeZ12* __attr  , int* __prioceiling);
int pthread_mutexattr_setprioceiling(union anonymous_typeZ12* __attr  , int __prioceiling);
int pthread_mutexattr_getrobust(const union anonymous_typeZ12* __attr  , int* __robustness);
int pthread_mutexattr_setrobust(union anonymous_typeZ12* __attr  , int __robustness);
int pthread_rwlock_init(union anonymous_typeZ16* __rwlock  , const union anonymous_typeZ17* __attr  );
int pthread_rwlock_destroy(union anonymous_typeZ16* __rwlock  );
int pthread_rwlock_rdlock(union anonymous_typeZ16* __rwlock  );
int pthread_rwlock_tryrdlock(union anonymous_typeZ16* __rwlock  );
int pthread_rwlock_timedrdlock(union anonymous_typeZ16* __rwlock  , const struct timespec* __abstime  );
int pthread_rwlock_clockrdlock(union anonymous_typeZ16* __rwlock  , int __clockid  , const struct timespec* __abstime  );
int pthread_rwlock_wrlock(union anonymous_typeZ16* __rwlock  );
int pthread_rwlock_trywrlock(union anonymous_typeZ16* __rwlock  );
int pthread_rwlock_timedwrlock(union anonymous_typeZ16* __rwlock  , const struct timespec* __abstime  );
int pthread_rwlock_clockwrlock(union anonymous_typeZ16* __rwlock  , int __clockid  , const struct timespec* __abstime  );
int pthread_rwlock_unlock(union anonymous_typeZ16* __rwlock  );
int pthread_rwlockattr_init(union anonymous_typeZ17* __attr  );
int pthread_rwlockattr_destroy(union anonymous_typeZ17* __attr  );
int pthread_rwlockattr_getpshared(const union anonymous_typeZ17* __attr  , int* __pshared);
int pthread_rwlockattr_setpshared(union anonymous_typeZ17* __attr  , int __pshared);
int pthread_rwlockattr_getkind_np(const union anonymous_typeZ17* __attr  , int* __pref);
int pthread_rwlockattr_setkind_np(union anonymous_typeZ17* __attr  , int __pref);
int pthread_cond_init(union anonymous_typeZ15* __cond  , const union anonymous_typeZ13* __cond_attr  );
int pthread_cond_destroy(union anonymous_typeZ15* __cond  );
int pthread_cond_signal(union anonymous_typeZ15* __cond  );
int pthread_cond_broadcast(union anonymous_typeZ15* __cond  );
int pthread_cond_wait(union anonymous_typeZ15* __cond  , union anonymous_typeZ14* __mutex  );
int pthread_cond_timedwait(union anonymous_typeZ15* __cond  , union anonymous_typeZ14* __mutex  , const struct timespec* __abstime  );
int pthread_cond_clockwait(union anonymous_typeZ15* __cond  , union anonymous_typeZ14* __mutex  , int __clock_id  , const struct timespec* __abstime  );
int pthread_condattr_init(union anonymous_typeZ13* __attr  );
int pthread_condattr_destroy(union anonymous_typeZ13* __attr  );
int pthread_condattr_getpshared(const union anonymous_typeZ13* __attr  , int* __pshared);
int pthread_condattr_setpshared(union anonymous_typeZ13* __attr  , int __pshared);
int pthread_condattr_getclock(const union anonymous_typeZ13* __attr  , int* __clock_id  );
int pthread_condattr_setclock(union anonymous_typeZ13* __attr  , int __clock_id  );
int pthread_spin_init(int* __lock  , int __pshared);
int pthread_spin_destroy(int* __lock  );
int pthread_spin_lock(int* __lock  );
int pthread_spin_trylock(int* __lock  );
int pthread_spin_unlock(int* __lock  );
int pthread_barrier_init(union anonymous_typeZ18* __barrier  , const union anonymous_typeZ19* __attr  , unsigned int __count);
int pthread_barrier_destroy(union anonymous_typeZ18* __barrier  );
int pthread_barrier_wait(union anonymous_typeZ18* __barrier  );
int pthread_barrierattr_init(union anonymous_typeZ19* __attr  );
int pthread_barrierattr_destroy(union anonymous_typeZ19* __attr  );
int pthread_barrierattr_getpshared(const union anonymous_typeZ19* __attr  , int* __pshared);
int pthread_barrierattr_setpshared(union anonymous_typeZ19* __attr  , int __pshared);
int pthread_key_create(unsigned int* __key  , void (*__destr_function)(void*));
int pthread_key_delete(unsigned int __key  );
void* pthread_getspecific(unsigned int __key  );
int pthread_setspecific(unsigned int __key  , const void* __pointer);
int pthread_getcpuclockid(unsigned long  int __thread_id  , int* __clock_id  );
int pthread_gettid_np(unsigned long  int __thread_id  );
int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)());
int CRYPTO_THREAD_run_once(int* once  , void (*init)());
int CRYPTO_THREAD_init_local(unsigned int* key  , void (*cleanup)(void*));
void* CRYPTO_THREAD_get_local(unsigned int* key  );
int CRYPTO_THREAD_set_local(unsigned int* key  , void* val);
int CRYPTO_THREAD_cleanup_local(unsigned int* key  );
unsigned long  int CRYPTO_THREAD_get_current_id();
int CRYPTO_THREAD_compare_id(unsigned long  int a  , unsigned long  int b  );
struct ossl_lib_ctx_st* OSSL_LIB_CTX_new();
struct ossl_lib_ctx_st* OSSL_LIB_CTX_new_from_dispatch(const struct ossl_core_handle_st* handle  , const struct ossl_dispatch_st* in  );
struct ossl_lib_ctx_st* OSSL_LIB_CTX_new_child(const struct ossl_core_handle_st* handle  , const struct ossl_dispatch_st* in  );
int OSSL_LIB_CTX_load_config(struct ossl_lib_ctx_st* ctx  , const char* config_file);
void OSSL_LIB_CTX_free(struct ossl_lib_ctx_st*   );
struct ossl_lib_ctx_st* OSSL_LIB_CTX_get0_global_default();
struct ossl_lib_ctx_st* OSSL_LIB_CTX_set0_default(struct ossl_lib_ctx_st* libctx  );
int OSSL_LIB_CTX_get_conf_diagnostics(struct ossl_lib_ctx_st* ctx  );
void OSSL_LIB_CTX_set_conf_diagnostics(struct ossl_lib_ctx_st* ctx  , int value);
void OSSL_sleep(unsigned long  int millis  );
void* OSSL_LIB_CTX_get_data(struct ossl_lib_ctx_st* ctx  , int index);
struct comp_ctx_st* COMP_CTX_new(struct comp_method_st* meth  );
const struct comp_method_st* COMP_CTX_get_method(const struct comp_ctx_st* ctx  );
int COMP_CTX_get_type(const struct comp_ctx_st* comp  );
int COMP_get_type(const struct comp_method_st* meth  );
const char* COMP_get_name(const struct comp_method_st* meth  );
void COMP_CTX_free(struct comp_ctx_st* ctx  );
int COMP_compress_block(struct comp_ctx_st* ctx  , unsigned char* out, int olen, unsigned char* in, int ilen);
int COMP_expand_block(struct comp_ctx_st* ctx  , unsigned char* out, int olen, unsigned char* in, int ilen);
struct comp_method_st* COMP_zlib();
struct comp_method_st* COMP_zlib_oneshot();
struct comp_method_st* COMP_brotli();
struct comp_method_st* COMP_brotli_oneshot();
struct comp_method_st* COMP_zstd();
struct comp_method_st* COMP_zstd_oneshot();
static struct ssl_comp_st* ossl_check_SSL_COMP_type(struct ssl_comp_st* ptr  );
static const struct stack_st* ossl_check_const_SSL_COMP_sk_type(const struct stack_st_SSL_COMP* sk  );
static struct stack_st* ossl_check_SSL_COMP_sk_type(struct stack_st_SSL_COMP* sk  );
static int (*ossl_check_SSL_COMP_compfunc_type(int (*cmp)(const struct ssl_comp_st**,const struct ssl_comp_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_SSL_COMP_copyfunc_type(struct ssl_comp_st* (*cpy)(const struct ssl_comp_st*)  ))(const void*) ;
static void (*ossl_check_SSL_COMP_freefunc_type(void (*fr)(struct ssl_comp_st*)  ))(void*) ;
int BIO_get_new_index();
void BIO_set_flags(struct bio_st* b  , int flags);
int BIO_test_flags(const struct bio_st* b  , int flags);
void BIO_clear_flags(struct bio_st* b  , int flags);
long (*BIO_get_callback(const struct bio_st* b  ))(struct bio_st*,int,const char*,int,long,long) ;
void BIO_set_callback(struct bio_st* b  , long (*callback)(struct bio_st*,int,const char*,int,long,long)  );
long BIO_debug_callback(struct bio_st* bio  , int cmd, const char* argp, int argi, long argl, long ret);
long (*BIO_get_callback_ex(const struct bio_st* b  ))(struct bio_st*,int,const char*,unsigned long,int,long,int,unsigned long*) ;
void BIO_set_callback_ex(struct bio_st* b  , long (*callback)(struct bio_st*,int,const char*,unsigned long,int,long,int,unsigned long*)  );
long BIO_debug_callback_ex(struct bio_st* bio  , int oper, const char* argp, unsigned long len  , int argi, long argl, int ret, unsigned long* processed  );
char* BIO_get_callback_arg(const struct bio_st* b  );
void BIO_set_callback_arg(struct bio_st* b  , char* arg);
const char* BIO_method_name(const struct bio_st* b  );
int BIO_method_type(const struct bio_st* b  );
static struct bio_st* ossl_check_BIO_type(struct bio_st* ptr  );
static const struct stack_st* ossl_check_const_BIO_sk_type(const struct stack_st_BIO* sk  );
static struct stack_st* ossl_check_BIO_sk_type(struct stack_st_BIO* sk  );
static int (*ossl_check_BIO_compfunc_type(int (*cmp)(const struct bio_st**,const struct bio_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_BIO_copyfunc_type(struct bio_st* (*cpy)(const struct bio_st*)  ))(const void*) ;
static void (*ossl_check_BIO_freefunc_type(void (*fr)(struct bio_st*)  ))(void*) ;
unsigned long BIO_ctrl_pending(struct bio_st* b  );
unsigned long BIO_ctrl_wpending(struct bio_st* b  );
unsigned long BIO_ctrl_get_write_guarantee(struct bio_st* b  );
unsigned long BIO_ctrl_get_read_request(struct bio_st* b  );
int BIO_ctrl_reset_read_request(struct bio_st* b  );
int BIO_set_ex_data(struct bio_st* bio  , int idx, void* data);
void* BIO_get_ex_data(const struct bio_st* bio  , int idx);
unsigned long  int BIO_number_read(struct bio_st* bio  );
unsigned long  int BIO_number_written(struct bio_st* bio  );
int BIO_asn1_set_prefix(struct bio_st* b  , int (*(*prefix))(struct bio_st*,unsigned char**,int*,void*)  , int (*(*prefix_free))(struct bio_st*,unsigned char**,int*,void*)  );
int BIO_asn1_get_prefix(struct bio_st* b  , int (*(*(*pprefix)))(struct bio_st*,unsigned char**,int*,void*)  , int (*(*(*pprefix_free)))(struct bio_st*,unsigned char**,int*,void*)  );
int BIO_asn1_set_suffix(struct bio_st* b  , int (*(*suffix))(struct bio_st*,unsigned char**,int*,void*)  , int (*(*suffix_free))(struct bio_st*,unsigned char**,int*,void*)  );
int BIO_asn1_get_suffix(struct bio_st* b  , int (*(*(*psuffix)))(struct bio_st*,unsigned char**,int*,void*)  , int (*(*(*psuffix_free)))(struct bio_st*,unsigned char**,int*,void*)  );
const struct bio_method_st* BIO_s_file();
struct bio_st* BIO_new_file(const char* filename, const char* mode);
struct bio_st* BIO_new_from_core_bio(struct ossl_lib_ctx_st* libctx  , struct ossl_core_bio_st* corebio  );
struct bio_st* BIO_new_fp(struct _IO_FILE* stream  , int close_flag);
struct bio_st* BIO_new_ex(struct ossl_lib_ctx_st* libctx  , const struct bio_method_st* method  );
struct bio_st* BIO_new(const struct bio_method_st* type  );
int BIO_free(struct bio_st* a  );
void BIO_set_data(struct bio_st* a  , void* ptr);
void* BIO_get_data(struct bio_st* a  );
void BIO_set_init(struct bio_st* a  , int init);
int BIO_get_init(struct bio_st* a  );
void BIO_set_shutdown(struct bio_st* a  , int shut);
int BIO_get_shutdown(struct bio_st* a  );
void BIO_vfree(struct bio_st* a  );
int BIO_up_ref(struct bio_st* a  );
int BIO_read(struct bio_st* b  , void* data, int dlen);
int BIO_read_ex(struct bio_st* b  , void* data, unsigned long dlen  , unsigned long* readbytes  );
int BIO_recvmmsg(struct bio_st* b  , struct bio_msg_st* msg  , unsigned long stride  , unsigned long num_msg  , unsigned long  int flags  , unsigned long* msgs_processed  );
int BIO_gets(struct bio_st* bp  , char* buf, int size);
int BIO_get_line(struct bio_st* bio  , char* buf, int size);
int BIO_write(struct bio_st* b  , const void* data, int dlen);
int BIO_write_ex(struct bio_st* b  , const void* data, unsigned long dlen  , unsigned long* written  );
int BIO_sendmmsg(struct bio_st* b  , struct bio_msg_st* msg  , unsigned long stride  , unsigned long num_msg  , unsigned long  int flags  , unsigned long* msgs_processed  );
int BIO_get_rpoll_descriptor(struct bio_st* b  , struct bio_poll_descriptor_st* desc  );
int BIO_get_wpoll_descriptor(struct bio_st* b  , struct bio_poll_descriptor_st* desc  );
int BIO_puts(struct bio_st* bp  , const char* buf);
int BIO_indent(struct bio_st* b  , int indent, int max);
long BIO_ctrl(struct bio_st* bp  , int cmd, long larg, void* parg);
long BIO_callback_ctrl(struct bio_st* b  , int cmd, int (*(*fp))(struct bio_st*,int,int)  );
void* BIO_ptr_ctrl(struct bio_st* bp  , int cmd, long larg);
long BIO_int_ctrl(struct bio_st* bp  , int cmd, long larg, int iarg);
struct bio_st* BIO_push(struct bio_st* b  , struct bio_st* append  );
struct bio_st* BIO_pop(struct bio_st* b  );
void BIO_free_all(struct bio_st* a  );
struct bio_st* BIO_find_type(struct bio_st* b  , int bio_type);
struct bio_st* BIO_next(struct bio_st* b  );
void BIO_set_next(struct bio_st* b  , struct bio_st* next  );
struct bio_st* BIO_get_retry_BIO(struct bio_st* bio  , int* reason);
int BIO_get_retry_reason(struct bio_st* bio  );
void BIO_set_retry_reason(struct bio_st* bio  , int reason);
struct bio_st* BIO_dup_chain(struct bio_st* in  );
int BIO_nread0(struct bio_st* bio  , char** buf);
int BIO_nread(struct bio_st* bio  , char** buf, int num);
int BIO_nwrite0(struct bio_st* bio  , char** buf);
int BIO_nwrite(struct bio_st* bio  , char** buf, int num);
const struct bio_method_st* BIO_s_mem();
const struct bio_method_st* BIO_s_dgram_mem();
const struct bio_method_st* BIO_s_secmem();
struct bio_st* BIO_new_mem_buf(const void* buf, int len);
const struct bio_method_st* BIO_s_socket();
const struct bio_method_st* BIO_s_connect();
const struct bio_method_st* BIO_s_accept();
const struct bio_method_st* BIO_s_fd();
const struct bio_method_st* BIO_s_log();
const struct bio_method_st* BIO_s_bio();
const struct bio_method_st* BIO_s_null();
const struct bio_method_st* BIO_f_null();
const struct bio_method_st* BIO_f_buffer();
const struct bio_method_st* BIO_f_readbuffer();
const struct bio_method_st* BIO_f_linebuffer();
const struct bio_method_st* BIO_f_nbio_test();
const struct bio_method_st* BIO_f_prefix();
const struct bio_method_st* BIO_s_core();
const struct bio_method_st* BIO_s_dgram_pair();
const struct bio_method_st* BIO_s_datagram();
int BIO_dgram_non_fatal_error(int error);
struct bio_st* BIO_new_dgram(int fd, int close_flag);
const struct bio_method_st* BIO_s_datagram_sctp();
struct bio_st* BIO_new_dgram_sctp(int fd, int close_flag);
int BIO_dgram_is_sctp(struct bio_st* bio  );
int BIO_dgram_sctp_notification_cb(struct bio_st* b  , void (*handle_notifications)(struct bio_st*,void*,void*)  , void* context);
int BIO_dgram_sctp_wait_for_dry(struct bio_st* b  );
int BIO_dgram_sctp_msg_waiting(struct bio_st* b  );
int BIO_sock_should_retry(int i);
int BIO_sock_non_fatal_error(int error);
int BIO_err_is_non_fatal(unsigned int errcode);
int BIO_socket_wait(int fd, int for_read, long  int max_time  );
int BIO_wait(struct bio_st* bio  , long  int max_time  , unsigned int nap_milliseconds);
int BIO_do_connect_retry(struct bio_st* bio  , int timeout, int nap_milliseconds);
int BIO_fd_should_retry(int i);
int BIO_fd_non_fatal_error(int error);
int BIO_dump_cb(int (*cb)(const void*,unsigned long,void*), void* u, const void* s, int len);
int BIO_dump_indent_cb(int (*cb)(const void*,unsigned long,void*), void* u, const void* s, int len, int indent);
int BIO_dump(struct bio_st* b  , const void* bytes, int len);
int BIO_dump_indent(struct bio_st* b  , const void* bytes, int len, int indent);
int BIO_dump_fp(struct _IO_FILE* fp  , const void* s, int len);
int BIO_dump_indent_fp(struct _IO_FILE* fp  , const void* s, int len, int indent);
int BIO_hex_string(struct bio_st* out  , int indent, int width, const void* data, int datalen);
union bio_addr_st* BIO_ADDR_new();
int BIO_ADDR_copy(union bio_addr_st* dst  , const union bio_addr_st* src  );
union bio_addr_st* BIO_ADDR_dup(const union bio_addr_st* ap  );
int BIO_ADDR_rawmake(union bio_addr_st* ap  , int family, const void* where, unsigned long wherelen  , unsigned short int port);
void BIO_ADDR_free(union bio_addr_st*   );
void BIO_ADDR_clear(union bio_addr_st* ap  );
int BIO_ADDR_family(const union bio_addr_st* ap  );
int BIO_ADDR_rawaddress(const union bio_addr_st* ap  , void* p, unsigned long* l  );
unsigned short int BIO_ADDR_rawport(const union bio_addr_st* ap  );
char* BIO_ADDR_hostname_string(const union bio_addr_st* ap  , int numeric);
char* BIO_ADDR_service_string(const union bio_addr_st* ap  , int numeric);
char* BIO_ADDR_path_string(const union bio_addr_st* ap  );
const struct bio_addrinfo_st* BIO_ADDRINFO_next(const struct bio_addrinfo_st* bai  );
int BIO_ADDRINFO_family(const struct bio_addrinfo_st* bai  );
int BIO_ADDRINFO_socktype(const struct bio_addrinfo_st* bai  );
int BIO_ADDRINFO_protocol(const struct bio_addrinfo_st* bai  );
const union bio_addr_st* BIO_ADDRINFO_address(const struct bio_addrinfo_st* bai  );
void BIO_ADDRINFO_free(struct bio_addrinfo_st* bai  );
int BIO_parse_hostserv(const char* hostserv, char** host, char** service, enum BIO_hostserv_priorities hostserv_prio);
int BIO_lookup(const char* host, const char* service, enum BIO_lookup_type lookup_type, int family, int socktype, struct bio_addrinfo_st** res  );
int BIO_lookup_ex(const char* host, const char* service, int lookup_type, int family, int socktype, int protocol, struct bio_addrinfo_st** res  );
int BIO_sock_error(int sock);
int BIO_socket_ioctl(int fd, long type, void* arg);
int BIO_socket_nbio(int fd, int mode);
int BIO_sock_init();
int BIO_set_tcp_ndelay(int sock, int turn_on);
struct hostent* BIO_gethostbyname(const char* name);
int BIO_get_port(const char* str, unsigned short int* port_ptr);
int BIO_get_host_ip(const char* str, unsigned char* ip);
int BIO_get_accept_socket(char* host_port, int mode);
int BIO_accept(int sock, char** ip_port);
int BIO_sock_info(int sock, enum BIO_sock_info_type type, union BIO_sock_info_u* info  );
int BIO_socket(int domain, int socktype, int protocol, int options);
int BIO_connect(int sock, const union bio_addr_st* addr  , int options);
int BIO_bind(int sock, const union bio_addr_st* addr  , int options);
int BIO_listen(int sock, const union bio_addr_st* addr  , int options);
int BIO_accept_ex(int accept_sock, union bio_addr_st* addr  , int options);
int BIO_closesocket(int sock);
struct bio_st* BIO_new_socket(int sock, int close_flag);
struct bio_st* BIO_new_connect(const char* host_port);
struct bio_st* BIO_new_accept(const char* host_port);
struct bio_st* BIO_new_fd(int fd, int close_flag);
int BIO_new_bio_pair(struct bio_st** bio1  , unsigned long writebuf1  , struct bio_st** bio2  , unsigned long writebuf2  );
int BIO_new_bio_dgram_pair(struct bio_st** bio1  , unsigned long writebuf1  , struct bio_st** bio2  , unsigned long writebuf2  );
void BIO_copy_next_retry(struct bio_st* b  );
int BIO_printf(struct bio_st* bio  , const char* format, ...);
int BIO_vprintf(struct bio_st* bio  , const char* format, __builtin_va_list args  );
int BIO_snprintf(char* buf, unsigned long n  , const char* format, ...);
int BIO_vsnprintf(char* buf, unsigned long n  , const char* format, __builtin_va_list args  );
struct bio_method_st* BIO_meth_new(int type, const char* name);
void BIO_meth_free(struct bio_method_st* biom  );
int BIO_meth_set_write(struct bio_method_st* biom  , int (*write)(struct bio_st*,const char*,int));
int BIO_meth_set_write_ex(struct bio_method_st* biom  , int (*bwrite)(struct bio_st*,const char*,unsigned long,unsigned long*));
int BIO_meth_set_sendmmsg(struct bio_method_st* biom  , int (*f)(struct bio_st*,struct bio_msg_st*,unsigned long,unsigned long,unsigned long  int,unsigned long*));
int BIO_meth_set_read(struct bio_method_st* biom  , int (*read)(struct bio_st*,char*,int));
int BIO_meth_set_read_ex(struct bio_method_st* biom  , int (*bread)(struct bio_st*,char*,unsigned long,unsigned long*));
int BIO_meth_set_recvmmsg(struct bio_method_st* biom  , int (*f)(struct bio_st*,struct bio_msg_st*,unsigned long,unsigned long,unsigned long  int,unsigned long*));
int BIO_meth_set_puts(struct bio_method_st* biom  , int (*puts)(struct bio_st*,const char*));
int BIO_meth_set_gets(struct bio_method_st* biom  , int (*ossl_gets)(struct bio_st*,char*,int));
int BIO_meth_set_ctrl(struct bio_method_st* biom  , long (*ctrl)(struct bio_st*,int,long,void*));
int BIO_meth_set_create(struct bio_method_st* biom  , int (*create)(struct bio_st*));
int BIO_meth_set_destroy(struct bio_method_st* biom  , int (*destroy)(struct bio_st*));
int BIO_meth_set_callback_ctrl(struct bio_method_st* biom  , long (*callback_ctrl)(struct bio_st*,int,int (*)(struct bio_st*,int,int)));
int (*BIO_meth_get_write(const struct bio_method_st* _function_pointer_result_var_name_a1  ))(struct bio_st*,const char*,int);
int (*BIO_meth_get_write_ex(const struct bio_method_st* _function_pointer_result_var_name_a2  ))(struct bio_st*,const char*,unsigned long,unsigned long*);
int (*BIO_meth_get_sendmmsg(const struct bio_method_st* _function_pointer_result_var_name_a3  ))(struct bio_st*,struct bio_msg_st*,unsigned long,unsigned long,unsigned long  int,unsigned long*);
int (*BIO_meth_get_read(const struct bio_method_st* _function_pointer_result_var_name_a4  ))(struct bio_st*,char*,int);
int (*BIO_meth_get_read_ex(const struct bio_method_st* _function_pointer_result_var_name_a5  ))(struct bio_st*,char*,unsigned long,unsigned long*);
int (*BIO_meth_get_recvmmsg(const struct bio_method_st* _function_pointer_result_var_name_a6  ))(struct bio_st*,struct bio_msg_st*,unsigned long,unsigned long,unsigned long  int,unsigned long*);
int (*BIO_meth_get_puts(const struct bio_method_st* _function_pointer_result_var_name_a7  ))(struct bio_st*,const char*);
int (*BIO_meth_get_gets(const struct bio_method_st* _function_pointer_result_var_name_a8  ))(struct bio_st*,char*,int);
long (*BIO_meth_get_ctrl(const struct bio_method_st* _function_pointer_result_var_name_a9  ))(struct bio_st*,int,long,void*);
int (*BIO_meth_get_create(const struct bio_method_st* _function_pointer_result_var_name_a10  ))(struct bio_st*);
int (*BIO_meth_get_destroy(const struct bio_method_st* _function_pointer_result_var_name_a11  ))(struct bio_st*);
long (*BIO_meth_get_callback_ctrl(const struct bio_method_st* _function_pointer_result_var_name_a12  ))(struct bio_st*,int,int (*)(struct bio_st*,int,int));
struct buf_mem_st* BUF_MEM_new();
struct buf_mem_st* BUF_MEM_new_ex(unsigned long  int flags);
void BUF_MEM_free(struct buf_mem_st* a  );
unsigned long BUF_MEM_grow(struct buf_mem_st* str  , unsigned long len  );
unsigned long BUF_MEM_grow_clean(struct buf_mem_st* str  , unsigned long len  );
void BUF_reverse(unsigned char* out, const unsigned char* in, unsigned long siz  );
void BN_set_flags(struct bignum_st* b  , int n);
int BN_get_flags(const struct bignum_st* b  , int n);
void BN_with_flags(struct bignum_st* dest  , const struct bignum_st* b  , int flags);
int BN_GENCB_call(struct bn_gencb_st* cb  , int a, int b);
struct bn_gencb_st* BN_GENCB_new();
void BN_GENCB_free(struct bn_gencb_st* cb  );
void BN_GENCB_set_old(struct bn_gencb_st* gencb  , void (*callback)(int,int,void*), void* cb_arg);
void BN_GENCB_set(struct bn_gencb_st* gencb  , int (*callback)(int,int,struct bn_gencb_st*), void* cb_arg);
void* BN_GENCB_get_arg(struct bn_gencb_st* cb  );
int BN_abs_is_word(const struct bignum_st* a  , const unsigned long  int w);
int BN_is_zero(const struct bignum_st* a  );
int BN_is_one(const struct bignum_st* a  );
int BN_is_word(const struct bignum_st* a  , const unsigned long  int w);
int BN_is_odd(const struct bignum_st* a  );
void BN_zero_ex(struct bignum_st* a  );
const struct bignum_st* BN_value_one();
char* BN_options();
struct bignum_ctx* BN_CTX_new_ex(struct ossl_lib_ctx_st* ctx  );
struct bignum_ctx* BN_CTX_new();
struct bignum_ctx* BN_CTX_secure_new_ex(struct ossl_lib_ctx_st* ctx  );
struct bignum_ctx* BN_CTX_secure_new();
void BN_CTX_free(struct bignum_ctx* c  );
void BN_CTX_start(struct bignum_ctx* ctx  );
struct bignum_st* BN_CTX_get(struct bignum_ctx* ctx  );
void BN_CTX_end(struct bignum_ctx* ctx  );
int BN_rand_ex(struct bignum_st* rnd  , int bits, int top, int bottom, unsigned int strength, struct bignum_ctx* ctx  );
int BN_rand(struct bignum_st* rnd  , int bits, int top, int bottom);
int BN_priv_rand_ex(struct bignum_st* rnd  , int bits, int top, int bottom, unsigned int strength, struct bignum_ctx* ctx  );
int BN_priv_rand(struct bignum_st* rnd  , int bits, int top, int bottom);
int BN_rand_range_ex(struct bignum_st* r  , const struct bignum_st* range  , unsigned int strength, struct bignum_ctx* ctx  );
int BN_rand_range(struct bignum_st* rnd  , const struct bignum_st* range  );
int BN_priv_rand_range_ex(struct bignum_st* r  , const struct bignum_st* range  , unsigned int strength, struct bignum_ctx* ctx  );
int BN_priv_rand_range(struct bignum_st* rnd  , const struct bignum_st* range  );
int BN_pseudo_rand(struct bignum_st* rnd  , int bits, int top, int bottom);
int BN_pseudo_rand_range(struct bignum_st* rnd  , const struct bignum_st* range  );
int BN_num_bits(const struct bignum_st* a  );
int BN_num_bits_word(unsigned long  int l);
int BN_security_bits(int L, int N);
struct bignum_st* BN_new();
struct bignum_st* BN_secure_new();
void BN_clear_free(struct bignum_st* a  );
struct bignum_st* BN_copy(struct bignum_st* a  , const struct bignum_st* b  );
void BN_swap(struct bignum_st* a  , struct bignum_st* b  );
struct bignum_st* BN_bin2bn(const unsigned char* s, int len, struct bignum_st* ret  );
struct bignum_st* BN_signed_bin2bn(const unsigned char* s, int len, struct bignum_st* ret  );
int BN_bn2bin(const struct bignum_st* a  , unsigned char* to);
int BN_bn2binpad(const struct bignum_st* a  , unsigned char* to, int tolen);
int BN_signed_bn2bin(const struct bignum_st* a  , unsigned char* to, int tolen);
struct bignum_st* BN_lebin2bn(const unsigned char* s, int len, struct bignum_st* ret  );
struct bignum_st* BN_signed_lebin2bn(const unsigned char* s, int len, struct bignum_st* ret  );
int BN_bn2lebinpad(const struct bignum_st* a  , unsigned char* to, int tolen);
int BN_signed_bn2lebin(const struct bignum_st* a  , unsigned char* to, int tolen);
struct bignum_st* BN_native2bn(const unsigned char* s, int len, struct bignum_st* ret  );
struct bignum_st* BN_signed_native2bn(const unsigned char* s, int len, struct bignum_st* ret  );
int BN_bn2nativepad(const struct bignum_st* a  , unsigned char* to, int tolen);
int BN_signed_bn2native(const struct bignum_st* a  , unsigned char* to, int tolen);
struct bignum_st* BN_mpi2bn(const unsigned char* s, int len, struct bignum_st* ret  );
int BN_bn2mpi(const struct bignum_st* a  , unsigned char* to);
int BN_sub(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  );
int BN_usub(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  );
int BN_uadd(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  );
int BN_add(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  );
int BN_mul(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  , struct bignum_ctx* ctx  );
int BN_sqr(struct bignum_st* r  , const struct bignum_st* a  , struct bignum_ctx* ctx  );
void BN_set_negative(struct bignum_st* b  , int n);
int BN_is_negative(const struct bignum_st* b  );
int BN_div(struct bignum_st* dv  , struct bignum_st* rem  , const struct bignum_st* m  , const struct bignum_st* d  , struct bignum_ctx* ctx  );
int BN_nnmod(struct bignum_st* r  , const struct bignum_st* m  , const struct bignum_st* d  , struct bignum_ctx* ctx  );
int BN_mod_add(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  , const struct bignum_st* m  , struct bignum_ctx* ctx  );
int BN_mod_add_quick(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  , const struct bignum_st* m  );
int BN_mod_sub(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  , const struct bignum_st* m  , struct bignum_ctx* ctx  );
int BN_mod_sub_quick(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  , const struct bignum_st* m  );
int BN_mod_mul(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  , const struct bignum_st* m  , struct bignum_ctx* ctx  );
int BN_mod_sqr(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* m  , struct bignum_ctx* ctx  );
int BN_mod_lshift1(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* m  , struct bignum_ctx* ctx  );
int BN_mod_lshift1_quick(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* m  );
int BN_mod_lshift(struct bignum_st* r  , const struct bignum_st* a  , int n, const struct bignum_st* m  , struct bignum_ctx* ctx  );
int BN_mod_lshift_quick(struct bignum_st* r  , const struct bignum_st* a  , int n, const struct bignum_st* m  );
unsigned long  int BN_mod_word(const struct bignum_st* a  , unsigned long  int w);
unsigned long  int BN_div_word(struct bignum_st* a  , unsigned long  int w);
int BN_mul_word(struct bignum_st* a  , unsigned long  int w);
int BN_add_word(struct bignum_st* a  , unsigned long  int w);
int BN_sub_word(struct bignum_st* a  , unsigned long  int w);
int BN_set_word(struct bignum_st* a  , unsigned long  int w);
unsigned long  int BN_get_word(const struct bignum_st* a  );
int BN_cmp(const struct bignum_st* a  , const struct bignum_st* b  );
void BN_free(struct bignum_st* a  );
int BN_is_bit_set(const struct bignum_st* a  , int n);
int BN_lshift(struct bignum_st* r  , const struct bignum_st* a  , int n);
int BN_lshift1(struct bignum_st* r  , const struct bignum_st* a  );
int BN_exp(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , struct bignum_ctx* ctx  );
int BN_mod_exp(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , const struct bignum_st* m  , struct bignum_ctx* ctx  );
int BN_mod_exp_mont(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , const struct bignum_st* m  , struct bignum_ctx* ctx  , struct bn_mont_ctx_st* m_ctx  );
int BN_mod_exp_mont_consttime(struct bignum_st* rr  , const struct bignum_st* a  , const struct bignum_st* p  , const struct bignum_st* m  , struct bignum_ctx* ctx  , struct bn_mont_ctx_st* in_mont  );
int BN_mod_exp_mont_word(struct bignum_st* r  , unsigned long  int a, const struct bignum_st* p  , const struct bignum_st* m  , struct bignum_ctx* ctx  , struct bn_mont_ctx_st* m_ctx  );
int BN_mod_exp2_mont(struct bignum_st* r  , const struct bignum_st* a1  , const struct bignum_st* p1  , const struct bignum_st* a2  , const struct bignum_st* p2  , const struct bignum_st* m  , struct bignum_ctx* ctx  , struct bn_mont_ctx_st* m_ctx  );
int BN_mod_exp_simple(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , const struct bignum_st* m  , struct bignum_ctx* ctx  );
int BN_mod_exp_mont_consttime_x2(struct bignum_st* rr1  , const struct bignum_st* a1  , const struct bignum_st* p1  , const struct bignum_st* m1  , struct bn_mont_ctx_st* in_mont1  , struct bignum_st* rr2  , const struct bignum_st* a2  , const struct bignum_st* p2  , const struct bignum_st* m2  , struct bn_mont_ctx_st* in_mont2  , struct bignum_ctx* ctx  );
int BN_mask_bits(struct bignum_st* a  , int n);
int BN_print_fp(struct _IO_FILE* fp  , const struct bignum_st* a  );
int BN_print(struct bio_st* bio  , const struct bignum_st* a  );
int BN_reciprocal(struct bignum_st* r  , const struct bignum_st* m  , int len, struct bignum_ctx* ctx  );
int BN_rshift(struct bignum_st* r  , const struct bignum_st* a  , int n);
int BN_rshift1(struct bignum_st* r  , const struct bignum_st* a  );
void BN_clear(struct bignum_st* a  );
struct bignum_st* BN_dup(const struct bignum_st* a  );
int BN_ucmp(const struct bignum_st* a  , const struct bignum_st* b  );
int BN_set_bit(struct bignum_st* a  , int n);
int BN_clear_bit(struct bignum_st* a  , int n);
char* BN_bn2hex(const struct bignum_st* a  );
char* BN_bn2dec(const struct bignum_st* a  );
int BN_hex2bn(struct bignum_st** a  , const char* str);
int BN_dec2bn(struct bignum_st** a  , const char* str);
int BN_asc2bn(struct bignum_st** a  , const char* str);
int BN_gcd(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  , struct bignum_ctx* ctx  );
int BN_kronecker(const struct bignum_st* a  , const struct bignum_st* b  , struct bignum_ctx* ctx  );
int BN_are_coprime(struct bignum_st* a  , const struct bignum_st* b  , struct bignum_ctx* ctx  );
struct bignum_st* BN_mod_inverse(struct bignum_st* ret  , const struct bignum_st* a  , const struct bignum_st* n  , struct bignum_ctx* ctx  );
struct bignum_st* BN_mod_sqrt(struct bignum_st* ret  , const struct bignum_st* a  , const struct bignum_st* n  , struct bignum_ctx* ctx  );
void BN_consttime_swap(unsigned long  int swap, struct bignum_st* a  , struct bignum_st* b  , int nwords);
struct bignum_st* BN_generate_prime(struct bignum_st* ret  , int bits, int safe, const struct bignum_st* add  , const struct bignum_st* rem  , void (*callback)(int,int,void*), void* cb_arg);
int BN_is_prime(const struct bignum_st* p  , int nchecks, void (*callback)(int,int,void*), struct bignum_ctx* ctx  , void* cb_arg);
int BN_is_prime_fasttest(const struct bignum_st* p  , int nchecks, void (*callback)(int,int,void*), struct bignum_ctx* ctx  , void* cb_arg, int do_trial_division);
int BN_is_prime_ex(const struct bignum_st* p  , int nchecks, struct bignum_ctx* ctx  , struct bn_gencb_st* cb  );
int BN_is_prime_fasttest_ex(const struct bignum_st* p  , int nchecks, struct bignum_ctx* ctx  , int do_trial_division, struct bn_gencb_st* cb  );
int BN_generate_prime_ex2(struct bignum_st* ret  , int bits, int safe, const struct bignum_st* add  , const struct bignum_st* rem  , struct bn_gencb_st* cb  , struct bignum_ctx* ctx  );
int BN_generate_prime_ex(struct bignum_st* ret  , int bits, int safe, const struct bignum_st* add  , const struct bignum_st* rem  , struct bn_gencb_st* cb  );
int BN_check_prime(const struct bignum_st* p  , struct bignum_ctx* ctx  , struct bn_gencb_st* cb  );
int BN_X931_generate_Xpq(struct bignum_st* Xp  , struct bignum_st* Xq  , int nbits, struct bignum_ctx* ctx  );
int BN_X931_derive_prime_ex(struct bignum_st* p  , struct bignum_st* p1  , struct bignum_st* p2  , const struct bignum_st* Xp  , const struct bignum_st* Xp1  , const struct bignum_st* Xp2  , const struct bignum_st* e  , struct bignum_ctx* ctx  , struct bn_gencb_st* cb  );
int BN_X931_generate_prime_ex(struct bignum_st* p  , struct bignum_st* p1  , struct bignum_st* p2  , struct bignum_st* Xp1  , struct bignum_st* Xp2  , const struct bignum_st* Xp  , const struct bignum_st* e  , struct bignum_ctx* ctx  , struct bn_gencb_st* cb  );
struct bn_mont_ctx_st* BN_MONT_CTX_new();
int BN_mod_mul_montgomery(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* b  , struct bn_mont_ctx_st* mont  , struct bignum_ctx* ctx  );
int BN_to_montgomery(struct bignum_st* r  , const struct bignum_st* a  , struct bn_mont_ctx_st* mont  , struct bignum_ctx* ctx  );
int BN_from_montgomery(struct bignum_st* r  , const struct bignum_st* a  , struct bn_mont_ctx_st* mont  , struct bignum_ctx* ctx  );
void BN_MONT_CTX_free(struct bn_mont_ctx_st* mont  );
int BN_MONT_CTX_set(struct bn_mont_ctx_st* mont  , const struct bignum_st* mod  , struct bignum_ctx* ctx  );
struct bn_mont_ctx_st* BN_MONT_CTX_copy(struct bn_mont_ctx_st* to  , struct bn_mont_ctx_st* from  );
struct bn_mont_ctx_st* BN_MONT_CTX_set_locked(struct bn_mont_ctx_st** pmont  , void* lock  , const struct bignum_st* mod  , struct bignum_ctx* ctx  );
struct bn_blinding_st* BN_BLINDING_new(const struct bignum_st* A  , const struct bignum_st* Ai  , struct bignum_st* mod  );
void BN_BLINDING_free(struct bn_blinding_st* b  );
int BN_BLINDING_update(struct bn_blinding_st* b  , struct bignum_ctx* ctx  );
int BN_BLINDING_convert(struct bignum_st* n  , struct bn_blinding_st* b  , struct bignum_ctx* ctx  );
int BN_BLINDING_invert(struct bignum_st* n  , struct bn_blinding_st* b  , struct bignum_ctx* ctx  );
int BN_BLINDING_convert_ex(struct bignum_st* n  , struct bignum_st* r  , struct bn_blinding_st* b  , struct bignum_ctx*   );
int BN_BLINDING_invert_ex(struct bignum_st* n  , const struct bignum_st* r  , struct bn_blinding_st* b  , struct bignum_ctx*   );
int BN_BLINDING_is_current_thread(struct bn_blinding_st* b  );
void BN_BLINDING_set_current_thread(struct bn_blinding_st* b  );
int BN_BLINDING_lock(struct bn_blinding_st* b  );
int BN_BLINDING_unlock(struct bn_blinding_st* b  );
unsigned long  int BN_BLINDING_get_flags(const struct bn_blinding_st*   );
void BN_BLINDING_set_flags(struct bn_blinding_st*   , unsigned long  int );
struct bn_blinding_st* BN_BLINDING_create_param(struct bn_blinding_st* b  , const struct bignum_st* e  , struct bignum_st* m  , struct bignum_ctx* ctx  , int (*bn_mod_exp)(struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*,struct bn_mont_ctx_st*), struct bn_mont_ctx_st* m_ctx  );
void BN_set_params(int mul, int high, int low, int mont);
int BN_get_params(int which);
struct bn_recp_ctx_st* BN_RECP_CTX_new();
void BN_RECP_CTX_free(struct bn_recp_ctx_st* recp  );
int BN_RECP_CTX_set(struct bn_recp_ctx_st* recp  , const struct bignum_st* rdiv  , struct bignum_ctx* ctx  );
int BN_mod_mul_reciprocal(struct bignum_st* r  , const struct bignum_st* x  , const struct bignum_st* y  , struct bn_recp_ctx_st* recp  , struct bignum_ctx* ctx  );
int BN_mod_exp_recp(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , const struct bignum_st* m  , struct bignum_ctx* ctx  );
int BN_div_recp(struct bignum_st* dv  , struct bignum_st* rem  , const struct bignum_st* m  , struct bn_recp_ctx_st* recp  , struct bignum_ctx* ctx  );
int BN_nist_mod_192(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , struct bignum_ctx* ctx  );
int BN_nist_mod_224(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , struct bignum_ctx* ctx  );
int BN_nist_mod_256(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , struct bignum_ctx* ctx  );
int BN_nist_mod_384(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , struct bignum_ctx* ctx  );
int BN_nist_mod_521(struct bignum_st* r  , const struct bignum_st* a  , const struct bignum_st* p  , struct bignum_ctx* ctx  );
const struct bignum_st* BN_get0_nist_prime_192();
const struct bignum_st* BN_get0_nist_prime_224();
const struct bignum_st* BN_get0_nist_prime_256();
const struct bignum_st* BN_get0_nist_prime_384();
const struct bignum_st* BN_get0_nist_prime_521();
int (*BN_nist_mod_func(const struct bignum_st* _function_pointer_result_var_name_a13  ))(struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*);
int BN_generate_dsa_nonce(struct bignum_st* out  , const struct bignum_st* range  , const struct bignum_st* priv  , const unsigned char* message, unsigned long message_len  , struct bignum_ctx* ctx  );
struct bignum_st* BN_get_rfc2409_prime_768(struct bignum_st* bn  );
struct bignum_st* BN_get_rfc2409_prime_1024(struct bignum_st* bn  );
struct bignum_st* BN_get_rfc3526_prime_1536(struct bignum_st* bn  );
struct bignum_st* BN_get_rfc3526_prime_2048(struct bignum_st* bn  );
struct bignum_st* BN_get_rfc3526_prime_3072(struct bignum_st* bn  );
struct bignum_st* BN_get_rfc3526_prime_4096(struct bignum_st* bn  );
struct bignum_st* BN_get_rfc3526_prime_6144(struct bignum_st* bn  );
struct bignum_st* BN_get_rfc3526_prime_8192(struct bignum_st* bn  );
int BN_bntest_rand(struct bignum_st* rnd  , int bits, int top, int bottom);
struct ossl_param_st* OSSL_PARAM_locate(struct ossl_param_st* p  , const char* key);
const struct ossl_param_st* OSSL_PARAM_locate_const(const struct ossl_param_st* p  , const char* key);
struct ossl_param_st OSSL_PARAM_construct_int(const char* key, int* buf);
struct ossl_param_st OSSL_PARAM_construct_uint(const char* key, unsigned int* buf);
struct ossl_param_st OSSL_PARAM_construct_long(const char* key, long  int* buf);
struct ossl_param_st OSSL_PARAM_construct_ulong(const char* key, unsigned long  int* buf);
struct ossl_param_st OSSL_PARAM_construct_int32(const char* key, int* buf  );
struct ossl_param_st OSSL_PARAM_construct_uint32(const char* key, unsigned int* buf  );
struct ossl_param_st OSSL_PARAM_construct_int64(const char* key, long  int* buf  );
struct ossl_param_st OSSL_PARAM_construct_uint64(const char* key, unsigned long  int* buf  );
struct ossl_param_st OSSL_PARAM_construct_size_t(const char* key, unsigned long* buf  );
struct ossl_param_st OSSL_PARAM_construct_time_t(const char* key, long  int* buf  );
struct ossl_param_st OSSL_PARAM_construct_BN(const char* key, unsigned char* buf, unsigned long bsize  );
struct ossl_param_st OSSL_PARAM_construct_double(const char* key, double* buf);
struct ossl_param_st OSSL_PARAM_construct_utf8_string(const char* key, char* buf, unsigned long bsize  );
struct ossl_param_st OSSL_PARAM_construct_utf8_ptr(const char* key, char** buf, unsigned long bsize  );
struct ossl_param_st OSSL_PARAM_construct_octet_string(const char* key, void* buf, unsigned long bsize  );
struct ossl_param_st OSSL_PARAM_construct_octet_ptr(const char* key, void** buf, unsigned long bsize  );
struct ossl_param_st OSSL_PARAM_construct_end();
int OSSL_PARAM_allocate_from_text(struct ossl_param_st* to  , const struct ossl_param_st* paramdefs  , const char* key, const char* value, unsigned long value_n  , int* found);
int OSSL_PARAM_print_to_bio(const struct ossl_param_st* params  , struct bio_st* bio  , int print_values);
int OSSL_PARAM_get_int(const struct ossl_param_st* p  , int* val);
int OSSL_PARAM_get_uint(const struct ossl_param_st* p  , unsigned int* val);
int OSSL_PARAM_get_long(const struct ossl_param_st* p  , long  int* val);
int OSSL_PARAM_get_ulong(const struct ossl_param_st* p  , unsigned long  int* val);
int OSSL_PARAM_get_int32(const struct ossl_param_st* p  , int* val  );
int OSSL_PARAM_get_uint32(const struct ossl_param_st* p  , unsigned int* val  );
int OSSL_PARAM_get_int64(const struct ossl_param_st* p  , long  int* val  );
int OSSL_PARAM_get_uint64(const struct ossl_param_st* p  , unsigned long  int* val  );
int OSSL_PARAM_get_size_t(const struct ossl_param_st* p  , unsigned long* val  );
int OSSL_PARAM_get_time_t(const struct ossl_param_st* p  , long  int* val  );
int OSSL_PARAM_set_int(struct ossl_param_st* p  , int val);
int OSSL_PARAM_set_uint(struct ossl_param_st* p  , unsigned int val);
int OSSL_PARAM_set_long(struct ossl_param_st* p  , long  int val);
int OSSL_PARAM_set_ulong(struct ossl_param_st* p  , unsigned long  int val);
int OSSL_PARAM_set_int32(struct ossl_param_st* p  , int val  );
int OSSL_PARAM_set_uint32(struct ossl_param_st* p  , unsigned int val  );
int OSSL_PARAM_set_int64(struct ossl_param_st* p  , long  int val  );
int OSSL_PARAM_set_uint64(struct ossl_param_st* p  , unsigned long  int val  );
int OSSL_PARAM_set_size_t(struct ossl_param_st* p  , unsigned long val  );
int OSSL_PARAM_set_time_t(struct ossl_param_st* p  , long  int val  );
int OSSL_PARAM_get_double(const struct ossl_param_st* p  , double* val);
int OSSL_PARAM_set_double(struct ossl_param_st* p  , double val);
int OSSL_PARAM_get_BN(const struct ossl_param_st* p  , struct bignum_st** val  );
int OSSL_PARAM_set_BN(struct ossl_param_st* p  , const struct bignum_st* val  );
int OSSL_PARAM_get_utf8_string(const struct ossl_param_st* p  , char** val, unsigned long max_len  );
int OSSL_PARAM_set_utf8_string(struct ossl_param_st* p  , const char* val);
int OSSL_PARAM_get_octet_string(const struct ossl_param_st* p  , void** val, unsigned long max_len  , unsigned long* used_len  );
int OSSL_PARAM_set_octet_string(struct ossl_param_st* p  , const void* val, unsigned long len  );
int OSSL_PARAM_get_utf8_ptr(const struct ossl_param_st* p  , const char** val);
int OSSL_PARAM_set_utf8_ptr(struct ossl_param_st* p  , const char* val);
int OSSL_PARAM_get_octet_ptr(const struct ossl_param_st* p  , const void** val, unsigned long* used_len  );
int OSSL_PARAM_set_octet_ptr(struct ossl_param_st* p  , const void* val, unsigned long used_len  );
int OSSL_PARAM_get_utf8_string_ptr(const struct ossl_param_st* p  , const char** val);
int OSSL_PARAM_get_octet_string_ptr(const struct ossl_param_st* p  , const void** val, unsigned long* used_len  );
int OSSL_PARAM_modified(const struct ossl_param_st* p  );
void OSSL_PARAM_set_all_unmodified(struct ossl_param_st* p  );
struct ossl_param_st* OSSL_PARAM_dup(const struct ossl_param_st* p  );
struct ossl_param_st* OSSL_PARAM_merge(const struct ossl_param_st* p1  , const struct ossl_param_st* p2  );
void OSSL_PARAM_free(struct ossl_param_st* p  );
void OSSL_INDICATOR_set_callback(struct ossl_lib_ctx_st* libctx  , int (*(*cb))(const char*,const char*,const struct ossl_param_st)  );
void OSSL_INDICATOR_get_callback(struct ossl_lib_ctx_st* libctx  , int (*(*(*cb)))(const char*,const char*,const struct ossl_param_st)  );
static const struct ossl_param_st* (*(*OSSL_FUNC_core_gettable_params(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static int (*(*OSSL_FUNC_core_get_params(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,struct ossl_param_st) ;
static int (*(*OSSL_FUNC_core_thread_start(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,void (*)(void*),void*) ;
static struct openssl_core_ctx_st* (*(*OSSL_FUNC_core_get_libctx(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static void (*(*OSSL_FUNC_core_new_error(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static void (*(*OSSL_FUNC_core_set_error_debug(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,const char*,int,const char*) ;
static void (*(*OSSL_FUNC_core_vset_error(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned int,const char*,__builtin_va_list) ;
static int (*(*OSSL_FUNC_core_set_error_mark(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static int (*(*OSSL_FUNC_core_clear_last_error_mark(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static int (*(*OSSL_FUNC_core_pop_error_to_mark(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static int (*(*OSSL_FUNC_core_obj_add_sigid(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,const char*,const char*,const char*) ;
static int (*(*OSSL_FUNC_core_obj_create(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,const char*,const char*,const char*) ;
static void* (*(*OSSL_FUNC_CRYPTO_malloc(const struct ossl_dispatch_st* opf  )))(unsigned long,const char*,int) ;
static void* (*(*OSSL_FUNC_CRYPTO_zalloc(const struct ossl_dispatch_st* opf  )))(unsigned long,const char*,int) ;
static void (*(*OSSL_FUNC_CRYPTO_free(const struct ossl_dispatch_st* opf  )))(void*,const char*,int) ;
static void (*(*OSSL_FUNC_CRYPTO_clear_free(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,const char*,int) ;
static void* (*(*OSSL_FUNC_CRYPTO_realloc(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,const char*,int) ;
static void* (*(*OSSL_FUNC_CRYPTO_clear_realloc(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,unsigned long,const char*,int) ;
static void* (*(*OSSL_FUNC_CRYPTO_secure_malloc(const struct ossl_dispatch_st* opf  )))(unsigned long,const char*,int) ;
static void* (*(*OSSL_FUNC_CRYPTO_secure_zalloc(const struct ossl_dispatch_st* opf  )))(unsigned long,const char*,int) ;
static void (*(*OSSL_FUNC_CRYPTO_secure_free(const struct ossl_dispatch_st* opf  )))(void*,const char*,int) ;
static void (*(*OSSL_FUNC_CRYPTO_secure_clear_free(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,const char*,int) ;
static int (*(*OSSL_FUNC_CRYPTO_secure_allocated(const struct ossl_dispatch_st* opf  )))(const void*) ;
static void (*(*OSSL_FUNC_OPENSSL_cleanse(const struct ossl_dispatch_st* opf  )))(void*,unsigned long) ;
static struct ossl_core_bio_st* (*(*OSSL_FUNC_BIO_new_file(const struct ossl_dispatch_st* opf  )))(const char*,const char*) ;
static struct ossl_core_bio_st* (*(*OSSL_FUNC_BIO_new_membuf(const struct ossl_dispatch_st* opf  )))(const void*,int) ;
static int (*(*OSSL_FUNC_BIO_read_ex(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,void*,unsigned long,unsigned long*) ;
static int (*(*OSSL_FUNC_BIO_write_ex(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,const void*,unsigned long,unsigned long*) ;
static int (*(*OSSL_FUNC_BIO_gets(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,char*,int) ;
static int (*(*OSSL_FUNC_BIO_puts(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,const char*) ;
static int (*(*OSSL_FUNC_BIO_up_ref(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*) ;
static int (*(*OSSL_FUNC_BIO_free(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*) ;
static int (*(*OSSL_FUNC_BIO_vprintf(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,const char*,__builtin_va_list) ;
static int (*(*OSSL_FUNC_BIO_vsnprintf(const struct ossl_dispatch_st* opf  )))(char*,unsigned long,const char*,__builtin_va_list) ;
static int (*(*OSSL_FUNC_BIO_ctrl(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,int,long,void*) ;
static void (*(*OSSL_FUNC_indicator_cb(const struct ossl_dispatch_st* opf  )))(struct openssl_core_ctx_st*,int (*)(const char*,const char*,const struct ossl_param_st)) ;
static void (*(*OSSL_FUNC_self_test_cb(const struct ossl_dispatch_st* opf  )))(struct openssl_core_ctx_st*,int (*)(const struct ossl_param_st,void*),void**) ;
static unsigned long (*(*OSSL_FUNC_get_entropy(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char**,int,unsigned long,unsigned long) ;
static unsigned long (*(*OSSL_FUNC_get_user_entropy(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char**,int,unsigned long,unsigned long) ;
static void (*(*OSSL_FUNC_cleanup_entropy(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char*,unsigned long) ;
static void (*(*OSSL_FUNC_cleanup_user_entropy(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char*,unsigned long) ;
static unsigned long (*(*OSSL_FUNC_get_nonce(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char**,unsigned long,unsigned long,const void*,unsigned long) ;
static unsigned long (*(*OSSL_FUNC_get_user_nonce(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char**,unsigned long,unsigned long,const void*,unsigned long) ;
static void (*(*OSSL_FUNC_cleanup_nonce(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char*,unsigned long) ;
static void (*(*OSSL_FUNC_cleanup_user_nonce(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_provider_register_child_cb(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,int (*)(const struct ossl_core_handle_st*,void*),int (*)(const struct ossl_core_handle_st*,void*),int (*)(const char*,void*),void*) ;
static void (*(*OSSL_FUNC_provider_deregister_child_cb(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static const char* (*(*OSSL_FUNC_provider_name(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static void* (*(*OSSL_FUNC_provider_get0_provider_ctx(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static const struct ossl_dispatch_st* (*(*OSSL_FUNC_provider_get0_dispatch(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static int (*(*OSSL_FUNC_provider_up_ref(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,int) ;
static int (*(*OSSL_FUNC_provider_free(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,int) ;
static int (*(*OSSL_FUNC_core_count_to_mark(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) ;
static void (*(*OSSL_FUNC_provider_teardown(const struct ossl_dispatch_st* opf  )))(void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_provider_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_provider_get_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static const struct ossl_algorithm_st* (*(*OSSL_FUNC_provider_query_operation(const struct ossl_dispatch_st* opf  )))(void*,int,int*) ;
static void (*(*OSSL_FUNC_provider_unquery_operation(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_algorithm_st*) ;
static const struct ossl_item_st* (*(*OSSL_FUNC_provider_get_reason_strings(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_provider_get_capabilities(const struct ossl_dispatch_st* opf  )))(void*,const char*,int (*)(const struct ossl_param_st,void*),void*) ;
static int (*(*OSSL_FUNC_provider_self_test(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_provider_random_bytes(const struct ossl_dispatch_st* opf  )))(void*,int,void*,unsigned long,unsigned int) ;
static int (*(*OSSL_FUNC_SSL_QUIC_TLS_crypto_send(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,const unsigned char*,unsigned long,unsigned long*,void*) ;
static int (*(*OSSL_FUNC_SSL_QUIC_TLS_crypto_recv_rcd(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,const unsigned char**,unsigned long*,void*) ;
static int (*(*OSSL_FUNC_SSL_QUIC_TLS_crypto_release_rcd(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,unsigned long,void*) ;
static int (*(*OSSL_FUNC_SSL_QUIC_TLS_yield_secret(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,unsigned int,int,const unsigned char*,unsigned long,void*) ;
static int (*(*OSSL_FUNC_SSL_QUIC_TLS_got_transport_params(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,const unsigned char*,unsigned long,void*) ;
static int (*(*OSSL_FUNC_SSL_QUIC_TLS_alert(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,unsigned char,void*) ;
static void* (*(*OSSL_FUNC_digest_newctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_digest_init(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_digest_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_digest_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) ;
static int (*(*OSSL_FUNC_digest_squeeze(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) ;
static int (*(*OSSL_FUNC_digest_digest(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,unsigned char*,unsigned long*,unsigned long) ;
static void (*(*OSSL_FUNC_digest_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_digest_dupctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void (*(*OSSL_FUNC_digest_copyctx(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_digest_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) ;
static int (*(*OSSL_FUNC_digest_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_digest_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_digest_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_digest_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_digest_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static void* (*(*OSSL_FUNC_cipher_newctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_cipher_encrypt_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_cipher_decrypt_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_cipher_update(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_cipher_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) ;
static int (*(*OSSL_FUNC_cipher_cipher(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_cipher_pipeline_encrypt_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,unsigned long,const unsigned char**,unsigned long,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_cipher_pipeline_decrypt_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,unsigned long,const unsigned char**,unsigned long,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_cipher_pipeline_update(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,unsigned char**,unsigned long*,const unsigned long*,const unsigned char**,const unsigned long*) ;
static int (*(*OSSL_FUNC_cipher_pipeline_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,unsigned char**,unsigned long*,const unsigned long*) ;
static void (*(*OSSL_FUNC_cipher_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_cipher_dupctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_cipher_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) ;
static int (*(*OSSL_FUNC_cipher_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static int (*(*OSSL_FUNC_cipher_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_cipher_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_cipher_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_cipher_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_cipher_encrypt_skey_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const unsigned char*,unsigned long,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_cipher_decrypt_skey_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const unsigned char*,unsigned long,const struct ossl_param_st) ;
static void* (*(*OSSL_FUNC_mac_newctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_mac_dupctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void (*(*OSSL_FUNC_mac_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_mac_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_mac_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_mac_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_mac_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_mac_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_mac_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_mac_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) ;
static int (*(*OSSL_FUNC_mac_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static int (*(*OSSL_FUNC_mac_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_mac_init_skey(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static void* (*(*OSSL_FUNC_kdf_newctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_kdf_dupctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void (*(*OSSL_FUNC_kdf_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void (*(*OSSL_FUNC_kdf_reset(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_kdf_derive(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_kdf_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_kdf_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_kdf_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_kdf_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) ;
static int (*(*OSSL_FUNC_kdf_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static int (*(*OSSL_FUNC_kdf_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static void* (*(*OSSL_FUNC_rand_newctx(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_dispatch_st*) ;
static void (*(*OSSL_FUNC_rand_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_rand_instantiate(const struct ossl_dispatch_st* opf  )))(void*,unsigned int,int,const unsigned char*,unsigned long,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_rand_uninstantiate(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_rand_generate(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long,unsigned int,int,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_rand_reseed(const struct ossl_dispatch_st* opf  )))(void*,int,const unsigned char*,unsigned long,const unsigned char*,unsigned long) ;
static unsigned long (*(*OSSL_FUNC_rand_nonce(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned int,unsigned long,unsigned long) ;
static int (*(*OSSL_FUNC_rand_enable_locking(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_rand_lock(const struct ossl_dispatch_st* opf  )))(void*) ;
static void (*(*OSSL_FUNC_rand_unlock(const struct ossl_dispatch_st* opf  )))(void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_rand_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_rand_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_rand_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_rand_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) ;
static int (*(*OSSL_FUNC_rand_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static int (*(*OSSL_FUNC_rand_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static void (*(*OSSL_FUNC_rand_set_callbacks(const struct ossl_dispatch_st* opf  )))(void*,int (*)(const struct ossl_param_st,struct ossl_param_st,void*),int (*)(const struct ossl_param_st,void*),int (*)(const struct ossl_param_st,struct ossl_param_st,void*),int (*)(const struct ossl_param_st,void*),void*) ;
static int (*(*OSSL_FUNC_rand_verify_zeroization(const struct ossl_dispatch_st* opf  )))(void*) ;
static unsigned long (*(*OSSL_FUNC_rand_get_seed(const struct ossl_dispatch_st* opf  )))(void*,unsigned char**,int,unsigned long,unsigned long,int,const unsigned char*,unsigned long) ;
static void (*(*OSSL_FUNC_rand_clear_seed(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long) ;
static void* (*(*OSSL_FUNC_keymgmt_new(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_keymgmt_gen_init(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_keymgmt_gen_set_template(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_keymgmt_gen_set_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_gen_settable_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_keymgmt_gen_get_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_gen_gettable_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static void* (*(*OSSL_FUNC_keymgmt_gen(const struct ossl_dispatch_st* opf  )))(void*,int (*)(const struct ossl_param_st,void*),void*) ;
static void (*(*OSSL_FUNC_keymgmt_gen_cleanup(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_keymgmt_load(const struct ossl_dispatch_st* opf  )))(const void*,unsigned long) ;
static void (*(*OSSL_FUNC_keymgmt_free(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_keymgmt_get_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_keymgmt_set_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_settable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static const char* (*(*OSSL_FUNC_keymgmt_query_operation_name(const struct ossl_dispatch_st* opf  )))(int) ;
static int (*(*OSSL_FUNC_keymgmt_has(const struct ossl_dispatch_st* opf  )))(const void*,int) ;
static int (*(*OSSL_FUNC_keymgmt_validate(const struct ossl_dispatch_st* opf  )))(const void*,int,int) ;
static int (*(*OSSL_FUNC_keymgmt_match(const struct ossl_dispatch_st* opf  )))(const void*,const void*,int) ;
static int (*(*OSSL_FUNC_keymgmt_import(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_import_types(const struct ossl_dispatch_st* opf  )))(int) ;
static int (*(*OSSL_FUNC_keymgmt_export(const struct ossl_dispatch_st* opf  )))(void*,int,int (*)(const struct ossl_param_st,void*),void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_export_types(const struct ossl_dispatch_st* opf  )))(int) ;
static void* (*(*OSSL_FUNC_keymgmt_dup(const struct ossl_dispatch_st* opf  )))(const void*,int) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_import_types_ex(const struct ossl_dispatch_st* opf  )))(void*,int) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_export_types_ex(const struct ossl_dispatch_st* opf  )))(void*,int) ;
static void* (*(*OSSL_FUNC_keyexch_newctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_keyexch_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_keyexch_derive(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) ;
static int (*(*OSSL_FUNC_keyexch_set_peer(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static void (*(*OSSL_FUNC_keyexch_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_keyexch_dupctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_keyexch_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keyexch_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_keyexch_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_keyexch_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static void* (*(*OSSL_FUNC_signature_newctx(const struct ossl_dispatch_st* opf  )))(void*,const char*) ;
static int (*(*OSSL_FUNC_signature_sign_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_signature_sign(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_sign_message_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_signature_sign_message_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_sign_message_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_verify_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_signature_verify(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_verify_message_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_signature_verify_message_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_verify_message_final(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_signature_verify_recover_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_signature_verify_recover(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_digest_sign_init(const struct ossl_dispatch_st* opf  )))(void*,const char*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_signature_digest_sign_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_digest_sign_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_digest_sign(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_digest_verify_init(const struct ossl_dispatch_st* opf  )))(void*,const char*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_signature_digest_verify_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_digest_verify_final(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_signature_digest_verify(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long) ;
static void (*(*OSSL_FUNC_signature_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_signature_dupctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_signature_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_signature_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_signature_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_signature_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_signature_get_ctx_md_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_signature_gettable_ctx_md_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_signature_set_ctx_md_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_signature_settable_ctx_md_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static const char** (*(*OSSL_FUNC_signature_query_key_types(const struct ossl_dispatch_st* opf  )))() ;
static void (*(*OSSL_FUNC_skeymgmt_free(const struct ossl_dispatch_st* opf  )))(void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_skeymgmt_imp_settable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_skeymgmt_import(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_skeymgmt_export(const struct ossl_dispatch_st* opf  )))(void*,int,int (*)(const struct ossl_param_st,void*),void*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_skeymgmt_gen_settable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_skeymgmt_generate(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const char* (*(*OSSL_FUNC_skeymgmt_get_key_id(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_asym_cipher_newctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_asym_cipher_encrypt_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_asym_cipher_encrypt(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) ;
static int (*(*OSSL_FUNC_asym_cipher_decrypt_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_asym_cipher_decrypt(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) ;
static void (*(*OSSL_FUNC_asym_cipher_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_asym_cipher_dupctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_asym_cipher_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_asym_cipher_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_asym_cipher_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_asym_cipher_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static void* (*(*OSSL_FUNC_kem_newctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_kem_encapsulate_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_kem_auth_encapsulate_init(const struct ossl_dispatch_st* opf  )))(void*,void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_kem_encapsulate(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned char*,unsigned long*) ;
static int (*(*OSSL_FUNC_kem_decapsulate_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_kem_auth_decapsulate_init(const struct ossl_dispatch_st* opf  )))(void*,void*,void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_kem_decapsulate(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,const unsigned char*,unsigned long) ;
static void (*(*OSSL_FUNC_kem_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_kem_dupctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_kem_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_kem_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static int (*(*OSSL_FUNC_kem_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_kem_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) ;
static void* (*(*OSSL_FUNC_encoder_newctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void (*(*OSSL_FUNC_encoder_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_encoder_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_encoder_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_encoder_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_encoder_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_encoder_does_selection(const struct ossl_dispatch_st* opf  )))(void*,int) ;
static int (*(*OSSL_FUNC_encoder_encode(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_core_bio_st*,const void*,const struct ossl_param_st,int,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) ;
static void* (*(*OSSL_FUNC_encoder_import_object(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_param_st) ;
static void (*(*OSSL_FUNC_encoder_free_object(const struct ossl_dispatch_st* opf  )))(void*) ;
static void* (*(*OSSL_FUNC_decoder_newctx(const struct ossl_dispatch_st* opf  )))(void*) ;
static void (*(*OSSL_FUNC_decoder_freectx(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_decoder_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_decoder_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_decoder_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_decoder_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_decoder_does_selection(const struct ossl_dispatch_st* opf  )))(void*,int) ;
static int (*(*OSSL_FUNC_decoder_decode(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_core_bio_st*,int,int (*)(const struct ossl_param_st,void*),void*,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) ;
static int (*(*OSSL_FUNC_decoder_export_object(const struct ossl_dispatch_st* opf  )))(void*,const void*,unsigned long,int (*)(const struct ossl_param_st,void*),void*) ;
static void* (*(*OSSL_FUNC_store_open(const struct ossl_dispatch_st* opf  )))(void*,const char*) ;
static void* (*(*OSSL_FUNC_store_attach(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_core_bio_st*) ;
static const struct ossl_param_st* (*(*OSSL_FUNC_store_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_store_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) ;
static int (*(*OSSL_FUNC_store_load(const struct ossl_dispatch_st* opf  )))(void*,int (*)(const struct ossl_param_st,void*),void*,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) ;
static int (*(*OSSL_FUNC_store_eof(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_store_close(const struct ossl_dispatch_st* opf  )))(void*) ;
static int (*(*OSSL_FUNC_store_export_object(const struct ossl_dispatch_st* opf  )))(void*,const void*,unsigned long,int (*)(const struct ossl_param_st,void*),void*) ;
static int (*(*OSSL_FUNC_store_delete(const struct ossl_dispatch_st* opf  )))(void*,const char*,const struct ossl_param_st,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) ;
static void* (*(*OSSL_FUNC_store_open_ex(const struct ossl_dispatch_st* opf  )))(void*,const char*,const struct ossl_param_st,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) ;
static struct X509_algor_st* ossl_check_X509_ALGOR_type(struct X509_algor_st* ptr  );
static const struct stack_st* ossl_check_const_X509_ALGOR_sk_type(const struct stack_st_X509_ALGOR* sk  );
static struct stack_st* ossl_check_X509_ALGOR_sk_type(struct stack_st_X509_ALGOR* sk  );
static int (*ossl_check_X509_ALGOR_compfunc_type(int (*cmp)(const struct X509_algor_st**,const struct X509_algor_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_ALGOR_copyfunc_type(struct X509_algor_st* (*cpy)(const struct X509_algor_st*)  ))(const void*) ;
static void (*ossl_check_X509_ALGOR_freefunc_type(void (*fr)(struct X509_algor_st*)  ))(void*) ;
static struct asn1_string_table_st* ossl_check_ASN1_STRING_TABLE_type(struct asn1_string_table_st* ptr  );
static const struct stack_st* ossl_check_const_ASN1_STRING_TABLE_sk_type(const struct stack_st_ASN1_STRING_TABLE* sk  );
static struct stack_st* ossl_check_ASN1_STRING_TABLE_sk_type(struct stack_st_ASN1_STRING_TABLE* sk  );
static int (*ossl_check_ASN1_STRING_TABLE_compfunc_type(int (*cmp)(const struct asn1_string_table_st**,const struct asn1_string_table_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_ASN1_STRING_TABLE_copyfunc_type(struct asn1_string_table_st* (*cpy)(const struct asn1_string_table_st*)  ))(const void*) ;
static void (*ossl_check_ASN1_STRING_TABLE_freefunc_type(void (*fr)(struct asn1_string_table_st*)  ))(void*) ;
static struct asn1_type_st* ossl_check_ASN1_TYPE_type(struct asn1_type_st* ptr  );
static const struct stack_st* ossl_check_const_ASN1_TYPE_sk_type(const struct stack_st_ASN1_TYPE* sk  );
static struct stack_st* ossl_check_ASN1_TYPE_sk_type(struct stack_st_ASN1_TYPE* sk  );
static int (*ossl_check_ASN1_TYPE_compfunc_type(int (*cmp)(const struct asn1_type_st**,const struct asn1_type_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_ASN1_TYPE_copyfunc_type(struct asn1_type_st* (*cpy)(const struct asn1_type_st*)  ))(const void*) ;
static void (*ossl_check_ASN1_TYPE_freefunc_type(void (*fr)(struct asn1_type_st*)  ))(void*) ;
struct stack_st_ASN1_TYPE* d2i_ASN1_SEQUENCE_ANY(struct stack_st_ASN1_TYPE** a  , const unsigned char** in, long len);
int i2d_ASN1_SEQUENCE_ANY(const struct stack_st_ASN1_TYPE* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_SEQUENCE_ANY_it();
struct stack_st_ASN1_TYPE* d2i_ASN1_SET_ANY(struct stack_st_ASN1_TYPE** a  , const unsigned char** in, long len);
int i2d_ASN1_SET_ANY(const struct stack_st_ASN1_TYPE* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_SET_ANY_it();
struct asn1_type_st* ASN1_TYPE_new();
void ASN1_TYPE_free(struct asn1_type_st* a  );
struct asn1_type_st* d2i_ASN1_TYPE(struct asn1_type_st** a  , const unsigned char** in, long len);
int i2d_ASN1_TYPE(const struct asn1_type_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_ANY_it();
int ASN1_TYPE_get(const struct asn1_type_st* a  );
void ASN1_TYPE_set(struct asn1_type_st* a  , int type, void* value);
int ASN1_TYPE_set1(struct asn1_type_st* a  , int type, const void* value);
int ASN1_TYPE_cmp(const struct asn1_type_st* a  , const struct asn1_type_st* b  );
struct asn1_type_st* ASN1_TYPE_pack_sequence(const struct ASN1_ITEM_st* it  , void* s, struct asn1_type_st** t  );
void* ASN1_TYPE_unpack_sequence(const struct ASN1_ITEM_st* it  , const struct asn1_type_st* t  );
static struct asn1_object_st* ossl_check_ASN1_OBJECT_type(struct asn1_object_st* ptr  );
static const struct stack_st* ossl_check_const_ASN1_OBJECT_sk_type(const struct stack_st_ASN1_OBJECT* sk  );
static struct stack_st* ossl_check_ASN1_OBJECT_sk_type(struct stack_st_ASN1_OBJECT* sk  );
static int (*ossl_check_ASN1_OBJECT_compfunc_type(int (*cmp)(const struct asn1_object_st**,const struct asn1_object_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_ASN1_OBJECT_copyfunc_type(struct asn1_object_st* (*cpy)(const struct asn1_object_st*)  ))(const void*) ;
static void (*ossl_check_ASN1_OBJECT_freefunc_type(void (*fr)(struct asn1_object_st*)  ))(void*) ;
struct asn1_object_st* ASN1_OBJECT_new();
void ASN1_OBJECT_free(struct asn1_object_st* a  );
struct asn1_object_st* d2i_ASN1_OBJECT(struct asn1_object_st** a  , const unsigned char** in, long len);
int i2d_ASN1_OBJECT(const struct asn1_object_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_OBJECT_it();
struct asn1_string_st* ASN1_STRING_new();
void ASN1_STRING_free(struct asn1_string_st* a  );
void ASN1_STRING_clear_free(struct asn1_string_st* a  );
int ASN1_STRING_copy(struct asn1_string_st* dst  , const struct asn1_string_st* str  );
struct asn1_string_st* ASN1_STRING_dup(const struct asn1_string_st* a  );
struct asn1_string_st* ASN1_STRING_type_new(int type);
int ASN1_STRING_cmp(const struct asn1_string_st* a  , const struct asn1_string_st* b  );
int ASN1_STRING_set(struct asn1_string_st* str  , const void* data, int len);
void ASN1_STRING_set0(struct asn1_string_st* str  , void* data, int len);
int ASN1_STRING_length(const struct asn1_string_st* x  );
void ASN1_STRING_length_set(struct asn1_string_st* x  , int n);
int ASN1_STRING_type(const struct asn1_string_st* x  );
unsigned char* ASN1_STRING_data(struct asn1_string_st* x  );
const unsigned char* ASN1_STRING_get0_data(const struct asn1_string_st* x  );
struct asn1_string_st* ASN1_BIT_STRING_new();
void ASN1_BIT_STRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_BIT_STRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_BIT_STRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_BIT_STRING_it();
int ASN1_BIT_STRING_set(struct asn1_string_st* a  , unsigned char* d, int length);
int ASN1_BIT_STRING_set_bit(struct asn1_string_st* a  , int n, int value);
int ASN1_BIT_STRING_get_bit(const struct asn1_string_st* a  , int n);
int ASN1_BIT_STRING_check(const struct asn1_string_st* a  , const unsigned char* flags, int flags_len);
int ASN1_BIT_STRING_name_print(struct bio_st* out  , struct asn1_string_st* bs  , struct BIT_STRING_BITNAME_st* tbl  , int indent);
int ASN1_BIT_STRING_num_asc(const char* name, struct BIT_STRING_BITNAME_st* tbl  );
int ASN1_BIT_STRING_set_asc(struct asn1_string_st* bs  , const char* name, int value, struct BIT_STRING_BITNAME_st* tbl  );
static struct asn1_string_st* ossl_check_ASN1_INTEGER_type(struct asn1_string_st* ptr  );
static const struct stack_st* ossl_check_const_ASN1_INTEGER_sk_type(const struct stack_st_ASN1_INTEGER* sk  );
static struct stack_st* ossl_check_ASN1_INTEGER_sk_type(struct stack_st_ASN1_INTEGER* sk  );
static int (*ossl_check_ASN1_INTEGER_compfunc_type(int (*cmp)(const struct asn1_string_st**,const struct asn1_string_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_ASN1_INTEGER_copyfunc_type(struct asn1_string_st* (*cpy)(const struct asn1_string_st*)  ))(const void*) ;
static void (*ossl_check_ASN1_INTEGER_freefunc_type(void (*fr)(struct asn1_string_st*)  ))(void*) ;
struct asn1_string_st* ASN1_INTEGER_new();
void ASN1_INTEGER_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_INTEGER(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_INTEGER(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_INTEGER_it();
struct asn1_string_st* d2i_ASN1_UINTEGER(struct asn1_string_st** a  , const unsigned char** pp, long length);
struct asn1_string_st* ASN1_INTEGER_dup(const struct asn1_string_st* a  );
int ASN1_INTEGER_cmp(const struct asn1_string_st* x  , const struct asn1_string_st* y  );
struct asn1_string_st* ASN1_ENUMERATED_new();
void ASN1_ENUMERATED_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_ENUMERATED(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_ENUMERATED(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_ENUMERATED_it();
int ASN1_UTCTIME_check(const struct asn1_string_st* a  );
struct asn1_string_st* ASN1_UTCTIME_set(struct asn1_string_st* s  , long  int t  );
struct asn1_string_st* ASN1_UTCTIME_adj(struct asn1_string_st* s  , long  int t  , int offset_day, long offset_sec);
int ASN1_UTCTIME_set_string(struct asn1_string_st* s  , const char* str);
int ASN1_UTCTIME_cmp_time_t(const struct asn1_string_st* s  , long  int t  );
int ASN1_GENERALIZEDTIME_check(const struct asn1_string_st* a  );
struct asn1_string_st* ASN1_GENERALIZEDTIME_set(struct asn1_string_st* s  , long  int t  );
struct asn1_string_st* ASN1_GENERALIZEDTIME_adj(struct asn1_string_st* s  , long  int t  , int offset_day, long offset_sec);
int ASN1_GENERALIZEDTIME_set_string(struct asn1_string_st* s  , const char* str);
int ASN1_TIME_diff(int* pday, int* psec, const struct asn1_string_st* from  , const struct asn1_string_st* to  );
struct asn1_string_st* ASN1_OCTET_STRING_new();
void ASN1_OCTET_STRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_OCTET_STRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_OCTET_STRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_OCTET_STRING_it();
struct asn1_string_st* ASN1_OCTET_STRING_dup(const struct asn1_string_st* a  );
int ASN1_OCTET_STRING_cmp(const struct asn1_string_st* a  , const struct asn1_string_st* b  );
int ASN1_OCTET_STRING_set(struct asn1_string_st* str  , const unsigned char* data, int len);
static struct asn1_string_st* ossl_check_ASN1_UTF8STRING_type(struct asn1_string_st* ptr  );
static const struct stack_st* ossl_check_const_ASN1_UTF8STRING_sk_type(const struct stack_st_ASN1_UTF8STRING* sk  );
static struct stack_st* ossl_check_ASN1_UTF8STRING_sk_type(struct stack_st_ASN1_UTF8STRING* sk  );
static int (*ossl_check_ASN1_UTF8STRING_compfunc_type(int (*cmp)(const struct asn1_string_st**,const struct asn1_string_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_ASN1_UTF8STRING_copyfunc_type(struct asn1_string_st* (*cpy)(const struct asn1_string_st*)  ))(const void*) ;
static void (*ossl_check_ASN1_UTF8STRING_freefunc_type(void (*fr)(struct asn1_string_st*)  ))(void*) ;
struct asn1_string_st* ASN1_VISIBLESTRING_new();
void ASN1_VISIBLESTRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_VISIBLESTRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_VISIBLESTRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_VISIBLESTRING_it();
struct asn1_string_st* ASN1_UNIVERSALSTRING_new();
void ASN1_UNIVERSALSTRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_UNIVERSALSTRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_UNIVERSALSTRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_UNIVERSALSTRING_it();
struct asn1_string_st* ASN1_UTF8STRING_new();
void ASN1_UTF8STRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_UTF8STRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_UTF8STRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_UTF8STRING_it();
int* ASN1_NULL_new();
void ASN1_NULL_free(int* a  );
int* d2i_ASN1_NULL(int** a  , const unsigned char** in, long len);
int i2d_ASN1_NULL(const int* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_NULL_it();
struct asn1_string_st* ASN1_BMPSTRING_new();
void ASN1_BMPSTRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_BMPSTRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_BMPSTRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_BMPSTRING_it();
int UTF8_getc(const unsigned char* str, int len, unsigned long  int* val);
int UTF8_putc(unsigned char* str, int len, unsigned long  int value);
static struct asn1_string_st* ossl_check_ASN1_GENERALSTRING_type(struct asn1_string_st* ptr  );
static const struct stack_st* ossl_check_const_ASN1_GENERALSTRING_sk_type(const struct stack_st_ASN1_GENERALSTRING* sk  );
static struct stack_st* ossl_check_ASN1_GENERALSTRING_sk_type(struct stack_st_ASN1_GENERALSTRING* sk  );
static int (*ossl_check_ASN1_GENERALSTRING_compfunc_type(int (*cmp)(const struct asn1_string_st**,const struct asn1_string_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_ASN1_GENERALSTRING_copyfunc_type(struct asn1_string_st* (*cpy)(const struct asn1_string_st*)  ))(const void*) ;
static void (*ossl_check_ASN1_GENERALSTRING_freefunc_type(void (*fr)(struct asn1_string_st*)  ))(void*) ;
struct asn1_string_st* ASN1_PRINTABLE_new();
void ASN1_PRINTABLE_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_PRINTABLE(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_PRINTABLE(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_PRINTABLE_it();
struct asn1_string_st* DIRECTORYSTRING_new();
void DIRECTORYSTRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_DIRECTORYSTRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_DIRECTORYSTRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* DIRECTORYSTRING_it();
struct asn1_string_st* DISPLAYTEXT_new();
void DISPLAYTEXT_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_DISPLAYTEXT(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_DISPLAYTEXT(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* DISPLAYTEXT_it();
struct asn1_string_st* ASN1_PRINTABLESTRING_new();
void ASN1_PRINTABLESTRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_PRINTABLESTRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_PRINTABLESTRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_PRINTABLESTRING_it();
struct asn1_string_st* ASN1_T61STRING_new();
void ASN1_T61STRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_T61STRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_T61STRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_T61STRING_it();
struct asn1_string_st* ASN1_IA5STRING_new();
void ASN1_IA5STRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_IA5STRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_IA5STRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_IA5STRING_it();
struct asn1_string_st* ASN1_GENERALSTRING_new();
void ASN1_GENERALSTRING_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_GENERALSTRING(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_GENERALSTRING(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_GENERALSTRING_it();
struct asn1_string_st* ASN1_UTCTIME_new();
void ASN1_UTCTIME_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_UTCTIME(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_UTCTIME(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_UTCTIME_it();
struct asn1_string_st* ASN1_GENERALIZEDTIME_new();
void ASN1_GENERALIZEDTIME_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_GENERALIZEDTIME(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_GENERALIZEDTIME(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_GENERALIZEDTIME_it();
struct asn1_string_st* ASN1_TIME_new();
void ASN1_TIME_free(struct asn1_string_st* a  );
struct asn1_string_st* d2i_ASN1_TIME(struct asn1_string_st** a  , const unsigned char** in, long len);
int i2d_ASN1_TIME(const struct asn1_string_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* ASN1_TIME_it();
struct asn1_string_st* ASN1_TIME_dup(const struct asn1_string_st* a  );
struct asn1_string_st* ASN1_UTCTIME_dup(const struct asn1_string_st* a  );
struct asn1_string_st* ASN1_GENERALIZEDTIME_dup(const struct asn1_string_st* a  );
const struct ASN1_ITEM_st* ASN1_OCTET_STRING_NDEF_it();
struct asn1_string_st* ASN1_TIME_set(struct asn1_string_st* s  , long  int t  );
struct asn1_string_st* ASN1_TIME_adj(struct asn1_string_st* s  , long  int t  , int offset_day, long offset_sec);
int ASN1_TIME_check(const struct asn1_string_st* t  );
struct asn1_string_st* ASN1_TIME_to_generalizedtime(const struct asn1_string_st* t  , struct asn1_string_st** out  );
int ASN1_TIME_set_string(struct asn1_string_st* s  , const char* str);
int ASN1_TIME_set_string_X509(struct asn1_string_st* s  , const char* str);
int ASN1_TIME_to_tm(const struct asn1_string_st* s  , struct tm* tm  );
int ASN1_TIME_normalize(struct asn1_string_st* s  );
int ASN1_TIME_cmp_time_t(const struct asn1_string_st* s  , long  int t  );
int ASN1_TIME_compare(const struct asn1_string_st* a  , const struct asn1_string_st* b  );
int i2a_ASN1_INTEGER(struct bio_st* bp  , const struct asn1_string_st* a  );
int a2i_ASN1_INTEGER(struct bio_st* bp  , struct asn1_string_st* bs  , char* buf, int size);
int i2a_ASN1_ENUMERATED(struct bio_st* bp  , const struct asn1_string_st* a  );
int a2i_ASN1_ENUMERATED(struct bio_st* bp  , struct asn1_string_st* bs  , char* buf, int size);
int i2a_ASN1_OBJECT(struct bio_st* bp  , const struct asn1_object_st* a  );
int a2i_ASN1_STRING(struct bio_st* bp  , struct asn1_string_st* bs  , char* buf, int size);
int i2a_ASN1_STRING(struct bio_st* bp  , const struct asn1_string_st* a  , int type);
int i2t_ASN1_OBJECT(char* buf, int buf_len, const struct asn1_object_st* a  );
int a2d_ASN1_OBJECT(unsigned char* out, int olen, const char* buf, int num);
struct asn1_object_st* ASN1_OBJECT_create(int nid, unsigned char* data, int len, const char* sn, const char* ln);
int ASN1_INTEGER_get_int64(long  int* pr  , const struct asn1_string_st* a  );
int ASN1_INTEGER_set_int64(struct asn1_string_st* a  , long  int r  );
int ASN1_INTEGER_get_uint64(unsigned long  int* pr  , const struct asn1_string_st* a  );
int ASN1_INTEGER_set_uint64(struct asn1_string_st* a  , unsigned long  int r  );
int ASN1_INTEGER_set(struct asn1_string_st* a  , long v);
long ASN1_INTEGER_get(const struct asn1_string_st* a  );
struct asn1_string_st* BN_to_ASN1_INTEGER(const struct bignum_st* bn  , struct asn1_string_st* ai  );
struct bignum_st* ASN1_INTEGER_to_BN(const struct asn1_string_st* ai  , struct bignum_st* bn  );
int ASN1_ENUMERATED_get_int64(long  int* pr  , const struct asn1_string_st* a  );
int ASN1_ENUMERATED_set_int64(struct asn1_string_st* a  , long  int r  );
int ASN1_ENUMERATED_set(struct asn1_string_st* a  , long v);
long ASN1_ENUMERATED_get(const struct asn1_string_st* a  );
struct asn1_string_st* BN_to_ASN1_ENUMERATED(const struct bignum_st* bn  , struct asn1_string_st* ai  );
struct bignum_st* ASN1_ENUMERATED_to_BN(const struct asn1_string_st* ai  , struct bignum_st* bn  );
int ASN1_PRINTABLE_type(const unsigned char* s, int max);
unsigned long  int ASN1_tag2bit(int tag);
int ASN1_get_object(const unsigned char** pp, long* plength, int* ptag, int* pclass, long omax);
int ASN1_check_infinite_end(unsigned char** p, long len);
int ASN1_const_check_infinite_end(const unsigned char** p, long len);
void ASN1_put_object(unsigned char** pp, int constructed, int length, int tag, int xclass);
int ASN1_put_eoc(unsigned char** pp);
int ASN1_object_size(int constructed, int length, int tag);
void* ASN1_dup(int (*(*i2d))(const void*,unsigned char**)  , void* (*(*d2i))(void**,const unsigned char**,long)  , const void* x);
void* ASN1_item_dup(const struct ASN1_ITEM_st* it  , const void* x);
int ASN1_item_sign_ex(const struct ASN1_ITEM_st* it  , struct X509_algor_st* algor1  , struct X509_algor_st* algor2  , struct asn1_string_st* signature  , const void* data, const struct asn1_string_st* id  , struct evp_pkey_st* pkey  , const struct evp_md_st* md  , struct ossl_lib_ctx_st* libctx  , const char* propq);
int ASN1_item_verify_ex(const struct ASN1_ITEM_st* it  , const struct X509_algor_st* alg  , const struct asn1_string_st* signature  , const void* data, const struct asn1_string_st* id  , struct evp_pkey_st* pkey  , struct ossl_lib_ctx_st* libctx  , const char* propq);
void* ASN1_d2i_fp(void* (*xnew)(), void* (*(*d2i))(void**,const unsigned char**,long)  , struct _IO_FILE* in  , void** x);
void* ASN1_item_d2i_fp_ex(const struct ASN1_ITEM_st* it  , struct _IO_FILE* in  , void* x, struct ossl_lib_ctx_st* libctx  , const char* propq);
void* ASN1_item_d2i_fp(const struct ASN1_ITEM_st* it  , struct _IO_FILE* in  , void* x);
int ASN1_i2d_fp(int (*(*i2d))(const void*,unsigned char**)  , struct _IO_FILE* out  , const void* x);
int ASN1_item_i2d_fp(const struct ASN1_ITEM_st* it  , struct _IO_FILE* out  , const void* x);
int ASN1_STRING_print_ex_fp(struct _IO_FILE* fp  , const struct asn1_string_st* str  , unsigned long  int flags);
int ASN1_STRING_to_UTF8(unsigned char** out, const struct asn1_string_st* in  );
void* ASN1_d2i_bio(void* (*xnew)(), void* (*(*d2i))(void**,const unsigned char**,long)  , struct bio_st* in  , void** x);
void* ASN1_item_d2i_bio_ex(const struct ASN1_ITEM_st* it  , struct bio_st* in  , void* pval, struct ossl_lib_ctx_st* libctx  , const char* propq);
void* ASN1_item_d2i_bio(const struct ASN1_ITEM_st* it  , struct bio_st* in  , void* pval);
int ASN1_i2d_bio(int (*(*i2d))(const void*,unsigned char**)  , struct bio_st* out  , const void* x);
int ASN1_item_i2d_bio(const struct ASN1_ITEM_st* it  , struct bio_st* out  , const void* x);
struct bio_st* ASN1_item_i2d_mem_bio(const struct ASN1_ITEM_st* it  , const struct ASN1_VALUE_st* val  );
int ASN1_UTCTIME_print(struct bio_st* fp  , const struct asn1_string_st* a  );
int ASN1_GENERALIZEDTIME_print(struct bio_st* fp  , const struct asn1_string_st* a  );
int ASN1_TIME_print(struct bio_st* bp  , const struct asn1_string_st* tm  );
int ASN1_TIME_print_ex(struct bio_st* bp  , const struct asn1_string_st* tm  , unsigned long  int flags);
int ASN1_STRING_print(struct bio_st* bp  , const struct asn1_string_st* v  );
int ASN1_STRING_print_ex(struct bio_st* out  , const struct asn1_string_st* str  , unsigned long  int flags);
int ASN1_buf_print(struct bio_st* bp  , const unsigned char* buf, unsigned long buflen  , int off);
int ASN1_bn_print(struct bio_st* bp  , const char* number, const struct bignum_st* num  , unsigned char* buf, int off);
int ASN1_parse(struct bio_st* bp  , const unsigned char* pp, long len, int indent);
int ASN1_parse_dump(struct bio_st* bp  , const unsigned char* pp, long len, int indent, int dump);
const char* ASN1_tag2str(int tag);
int ASN1_UNIVERSALSTRING_to_string(struct asn1_string_st* s  );
int ASN1_TYPE_set_octetstring(struct asn1_type_st* a  , unsigned char* data, int len);
int ASN1_TYPE_get_octetstring(const struct asn1_type_st* a  , unsigned char* data, int max_len);
int ASN1_TYPE_set_int_octetstring(struct asn1_type_st* a  , long num, unsigned char* data, int len);
int ASN1_TYPE_get_int_octetstring(const struct asn1_type_st* a  , long* num, unsigned char* data, int max_len);
void* ASN1_item_unpack(const struct asn1_string_st* oct  , const struct ASN1_ITEM_st* it  );
void* ASN1_item_unpack_ex(const struct asn1_string_st* oct  , const struct ASN1_ITEM_st* it  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct asn1_string_st* ASN1_item_pack(void* obj, const struct ASN1_ITEM_st* it  , struct asn1_string_st** oct  );
void ASN1_STRING_set_default_mask(unsigned long  int mask);
int ASN1_STRING_set_default_mask_asc(const char* p);
unsigned long  int ASN1_STRING_get_default_mask();
int ASN1_mbstring_copy(struct asn1_string_st** out  , const unsigned char* in, int len, int inform, unsigned long  int mask);
int ASN1_mbstring_ncopy(struct asn1_string_st** out  , const unsigned char* in, int len, int inform, unsigned long  int mask, long minsize, long maxsize);
struct asn1_string_st* ASN1_STRING_set_by_NID(struct asn1_string_st** out  , const unsigned char* in, int inlen, int inform, int nid);
struct asn1_string_table_st* ASN1_STRING_TABLE_get(int nid);
int ASN1_STRING_TABLE_add(int , long , long , unsigned long  int , unsigned long  int );
void ASN1_STRING_TABLE_cleanup();
struct ASN1_VALUE_st* ASN1_item_new(const struct ASN1_ITEM_st* it  );
struct ASN1_VALUE_st* ASN1_item_new_ex(const struct ASN1_ITEM_st* it  , struct ossl_lib_ctx_st* libctx  , const char* propq);
void ASN1_item_free(struct ASN1_VALUE_st* val  , const struct ASN1_ITEM_st* it  );
struct ASN1_VALUE_st* ASN1_item_d2i_ex(struct ASN1_VALUE_st** val  , const unsigned char** in, long len, const struct ASN1_ITEM_st* it  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct ASN1_VALUE_st* ASN1_item_d2i(struct ASN1_VALUE_st** val  , const unsigned char** in, long len, const struct ASN1_ITEM_st* it  );
int ASN1_item_i2d(const struct ASN1_VALUE_st* val  , unsigned char** out, const struct ASN1_ITEM_st* it  );
int ASN1_item_ndef_i2d(const struct ASN1_VALUE_st* val  , unsigned char** out, const struct ASN1_ITEM_st* it  );
void ASN1_add_oid_module();
void ASN1_add_stable_module();
struct asn1_type_st* ASN1_generate_nconf(const char* str, struct conf_st* nconf  );
struct asn1_type_st* ASN1_generate_v3(const char* str, struct v3_ext_ctx* cnf  );
int ASN1_str2mask(const char* str, unsigned long  int* pmask);
int ASN1_item_print(struct bio_st* out  , const struct ASN1_VALUE_st* ifld  , int indent, const struct ASN1_ITEM_st* it  , const struct asn1_pctx_st* pctx  );
struct asn1_pctx_st* ASN1_PCTX_new();
void ASN1_PCTX_free(struct asn1_pctx_st* p  );
unsigned long  int ASN1_PCTX_get_flags(const struct asn1_pctx_st* p  );
void ASN1_PCTX_set_flags(struct asn1_pctx_st* p  , unsigned long  int flags);
unsigned long  int ASN1_PCTX_get_nm_flags(const struct asn1_pctx_st* p  );
void ASN1_PCTX_set_nm_flags(struct asn1_pctx_st* p  , unsigned long  int flags);
unsigned long  int ASN1_PCTX_get_cert_flags(const struct asn1_pctx_st* p  );
void ASN1_PCTX_set_cert_flags(struct asn1_pctx_st* p  , unsigned long  int flags);
unsigned long  int ASN1_PCTX_get_oid_flags(const struct asn1_pctx_st* p  );
void ASN1_PCTX_set_oid_flags(struct asn1_pctx_st* p  , unsigned long  int flags);
unsigned long  int ASN1_PCTX_get_str_flags(const struct asn1_pctx_st* p  );
void ASN1_PCTX_set_str_flags(struct asn1_pctx_st* p  , unsigned long  int flags);
struct asn1_sctx_st* ASN1_SCTX_new(int (*scan_cb)(struct asn1_sctx_st*));
void ASN1_SCTX_free(struct asn1_sctx_st* p  );
const struct ASN1_ITEM_st* ASN1_SCTX_get_item(struct asn1_sctx_st* p  );
const struct ASN1_TEMPLATE_st* ASN1_SCTX_get_template(struct asn1_sctx_st* p  );
unsigned long  int ASN1_SCTX_get_flags(struct asn1_sctx_st* p  );
void ASN1_SCTX_set_app_data(struct asn1_sctx_st* p  , void* data);
void* ASN1_SCTX_get_app_data(struct asn1_sctx_st* p  );
const struct bio_method_st* BIO_f_asn1();
struct bio_st* BIO_new_NDEF(struct bio_st* out  , struct ASN1_VALUE_st* val  , const struct ASN1_ITEM_st* it  );
int i2d_ASN1_bio_stream(struct bio_st* out  , struct ASN1_VALUE_st* val  , struct bio_st* in  , int flags, const struct ASN1_ITEM_st* it  );
int PEM_write_bio_ASN1_stream(struct bio_st* out  , struct ASN1_VALUE_st* val  , struct bio_st* in  , int flags, const char* hdr, const struct ASN1_ITEM_st* it  );
int SMIME_write_ASN1(struct bio_st* bio  , struct ASN1_VALUE_st* val  , struct bio_st* data  , int flags, int ctype_nid, int econt_nid, struct stack_st_X509_ALGOR* mdalgs  , const struct ASN1_ITEM_st* it  );
int SMIME_write_ASN1_ex(struct bio_st* bio  , struct ASN1_VALUE_st* val  , struct bio_st* data  , int flags, int ctype_nid, int econt_nid, struct stack_st_X509_ALGOR* mdalgs  , const struct ASN1_ITEM_st* it  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct ASN1_VALUE_st* SMIME_read_ASN1(struct bio_st* bio  , struct bio_st** bcont  , const struct ASN1_ITEM_st* it  );
struct ASN1_VALUE_st* SMIME_read_ASN1_ex(struct bio_st* bio  , int flags, struct bio_st** bcont  , const struct ASN1_ITEM_st* it  , struct ASN1_VALUE_st** x  , struct ossl_lib_ctx_st* libctx  , const char* propq);
int SMIME_crlf_copy(struct bio_st* in  , struct bio_st* out  , int flags);
int SMIME_text(struct bio_st* in  , struct bio_st* out  );
const struct ASN1_ITEM_st* ASN1_ITEM_lookup(const char* name);
const struct ASN1_ITEM_st* ASN1_ITEM_get(unsigned long i  );
int OBJ_NAME_init();
int OBJ_NAME_new_index(unsigned long  int (*hash_func)(const char*), int (*cmp_func)(const char*,const char*), void (*free_func)(const char*,int,const char*));
const char* OBJ_NAME_get(const char* name, int type);
int OBJ_NAME_add(const char* name, int type, const char* data);
int OBJ_NAME_remove(const char* name, int type);
void OBJ_NAME_cleanup(int type);
void OBJ_NAME_do_all(int type, void (*fn)(const struct obj_name_st*,void*), void* arg);
void OBJ_NAME_do_all_sorted(int type, void (*fn)(const struct obj_name_st*,void*), void* arg);
struct asn1_object_st* OBJ_dup(const struct asn1_object_st* a  );
struct asn1_object_st* OBJ_nid2obj(int n);
const char* OBJ_nid2ln(int n);
const char* OBJ_nid2sn(int n);
int OBJ_obj2nid(const struct asn1_object_st* o  );
struct asn1_object_st* OBJ_txt2obj(const char* s, int no_name);
int OBJ_obj2txt(char* buf, int buf_len, const struct asn1_object_st* a  , int no_name);
int OBJ_txt2nid(const char* s);
int OBJ_ln2nid(const char* s);
int OBJ_sn2nid(const char* s);
int OBJ_cmp(const struct asn1_object_st* a  , const struct asn1_object_st* b  );
const void* OBJ_bsearch_(const void* key, const void* base, int num, int size, int (*cmp)(const void*,const void*));
const void* OBJ_bsearch_ex_(const void* key, const void* base, int num, int size, int (*cmp)(const void*,const void*), int flags);
int OBJ_new_nid(int num);
int OBJ_add_object(const struct asn1_object_st* obj  );
int OBJ_create(const char* oid, const char* sn, const char* ln);
int OBJ_create_objects(struct bio_st* in  );
unsigned long OBJ_length(const struct asn1_object_st* obj  );
const unsigned char* OBJ_get0_data(const struct asn1_object_st* obj  );
int OBJ_find_sigid_algs(int signid, int* pdig_nid, int* ppkey_nid);
int OBJ_find_sigid_by_algs(int* psignid, int dig_nid, int pkey_nid);
int OBJ_add_sigid(int signid, int dig_id, int pkey_id);
void OBJ_sigid_free();
int EVP_set_default_properties(struct ossl_lib_ctx_st* libctx  , const char* propq);
char* EVP_get1_default_properties(struct ossl_lib_ctx_st* libctx  );
int EVP_default_properties_is_fips_enabled(struct ossl_lib_ctx_st* libctx  );
int EVP_default_properties_enable_fips(struct ossl_lib_ctx_st* libctx  , int enable);
struct evp_md_st* EVP_MD_meth_new(int md_type, int pkey_type);
struct evp_md_st* EVP_MD_meth_dup(const struct evp_md_st* md  );
void EVP_MD_meth_free(struct evp_md_st* md  );
int EVP_MD_meth_set_input_blocksize(struct evp_md_st* md  , int blocksize);
int EVP_MD_meth_set_result_size(struct evp_md_st* md  , int resultsize);
int EVP_MD_meth_set_app_datasize(struct evp_md_st* md  , int datasize);
int EVP_MD_meth_set_flags(struct evp_md_st* md  , unsigned long  int flags);
int EVP_MD_meth_set_init(struct evp_md_st* md  , int (*init)(struct evp_md_ctx_st*));
int EVP_MD_meth_set_update(struct evp_md_st* md  , int (*update)(struct evp_md_ctx_st*,const void*,unsigned long));
int EVP_MD_meth_set_final(struct evp_md_st* md  , int (*final)(struct evp_md_ctx_st*,unsigned char*));
int EVP_MD_meth_set_copy(struct evp_md_st* md  , int (*copy)(struct evp_md_ctx_st*,const struct evp_md_ctx_st*));
int EVP_MD_meth_set_cleanup(struct evp_md_st* md  , int (*cleanup)(struct evp_md_ctx_st*));
int EVP_MD_meth_set_ctrl(struct evp_md_st* md  , int (*ctrl)(struct evp_md_ctx_st*,int,int,void*));
int EVP_MD_meth_get_input_blocksize(const struct evp_md_st* md  );
int EVP_MD_meth_get_result_size(const struct evp_md_st* md  );
int EVP_MD_meth_get_app_datasize(const struct evp_md_st* md  );
unsigned long  int EVP_MD_meth_get_flags(const struct evp_md_st* md  );
int (*EVP_MD_meth_get_init(const struct evp_md_st* _function_pointer_result_var_name_a14  ))(struct evp_md_ctx_st*);
int (*EVP_MD_meth_get_update(const struct evp_md_st* _function_pointer_result_var_name_a15  ))(struct evp_md_ctx_st*,const void*,unsigned long);
int (*EVP_MD_meth_get_final(const struct evp_md_st* _function_pointer_result_var_name_a16  ))(struct evp_md_ctx_st*,unsigned char*);
int (*EVP_MD_meth_get_copy(const struct evp_md_st* _function_pointer_result_var_name_a17  ))(struct evp_md_ctx_st*,const struct evp_md_ctx_st*);
int (*EVP_MD_meth_get_cleanup(const struct evp_md_st* _function_pointer_result_var_name_a18  ))(struct evp_md_ctx_st*);
int (*EVP_MD_meth_get_ctrl(const struct evp_md_st* _function_pointer_result_var_name_a19  ))(struct evp_md_ctx_st*,int,int,void*);
struct evp_cipher_st* EVP_CIPHER_meth_new(int cipher_type, int block_size, int key_len);
struct evp_cipher_st* EVP_CIPHER_meth_dup(const struct evp_cipher_st* cipher  );
void EVP_CIPHER_meth_free(struct evp_cipher_st* cipher  );
int EVP_CIPHER_meth_set_iv_length(struct evp_cipher_st* cipher  , int iv_len);
int EVP_CIPHER_meth_set_flags(struct evp_cipher_st* cipher  , unsigned long  int flags);
int EVP_CIPHER_meth_set_impl_ctx_size(struct evp_cipher_st* cipher  , int ctx_size);
int EVP_CIPHER_meth_set_init(struct evp_cipher_st* cipher  , int (*init)(struct evp_cipher_ctx_st*,const unsigned char*,const unsigned char*,int));
int EVP_CIPHER_meth_set_do_cipher(struct evp_cipher_st* cipher  , int (*do_cipher)(struct evp_cipher_ctx_st*,unsigned char*,const unsigned char*,unsigned long));
int EVP_CIPHER_meth_set_cleanup(struct evp_cipher_st* cipher  , int (*cleanup)(struct evp_cipher_ctx_st*));
int EVP_CIPHER_meth_set_set_asn1_params(struct evp_cipher_st* cipher  , int (*set_asn1_parameters)(struct evp_cipher_ctx_st*,struct asn1_type_st*));
int EVP_CIPHER_meth_set_get_asn1_params(struct evp_cipher_st* cipher  , int (*get_asn1_parameters)(struct evp_cipher_ctx_st*,struct asn1_type_st*));
int EVP_CIPHER_meth_set_ctrl(struct evp_cipher_st* cipher  , int (*ctrl)(struct evp_cipher_ctx_st*,int,int,void*));
int (*EVP_CIPHER_meth_get_init(const struct evp_cipher_st* _function_pointer_result_var_name_a20  ))(struct evp_cipher_ctx_st*,const unsigned char*,const unsigned char*,int);
int (*EVP_CIPHER_meth_get_do_cipher(const struct evp_cipher_st* _function_pointer_result_var_name_a21  ))(struct evp_cipher_ctx_st*,unsigned char*,const unsigned char*,unsigned long);
int (*EVP_CIPHER_meth_get_cleanup(const struct evp_cipher_st* _function_pointer_result_var_name_a22  ))(struct evp_cipher_ctx_st*);
int (*EVP_CIPHER_meth_get_set_asn1_params(const struct evp_cipher_st* _function_pointer_result_var_name_a23  ))(struct evp_cipher_ctx_st*,struct asn1_type_st*);
int (*EVP_CIPHER_meth_get_get_asn1_params(const struct evp_cipher_st* _function_pointer_result_var_name_a24  ))(struct evp_cipher_ctx_st*,struct asn1_type_st*);
int (*EVP_CIPHER_meth_get_ctrl(const struct evp_cipher_st* _function_pointer_result_var_name_a25  ))(struct evp_cipher_ctx_st*,int,int,void*);
int EVP_MD_get_type(const struct evp_md_st* md  );
const char* EVP_MD_get0_name(const struct evp_md_st* md  );
const char* EVP_MD_get0_description(const struct evp_md_st* md  );
int EVP_MD_is_a(const struct evp_md_st* md  , const char* name);
int EVP_MD_names_do_all(const struct evp_md_st* md  , void (*fn)(const char*,void*), void* data);
const struct ossl_provider_st* EVP_MD_get0_provider(const struct evp_md_st* md  );
int EVP_MD_get_pkey_type(const struct evp_md_st* md  );
int EVP_MD_get_size(const struct evp_md_st* md  );
int EVP_MD_get_block_size(const struct evp_md_st* md  );
unsigned long  int EVP_MD_get_flags(const struct evp_md_st* md  );
int EVP_MD_xof(const struct evp_md_st* md  );
const struct evp_md_st* EVP_MD_CTX_get0_md(const struct evp_md_ctx_st* ctx  );
struct evp_md_st* EVP_MD_CTX_get1_md(struct evp_md_ctx_st* ctx  );
const struct evp_md_st* EVP_MD_CTX_md(const struct evp_md_ctx_st* ctx  );
int (*EVP_MD_CTX_update_fn(struct evp_md_ctx_st* _function_pointer_result_var_name_a26  ))(struct evp_md_ctx_st*,const void*,unsigned long);
void EVP_MD_CTX_set_update_fn(struct evp_md_ctx_st* ctx  , int (*update)(struct evp_md_ctx_st*,const void*,unsigned long));
int EVP_MD_CTX_get_size_ex(const struct evp_md_ctx_st* ctx  );
struct evp_pkey_ctx_st* EVP_MD_CTX_get_pkey_ctx(const struct evp_md_ctx_st* ctx  );
void EVP_MD_CTX_set_pkey_ctx(struct evp_md_ctx_st* ctx  , struct evp_pkey_ctx_st* pctx  );
void* EVP_MD_CTX_get0_md_data(const struct evp_md_ctx_st* ctx  );
int EVP_CIPHER_get_nid(const struct evp_cipher_st* cipher  );
const char* EVP_CIPHER_get0_name(const struct evp_cipher_st* cipher  );
const char* EVP_CIPHER_get0_description(const struct evp_cipher_st* cipher  );
int EVP_CIPHER_is_a(const struct evp_cipher_st* cipher  , const char* name);
int EVP_CIPHER_names_do_all(const struct evp_cipher_st* cipher  , void (*fn)(const char*,void*), void* data);
const struct ossl_provider_st* EVP_CIPHER_get0_provider(const struct evp_cipher_st* cipher  );
int EVP_CIPHER_get_block_size(const struct evp_cipher_st* cipher  );
int EVP_CIPHER_impl_ctx_size(const struct evp_cipher_st* cipher  );
int EVP_CIPHER_get_key_length(const struct evp_cipher_st* cipher  );
int EVP_CIPHER_get_iv_length(const struct evp_cipher_st* cipher  );
unsigned long  int EVP_CIPHER_get_flags(const struct evp_cipher_st* cipher  );
int EVP_CIPHER_get_mode(const struct evp_cipher_st* cipher  );
int EVP_CIPHER_get_type(const struct evp_cipher_st* cipher  );
struct evp_cipher_st* EVP_CIPHER_fetch(struct ossl_lib_ctx_st* ctx  , const char* algorithm, const char* properties);
int EVP_CIPHER_can_pipeline(const struct evp_cipher_st* cipher  , int enc);
int EVP_CIPHER_up_ref(struct evp_cipher_st* cipher  );
void EVP_CIPHER_free(struct evp_cipher_st* cipher  );
const struct evp_cipher_st* EVP_CIPHER_CTX_get0_cipher(const struct evp_cipher_ctx_st* ctx  );
struct evp_cipher_st* EVP_CIPHER_CTX_get1_cipher(struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_is_encrypting(const struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_get_nid(const struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_get_block_size(const struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_get_key_length(const struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_get_iv_length(const struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_get_tag_length(const struct evp_cipher_ctx_st* ctx  );
const struct evp_cipher_st* EVP_CIPHER_CTX_cipher(const struct evp_cipher_ctx_st* ctx  );
const unsigned char* EVP_CIPHER_CTX_iv(const struct evp_cipher_ctx_st* ctx  );
const unsigned char* EVP_CIPHER_CTX_original_iv(const struct evp_cipher_ctx_st* ctx  );
unsigned char* EVP_CIPHER_CTX_iv_noconst(struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_get_updated_iv(struct evp_cipher_ctx_st* ctx  , void* buf, unsigned long len  );
int EVP_CIPHER_CTX_get_original_iv(struct evp_cipher_ctx_st* ctx  , void* buf, unsigned long len  );
unsigned char* EVP_CIPHER_CTX_buf_noconst(struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_get_num(const struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_set_num(struct evp_cipher_ctx_st* ctx  , int num);
struct evp_cipher_ctx_st* EVP_CIPHER_CTX_dup(const struct evp_cipher_ctx_st* in  );
int EVP_CIPHER_CTX_copy(struct evp_cipher_ctx_st* out  , const struct evp_cipher_ctx_st* in  );
void* EVP_CIPHER_CTX_get_app_data(const struct evp_cipher_ctx_st* ctx  );
void EVP_CIPHER_CTX_set_app_data(struct evp_cipher_ctx_st* ctx  , void* data);
void* EVP_CIPHER_CTX_get_cipher_data(const struct evp_cipher_ctx_st* ctx  );
void* EVP_CIPHER_CTX_set_cipher_data(struct evp_cipher_ctx_st* ctx  , void* cipher_data);
int EVP_Cipher(struct evp_cipher_ctx_st* c  , unsigned char* out, const unsigned char* in, unsigned int inl);
int EVP_MD_get_params(const struct evp_md_st* digest  , struct ossl_param_st params[]  );
int EVP_MD_CTX_set_params(struct evp_md_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_MD_CTX_get_params(struct evp_md_ctx_st* ctx  , struct ossl_param_st params[]  );
const struct ossl_param_st* EVP_MD_gettable_params(const struct evp_md_st* digest  );
const struct ossl_param_st* EVP_MD_settable_ctx_params(const struct evp_md_st* md  );
const struct ossl_param_st* EVP_MD_gettable_ctx_params(const struct evp_md_st* md  );
const struct ossl_param_st* EVP_MD_CTX_settable_params(struct evp_md_ctx_st* ctx  );
const struct ossl_param_st* EVP_MD_CTX_gettable_params(struct evp_md_ctx_st* ctx  );
int EVP_MD_CTX_ctrl(struct evp_md_ctx_st* ctx  , int cmd, int p1, void* p2);
struct evp_md_ctx_st* EVP_MD_CTX_new();
int EVP_MD_CTX_reset(struct evp_md_ctx_st* ctx  );
void EVP_MD_CTX_free(struct evp_md_ctx_st* ctx  );
struct evp_md_ctx_st* EVP_MD_CTX_dup(const struct evp_md_ctx_st* in  );
int EVP_MD_CTX_copy_ex(struct evp_md_ctx_st* out  , const struct evp_md_ctx_st* in  );
void EVP_MD_CTX_set_flags(struct evp_md_ctx_st* ctx  , int flags);
void EVP_MD_CTX_clear_flags(struct evp_md_ctx_st* ctx  , int flags);
int EVP_MD_CTX_test_flags(const struct evp_md_ctx_st* ctx  , int flags);
int EVP_DigestInit_ex2(struct evp_md_ctx_st* ctx  , const struct evp_md_st* type  , const struct ossl_param_st params[]  );
int EVP_DigestInit_ex(struct evp_md_ctx_st* ctx  , const struct evp_md_st* type  , struct engine_st* impl  );
int EVP_DigestUpdate(struct evp_md_ctx_st* ctx  , const void* d, unsigned long cnt  );
int EVP_DigestFinal_ex(struct evp_md_ctx_st* ctx  , unsigned char* md, unsigned int* s);
int EVP_Digest(const void* data, unsigned long count  , unsigned char* md, unsigned int* size, const struct evp_md_st* type  , struct engine_st* impl  );
int EVP_Q_digest(struct ossl_lib_ctx_st* libctx  , const char* name, const char* propq, const void* data, unsigned long datalen  , unsigned char* md, unsigned long* mdlen  );
int EVP_MD_CTX_copy(struct evp_md_ctx_st* out  , const struct evp_md_ctx_st* in  );
int EVP_DigestInit(struct evp_md_ctx_st* ctx  , const struct evp_md_st* type  );
int EVP_DigestFinal(struct evp_md_ctx_st* ctx  , unsigned char* md, unsigned int* s);
int EVP_DigestFinalXOF(struct evp_md_ctx_st* ctx  , unsigned char* out, unsigned long outlen  );
int EVP_DigestSqueeze(struct evp_md_ctx_st* ctx  , unsigned char* out, unsigned long outlen  );
struct evp_md_st* EVP_MD_fetch(struct ossl_lib_ctx_st* ctx  , const char* algorithm, const char* properties);
int EVP_MD_up_ref(struct evp_md_st* md  );
void EVP_MD_free(struct evp_md_st* md  );
int EVP_read_pw_string(char* buf, int length, const char* prompt, int verify);
int EVP_read_pw_string_min(char* buf, int minlen, int maxlen, const char* prompt, int verify);
void EVP_set_pw_prompt(const char* prompt);
char* EVP_get_pw_prompt();
int EVP_BytesToKey(const struct evp_cipher_st* type  , const struct evp_md_st* md  , const unsigned char* salt, const unsigned char* data, int datal, int count, unsigned char* key, unsigned char* iv);
void EVP_CIPHER_CTX_set_flags(struct evp_cipher_ctx_st* ctx  , int flags);
void EVP_CIPHER_CTX_clear_flags(struct evp_cipher_ctx_st* ctx  , int flags);
int EVP_CIPHER_CTX_test_flags(const struct evp_cipher_ctx_st* ctx  , int flags);
int EVP_EncryptInit(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , const unsigned char* key, const unsigned char* iv);
int EVP_EncryptInit_ex(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , struct engine_st* impl  , const unsigned char* key, const unsigned char* iv);
int EVP_EncryptInit_ex2(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , const unsigned char* key, const unsigned char* iv, const struct ossl_param_st params[]  );
int EVP_EncryptUpdate(struct evp_cipher_ctx_st* ctx  , unsigned char* out, int* outl, const unsigned char* in, int inl);
int EVP_EncryptFinal_ex(struct evp_cipher_ctx_st* ctx  , unsigned char* out, int* outl);
int EVP_EncryptFinal(struct evp_cipher_ctx_st* ctx  , unsigned char* out, int* outl);
int EVP_DecryptInit(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , const unsigned char* key, const unsigned char* iv);
int EVP_DecryptInit_ex(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , struct engine_st* impl  , const unsigned char* key, const unsigned char* iv);
int EVP_DecryptInit_ex2(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , const unsigned char* key, const unsigned char* iv, const struct ossl_param_st params[]  );
int EVP_DecryptUpdate(struct evp_cipher_ctx_st* ctx  , unsigned char* out, int* outl, const unsigned char* in, int inl);
int EVP_DecryptFinal(struct evp_cipher_ctx_st* ctx  , unsigned char* outm, int* outl);
int EVP_DecryptFinal_ex(struct evp_cipher_ctx_st* ctx  , unsigned char* outm, int* outl);
int EVP_CipherInit(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , const unsigned char* key, const unsigned char* iv, int enc);
int EVP_CipherInit_ex(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , struct engine_st* impl  , const unsigned char* key, const unsigned char* iv, int enc);
int EVP_CipherInit_SKEY(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , struct evp_skey_st* skey  , const unsigned char* iv, unsigned long iv_len  , int enc, const struct ossl_param_st params[]  );
int EVP_CipherInit_ex2(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , const unsigned char* key, const unsigned char* iv, int enc, const struct ossl_param_st params[]  );
int EVP_CipherUpdate(struct evp_cipher_ctx_st* ctx  , unsigned char* out, int* outl, const unsigned char* in, int inl);
int EVP_CipherFinal(struct evp_cipher_ctx_st* ctx  , unsigned char* outm, int* outl);
int EVP_CipherPipelineEncryptInit(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , const unsigned char* key, unsigned long keylen  , unsigned long numpipes  , const unsigned char** iv, unsigned long ivlen  );
int EVP_CipherPipelineDecryptInit(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* cipher  , const unsigned char* key, unsigned long keylen  , unsigned long numpipes  , const unsigned char** iv, unsigned long ivlen  );
int EVP_CipherPipelineUpdate(struct evp_cipher_ctx_st* ctx  , unsigned char** out, unsigned long* outl  , const unsigned long* outsize  , const unsigned char** in, const unsigned long* inl  );
int EVP_CipherPipelineFinal(struct evp_cipher_ctx_st* ctx  , unsigned char** outm, unsigned long* outl  , const unsigned long* outsize  );
int EVP_CipherFinal_ex(struct evp_cipher_ctx_st* ctx  , unsigned char* outm, int* outl);
int EVP_SignFinal(struct evp_md_ctx_st* ctx  , unsigned char* md, unsigned int* s, struct evp_pkey_st* pkey  );
int EVP_SignFinal_ex(struct evp_md_ctx_st* ctx  , unsigned char* md, unsigned int* s, struct evp_pkey_st* pkey  , struct ossl_lib_ctx_st* libctx  , const char* propq);
int EVP_DigestSign(struct evp_md_ctx_st* ctx  , unsigned char* sigret, unsigned long* siglen  , const unsigned char* tbs, unsigned long tbslen  );
int EVP_VerifyFinal(struct evp_md_ctx_st* ctx  , const unsigned char* sigbuf, unsigned int siglen, struct evp_pkey_st* pkey  );
int EVP_VerifyFinal_ex(struct evp_md_ctx_st* ctx  , const unsigned char* sigbuf, unsigned int siglen, struct evp_pkey_st* pkey  , struct ossl_lib_ctx_st* libctx  , const char* propq);
int EVP_DigestVerify(struct evp_md_ctx_st* ctx  , const unsigned char* sigret, unsigned long siglen  , const unsigned char* tbs, unsigned long tbslen  );
int EVP_DigestSignInit_ex(struct evp_md_ctx_st* ctx  , struct evp_pkey_ctx_st** pctx  , const char* mdname, struct ossl_lib_ctx_st* libctx  , const char* props, struct evp_pkey_st* pkey  , const struct ossl_param_st params[]  );
int EVP_DigestSignInit(struct evp_md_ctx_st* ctx  , struct evp_pkey_ctx_st** pctx  , const struct evp_md_st* type  , struct engine_st* e  , struct evp_pkey_st* pkey  );
int EVP_DigestSignUpdate(struct evp_md_ctx_st* ctx  , const void* data, unsigned long dsize  );
int EVP_DigestSignFinal(struct evp_md_ctx_st* ctx  , unsigned char* sigret, unsigned long* siglen  );
int EVP_DigestVerifyInit_ex(struct evp_md_ctx_st* ctx  , struct evp_pkey_ctx_st** pctx  , const char* mdname, struct ossl_lib_ctx_st* libctx  , const char* props, struct evp_pkey_st* pkey  , const struct ossl_param_st params[]  );
int EVP_DigestVerifyInit(struct evp_md_ctx_st* ctx  , struct evp_pkey_ctx_st** pctx  , const struct evp_md_st* type  , struct engine_st* e  , struct evp_pkey_st* pkey  );
int EVP_DigestVerifyUpdate(struct evp_md_ctx_st* ctx  , const void* data, unsigned long dsize  );
int EVP_DigestVerifyFinal(struct evp_md_ctx_st* ctx  , const unsigned char* sig, unsigned long siglen  );
int EVP_OpenInit(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* type  , const unsigned char* ek, int ekl, const unsigned char* iv, struct evp_pkey_st* priv  );
int EVP_OpenFinal(struct evp_cipher_ctx_st* ctx  , unsigned char* out, int* outl);
int EVP_SealInit(struct evp_cipher_ctx_st* ctx  , const struct evp_cipher_st* type  , unsigned char** ek, int* ekl, unsigned char* iv, struct evp_pkey_st** pubk  , int npubk);
int EVP_SealFinal(struct evp_cipher_ctx_st* ctx  , unsigned char* out, int* outl);
struct evp_Encode_Ctx_st* EVP_ENCODE_CTX_new();
void EVP_ENCODE_CTX_free(struct evp_Encode_Ctx_st* ctx  );
int EVP_ENCODE_CTX_copy(struct evp_Encode_Ctx_st* dctx  , const struct evp_Encode_Ctx_st* sctx  );
int EVP_ENCODE_CTX_num(struct evp_Encode_Ctx_st* ctx  );
void EVP_EncodeInit(struct evp_Encode_Ctx_st* ctx  );
int EVP_EncodeUpdate(struct evp_Encode_Ctx_st* ctx  , unsigned char* out, int* outl, const unsigned char* in, int inl);
void EVP_EncodeFinal(struct evp_Encode_Ctx_st* ctx  , unsigned char* out, int* outl);
int EVP_EncodeBlock(unsigned char* t, const unsigned char* f, int n);
void EVP_DecodeInit(struct evp_Encode_Ctx_st* ctx  );
int EVP_DecodeUpdate(struct evp_Encode_Ctx_st* ctx  , unsigned char* out, int* outl, const unsigned char* in, int inl);
int EVP_DecodeFinal(struct evp_Encode_Ctx_st* ctx  , unsigned char* out, int* outl);
int EVP_DecodeBlock(unsigned char* t, const unsigned char* f, int n);
struct evp_cipher_ctx_st* EVP_CIPHER_CTX_new();
int EVP_CIPHER_CTX_reset(struct evp_cipher_ctx_st* c  );
void EVP_CIPHER_CTX_free(struct evp_cipher_ctx_st* c  );
int EVP_CIPHER_CTX_set_key_length(struct evp_cipher_ctx_st* x  , int keylen);
int EVP_CIPHER_CTX_set_padding(struct evp_cipher_ctx_st* c  , int pad);
int EVP_CIPHER_CTX_ctrl(struct evp_cipher_ctx_st* ctx  , int type, int arg, void* ptr);
int EVP_CIPHER_CTX_rand_key(struct evp_cipher_ctx_st* ctx  , unsigned char* key);
int EVP_CIPHER_get_params(struct evp_cipher_st* cipher  , struct ossl_param_st params[]  );
int EVP_CIPHER_CTX_set_params(struct evp_cipher_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_CIPHER_CTX_get_params(struct evp_cipher_ctx_st* ctx  , struct ossl_param_st params[]  );
const struct ossl_param_st* EVP_CIPHER_gettable_params(const struct evp_cipher_st* cipher  );
const struct ossl_param_st* EVP_CIPHER_settable_ctx_params(const struct evp_cipher_st* cipher  );
const struct ossl_param_st* EVP_CIPHER_gettable_ctx_params(const struct evp_cipher_st* cipher  );
const struct ossl_param_st* EVP_CIPHER_CTX_settable_params(struct evp_cipher_ctx_st* ctx  );
const struct ossl_param_st* EVP_CIPHER_CTX_gettable_params(struct evp_cipher_ctx_st* ctx  );
int EVP_CIPHER_CTX_set_algor_params(struct evp_cipher_ctx_st* ctx  , const struct X509_algor_st* alg  );
int EVP_CIPHER_CTX_get_algor_params(struct evp_cipher_ctx_st* ctx  , struct X509_algor_st* alg  );
int EVP_CIPHER_CTX_get_algor(struct evp_cipher_ctx_st* ctx  , struct X509_algor_st** alg  );
const struct bio_method_st* BIO_f_md();
const struct bio_method_st* BIO_f_base64();
const struct bio_method_st* BIO_f_cipher();
const struct bio_method_st* BIO_f_reliable();
int BIO_set_cipher(struct bio_st* b  , const struct evp_cipher_st* c  , const unsigned char* k, const unsigned char* i, int enc);
const struct evp_md_st* EVP_md_null();
const struct evp_md_st* EVP_md2();
const struct evp_md_st* EVP_md4();
const struct evp_md_st* EVP_md5();
const struct evp_md_st* EVP_md5_sha1();
const struct evp_md_st* EVP_blake2b512();
const struct evp_md_st* EVP_blake2s256();
const struct evp_md_st* EVP_sha1();
const struct evp_md_st* EVP_sha224();
const struct evp_md_st* EVP_sha256();
const struct evp_md_st* EVP_sha384();
const struct evp_md_st* EVP_sha512();
const struct evp_md_st* EVP_sha512_224();
const struct evp_md_st* EVP_sha512_256();
const struct evp_md_st* EVP_sha3_224();
const struct evp_md_st* EVP_sha3_256();
const struct evp_md_st* EVP_sha3_384();
const struct evp_md_st* EVP_sha3_512();
const struct evp_md_st* EVP_shake128();
const struct evp_md_st* EVP_shake256();
const struct evp_md_st* EVP_ripemd160();
const struct evp_md_st* EVP_whirlpool();
const struct evp_md_st* EVP_sm3();
const struct evp_cipher_st* EVP_enc_null();
const struct evp_cipher_st* EVP_des_ecb();
const struct evp_cipher_st* EVP_des_ede();
const struct evp_cipher_st* EVP_des_ede3();
const struct evp_cipher_st* EVP_des_ede_ecb();
const struct evp_cipher_st* EVP_des_ede3_ecb();
const struct evp_cipher_st* EVP_des_cfb64();
const struct evp_cipher_st* EVP_des_cfb1();
const struct evp_cipher_st* EVP_des_cfb8();
const struct evp_cipher_st* EVP_des_ede_cfb64();
const struct evp_cipher_st* EVP_des_ede3_cfb64();
const struct evp_cipher_st* EVP_des_ede3_cfb1();
const struct evp_cipher_st* EVP_des_ede3_cfb8();
const struct evp_cipher_st* EVP_des_ofb();
const struct evp_cipher_st* EVP_des_ede_ofb();
const struct evp_cipher_st* EVP_des_ede3_ofb();
const struct evp_cipher_st* EVP_des_cbc();
const struct evp_cipher_st* EVP_des_ede_cbc();
const struct evp_cipher_st* EVP_des_ede3_cbc();
const struct evp_cipher_st* EVP_desx_cbc();
const struct evp_cipher_st* EVP_des_ede3_wrap();
const struct evp_cipher_st* EVP_rc4();
const struct evp_cipher_st* EVP_rc4_40();
const struct evp_cipher_st* EVP_rc4_hmac_md5();
const struct evp_cipher_st* EVP_idea_ecb();
const struct evp_cipher_st* EVP_idea_cfb64();
const struct evp_cipher_st* EVP_idea_ofb();
const struct evp_cipher_st* EVP_idea_cbc();
const struct evp_cipher_st* EVP_rc2_ecb();
const struct evp_cipher_st* EVP_rc2_cbc();
const struct evp_cipher_st* EVP_rc2_40_cbc();
const struct evp_cipher_st* EVP_rc2_64_cbc();
const struct evp_cipher_st* EVP_rc2_cfb64();
const struct evp_cipher_st* EVP_rc2_ofb();
const struct evp_cipher_st* EVP_bf_ecb();
const struct evp_cipher_st* EVP_bf_cbc();
const struct evp_cipher_st* EVP_bf_cfb64();
const struct evp_cipher_st* EVP_bf_ofb();
const struct evp_cipher_st* EVP_cast5_ecb();
const struct evp_cipher_st* EVP_cast5_cbc();
const struct evp_cipher_st* EVP_cast5_cfb64();
const struct evp_cipher_st* EVP_cast5_ofb();
const struct evp_cipher_st* EVP_rc5_32_12_16_cbc();
const struct evp_cipher_st* EVP_rc5_32_12_16_ecb();
const struct evp_cipher_st* EVP_rc5_32_12_16_cfb64();
const struct evp_cipher_st* EVP_rc5_32_12_16_ofb();
const struct evp_cipher_st* EVP_aes_128_ecb();
const struct evp_cipher_st* EVP_aes_128_cbc();
const struct evp_cipher_st* EVP_aes_128_cfb1();
const struct evp_cipher_st* EVP_aes_128_cfb8();
const struct evp_cipher_st* EVP_aes_128_cfb128();
const struct evp_cipher_st* EVP_aes_128_ofb();
const struct evp_cipher_st* EVP_aes_128_ctr();
const struct evp_cipher_st* EVP_aes_128_ccm();
const struct evp_cipher_st* EVP_aes_128_gcm();
const struct evp_cipher_st* EVP_aes_128_xts();
const struct evp_cipher_st* EVP_aes_128_wrap();
const struct evp_cipher_st* EVP_aes_128_wrap_pad();
const struct evp_cipher_st* EVP_aes_128_ocb();
const struct evp_cipher_st* EVP_aes_192_ecb();
const struct evp_cipher_st* EVP_aes_192_cbc();
const struct evp_cipher_st* EVP_aes_192_cfb1();
const struct evp_cipher_st* EVP_aes_192_cfb8();
const struct evp_cipher_st* EVP_aes_192_cfb128();
const struct evp_cipher_st* EVP_aes_192_ofb();
const struct evp_cipher_st* EVP_aes_192_ctr();
const struct evp_cipher_st* EVP_aes_192_ccm();
const struct evp_cipher_st* EVP_aes_192_gcm();
const struct evp_cipher_st* EVP_aes_192_wrap();
const struct evp_cipher_st* EVP_aes_192_wrap_pad();
const struct evp_cipher_st* EVP_aes_192_ocb();
const struct evp_cipher_st* EVP_aes_256_ecb();
const struct evp_cipher_st* EVP_aes_256_cbc();
const struct evp_cipher_st* EVP_aes_256_cfb1();
const struct evp_cipher_st* EVP_aes_256_cfb8();
const struct evp_cipher_st* EVP_aes_256_cfb128();
const struct evp_cipher_st* EVP_aes_256_ofb();
const struct evp_cipher_st* EVP_aes_256_ctr();
const struct evp_cipher_st* EVP_aes_256_ccm();
const struct evp_cipher_st* EVP_aes_256_gcm();
const struct evp_cipher_st* EVP_aes_256_xts();
const struct evp_cipher_st* EVP_aes_256_wrap();
const struct evp_cipher_st* EVP_aes_256_wrap_pad();
const struct evp_cipher_st* EVP_aes_256_ocb();
const struct evp_cipher_st* EVP_aes_128_cbc_hmac_sha1();
const struct evp_cipher_st* EVP_aes_256_cbc_hmac_sha1();
const struct evp_cipher_st* EVP_aes_128_cbc_hmac_sha256();
const struct evp_cipher_st* EVP_aes_256_cbc_hmac_sha256();
const struct evp_cipher_st* EVP_aria_128_ecb();
const struct evp_cipher_st* EVP_aria_128_cbc();
const struct evp_cipher_st* EVP_aria_128_cfb1();
const struct evp_cipher_st* EVP_aria_128_cfb8();
const struct evp_cipher_st* EVP_aria_128_cfb128();
const struct evp_cipher_st* EVP_aria_128_ctr();
const struct evp_cipher_st* EVP_aria_128_ofb();
const struct evp_cipher_st* EVP_aria_128_gcm();
const struct evp_cipher_st* EVP_aria_128_ccm();
const struct evp_cipher_st* EVP_aria_192_ecb();
const struct evp_cipher_st* EVP_aria_192_cbc();
const struct evp_cipher_st* EVP_aria_192_cfb1();
const struct evp_cipher_st* EVP_aria_192_cfb8();
const struct evp_cipher_st* EVP_aria_192_cfb128();
const struct evp_cipher_st* EVP_aria_192_ctr();
const struct evp_cipher_st* EVP_aria_192_ofb();
const struct evp_cipher_st* EVP_aria_192_gcm();
const struct evp_cipher_st* EVP_aria_192_ccm();
const struct evp_cipher_st* EVP_aria_256_ecb();
const struct evp_cipher_st* EVP_aria_256_cbc();
const struct evp_cipher_st* EVP_aria_256_cfb1();
const struct evp_cipher_st* EVP_aria_256_cfb8();
const struct evp_cipher_st* EVP_aria_256_cfb128();
const struct evp_cipher_st* EVP_aria_256_ctr();
const struct evp_cipher_st* EVP_aria_256_ofb();
const struct evp_cipher_st* EVP_aria_256_gcm();
const struct evp_cipher_st* EVP_aria_256_ccm();
const struct evp_cipher_st* EVP_camellia_128_ecb();
const struct evp_cipher_st* EVP_camellia_128_cbc();
const struct evp_cipher_st* EVP_camellia_128_cfb1();
const struct evp_cipher_st* EVP_camellia_128_cfb8();
const struct evp_cipher_st* EVP_camellia_128_cfb128();
const struct evp_cipher_st* EVP_camellia_128_ofb();
const struct evp_cipher_st* EVP_camellia_128_ctr();
const struct evp_cipher_st* EVP_camellia_192_ecb();
const struct evp_cipher_st* EVP_camellia_192_cbc();
const struct evp_cipher_st* EVP_camellia_192_cfb1();
const struct evp_cipher_st* EVP_camellia_192_cfb8();
const struct evp_cipher_st* EVP_camellia_192_cfb128();
const struct evp_cipher_st* EVP_camellia_192_ofb();
const struct evp_cipher_st* EVP_camellia_192_ctr();
const struct evp_cipher_st* EVP_camellia_256_ecb();
const struct evp_cipher_st* EVP_camellia_256_cbc();
const struct evp_cipher_st* EVP_camellia_256_cfb1();
const struct evp_cipher_st* EVP_camellia_256_cfb8();
const struct evp_cipher_st* EVP_camellia_256_cfb128();
const struct evp_cipher_st* EVP_camellia_256_ofb();
const struct evp_cipher_st* EVP_camellia_256_ctr();
const struct evp_cipher_st* EVP_chacha20();
const struct evp_cipher_st* EVP_chacha20_poly1305();
const struct evp_cipher_st* EVP_seed_ecb();
const struct evp_cipher_st* EVP_seed_cbc();
const struct evp_cipher_st* EVP_seed_cfb128();
const struct evp_cipher_st* EVP_seed_ofb();
int EVP_add_cipher(const struct evp_cipher_st* cipher  );
int EVP_add_digest(const struct evp_md_st* digest  );
const struct evp_cipher_st* EVP_get_cipherbyname(const char* name);
const struct evp_md_st* EVP_get_digestbyname(const char* name);
void EVP_CIPHER_do_all(void (*fn)(const struct evp_cipher_st*,const char*,const char*,void*), void* arg);
void EVP_CIPHER_do_all_sorted(void (*fn)(const struct evp_cipher_st*,const char*,const char*,void*), void* arg);
void EVP_CIPHER_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_cipher_st*,void*), void* arg);
void EVP_MD_do_all(void (*fn)(const struct evp_md_st*,const char*,const char*,void*), void* arg);
void EVP_MD_do_all_sorted(void (*fn)(const struct evp_md_st*,const char*,const char*,void*), void* arg);
void EVP_MD_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_md_st*,void*), void* arg);
struct evp_mac_st* EVP_MAC_fetch(struct ossl_lib_ctx_st* libctx  , const char* algorithm, const char* properties);
int EVP_MAC_up_ref(struct evp_mac_st* mac  );
void EVP_MAC_free(struct evp_mac_st* mac  );
const char* EVP_MAC_get0_name(const struct evp_mac_st* mac  );
const char* EVP_MAC_get0_description(const struct evp_mac_st* mac  );
int EVP_MAC_is_a(const struct evp_mac_st* mac  , const char* name);
const struct ossl_provider_st* EVP_MAC_get0_provider(const struct evp_mac_st* mac  );
int EVP_MAC_get_params(struct evp_mac_st* mac  , struct ossl_param_st params[]  );
struct evp_mac_ctx_st* EVP_MAC_CTX_new(struct evp_mac_st* mac  );
void EVP_MAC_CTX_free(struct evp_mac_ctx_st* ctx  );
struct evp_mac_ctx_st* EVP_MAC_CTX_dup(const struct evp_mac_ctx_st* src  );
struct evp_mac_st* EVP_MAC_CTX_get0_mac(struct evp_mac_ctx_st* ctx  );
int EVP_MAC_CTX_get_params(struct evp_mac_ctx_st* ctx  , struct ossl_param_st params[]  );
int EVP_MAC_CTX_set_params(struct evp_mac_ctx_st* ctx  , const struct ossl_param_st params[]  );
unsigned long EVP_MAC_CTX_get_mac_size(struct evp_mac_ctx_st* ctx  );
unsigned long EVP_MAC_CTX_get_block_size(struct evp_mac_ctx_st* ctx  );
unsigned char* EVP_Q_mac(struct ossl_lib_ctx_st* libctx  , const char* name, const char* propq, const char* subalg, const struct ossl_param_st* params  , const void* key, unsigned long keylen  , const unsigned char* data, unsigned long datalen  , unsigned char* out, unsigned long outsize  , unsigned long* outlen  );
int EVP_MAC_init(struct evp_mac_ctx_st* ctx  , const unsigned char* key, unsigned long keylen  , const struct ossl_param_st params[]  );
int EVP_MAC_init_SKEY(struct evp_mac_ctx_st* ctx  , struct evp_skey_st* skey  , const struct ossl_param_st params[]  );
int EVP_MAC_update(struct evp_mac_ctx_st* ctx  , const unsigned char* data, unsigned long datalen  );
int EVP_MAC_final(struct evp_mac_ctx_st* ctx  , unsigned char* out, unsigned long* outl  , unsigned long outsize  );
int EVP_MAC_finalXOF(struct evp_mac_ctx_st* ctx  , unsigned char* out, unsigned long outsize  );
const struct ossl_param_st* EVP_MAC_gettable_params(const struct evp_mac_st* mac  );
const struct ossl_param_st* EVP_MAC_gettable_ctx_params(const struct evp_mac_st* mac  );
const struct ossl_param_st* EVP_MAC_settable_ctx_params(const struct evp_mac_st* mac  );
const struct ossl_param_st* EVP_MAC_CTX_gettable_params(struct evp_mac_ctx_st* ctx  );
const struct ossl_param_st* EVP_MAC_CTX_settable_params(struct evp_mac_ctx_st* ctx  );
void EVP_MAC_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_mac_st*,void*), void* arg);
int EVP_MAC_names_do_all(const struct evp_mac_st* mac  , void (*fn)(const char*,void*), void* data);
struct evp_rand_st* EVP_RAND_fetch(struct ossl_lib_ctx_st* libctx  , const char* algorithm, const char* properties);
int EVP_RAND_up_ref(struct evp_rand_st* rand  );
void EVP_RAND_free(struct evp_rand_st* rand  );
const char* EVP_RAND_get0_name(const struct evp_rand_st* rand  );
const char* EVP_RAND_get0_description(const struct evp_rand_st* md  );
int EVP_RAND_is_a(const struct evp_rand_st* rand  , const char* name);
const struct ossl_provider_st* EVP_RAND_get0_provider(const struct evp_rand_st* rand  );
int EVP_RAND_get_params(struct evp_rand_st* rand  , struct ossl_param_st params[]  );
struct evp_rand_ctx_st* EVP_RAND_CTX_new(struct evp_rand_st* rand  , struct evp_rand_ctx_st* parent  );
int EVP_RAND_CTX_up_ref(struct evp_rand_ctx_st* ctx  );
void EVP_RAND_CTX_free(struct evp_rand_ctx_st* ctx  );
struct evp_rand_st* EVP_RAND_CTX_get0_rand(struct evp_rand_ctx_st* ctx  );
int EVP_RAND_CTX_get_params(struct evp_rand_ctx_st* ctx  , struct ossl_param_st params[]  );
int EVP_RAND_CTX_set_params(struct evp_rand_ctx_st* ctx  , const struct ossl_param_st params[]  );
const struct ossl_param_st* EVP_RAND_gettable_params(const struct evp_rand_st* rand  );
const struct ossl_param_st* EVP_RAND_gettable_ctx_params(const struct evp_rand_st* rand  );
const struct ossl_param_st* EVP_RAND_settable_ctx_params(const struct evp_rand_st* rand  );
const struct ossl_param_st* EVP_RAND_CTX_gettable_params(struct evp_rand_ctx_st* ctx  );
const struct ossl_param_st* EVP_RAND_CTX_settable_params(struct evp_rand_ctx_st* ctx  );
void EVP_RAND_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_rand_st*,void*), void* arg);
int EVP_RAND_names_do_all(const struct evp_rand_st* rand  , void (*fn)(const char*,void*), void* data);
int EVP_RAND_instantiate(struct evp_rand_ctx_st* ctx  , unsigned int strength, int prediction_resistance, const unsigned char* pstr, unsigned long pstr_len  , const struct ossl_param_st params[]  );
int EVP_RAND_uninstantiate(struct evp_rand_ctx_st* ctx  );
int EVP_RAND_generate(struct evp_rand_ctx_st* ctx  , unsigned char* out, unsigned long outlen  , unsigned int strength, int prediction_resistance, const unsigned char* addin, unsigned long addin_len  );
int EVP_RAND_reseed(struct evp_rand_ctx_st* ctx  , int prediction_resistance, const unsigned char* ent, unsigned long ent_len  , const unsigned char* addin, unsigned long addin_len  );
int EVP_RAND_nonce(struct evp_rand_ctx_st* ctx  , unsigned char* out, unsigned long outlen  );
int EVP_RAND_enable_locking(struct evp_rand_ctx_st* ctx  );
int EVP_RAND_verify_zeroization(struct evp_rand_ctx_st* ctx  );
unsigned int EVP_RAND_get_strength(struct evp_rand_ctx_st* ctx  );
int EVP_RAND_get_state(struct evp_rand_ctx_st* ctx  );
int EVP_PKEY_decrypt_old(unsigned char* dec_key, const unsigned char* enc_key, int enc_key_len, struct evp_pkey_st* private_key  );
int EVP_PKEY_encrypt_old(unsigned char* enc_key, const unsigned char* key, int key_len, struct evp_pkey_st* pub_key  );
int EVP_PKEY_is_a(const struct evp_pkey_st* pkey  , const char* name);
int EVP_PKEY_type_names_do_all(const struct evp_pkey_st* pkey  , void (*fn)(const char*,void*), void* data);
int EVP_PKEY_type(int type);
int EVP_PKEY_get_id(const struct evp_pkey_st* pkey  );
int EVP_PKEY_get_base_id(const struct evp_pkey_st* pkey  );
int EVP_PKEY_get_bits(const struct evp_pkey_st* pkey  );
int EVP_PKEY_get_security_bits(const struct evp_pkey_st* pkey  );
int EVP_PKEY_get_size(const struct evp_pkey_st* pkey  );
int EVP_PKEY_can_sign(const struct evp_pkey_st* pkey  );
int EVP_PKEY_set_type(struct evp_pkey_st* pkey  , int type);
int EVP_PKEY_set_type_str(struct evp_pkey_st* pkey  , const char* str, int len);
int EVP_PKEY_set_type_by_keymgmt(struct evp_pkey_st* pkey  , struct evp_keymgmt_st* keymgmt  );
int EVP_PKEY_assign(struct evp_pkey_st* pkey  , int type, void* key);
void* EVP_PKEY_get0(const struct evp_pkey_st* pkey  );
const unsigned char* EVP_PKEY_get0_hmac(const struct evp_pkey_st* pkey  , unsigned long* len  );
const unsigned char* EVP_PKEY_get0_poly1305(const struct evp_pkey_st* pkey  , unsigned long* len  );
const unsigned char* EVP_PKEY_get0_siphash(const struct evp_pkey_st* pkey  , unsigned long* len  );
int EVP_PKEY_set1_RSA(struct evp_pkey_st* pkey  , struct rsa_st* key  );
const struct rsa_st* EVP_PKEY_get0_RSA(const struct evp_pkey_st* pkey  );
struct rsa_st* EVP_PKEY_get1_RSA(struct evp_pkey_st* pkey  );
int EVP_PKEY_set1_DSA(struct evp_pkey_st* pkey  , struct dsa_st* key  );
const struct dsa_st* EVP_PKEY_get0_DSA(const struct evp_pkey_st* pkey  );
struct dsa_st* EVP_PKEY_get1_DSA(struct evp_pkey_st* pkey  );
int EVP_PKEY_set1_DH(struct evp_pkey_st* pkey  , struct dh_st* key  );
const struct dh_st* EVP_PKEY_get0_DH(const struct evp_pkey_st* pkey  );
struct dh_st* EVP_PKEY_get1_DH(struct evp_pkey_st* pkey  );
int EVP_PKEY_set1_EC_KEY(struct evp_pkey_st* pkey  , struct ec_key_st* key  );
const struct ec_key_st* EVP_PKEY_get0_EC_KEY(const struct evp_pkey_st* pkey  );
struct ec_key_st* EVP_PKEY_get1_EC_KEY(struct evp_pkey_st* pkey  );
struct evp_pkey_st* EVP_PKEY_new();
int EVP_PKEY_up_ref(struct evp_pkey_st* pkey  );
struct evp_pkey_st* EVP_PKEY_dup(struct evp_pkey_st* pkey  );
void EVP_PKEY_free(struct evp_pkey_st* pkey  );
const char* EVP_PKEY_get0_description(const struct evp_pkey_st* pkey  );
const struct ossl_provider_st* EVP_PKEY_get0_provider(const struct evp_pkey_st* key  );
struct evp_pkey_st* d2i_PublicKey(int type, struct evp_pkey_st** a  , const unsigned char** pp, long length);
int i2d_PublicKey(const struct evp_pkey_st* a  , unsigned char** pp);
struct evp_pkey_st* d2i_PrivateKey_ex(int type, struct evp_pkey_st** a  , const unsigned char** pp, long length, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* d2i_PrivateKey(int type, struct evp_pkey_st** a  , const unsigned char** pp, long length);
struct evp_pkey_st* d2i_AutoPrivateKey_ex(struct evp_pkey_st** a  , const unsigned char** pp, long length, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* d2i_AutoPrivateKey(struct evp_pkey_st** a  , const unsigned char** pp, long length);
int i2d_PrivateKey(const struct evp_pkey_st* a  , unsigned char** pp);
int i2d_KeyParams(const struct evp_pkey_st* a  , unsigned char** pp);
struct evp_pkey_st* d2i_KeyParams(int type, struct evp_pkey_st** a  , const unsigned char** pp, long length);
int i2d_KeyParams_bio(struct bio_st* bp  , const struct evp_pkey_st* pkey  );
struct evp_pkey_st* d2i_KeyParams_bio(int type, struct evp_pkey_st** a  , struct bio_st* in  );
int EVP_PKEY_copy_parameters(struct evp_pkey_st* to  , const struct evp_pkey_st* from  );
int EVP_PKEY_missing_parameters(const struct evp_pkey_st* pkey  );
int EVP_PKEY_save_parameters(struct evp_pkey_st* pkey  , int mode);
int EVP_PKEY_parameters_eq(const struct evp_pkey_st* a  , const struct evp_pkey_st* b  );
int EVP_PKEY_eq(const struct evp_pkey_st* a  , const struct evp_pkey_st* b  );
int EVP_PKEY_cmp_parameters(const struct evp_pkey_st* a  , const struct evp_pkey_st* b  );
int EVP_PKEY_cmp(const struct evp_pkey_st* a  , const struct evp_pkey_st* b  );
int EVP_PKEY_print_public(struct bio_st* out  , const struct evp_pkey_st* pkey  , int indent, struct asn1_pctx_st* pctx  );
int EVP_PKEY_print_private(struct bio_st* out  , const struct evp_pkey_st* pkey  , int indent, struct asn1_pctx_st* pctx  );
int EVP_PKEY_print_params(struct bio_st* out  , const struct evp_pkey_st* pkey  , int indent, struct asn1_pctx_st* pctx  );
int EVP_PKEY_print_public_fp(struct _IO_FILE* fp  , const struct evp_pkey_st* pkey  , int indent, struct asn1_pctx_st* pctx  );
int EVP_PKEY_print_private_fp(struct _IO_FILE* fp  , const struct evp_pkey_st* pkey  , int indent, struct asn1_pctx_st* pctx  );
int EVP_PKEY_print_params_fp(struct _IO_FILE* fp  , const struct evp_pkey_st* pkey  , int indent, struct asn1_pctx_st* pctx  );
int EVP_PKEY_get_default_digest_nid(struct evp_pkey_st* pkey  , int* pnid);
int EVP_PKEY_get_default_digest_name(struct evp_pkey_st* pkey  , char* mdname, unsigned long mdname_sz  );
int EVP_PKEY_digestsign_supports_digest(struct evp_pkey_st* pkey  , struct ossl_lib_ctx_st* libctx  , const char* name, const char* propq);
int EVP_PKEY_set1_encoded_public_key(struct evp_pkey_st* pkey  , const unsigned char* pub, unsigned long publen  );
unsigned long EVP_PKEY_get1_encoded_public_key(struct evp_pkey_st* pkey  , unsigned char** ppub);
int EVP_CIPHER_param_to_asn1(struct evp_cipher_ctx_st* c  , struct asn1_type_st* type  );
int EVP_CIPHER_asn1_to_param(struct evp_cipher_ctx_st* c  , struct asn1_type_st* type  );
int EVP_CIPHER_set_asn1_iv(struct evp_cipher_ctx_st* c  , struct asn1_type_st* type  );
int EVP_CIPHER_get_asn1_iv(struct evp_cipher_ctx_st* c  , struct asn1_type_st* type  );
int PKCS5_PBE_keyivgen(struct evp_cipher_ctx_st* ctx  , const char* pass, int passlen, struct asn1_type_st* param  , const struct evp_cipher_st* cipher  , const struct evp_md_st* md  , int en_de);
int PKCS5_PBE_keyivgen_ex(struct evp_cipher_ctx_st* cctx  , const char* pass, int passlen, struct asn1_type_st* param  , const struct evp_cipher_st* cipher  , const struct evp_md_st* md  , int en_de, struct ossl_lib_ctx_st* libctx  , const char* propq);
int PKCS5_PBKDF2_HMAC_SHA1(const char* pass, int passlen, const unsigned char* salt, int saltlen, int iter, int keylen, unsigned char* out);
int PKCS5_PBKDF2_HMAC(const char* pass, int passlen, const unsigned char* salt, int saltlen, int iter, const struct evp_md_st* digest  , int keylen, unsigned char* out);
int PKCS5_v2_PBE_keyivgen(struct evp_cipher_ctx_st* ctx  , const char* pass, int passlen, struct asn1_type_st* param  , const struct evp_cipher_st* cipher  , const struct evp_md_st* md  , int en_de);
int PKCS5_v2_PBE_keyivgen_ex(struct evp_cipher_ctx_st* ctx  , const char* pass, int passlen, struct asn1_type_st* param  , const struct evp_cipher_st* cipher  , const struct evp_md_st* md  , int en_de, struct ossl_lib_ctx_st* libctx  , const char* propq);
int EVP_PBE_scrypt(const char* pass, unsigned long passlen  , const unsigned char* salt, unsigned long saltlen  , unsigned long  int N  , unsigned long  int r  , unsigned long  int p  , unsigned long  int maxmem  , unsigned char* key, unsigned long keylen  );
int EVP_PBE_scrypt_ex(const char* pass, unsigned long passlen  , const unsigned char* salt, unsigned long saltlen  , unsigned long  int N  , unsigned long  int r  , unsigned long  int p  , unsigned long  int maxmem  , unsigned char* key, unsigned long keylen  , struct ossl_lib_ctx_st* ctx  , const char* propq);
int PKCS5_v2_scrypt_keyivgen(struct evp_cipher_ctx_st* ctx  , const char* pass, int passlen, struct asn1_type_st* param  , const struct evp_cipher_st* c  , const struct evp_md_st* md  , int en_de);
int PKCS5_v2_scrypt_keyivgen_ex(struct evp_cipher_ctx_st* ctx  , const char* pass, int passlen, struct asn1_type_st* param  , const struct evp_cipher_st* c  , const struct evp_md_st* md  , int en_de, struct ossl_lib_ctx_st* libctx  , const char* propq);
void PKCS5_PBE_add();
int EVP_PBE_CipherInit(struct asn1_object_st* pbe_obj  , const char* pass, int passlen, struct asn1_type_st* param  , struct evp_cipher_ctx_st* ctx  , int en_de);
int EVP_PBE_CipherInit_ex(struct asn1_object_st* pbe_obj  , const char* pass, int passlen, struct asn1_type_st* param  , struct evp_cipher_ctx_st* ctx  , int en_de, struct ossl_lib_ctx_st* libctx  , const char* propq);
int EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid, int md_nid, int (*(*keygen))(struct evp_cipher_ctx_st*,const char*,int,struct asn1_type_st*,const struct evp_cipher_st*,const struct evp_md_st*,int)  );
int EVP_PBE_alg_add(int nid, const struct evp_cipher_st* cipher  , const struct evp_md_st* md  , int (*(*keygen))(struct evp_cipher_ctx_st*,const char*,int,struct asn1_type_st*,const struct evp_cipher_st*,const struct evp_md_st*,int)  );
int EVP_PBE_find(int type, int pbe_nid, int* pcnid, int* pmnid, int (*(*(*pkeygen)))(struct evp_cipher_ctx_st*,const char*,int,struct asn1_type_st*,const struct evp_cipher_st*,const struct evp_md_st*,int)  );
int EVP_PBE_find_ex(int type, int pbe_nid, int* pcnid, int* pmnid, int (*(*(*pkeygen)))(struct evp_cipher_ctx_st*,const char*,int,struct asn1_type_st*,const struct evp_cipher_st*,const struct evp_md_st*,int)  , int (*(*(*pkeygen_ex)))(struct evp_cipher_ctx_st*,const char*,int,struct asn1_type_st*,const struct evp_cipher_st*,const struct evp_md_st*,int,struct ossl_lib_ctx_st*,const char*)  );
void EVP_PBE_cleanup();
int EVP_PBE_get(int* ptype, int* ppbe_nid, unsigned long num  );
int EVP_PKEY_asn1_get_count();
const struct evp_pkey_asn1_method_st* EVP_PKEY_asn1_get0(int idx);
const struct evp_pkey_asn1_method_st* EVP_PKEY_asn1_find(struct engine_st** pe  , int type);
const struct evp_pkey_asn1_method_st* EVP_PKEY_asn1_find_str(struct engine_st** pe  , const char* str, int len);
int EVP_PKEY_asn1_add0(const struct evp_pkey_asn1_method_st* ameth  );
int EVP_PKEY_asn1_add_alias(int to, int from);
int EVP_PKEY_asn1_get0_info(int* ppkey_id, int* pkey_base_id, int* ppkey_flags, const char** pinfo, const char** ppem_str, const struct evp_pkey_asn1_method_st* ameth  );
const struct evp_pkey_asn1_method_st* EVP_PKEY_get0_asn1(const struct evp_pkey_st* pkey  );
struct evp_pkey_asn1_method_st* EVP_PKEY_asn1_new(int id, int flags, const char* pem_str, const char* info);
void EVP_PKEY_asn1_copy(struct evp_pkey_asn1_method_st* dst  , const struct evp_pkey_asn1_method_st* src  );
void EVP_PKEY_asn1_free(struct evp_pkey_asn1_method_st* ameth  );
void EVP_PKEY_asn1_set_public(struct evp_pkey_asn1_method_st* ameth  , int (*pub_decode)(struct evp_pkey_st*,const struct X509_pubkey_st*), int (*pub_encode)(struct X509_pubkey_st*,const struct evp_pkey_st*), int (*pub_cmp)(const struct evp_pkey_st*,const struct evp_pkey_st*), int (*pub_print)(struct bio_st*,const struct evp_pkey_st*,int,struct asn1_pctx_st*), int (*pkey_size)(const struct evp_pkey_st*), int (*pkey_bits)(const struct evp_pkey_st*));
void EVP_PKEY_asn1_set_private(struct evp_pkey_asn1_method_st* ameth  , int (*priv_decode)(struct evp_pkey_st*,const struct pkcs8_priv_key_info_st*), int (*priv_encode)(struct pkcs8_priv_key_info_st*,const struct evp_pkey_st*), int (*priv_print)(struct bio_st*,const struct evp_pkey_st*,int,struct asn1_pctx_st*));
void EVP_PKEY_asn1_set_param(struct evp_pkey_asn1_method_st* ameth  , int (*param_decode)(struct evp_pkey_st*,const unsigned char**,int), int (*param_encode)(const struct evp_pkey_st*,unsigned char**), int (*param_missing)(const struct evp_pkey_st*), int (*param_copy)(struct evp_pkey_st*,const struct evp_pkey_st*), int (*param_cmp)(const struct evp_pkey_st*,const struct evp_pkey_st*), int (*param_print)(struct bio_st*,const struct evp_pkey_st*,int,struct asn1_pctx_st*));
void EVP_PKEY_asn1_set_free(struct evp_pkey_asn1_method_st* ameth  , void (*pkey_free)(struct evp_pkey_st*));
void EVP_PKEY_asn1_set_ctrl(struct evp_pkey_asn1_method_st* ameth  , int (*pkey_ctrl)(struct evp_pkey_st*,int,long,void*));
void EVP_PKEY_asn1_set_item(struct evp_pkey_asn1_method_st* ameth  , int (*item_verify)(struct evp_md_ctx_st*,const struct ASN1_ITEM_st*,const void*,const struct X509_algor_st*,const struct asn1_string_st*,struct evp_pkey_st*), int (*item_sign)(struct evp_md_ctx_st*,const struct ASN1_ITEM_st*,const void*,struct X509_algor_st*,struct X509_algor_st*,struct asn1_string_st*));
void EVP_PKEY_asn1_set_siginf(struct evp_pkey_asn1_method_st* ameth  , int (*siginf_set)(struct x509_sig_info_st*,const struct X509_algor_st*,const struct asn1_string_st*));
void EVP_PKEY_asn1_set_check(struct evp_pkey_asn1_method_st* ameth  , int (*pkey_check)(const struct evp_pkey_st*));
void EVP_PKEY_asn1_set_public_check(struct evp_pkey_asn1_method_st* ameth  , int (*pkey_pub_check)(const struct evp_pkey_st*));
void EVP_PKEY_asn1_set_param_check(struct evp_pkey_asn1_method_st* ameth  , int (*pkey_param_check)(const struct evp_pkey_st*));
void EVP_PKEY_asn1_set_set_priv_key(struct evp_pkey_asn1_method_st* ameth  , int (*set_priv_key)(struct evp_pkey_st*,const unsigned char*,unsigned long));
void EVP_PKEY_asn1_set_set_pub_key(struct evp_pkey_asn1_method_st* ameth  , int (*set_pub_key)(struct evp_pkey_st*,const unsigned char*,unsigned long));
void EVP_PKEY_asn1_set_get_priv_key(struct evp_pkey_asn1_method_st* ameth  , int (*get_priv_key)(const struct evp_pkey_st*,unsigned char*,unsigned long*));
void EVP_PKEY_asn1_set_get_pub_key(struct evp_pkey_asn1_method_st* ameth  , int (*get_pub_key)(const struct evp_pkey_st*,unsigned char*,unsigned long*));
void EVP_PKEY_asn1_set_security_bits(struct evp_pkey_asn1_method_st* ameth  , int (*pkey_security_bits)(const struct evp_pkey_st*));
int EVP_PKEY_CTX_get_signature_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st** md  );
int EVP_PKEY_CTX_set_signature_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st* md  );
int EVP_PKEY_CTX_set1_id(struct evp_pkey_ctx_st* ctx  , const void* id, int len);
int EVP_PKEY_CTX_get1_id(struct evp_pkey_ctx_st* ctx  , void* id);
int EVP_PKEY_CTX_get1_id_len(struct evp_pkey_ctx_st* ctx  , unsigned long* id_len  );
int EVP_PKEY_CTX_set_kem_op(struct evp_pkey_ctx_st* ctx  , const char* op);
const char* EVP_PKEY_get0_type_name(const struct evp_pkey_st* key  );
int EVP_PKEY_CTX_set_mac_key(struct evp_pkey_ctx_st* ctx  , const unsigned char* key, int keylen);
const struct evp_pkey_method_st* EVP_PKEY_meth_find(int type);
struct evp_pkey_method_st* EVP_PKEY_meth_new(int id, int flags);
void EVP_PKEY_meth_get0_info(int* ppkey_id, int* pflags, const struct evp_pkey_method_st* meth  );
void EVP_PKEY_meth_copy(struct evp_pkey_method_st* dst  , const struct evp_pkey_method_st* src  );
void EVP_PKEY_meth_free(struct evp_pkey_method_st* pmeth  );
int EVP_PKEY_meth_add0(const struct evp_pkey_method_st* pmeth  );
int EVP_PKEY_meth_remove(const struct evp_pkey_method_st* pmeth  );
unsigned long EVP_PKEY_meth_get_count();
const struct evp_pkey_method_st* EVP_PKEY_meth_get0(unsigned long idx  );
struct evp_keymgmt_st* EVP_KEYMGMT_fetch(struct ossl_lib_ctx_st* ctx  , const char* algorithm, const char* properties);
int EVP_KEYMGMT_up_ref(struct evp_keymgmt_st* keymgmt  );
void EVP_KEYMGMT_free(struct evp_keymgmt_st* keymgmt  );
const struct ossl_provider_st* EVP_KEYMGMT_get0_provider(const struct evp_keymgmt_st* keymgmt  );
const char* EVP_KEYMGMT_get0_name(const struct evp_keymgmt_st* keymgmt  );
const char* EVP_KEYMGMT_get0_description(const struct evp_keymgmt_st* keymgmt  );
int EVP_KEYMGMT_is_a(const struct evp_keymgmt_st* keymgmt  , const char* name);
void EVP_KEYMGMT_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_keymgmt_st*,void*), void* arg);
int EVP_KEYMGMT_names_do_all(const struct evp_keymgmt_st* keymgmt  , void (*fn)(const char*,void*), void* data);
const struct ossl_param_st* EVP_KEYMGMT_gettable_params(const struct evp_keymgmt_st* keymgmt  );
const struct ossl_param_st* EVP_KEYMGMT_settable_params(const struct evp_keymgmt_st* keymgmt  );
const struct ossl_param_st* EVP_KEYMGMT_gen_settable_params(const struct evp_keymgmt_st* keymgmt  );
const struct ossl_param_st* EVP_KEYMGMT_gen_gettable_params(const struct evp_keymgmt_st* keymgmt  );
struct evp_skeymgmt_st* EVP_SKEYMGMT_fetch(struct ossl_lib_ctx_st* ctx  , const char* algorithm, const char* properties);
int EVP_SKEYMGMT_up_ref(struct evp_skeymgmt_st* keymgmt  );
void EVP_SKEYMGMT_free(struct evp_skeymgmt_st* keymgmt  );
const struct ossl_provider_st* EVP_SKEYMGMT_get0_provider(const struct evp_skeymgmt_st* keymgmt  );
const char* EVP_SKEYMGMT_get0_name(const struct evp_skeymgmt_st* keymgmt  );
const char* EVP_SKEYMGMT_get0_description(const struct evp_skeymgmt_st* keymgmt  );
int EVP_SKEYMGMT_is_a(const struct evp_skeymgmt_st* keymgmt  , const char* name);
void EVP_SKEYMGMT_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_skeymgmt_st*,void*), void* arg);
int EVP_SKEYMGMT_names_do_all(const struct evp_skeymgmt_st* keymgmt  , void (*fn)(const char*,void*), void* data);
const struct ossl_param_st* EVP_SKEYMGMT_get0_gen_settable_params(const struct evp_skeymgmt_st* skeymgmt  );
const struct ossl_param_st* EVP_SKEYMGMT_get0_imp_settable_params(const struct evp_skeymgmt_st* skeymgmt  );
struct evp_pkey_ctx_st* EVP_PKEY_CTX_new(struct evp_pkey_st* pkey  , struct engine_st* e  );
struct evp_pkey_ctx_st* EVP_PKEY_CTX_new_id(int id, struct engine_st* e  );
struct evp_pkey_ctx_st* EVP_PKEY_CTX_new_from_name(struct ossl_lib_ctx_st* libctx  , const char* name, const char* propquery);
struct evp_pkey_ctx_st* EVP_PKEY_CTX_new_from_pkey(struct ossl_lib_ctx_st* libctx  , struct evp_pkey_st* pkey  , const char* propquery);
struct evp_pkey_ctx_st* EVP_PKEY_CTX_dup(const struct evp_pkey_ctx_st* ctx  );
void EVP_PKEY_CTX_free(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_CTX_is_a(struct evp_pkey_ctx_st* ctx  , const char* keytype);
int EVP_PKEY_CTX_get_params(struct evp_pkey_ctx_st* ctx  , struct ossl_param_st* params  );
const struct ossl_param_st* EVP_PKEY_CTX_gettable_params(const struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_CTX_set_params(struct evp_pkey_ctx_st* ctx  , const struct ossl_param_st* params  );
const struct ossl_param_st* EVP_PKEY_CTX_settable_params(const struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_CTX_set_algor_params(struct evp_pkey_ctx_st* ctx  , const struct X509_algor_st* alg  );
int EVP_PKEY_CTX_get_algor_params(struct evp_pkey_ctx_st* ctx  , struct X509_algor_st* alg  );
int EVP_PKEY_CTX_get_algor(struct evp_pkey_ctx_st* ctx  , struct X509_algor_st** alg  );
int EVP_PKEY_CTX_ctrl(struct evp_pkey_ctx_st* ctx  , int keytype, int optype, int cmd, int p1, void* p2);
int EVP_PKEY_CTX_ctrl_str(struct evp_pkey_ctx_st* ctx  , const char* type, const char* value);
int EVP_PKEY_CTX_ctrl_uint64(struct evp_pkey_ctx_st* ctx  , int keytype, int optype, int cmd, unsigned long  int value  );
int EVP_PKEY_CTX_str2ctrl(struct evp_pkey_ctx_st* ctx  , int cmd, const char* str);
int EVP_PKEY_CTX_hex2ctrl(struct evp_pkey_ctx_st* ctx  , int cmd, const char* hex);
int EVP_PKEY_CTX_md(struct evp_pkey_ctx_st* ctx  , int optype, int cmd, const char* md);
int EVP_PKEY_CTX_get_operation(struct evp_pkey_ctx_st* ctx  );
void EVP_PKEY_CTX_set0_keygen_info(struct evp_pkey_ctx_st* ctx  , int* dat, int datlen);
struct evp_pkey_st* EVP_PKEY_new_mac_key(int type, struct engine_st* e  , const unsigned char* key, int keylen);
struct evp_pkey_st* EVP_PKEY_new_raw_private_key_ex(struct ossl_lib_ctx_st* libctx  , const char* keytype, const char* propq, const unsigned char* priv, unsigned long len  );
struct evp_pkey_st* EVP_PKEY_new_raw_private_key(int type, struct engine_st* e  , const unsigned char* priv, unsigned long len  );
struct evp_pkey_st* EVP_PKEY_new_raw_public_key_ex(struct ossl_lib_ctx_st* libctx  , const char* keytype, const char* propq, const unsigned char* pub, unsigned long len  );
struct evp_pkey_st* EVP_PKEY_new_raw_public_key(int type, struct engine_st* e  , const unsigned char* pub, unsigned long len  );
int EVP_PKEY_get_raw_private_key(const struct evp_pkey_st* pkey  , unsigned char* priv, unsigned long* len  );
int EVP_PKEY_get_raw_public_key(const struct evp_pkey_st* pkey  , unsigned char* pub, unsigned long* len  );
struct evp_pkey_st* EVP_PKEY_new_CMAC_key(struct engine_st* e  , const unsigned char* priv, unsigned long len  , const struct evp_cipher_st* cipher  );
void EVP_PKEY_CTX_set_data(struct evp_pkey_ctx_st* ctx  , void* data);
void* EVP_PKEY_CTX_get_data(const struct evp_pkey_ctx_st* ctx  );
struct evp_pkey_st* EVP_PKEY_CTX_get0_pkey(struct evp_pkey_ctx_st* ctx  );
struct evp_pkey_st* EVP_PKEY_CTX_get0_peerkey(struct evp_pkey_ctx_st* ctx  );
void EVP_PKEY_CTX_set_app_data(struct evp_pkey_ctx_st* ctx  , void* data);
void* EVP_PKEY_CTX_get_app_data(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_CTX_set_signature(struct evp_pkey_ctx_st* pctx  , const unsigned char* sig, unsigned long siglen  );
void EVP_SIGNATURE_free(struct evp_signature_st* signature  );
int EVP_SIGNATURE_up_ref(struct evp_signature_st* signature  );
struct ossl_provider_st* EVP_SIGNATURE_get0_provider(const struct evp_signature_st* signature  );
struct evp_signature_st* EVP_SIGNATURE_fetch(struct ossl_lib_ctx_st* ctx  , const char* algorithm, const char* properties);
int EVP_SIGNATURE_is_a(const struct evp_signature_st* signature  , const char* name);
const char* EVP_SIGNATURE_get0_name(const struct evp_signature_st* signature  );
const char* EVP_SIGNATURE_get0_description(const struct evp_signature_st* signature  );
void EVP_SIGNATURE_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_signature_st*,void*), void* data);
int EVP_SIGNATURE_names_do_all(const struct evp_signature_st* signature  , void (*fn)(const char*,void*), void* data);
const struct ossl_param_st* EVP_SIGNATURE_gettable_ctx_params(const struct evp_signature_st* sig  );
const struct ossl_param_st* EVP_SIGNATURE_settable_ctx_params(const struct evp_signature_st* sig  );
void EVP_ASYM_CIPHER_free(struct evp_asym_cipher_st* cipher  );
int EVP_ASYM_CIPHER_up_ref(struct evp_asym_cipher_st* cipher  );
struct ossl_provider_st* EVP_ASYM_CIPHER_get0_provider(const struct evp_asym_cipher_st* cipher  );
struct evp_asym_cipher_st* EVP_ASYM_CIPHER_fetch(struct ossl_lib_ctx_st* ctx  , const char* algorithm, const char* properties);
int EVP_ASYM_CIPHER_is_a(const struct evp_asym_cipher_st* cipher  , const char* name);
const char* EVP_ASYM_CIPHER_get0_name(const struct evp_asym_cipher_st* cipher  );
const char* EVP_ASYM_CIPHER_get0_description(const struct evp_asym_cipher_st* cipher  );
void EVP_ASYM_CIPHER_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_asym_cipher_st*,void*), void* arg);
int EVP_ASYM_CIPHER_names_do_all(const struct evp_asym_cipher_st* cipher  , void (*fn)(const char*,void*), void* data);
const struct ossl_param_st* EVP_ASYM_CIPHER_gettable_ctx_params(const struct evp_asym_cipher_st* ciph  );
const struct ossl_param_st* EVP_ASYM_CIPHER_settable_ctx_params(const struct evp_asym_cipher_st* ciph  );
void EVP_KEM_free(struct evp_kem_st* wrap  );
int EVP_KEM_up_ref(struct evp_kem_st* wrap  );
struct ossl_provider_st* EVP_KEM_get0_provider(const struct evp_kem_st* wrap  );
struct evp_kem_st* EVP_KEM_fetch(struct ossl_lib_ctx_st* ctx  , const char* algorithm, const char* properties);
int EVP_KEM_is_a(const struct evp_kem_st* wrap  , const char* name);
const char* EVP_KEM_get0_name(const struct evp_kem_st* wrap  );
const char* EVP_KEM_get0_description(const struct evp_kem_st* wrap  );
void EVP_KEM_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_kem_st*,void*), void* arg);
int EVP_KEM_names_do_all(const struct evp_kem_st* wrap  , void (*fn)(const char*,void*), void* data);
const struct ossl_param_st* EVP_KEM_gettable_ctx_params(const struct evp_kem_st* kem  );
const struct ossl_param_st* EVP_KEM_settable_ctx_params(const struct evp_kem_st* kem  );
int EVP_PKEY_sign_init(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_sign_init_ex(struct evp_pkey_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_PKEY_sign_init_ex2(struct evp_pkey_ctx_st* ctx  , struct evp_signature_st* algo  , const struct ossl_param_st params[]  );
int EVP_PKEY_sign(struct evp_pkey_ctx_st* ctx  , unsigned char* sig, unsigned long* siglen  , const unsigned char* tbs, unsigned long tbslen  );
int EVP_PKEY_sign_message_init(struct evp_pkey_ctx_st* ctx  , struct evp_signature_st* algo  , const struct ossl_param_st params[]  );
int EVP_PKEY_sign_message_update(struct evp_pkey_ctx_st* ctx  , const unsigned char* in, unsigned long inlen  );
int EVP_PKEY_sign_message_final(struct evp_pkey_ctx_st* ctx  , unsigned char* sig, unsigned long* siglen  );
int EVP_PKEY_verify_init(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_verify_init_ex(struct evp_pkey_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_PKEY_verify_init_ex2(struct evp_pkey_ctx_st* ctx  , struct evp_signature_st* algo  , const struct ossl_param_st params[]  );
int EVP_PKEY_verify(struct evp_pkey_ctx_st* ctx  , const unsigned char* sig, unsigned long siglen  , const unsigned char* tbs, unsigned long tbslen  );
int EVP_PKEY_verify_message_init(struct evp_pkey_ctx_st* ctx  , struct evp_signature_st* algo  , const struct ossl_param_st params[]  );
int EVP_PKEY_verify_message_update(struct evp_pkey_ctx_st* ctx  , const unsigned char* in, unsigned long inlen  );
int EVP_PKEY_verify_message_final(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_verify_recover_init(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_verify_recover_init_ex(struct evp_pkey_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_PKEY_verify_recover_init_ex2(struct evp_pkey_ctx_st* ctx  , struct evp_signature_st* algo  , const struct ossl_param_st params[]  );
int EVP_PKEY_verify_recover(struct evp_pkey_ctx_st* ctx  , unsigned char* rout, unsigned long* routlen  , const unsigned char* sig, unsigned long siglen  );
int EVP_PKEY_encrypt_init(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_encrypt_init_ex(struct evp_pkey_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_PKEY_encrypt(struct evp_pkey_ctx_st* ctx  , unsigned char* out, unsigned long* outlen  , const unsigned char* in, unsigned long inlen  );
int EVP_PKEY_decrypt_init(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_decrypt_init_ex(struct evp_pkey_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_PKEY_decrypt(struct evp_pkey_ctx_st* ctx  , unsigned char* out, unsigned long* outlen  , const unsigned char* in, unsigned long inlen  );
int EVP_PKEY_derive_init(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_derive_init_ex(struct evp_pkey_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_PKEY_derive_set_peer_ex(struct evp_pkey_ctx_st* ctx  , struct evp_pkey_st* peer  , int validate_peer);
int EVP_PKEY_derive_set_peer(struct evp_pkey_ctx_st* ctx  , struct evp_pkey_st* peer  );
int EVP_PKEY_derive(struct evp_pkey_ctx_st* ctx  , unsigned char* key, unsigned long* keylen  );
int EVP_PKEY_encapsulate_init(struct evp_pkey_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_PKEY_auth_encapsulate_init(struct evp_pkey_ctx_st* ctx  , struct evp_pkey_st* authpriv  , const struct ossl_param_st params[]  );
int EVP_PKEY_encapsulate(struct evp_pkey_ctx_st* ctx  , unsigned char* wrappedkey, unsigned long* wrappedkeylen  , unsigned char* genkey, unsigned long* genkeylen  );
int EVP_PKEY_decapsulate_init(struct evp_pkey_ctx_st* ctx  , const struct ossl_param_st params[]  );
int EVP_PKEY_auth_decapsulate_init(struct evp_pkey_ctx_st* ctx  , struct evp_pkey_st* authpub  , const struct ossl_param_st params[]  );
int EVP_PKEY_decapsulate(struct evp_pkey_ctx_st* ctx  , unsigned char* unwrapped, unsigned long* unwrappedlen  , const unsigned char* wrapped, unsigned long wrappedlen  );
int EVP_PKEY_fromdata_init(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_fromdata(struct evp_pkey_ctx_st* ctx  , struct evp_pkey_st** ppkey  , int selection, struct ossl_param_st param[]  );
const struct ossl_param_st* EVP_PKEY_fromdata_settable(struct evp_pkey_ctx_st* ctx  , int selection);
int EVP_PKEY_todata(const struct evp_pkey_st* pkey  , int selection, struct ossl_param_st** params  );
int EVP_PKEY_export(const struct evp_pkey_st* pkey  , int selection, int (*(*export_cb))(const struct ossl_param_st,void*)  , void* export_cbarg);
const struct ossl_param_st* EVP_PKEY_gettable_params(const struct evp_pkey_st* pkey  );
int EVP_PKEY_get_params(const struct evp_pkey_st* pkey  , struct ossl_param_st params[]  );
int EVP_PKEY_get_int_param(const struct evp_pkey_st* pkey  , const char* key_name, int* out);
int EVP_PKEY_get_size_t_param(const struct evp_pkey_st* pkey  , const char* key_name, unsigned long* out  );
int EVP_PKEY_get_bn_param(const struct evp_pkey_st* pkey  , const char* key_name, struct bignum_st** bn  );
int EVP_PKEY_get_utf8_string_param(const struct evp_pkey_st* pkey  , const char* key_name, char* str, unsigned long max_buf_sz  , unsigned long* out_sz  );
int EVP_PKEY_get_octet_string_param(const struct evp_pkey_st* pkey  , const char* key_name, unsigned char* buf, unsigned long max_buf_sz  , unsigned long* out_sz  );
const struct ossl_param_st* EVP_PKEY_settable_params(const struct evp_pkey_st* pkey  );
int EVP_PKEY_set_params(struct evp_pkey_st* pkey  , struct ossl_param_st params[]  );
int EVP_PKEY_set_int_param(struct evp_pkey_st* pkey  , const char* key_name, int in);
int EVP_PKEY_set_size_t_param(struct evp_pkey_st* pkey  , const char* key_name, unsigned long in  );
int EVP_PKEY_set_bn_param(struct evp_pkey_st* pkey  , const char* key_name, const struct bignum_st* bn  );
int EVP_PKEY_set_utf8_string_param(struct evp_pkey_st* pkey  , const char* key_name, const char* str);
int EVP_PKEY_set_octet_string_param(struct evp_pkey_st* pkey  , const char* key_name, const unsigned char* buf, unsigned long bsize  );
int EVP_PKEY_get_ec_point_conv_form(const struct evp_pkey_st* pkey  );
int EVP_PKEY_get_field_type(const struct evp_pkey_st* pkey  );
struct evp_pkey_st* EVP_PKEY_Q_keygen(struct ossl_lib_ctx_st* libctx  , const char* propq, const char* type, ...);
int EVP_PKEY_paramgen_init(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_paramgen(struct evp_pkey_ctx_st* ctx  , struct evp_pkey_st** ppkey  );
int EVP_PKEY_keygen_init(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_keygen(struct evp_pkey_ctx_st* ctx  , struct evp_pkey_st** ppkey  );
int EVP_PKEY_generate(struct evp_pkey_ctx_st* ctx  , struct evp_pkey_st** ppkey  );
int EVP_PKEY_check(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_public_check(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_public_check_quick(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_param_check(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_param_check_quick(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_private_check(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_pairwise_check(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_set_ex_data(struct evp_pkey_st* key  , int idx, void* arg);
void* EVP_PKEY_get_ex_data(const struct evp_pkey_st* key  , int idx);
void EVP_PKEY_CTX_set_cb(struct evp_pkey_ctx_st* ctx  , int (*(*cb))(struct evp_pkey_ctx_st*)  );
int (*(*EVP_PKEY_CTX_get_cb(struct evp_pkey_ctx_st* ctx  )))(struct evp_pkey_ctx_st*) ;
int EVP_PKEY_CTX_get_keygen_info(struct evp_pkey_ctx_st* ctx  , int idx);
void EVP_PKEY_meth_set_init(struct evp_pkey_method_st* pmeth  , int (*init)(struct evp_pkey_ctx_st*));
void EVP_PKEY_meth_set_copy(struct evp_pkey_method_st* pmeth  , int (*copy)(struct evp_pkey_ctx_st*,const struct evp_pkey_ctx_st*));
void EVP_PKEY_meth_set_cleanup(struct evp_pkey_method_st* pmeth  , void (*cleanup)(struct evp_pkey_ctx_st*));
void EVP_PKEY_meth_set_paramgen(struct evp_pkey_method_st* pmeth  , int (*paramgen_init)(struct evp_pkey_ctx_st*), int (*paramgen)(struct evp_pkey_ctx_st*,struct evp_pkey_st*));
void EVP_PKEY_meth_set_keygen(struct evp_pkey_method_st* pmeth  , int (*keygen_init)(struct evp_pkey_ctx_st*), int (*keygen)(struct evp_pkey_ctx_st*,struct evp_pkey_st*));
void EVP_PKEY_meth_set_sign(struct evp_pkey_method_st* pmeth  , int (*sign_init)(struct evp_pkey_ctx_st*), int (*sign)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_set_verify(struct evp_pkey_method_st* pmeth  , int (*verify_init)(struct evp_pkey_ctx_st*), int (*verify)(struct evp_pkey_ctx_st*,const unsigned char*,unsigned long,const unsigned char*,unsigned long));
void EVP_PKEY_meth_set_verify_recover(struct evp_pkey_method_st* pmeth  , int (*verify_recover_init)(struct evp_pkey_ctx_st*), int (*verify_recover)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_set_signctx(struct evp_pkey_method_st* pmeth  , int (*signctx_init)(struct evp_pkey_ctx_st*,struct evp_md_ctx_st*), int (*signctx)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,struct evp_md_ctx_st*));
void EVP_PKEY_meth_set_verifyctx(struct evp_pkey_method_st* pmeth  , int (*verifyctx_init)(struct evp_pkey_ctx_st*,struct evp_md_ctx_st*), int (*verifyctx)(struct evp_pkey_ctx_st*,const unsigned char*,int,struct evp_md_ctx_st*));
void EVP_PKEY_meth_set_encrypt(struct evp_pkey_method_st* pmeth  , int (*encrypt_init)(struct evp_pkey_ctx_st*), int (*encryptfn)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_set_decrypt(struct evp_pkey_method_st* pmeth  , int (*decrypt_init)(struct evp_pkey_ctx_st*), int (*decrypt)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_set_derive(struct evp_pkey_method_st* pmeth  , int (*derive_init)(struct evp_pkey_ctx_st*), int (*derive)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*));
void EVP_PKEY_meth_set_ctrl(struct evp_pkey_method_st* pmeth  , int (*ctrl)(struct evp_pkey_ctx_st*,int,int,void*), int (*ctrl_str)(struct evp_pkey_ctx_st*,const char*,const char*));
void EVP_PKEY_meth_set_digestsign(struct evp_pkey_method_st* pmeth  , int (*digestsign)(struct evp_md_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_set_digestverify(struct evp_pkey_method_st* pmeth  , int (*digestverify)(struct evp_md_ctx_st*,const unsigned char*,unsigned long,const unsigned char*,unsigned long));
void EVP_PKEY_meth_set_check(struct evp_pkey_method_st* pmeth  , int (*check)(struct evp_pkey_st*));
void EVP_PKEY_meth_set_public_check(struct evp_pkey_method_st* pmeth  , int (*check)(struct evp_pkey_st*));
void EVP_PKEY_meth_set_param_check(struct evp_pkey_method_st* pmeth  , int (*check)(struct evp_pkey_st*));
void EVP_PKEY_meth_set_digest_custom(struct evp_pkey_method_st* pmeth  , int (*digest_custom)(struct evp_pkey_ctx_st*,struct evp_md_ctx_st*));
void EVP_PKEY_meth_get_init(const struct evp_pkey_method_st* pmeth  , int (**pinit)(struct evp_pkey_ctx_st*));
void EVP_PKEY_meth_get_copy(const struct evp_pkey_method_st* pmeth  , int (**pcopy)(struct evp_pkey_ctx_st*,const struct evp_pkey_ctx_st*));
void EVP_PKEY_meth_get_cleanup(const struct evp_pkey_method_st* pmeth  , void (**pcleanup)(struct evp_pkey_ctx_st*));
void EVP_PKEY_meth_get_paramgen(const struct evp_pkey_method_st* pmeth  , int (**pparamgen_init)(struct evp_pkey_ctx_st*), int (**pparamgen)(struct evp_pkey_ctx_st*,struct evp_pkey_st*));
void EVP_PKEY_meth_get_keygen(const struct evp_pkey_method_st* pmeth  , int (**pkeygen_init)(struct evp_pkey_ctx_st*), int (**pkeygen)(struct evp_pkey_ctx_st*,struct evp_pkey_st*));
void EVP_PKEY_meth_get_sign(const struct evp_pkey_method_st* pmeth  , int (**psign_init)(struct evp_pkey_ctx_st*), int (**psign)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_get_verify(const struct evp_pkey_method_st* pmeth  , int (**pverify_init)(struct evp_pkey_ctx_st*), int (**pverify)(struct evp_pkey_ctx_st*,const unsigned char*,unsigned long,const unsigned char*,unsigned long));
void EVP_PKEY_meth_get_verify_recover(const struct evp_pkey_method_st* pmeth  , int (**pverify_recover_init)(struct evp_pkey_ctx_st*), int (**pverify_recover)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_get_signctx(const struct evp_pkey_method_st* pmeth  , int (**psignctx_init)(struct evp_pkey_ctx_st*,struct evp_md_ctx_st*), int (**psignctx)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,struct evp_md_ctx_st*));
void EVP_PKEY_meth_get_verifyctx(const struct evp_pkey_method_st* pmeth  , int (**pverifyctx_init)(struct evp_pkey_ctx_st*,struct evp_md_ctx_st*), int (**pverifyctx)(struct evp_pkey_ctx_st*,const unsigned char*,int,struct evp_md_ctx_st*));
void EVP_PKEY_meth_get_encrypt(const struct evp_pkey_method_st* pmeth  , int (**pencrypt_init)(struct evp_pkey_ctx_st*), int (**pencryptfn)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_get_decrypt(const struct evp_pkey_method_st* pmeth  , int (**pdecrypt_init)(struct evp_pkey_ctx_st*), int (**pdecrypt)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_get_derive(const struct evp_pkey_method_st* pmeth  , int (**pderive_init)(struct evp_pkey_ctx_st*), int (**pderive)(struct evp_pkey_ctx_st*,unsigned char*,unsigned long*));
void EVP_PKEY_meth_get_ctrl(const struct evp_pkey_method_st* pmeth  , int (**pctrl)(struct evp_pkey_ctx_st*,int,int,void*), int (**pctrl_str)(struct evp_pkey_ctx_st*,const char*,const char*));
void EVP_PKEY_meth_get_digestsign(const struct evp_pkey_method_st* pmeth  , int (**digestsign)(struct evp_md_ctx_st*,unsigned char*,unsigned long*,const unsigned char*,unsigned long));
void EVP_PKEY_meth_get_digestverify(const struct evp_pkey_method_st* pmeth  , int (**digestverify)(struct evp_md_ctx_st*,const unsigned char*,unsigned long,const unsigned char*,unsigned long));
void EVP_PKEY_meth_get_check(const struct evp_pkey_method_st* pmeth  , int (**pcheck)(struct evp_pkey_st*));
void EVP_PKEY_meth_get_public_check(const struct evp_pkey_method_st* pmeth  , int (**pcheck)(struct evp_pkey_st*));
void EVP_PKEY_meth_get_param_check(const struct evp_pkey_method_st* pmeth  , int (**pcheck)(struct evp_pkey_st*));
void EVP_PKEY_meth_get_digest_custom(const struct evp_pkey_method_st* pmeth  , int (**pdigest_custom)(struct evp_pkey_ctx_st*,struct evp_md_ctx_st*));
void EVP_KEYEXCH_free(struct evp_keyexch_st* exchange  );
int EVP_KEYEXCH_up_ref(struct evp_keyexch_st* exchange  );
struct evp_keyexch_st* EVP_KEYEXCH_fetch(struct ossl_lib_ctx_st* ctx  , const char* algorithm, const char* properties);
struct ossl_provider_st* EVP_KEYEXCH_get0_provider(const struct evp_keyexch_st* exchange  );
int EVP_KEYEXCH_is_a(const struct evp_keyexch_st* keyexch  , const char* name);
const char* EVP_KEYEXCH_get0_name(const struct evp_keyexch_st* keyexch  );
const char* EVP_KEYEXCH_get0_description(const struct evp_keyexch_st* keyexch  );
void EVP_KEYEXCH_do_all_provided(struct ossl_lib_ctx_st* libctx  , void (*fn)(struct evp_keyexch_st*,void*), void* data);
int EVP_KEYEXCH_names_do_all(const struct evp_keyexch_st* keyexch  , void (*fn)(const char*,void*), void* data);
const struct ossl_param_st* EVP_KEYEXCH_gettable_ctx_params(const struct evp_keyexch_st* keyexch  );
const struct ossl_param_st* EVP_KEYEXCH_settable_ctx_params(const struct evp_keyexch_st* keyexch  );
void EVP_add_alg_module();
int EVP_PKEY_CTX_set_group_name(struct evp_pkey_ctx_st* ctx  , const char* name);
int EVP_PKEY_CTX_get_group_name(struct evp_pkey_ctx_st* ctx  , char* name, unsigned long namelen  );
int EVP_PKEY_get_group_name(const struct evp_pkey_st* pkey  , char* name, unsigned long name_sz  , unsigned long* gname_len  );
struct ossl_lib_ctx_st* EVP_PKEY_CTX_get0_libctx(struct evp_pkey_ctx_st* ctx  );
const char* EVP_PKEY_CTX_get0_propq(const struct evp_pkey_ctx_st* ctx  );
const struct ossl_provider_st* EVP_PKEY_CTX_get0_provider(const struct evp_pkey_ctx_st* ctx  );
int EVP_SKEY_is_a(const struct evp_skey_st* skey  , const char* name);
struct evp_skey_st* EVP_SKEY_import(struct ossl_lib_ctx_st* libctx  , const char* skeymgmtname, const char* propquery, int selection, const struct ossl_param_st* params  );
struct evp_skey_st* EVP_SKEY_generate(struct ossl_lib_ctx_st* libctx  , const char* skeymgmtname, const char* propquery, const struct ossl_param_st* params  );
struct evp_skey_st* EVP_SKEY_import_raw_key(struct ossl_lib_ctx_st* libctx  , const char* skeymgmtname, unsigned char* key, unsigned long keylen  , const char* propquery);
int EVP_SKEY_get0_raw_key(const struct evp_skey_st* skey  , const unsigned char** key, unsigned long* len  );
const char* EVP_SKEY_get0_key_id(const struct evp_skey_st* skey  );
int EVP_SKEY_export(const struct evp_skey_st* skey  , int selection, int (*(*export_cb))(const struct ossl_param_st,void*)  , void* export_cbarg);
int EVP_SKEY_up_ref(struct evp_skey_st* skey  );
void EVP_SKEY_free(struct evp_skey_st* skey  );
const char* EVP_SKEY_get0_skeymgmt_name(const struct evp_skey_st* skey  );
const char* EVP_SKEY_get0_provider_name(const struct evp_skey_st* skey  );
struct evp_skey_st* EVP_SKEY_to_provider(struct evp_skey_st* skey  , struct ossl_lib_ctx_st* libctx  , struct ossl_provider_st* prov  , const char* propquery);
int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(struct evp_pkey_ctx_st* ctx  , int nid);
int EVP_PKEY_CTX_set_ec_param_enc(struct evp_pkey_ctx_st* ctx  , int param_enc);
int EVP_PKEY_CTX_set_ecdh_cofactor_mode(struct evp_pkey_ctx_st* ctx  , int cofactor_mode);
int EVP_PKEY_CTX_get_ecdh_cofactor_mode(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_CTX_set_ecdh_kdf_type(struct evp_pkey_ctx_st* ctx  , int kdf);
int EVP_PKEY_CTX_get_ecdh_kdf_type(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_CTX_set_ecdh_kdf_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st* md  );
int EVP_PKEY_CTX_get_ecdh_kdf_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st** md  );
int EVP_PKEY_CTX_set_ecdh_kdf_outlen(struct evp_pkey_ctx_st* ctx  , int len);
int EVP_PKEY_CTX_get_ecdh_kdf_outlen(struct evp_pkey_ctx_st* ctx  , int* len);
int EVP_PKEY_CTX_set0_ecdh_kdf_ukm(struct evp_pkey_ctx_st* ctx  , unsigned char* ukm, int len);
int EVP_PKEY_CTX_get0_ecdh_kdf_ukm(struct evp_pkey_ctx_st* ctx  , unsigned char** ukm);
const char* OSSL_EC_curve_nid2name(int nid);
const struct ec_method_st* EC_GFp_simple_method();
const struct ec_method_st* EC_GFp_mont_method();
const struct ec_method_st* EC_GFp_nist_method();
const struct ec_method_st* EC_GFp_nistp224_method();
const struct ec_method_st* EC_GFp_nistp256_method();
const struct ec_method_st* EC_GFp_nistp521_method();
struct ec_group_st* EC_GROUP_new(const struct ec_method_st* meth  );
void EC_GROUP_clear_free(struct ec_group_st* group  );
const struct ec_method_st* EC_GROUP_method_of(const struct ec_group_st* group  );
int EC_METHOD_get_field_type(const struct ec_method_st* meth  );
void EC_GROUP_free(struct ec_group_st* group  );
int EC_GROUP_copy(struct ec_group_st* dst  , const struct ec_group_st* src  );
struct ec_group_st* EC_GROUP_dup(const struct ec_group_st* src  );
int EC_GROUP_set_generator(struct ec_group_st* group  , const struct ec_point_st* generator  , const struct bignum_st* order  , const struct bignum_st* cofactor  );
const struct ec_point_st* EC_GROUP_get0_generator(const struct ec_group_st* group  );
struct bn_mont_ctx_st* EC_GROUP_get_mont_data(const struct ec_group_st* group  );
int EC_GROUP_get_order(const struct ec_group_st* group  , struct bignum_st* order  , struct bignum_ctx* ctx  );
const struct bignum_st* EC_GROUP_get0_order(const struct ec_group_st* group  );
int EC_GROUP_order_bits(const struct ec_group_st* group  );
int EC_GROUP_get_cofactor(const struct ec_group_st* group  , struct bignum_st* cofactor  , struct bignum_ctx* ctx  );
const struct bignum_st* EC_GROUP_get0_cofactor(const struct ec_group_st* group  );
void EC_GROUP_set_curve_name(struct ec_group_st* group  , int nid);
int EC_GROUP_get_curve_name(const struct ec_group_st* group  );
const struct bignum_st* EC_GROUP_get0_field(const struct ec_group_st* group  );
int EC_GROUP_get_field_type(const struct ec_group_st* group  );
void EC_GROUP_set_asn1_flag(struct ec_group_st* group  , int flag);
int EC_GROUP_get_asn1_flag(const struct ec_group_st* group  );
void EC_GROUP_set_point_conversion_form(struct ec_group_st* group  , enum anonymous_typeY38 form  );
enum anonymous_typeY38 EC_GROUP_get_point_conversion_form(const struct ec_group_st*   );
unsigned char* EC_GROUP_get0_seed(const struct ec_group_st* x  );
unsigned long EC_GROUP_get_seed_len(const struct ec_group_st*   );
unsigned long EC_GROUP_set_seed(struct ec_group_st*   , const unsigned char* , unsigned long len  );
int EC_GROUP_set_curve(struct ec_group_st* group  , const struct bignum_st* p  , const struct bignum_st* a  , const struct bignum_st* b  , struct bignum_ctx* ctx  );
int EC_GROUP_get_curve(const struct ec_group_st* group  , struct bignum_st* p  , struct bignum_st* a  , struct bignum_st* b  , struct bignum_ctx* ctx  );
int EC_GROUP_set_curve_GFp(struct ec_group_st* group  , const struct bignum_st* p  , const struct bignum_st* a  , const struct bignum_st* b  , struct bignum_ctx* ctx  );
int EC_GROUP_get_curve_GFp(const struct ec_group_st* group  , struct bignum_st* p  , struct bignum_st* a  , struct bignum_st* b  , struct bignum_ctx* ctx  );
int EC_GROUP_get_degree(const struct ec_group_st* group  );
int EC_GROUP_check(const struct ec_group_st* group  , struct bignum_ctx* ctx  );
int EC_GROUP_check_discriminant(const struct ec_group_st* group  , struct bignum_ctx* ctx  );
int EC_GROUP_cmp(const struct ec_group_st* a  , const struct ec_group_st* b  , struct bignum_ctx* ctx  );
struct ec_group_st* EC_GROUP_new_curve_GFp(const struct bignum_st* p  , const struct bignum_st* a  , const struct bignum_st* b  , struct bignum_ctx* ctx  );
struct ec_group_st* EC_GROUP_new_from_params(const struct ossl_param_st params[]  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct ossl_param_st* EC_GROUP_to_params(const struct ec_group_st* group  , struct ossl_lib_ctx_st* libctx  , const char* propq, struct bignum_ctx* bnctx  );
struct ec_group_st* EC_GROUP_new_by_curve_name_ex(struct ossl_lib_ctx_st* libctx  , const char* propq, int nid);
struct ec_group_st* EC_GROUP_new_by_curve_name(int nid);
struct ec_group_st* EC_GROUP_new_from_ecparameters(const struct ec_parameters_st* params  );
struct ec_parameters_st* EC_GROUP_get_ecparameters(const struct ec_group_st* group  , struct ec_parameters_st* params  );
struct ec_group_st* EC_GROUP_new_from_ecpkparameters(const struct ecpk_parameters_st* params  );
struct ecpk_parameters_st* EC_GROUP_get_ecpkparameters(const struct ec_group_st* group  , struct ecpk_parameters_st* params  );
unsigned long EC_get_builtin_curves(struct anonymous_typeX39* r  , unsigned long nitems  );
const char* EC_curve_nid2nist(int nid);
int EC_curve_nist2nid(const char* name);
int EC_GROUP_check_named_curve(const struct ec_group_st* group  , int nist_only, struct bignum_ctx* ctx  );
struct ec_point_st* EC_POINT_new(const struct ec_group_st* group  );
void EC_POINT_free(struct ec_point_st* point  );
void EC_POINT_clear_free(struct ec_point_st* point  );
int EC_POINT_copy(struct ec_point_st* dst  , const struct ec_point_st* src  );
struct ec_point_st* EC_POINT_dup(const struct ec_point_st* src  , const struct ec_group_st* group  );
int EC_POINT_set_to_infinity(const struct ec_group_st* group  , struct ec_point_st* point  );
const struct ec_method_st* EC_POINT_method_of(const struct ec_point_st* point  );
int EC_POINT_set_Jprojective_coordinates_GFp(const struct ec_group_st* group  , struct ec_point_st* p  , const struct bignum_st* x  , const struct bignum_st* y  , const struct bignum_st* z  , struct bignum_ctx* ctx  );
int EC_POINT_get_Jprojective_coordinates_GFp(const struct ec_group_st* group  , const struct ec_point_st* p  , struct bignum_st* x  , struct bignum_st* y  , struct bignum_st* z  , struct bignum_ctx* ctx  );
int EC_POINT_set_affine_coordinates(const struct ec_group_st* group  , struct ec_point_st* p  , const struct bignum_st* x  , const struct bignum_st* y  , struct bignum_ctx* ctx  );
int EC_POINT_get_affine_coordinates(const struct ec_group_st* group  , const struct ec_point_st* p  , struct bignum_st* x  , struct bignum_st* y  , struct bignum_ctx* ctx  );
int EC_POINT_set_affine_coordinates_GFp(const struct ec_group_st* group  , struct ec_point_st* p  , const struct bignum_st* x  , const struct bignum_st* y  , struct bignum_ctx* ctx  );
int EC_POINT_get_affine_coordinates_GFp(const struct ec_group_st* group  , const struct ec_point_st* p  , struct bignum_st* x  , struct bignum_st* y  , struct bignum_ctx* ctx  );
int EC_POINT_set_compressed_coordinates(const struct ec_group_st* group  , struct ec_point_st* p  , const struct bignum_st* x  , int y_bit, struct bignum_ctx* ctx  );
int EC_POINT_set_compressed_coordinates_GFp(const struct ec_group_st* group  , struct ec_point_st* p  , const struct bignum_st* x  , int y_bit, struct bignum_ctx* ctx  );
unsigned long EC_POINT_point2oct(const struct ec_group_st* group  , const struct ec_point_st* p  , enum anonymous_typeY38 form  , unsigned char* buf, unsigned long len  , struct bignum_ctx* ctx  );
int EC_POINT_oct2point(const struct ec_group_st* group  , struct ec_point_st* p  , const unsigned char* buf, unsigned long len  , struct bignum_ctx* ctx  );
unsigned long EC_POINT_point2buf(const struct ec_group_st* group  , const struct ec_point_st* point  , enum anonymous_typeY38 form  , unsigned char** pbuf, struct bignum_ctx* ctx  );
struct bignum_st* EC_POINT_point2bn(const struct ec_group_st*   , const struct ec_point_st*   , enum anonymous_typeY38 form  , struct bignum_st*   , struct bignum_ctx*   );
struct ec_point_st* EC_POINT_bn2point(const struct ec_group_st*   , const struct bignum_st*   , struct ec_point_st*   , struct bignum_ctx*   );
char* EC_POINT_point2hex(const struct ec_group_st*   , const struct ec_point_st*   , enum anonymous_typeY38 form  , struct bignum_ctx*   );
struct ec_point_st* EC_POINT_hex2point(const struct ec_group_st*   , const char* , struct ec_point_st*   , struct bignum_ctx*   );
int EC_POINT_add(const struct ec_group_st* group  , struct ec_point_st* r  , const struct ec_point_st* a  , const struct ec_point_st* b  , struct bignum_ctx* ctx  );
int EC_POINT_dbl(const struct ec_group_st* group  , struct ec_point_st* r  , const struct ec_point_st* a  , struct bignum_ctx* ctx  );
int EC_POINT_invert(const struct ec_group_st* group  , struct ec_point_st* a  , struct bignum_ctx* ctx  );
int EC_POINT_is_at_infinity(const struct ec_group_st* group  , const struct ec_point_st* p  );
int EC_POINT_is_on_curve(const struct ec_group_st* group  , const struct ec_point_st* point  , struct bignum_ctx* ctx  );
int EC_POINT_cmp(const struct ec_group_st* group  , const struct ec_point_st* a  , const struct ec_point_st* b  , struct bignum_ctx* ctx  );
int EC_POINT_make_affine(const struct ec_group_st* group  , struct ec_point_st* point  , struct bignum_ctx* ctx  );
int EC_POINTs_make_affine(const struct ec_group_st* group  , unsigned long num  , struct ec_point_st* points[]  , struct bignum_ctx* ctx  );
int EC_POINTs_mul(const struct ec_group_st* group  , struct ec_point_st* r  , const struct bignum_st* n  , unsigned long num  , const struct ec_point_st* p[]  , const struct bignum_st* m[]  , struct bignum_ctx* ctx  );
int EC_POINT_mul(const struct ec_group_st* group  , struct ec_point_st* r  , const struct bignum_st* n  , const struct ec_point_st* q  , const struct bignum_st* m  , struct bignum_ctx* ctx  );
int EC_GROUP_precompute_mult(struct ec_group_st* group  , struct bignum_ctx* ctx  );
int EC_GROUP_have_precompute_mult(const struct ec_group_st* group  );
const struct ASN1_ITEM_st* ECPKPARAMETERS_it();
struct ecpk_parameters_st* ECPKPARAMETERS_new();
void ECPKPARAMETERS_free(struct ecpk_parameters_st* a  );
const struct ASN1_ITEM_st* ECPARAMETERS_it();
struct ec_parameters_st* ECPARAMETERS_new();
void ECPARAMETERS_free(struct ec_parameters_st* a  );
int EC_GROUP_get_basis_type(const struct ec_group_st*   );
struct ec_group_st* d2i_ECPKParameters(struct ec_group_st**   , const unsigned char** in, long len);
int i2d_ECPKParameters(const struct ec_group_st*   , unsigned char** out);
int ECPKParameters_print(struct bio_st* bp  , const struct ec_group_st* x  , int off);
int ECPKParameters_print_fp(struct _IO_FILE* fp  , const struct ec_group_st* x  , int off);
struct ec_key_st* EC_KEY_new_ex(struct ossl_lib_ctx_st* ctx  , const char* propq);
struct ec_key_st* EC_KEY_new();
int EC_KEY_get_flags(const struct ec_key_st* key  );
void EC_KEY_set_flags(struct ec_key_st* key  , int flags);
void EC_KEY_clear_flags(struct ec_key_st* key  , int flags);
int EC_KEY_decoded_from_explicit_params(const struct ec_key_st* key  );
struct ec_key_st* EC_KEY_new_by_curve_name_ex(struct ossl_lib_ctx_st* ctx  , const char* propq, int nid);
struct ec_key_st* EC_KEY_new_by_curve_name(int nid);
void EC_KEY_free(struct ec_key_st* key  );
struct ec_key_st* EC_KEY_copy(struct ec_key_st* dst  , const struct ec_key_st* src  );
struct ec_key_st* EC_KEY_dup(const struct ec_key_st* src  );
int EC_KEY_up_ref(struct ec_key_st* key  );
struct engine_st* EC_KEY_get0_engine(const struct ec_key_st* eckey  );
const struct ec_group_st* EC_KEY_get0_group(const struct ec_key_st* key  );
int EC_KEY_set_group(struct ec_key_st* key  , const struct ec_group_st* group  );
const struct bignum_st* EC_KEY_get0_private_key(const struct ec_key_st* key  );
int EC_KEY_set_private_key(struct ec_key_st* key  , const struct bignum_st* prv  );
const struct ec_point_st* EC_KEY_get0_public_key(const struct ec_key_st* key  );
int EC_KEY_set_public_key(struct ec_key_st* key  , const struct ec_point_st* pub  );
unsigned int EC_KEY_get_enc_flags(const struct ec_key_st* key  );
void EC_KEY_set_enc_flags(struct ec_key_st* eckey  , unsigned int flags);
enum anonymous_typeY38 EC_KEY_get_conv_form(const struct ec_key_st* key  );
void EC_KEY_set_conv_form(struct ec_key_st* eckey  , enum anonymous_typeY38 cform  );
int EC_KEY_set_ex_data(struct ec_key_st* key  , int idx, void* arg);
void* EC_KEY_get_ex_data(const struct ec_key_st* key  , int idx);
void EC_KEY_set_asn1_flag(struct ec_key_st* eckey  , int asn1_flag);
int EC_KEY_precompute_mult(struct ec_key_st* key  , struct bignum_ctx* ctx  );
int EC_KEY_generate_key(struct ec_key_st* key  );
int EC_KEY_check_key(const struct ec_key_st* key  );
int EC_KEY_can_sign(const struct ec_key_st* eckey  );
int EC_KEY_set_public_key_affine_coordinates(struct ec_key_st* key  , struct bignum_st* x  , struct bignum_st* y  );
unsigned long EC_KEY_key2buf(const struct ec_key_st* key  , enum anonymous_typeY38 form  , unsigned char** pbuf, struct bignum_ctx* ctx  );
int EC_KEY_oct2key(struct ec_key_st* key  , const unsigned char* buf, unsigned long len  , struct bignum_ctx* ctx  );
int EC_KEY_oct2priv(struct ec_key_st* key  , const unsigned char* buf, unsigned long len  );
unsigned long EC_KEY_priv2oct(const struct ec_key_st* key  , unsigned char* buf, unsigned long len  );
unsigned long EC_KEY_priv2buf(const struct ec_key_st* eckey  , unsigned char** pbuf);
struct ec_key_st* d2i_ECPrivateKey(struct ec_key_st** key  , const unsigned char** in, long len);
int i2d_ECPrivateKey(const struct ec_key_st* key  , unsigned char** out);
struct ec_key_st* d2i_ECParameters(struct ec_key_st** key  , const unsigned char** in, long len);
int i2d_ECParameters(const struct ec_key_st* key  , unsigned char** out);
struct ec_key_st* o2i_ECPublicKey(struct ec_key_st** key  , const unsigned char** in, long len);
int i2o_ECPublicKey(const struct ec_key_st* key  , unsigned char** out);
int ECParameters_print(struct bio_st* bp  , const struct ec_key_st* key  );
int EC_KEY_print(struct bio_st* bp  , const struct ec_key_st* key  , int off);
int ECParameters_print_fp(struct _IO_FILE* fp  , const struct ec_key_st* key  );
int EC_KEY_print_fp(struct _IO_FILE* fp  , const struct ec_key_st* key  , int off);
const struct ec_key_method_st* EC_KEY_OpenSSL();
const struct ec_key_method_st* EC_KEY_get_default_method();
void EC_KEY_set_default_method(const struct ec_key_method_st* meth  );
const struct ec_key_method_st* EC_KEY_get_method(const struct ec_key_st* key  );
int EC_KEY_set_method(struct ec_key_st* key  , const struct ec_key_method_st* meth  );
struct ec_key_st* EC_KEY_new_method(struct engine_st* engine  );
int ECDH_KDF_X9_62(unsigned char* out, unsigned long outlen  , const unsigned char* Z, unsigned long Zlen  , const unsigned char* sinfo, unsigned long sinfolen  , const struct evp_md_st* md  );
int ECDH_compute_key(void* out, unsigned long outlen  , const struct ec_point_st* pub_key  , const struct ec_key_st* ecdh  , void* (*KDF)(const void*,unsigned long,void*,unsigned long*));
struct ECDSA_SIG_st* ECDSA_SIG_new();
void ECDSA_SIG_free(struct ECDSA_SIG_st* sig  );
struct ECDSA_SIG_st* d2i_ECDSA_SIG(struct ECDSA_SIG_st** a  , const unsigned char** in, long len);
int i2d_ECDSA_SIG(const struct ECDSA_SIG_st* a  , unsigned char** out);
void ECDSA_SIG_get0(const struct ECDSA_SIG_st* sig  , const struct bignum_st** pr  , const struct bignum_st** ps  );
const struct bignum_st* ECDSA_SIG_get0_r(const struct ECDSA_SIG_st* sig  );
const struct bignum_st* ECDSA_SIG_get0_s(const struct ECDSA_SIG_st* sig  );
int ECDSA_SIG_set0(struct ECDSA_SIG_st* sig  , struct bignum_st* r  , struct bignum_st* s  );
struct ECDSA_SIG_st* ECDSA_do_sign(const unsigned char* dgst, int dgst_len, struct ec_key_st* eckey  );
struct ECDSA_SIG_st* ECDSA_do_sign_ex(const unsigned char* dgst, int dgstlen, const struct bignum_st* kinv  , const struct bignum_st* rp  , struct ec_key_st* eckey  );
int ECDSA_do_verify(const unsigned char* dgst, int dgst_len, const struct ECDSA_SIG_st* sig  , struct ec_key_st* eckey  );
int ECDSA_sign_setup(struct ec_key_st* eckey  , struct bignum_ctx* ctx  , struct bignum_st** kinv  , struct bignum_st** rp  );
int ECDSA_sign(int type, const unsigned char* dgst, int dgstlen, unsigned char* sig, unsigned int* siglen, struct ec_key_st* eckey  );
int ECDSA_sign_ex(int type, const unsigned char* dgst, int dgstlen, unsigned char* sig, unsigned int* siglen, const struct bignum_st* kinv  , const struct bignum_st* rp  , struct ec_key_st* eckey  );
int ECDSA_verify(int type, const unsigned char* dgst, int dgstlen, const unsigned char* sig, int siglen, struct ec_key_st* eckey  );
int ECDSA_size(const struct ec_key_st* eckey  );
struct ec_key_method_st* EC_KEY_METHOD_new(const struct ec_key_method_st* meth  );
void EC_KEY_METHOD_free(struct ec_key_method_st* meth  );
void EC_KEY_METHOD_set_init(struct ec_key_method_st* meth  , int (*init)(struct ec_key_st*), void (*finish)(struct ec_key_st*), int (*copy)(struct ec_key_st*,const struct ec_key_st*), int (*set_group)(struct ec_key_st*,const struct ec_group_st*), int (*set_private)(struct ec_key_st*,const struct bignum_st*), int (*set_public)(struct ec_key_st*,const struct ec_point_st*));
void EC_KEY_METHOD_set_keygen(struct ec_key_method_st* meth  , int (*keygen)(struct ec_key_st*));
void EC_KEY_METHOD_set_compute_key(struct ec_key_method_st* meth  , int (*ckey)(unsigned char**,unsigned long*,const struct ec_point_st*,const struct ec_key_st*));
void EC_KEY_METHOD_set_sign(struct ec_key_method_st* meth  , int (*sign)(int,const unsigned char*,int,unsigned char*,unsigned int*,const struct bignum_st*,const struct bignum_st*,struct ec_key_st*), int (*sign_setup)(struct ec_key_st*,struct bignum_ctx*,struct bignum_st**,struct bignum_st**), struct ECDSA_SIG_st* (*sign_sig)(const unsigned char*,int,const struct bignum_st*,const struct bignum_st*,struct ec_key_st*));
void EC_KEY_METHOD_set_verify(struct ec_key_method_st* meth  , int (*verify)(int,const unsigned char*,int,const unsigned char*,int,struct ec_key_st*), int (*verify_sig)(const unsigned char*,int,const struct ECDSA_SIG_st*,struct ec_key_st*));
void EC_KEY_METHOD_get_init(const struct ec_key_method_st* meth  , int (**pinit)(struct ec_key_st*), void (**pfinish)(struct ec_key_st*), int (**pcopy)(struct ec_key_st*,const struct ec_key_st*), int (**pset_group)(struct ec_key_st*,const struct ec_group_st*), int (**pset_private)(struct ec_key_st*,const struct bignum_st*), int (**pset_public)(struct ec_key_st*,const struct ec_point_st*));
void EC_KEY_METHOD_get_keygen(const struct ec_key_method_st* meth  , int (**pkeygen)(struct ec_key_st*));
void EC_KEY_METHOD_get_compute_key(const struct ec_key_method_st* meth  , int (**pck)(unsigned char**,unsigned long*,const struct ec_point_st*,const struct ec_key_st*));
void EC_KEY_METHOD_get_sign(const struct ec_key_method_st* meth  , int (**psign)(int,const unsigned char*,int,unsigned char*,unsigned int*,const struct bignum_st*,const struct bignum_st*,struct ec_key_st*), int (**psign_setup)(struct ec_key_st*,struct bignum_ctx*,struct bignum_st**,struct bignum_st**), struct ECDSA_SIG_st* (**psign_sig)(const unsigned char*,int,const struct bignum_st*,const struct bignum_st*,struct ec_key_st*));
void EC_KEY_METHOD_get_verify(const struct ec_key_method_st* meth  , int (**pverify)(int,const unsigned char*,int,const unsigned char*,int,struct ec_key_st*), int (**pverify_sig)(const unsigned char*,int,const struct ECDSA_SIG_st*,struct ec_key_st*));
int EVP_PKEY_CTX_set_rsa_padding(struct evp_pkey_ctx_st* ctx  , int pad_mode);
int EVP_PKEY_CTX_get_rsa_padding(struct evp_pkey_ctx_st* ctx  , int* pad_mode);
int EVP_PKEY_CTX_set_rsa_pss_saltlen(struct evp_pkey_ctx_st* ctx  , int saltlen);
int EVP_PKEY_CTX_get_rsa_pss_saltlen(struct evp_pkey_ctx_st* ctx  , int* saltlen);
int EVP_PKEY_CTX_set_rsa_keygen_bits(struct evp_pkey_ctx_st* ctx  , int bits);
int EVP_PKEY_CTX_set1_rsa_keygen_pubexp(struct evp_pkey_ctx_st* ctx  , struct bignum_st* pubexp  );
int EVP_PKEY_CTX_set_rsa_keygen_primes(struct evp_pkey_ctx_st* ctx  , int primes);
int EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(struct evp_pkey_ctx_st* ctx  , int saltlen);
int EVP_PKEY_CTX_set_rsa_keygen_pubexp(struct evp_pkey_ctx_st* ctx  , struct bignum_st* pubexp  );
int EVP_PKEY_CTX_set_rsa_mgf1_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st* md  );
int EVP_PKEY_CTX_set_rsa_mgf1_md_name(struct evp_pkey_ctx_st* ctx  , const char* mdname, const char* mdprops);
int EVP_PKEY_CTX_get_rsa_mgf1_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st** md  );
int EVP_PKEY_CTX_get_rsa_mgf1_md_name(struct evp_pkey_ctx_st* ctx  , char* name, unsigned long namelen  );
int EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st* md  );
int EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md_name(struct evp_pkey_ctx_st* ctx  , const char* mdname);
int EVP_PKEY_CTX_set_rsa_pss_keygen_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st* md  );
int EVP_PKEY_CTX_set_rsa_pss_keygen_md_name(struct evp_pkey_ctx_st* ctx  , const char* mdname, const char* mdprops);
int EVP_PKEY_CTX_set_rsa_oaep_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st* md  );
int EVP_PKEY_CTX_set_rsa_oaep_md_name(struct evp_pkey_ctx_st* ctx  , const char* mdname, const char* mdprops);
int EVP_PKEY_CTX_get_rsa_oaep_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st** md  );
int EVP_PKEY_CTX_get_rsa_oaep_md_name(struct evp_pkey_ctx_st* ctx  , char* name, unsigned long namelen  );
int EVP_PKEY_CTX_set0_rsa_oaep_label(struct evp_pkey_ctx_st* ctx  , void* label, int llen);
int EVP_PKEY_CTX_get0_rsa_oaep_label(struct evp_pkey_ctx_st* ctx  , unsigned char** label);
struct rsa_st* RSA_new();
struct rsa_st* RSA_new_method(struct engine_st* engine  );
int RSA_bits(const struct rsa_st* rsa  );
int RSA_size(const struct rsa_st* rsa  );
int RSA_security_bits(const struct rsa_st* rsa  );
int RSA_set0_key(struct rsa_st* r  , struct bignum_st* n  , struct bignum_st* e  , struct bignum_st* d  );
int RSA_set0_factors(struct rsa_st* r  , struct bignum_st* p  , struct bignum_st* q  );
int RSA_set0_crt_params(struct rsa_st* r  , struct bignum_st* dmp1  , struct bignum_st* dmq1  , struct bignum_st* iqmp  );
int RSA_set0_multi_prime_params(struct rsa_st* r  , struct bignum_st* primes[]  , struct bignum_st* exps[]  , struct bignum_st* coeffs[]  , int pnum);
void RSA_get0_key(const struct rsa_st* r  , const struct bignum_st** n  , const struct bignum_st** e  , const struct bignum_st** d  );
void RSA_get0_factors(const struct rsa_st* r  , const struct bignum_st** p  , const struct bignum_st** q  );
int RSA_get_multi_prime_extra_count(const struct rsa_st* r  );
int RSA_get0_multi_prime_factors(const struct rsa_st* r  , const struct bignum_st* primes[]  );
void RSA_get0_crt_params(const struct rsa_st* r  , const struct bignum_st** dmp1  , const struct bignum_st** dmq1  , const struct bignum_st** iqmp  );
int RSA_get0_multi_prime_crt_params(const struct rsa_st* r  , const struct bignum_st* exps[]  , const struct bignum_st* coeffs[]  );
const struct bignum_st* RSA_get0_n(const struct rsa_st* d  );
const struct bignum_st* RSA_get0_e(const struct rsa_st* d  );
const struct bignum_st* RSA_get0_d(const struct rsa_st* d  );
const struct bignum_st* RSA_get0_p(const struct rsa_st* d  );
const struct bignum_st* RSA_get0_q(const struct rsa_st* d  );
const struct bignum_st* RSA_get0_dmp1(const struct rsa_st* r  );
const struct bignum_st* RSA_get0_dmq1(const struct rsa_st* r  );
const struct bignum_st* RSA_get0_iqmp(const struct rsa_st* r  );
const struct rsa_pss_params_st* RSA_get0_pss_params(const struct rsa_st* r  );
void RSA_clear_flags(struct rsa_st* r  , int flags);
int RSA_test_flags(const struct rsa_st* r  , int flags);
void RSA_set_flags(struct rsa_st* r  , int flags);
int RSA_get_version(struct rsa_st* r  );
struct engine_st* RSA_get0_engine(const struct rsa_st* r  );
struct rsa_st* RSA_generate_key(int bits, unsigned long  int e, void (*callback)(int,int,void*), void* cb_arg);
int RSA_generate_key_ex(struct rsa_st* rsa  , int bits, struct bignum_st* e  , struct bn_gencb_st* cb  );
int RSA_generate_multi_prime_key(struct rsa_st* rsa  , int bits, int primes, struct bignum_st* e  , struct bn_gencb_st* cb  );
int RSA_X931_derive_ex(struct rsa_st* rsa  , struct bignum_st* p1  , struct bignum_st* p2  , struct bignum_st* q1  , struct bignum_st* q2  , const struct bignum_st* Xp1  , const struct bignum_st* Xp2  , const struct bignum_st* Xp  , const struct bignum_st* Xq1  , const struct bignum_st* Xq2  , const struct bignum_st* Xq  , const struct bignum_st* e  , struct bn_gencb_st* cb  );
int RSA_X931_generate_key_ex(struct rsa_st* rsa  , int bits, const struct bignum_st* e  , struct bn_gencb_st* cb  );
int RSA_check_key(const struct rsa_st*   );
int RSA_check_key_ex(const struct rsa_st*   , struct bn_gencb_st* cb  );
int RSA_public_encrypt(int flen, const unsigned char* from, unsigned char* to, struct rsa_st* rsa  , int padding);
int RSA_private_encrypt(int flen, const unsigned char* from, unsigned char* to, struct rsa_st* rsa  , int padding);
int RSA_public_decrypt(int flen, const unsigned char* from, unsigned char* to, struct rsa_st* rsa  , int padding);
int RSA_private_decrypt(int flen, const unsigned char* from, unsigned char* to, struct rsa_st* rsa  , int padding);
void RSA_free(struct rsa_st* r  );
int RSA_up_ref(struct rsa_st* r  );
int RSA_flags(const struct rsa_st* r  );
void RSA_set_default_method(const struct rsa_meth_st* meth  );
const struct rsa_meth_st* RSA_get_default_method();
const struct rsa_meth_st* RSA_null_method();
const struct rsa_meth_st* RSA_get_method(const struct rsa_st* rsa  );
int RSA_set_method(struct rsa_st* rsa  , const struct rsa_meth_st* meth  );
const struct rsa_meth_st* RSA_PKCS1_OpenSSL();
struct rsa_st* d2i_RSAPublicKey(struct rsa_st** a  , const unsigned char** in, long len);
int i2d_RSAPublicKey(const struct rsa_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* RSAPublicKey_it();
struct rsa_st* d2i_RSAPrivateKey(struct rsa_st** a  , const unsigned char** in, long len);
int i2d_RSAPrivateKey(const struct rsa_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* RSAPrivateKey_it();
int RSA_pkey_ctx_ctrl(struct evp_pkey_ctx_st* ctx  , int optype, int cmd, int p1, void* p2);
struct rsa_pss_params_st* RSA_PSS_PARAMS_new();
void RSA_PSS_PARAMS_free(struct rsa_pss_params_st* a  );
struct rsa_pss_params_st* d2i_RSA_PSS_PARAMS(struct rsa_pss_params_st** a  , const unsigned char** in, long len);
int i2d_RSA_PSS_PARAMS(const struct rsa_pss_params_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* RSA_PSS_PARAMS_it();
struct rsa_pss_params_st* RSA_PSS_PARAMS_dup(const struct rsa_pss_params_st* a  );
struct rsa_oaep_params_st* RSA_OAEP_PARAMS_new();
void RSA_OAEP_PARAMS_free(struct rsa_oaep_params_st* a  );
struct rsa_oaep_params_st* d2i_RSA_OAEP_PARAMS(struct rsa_oaep_params_st** a  , const unsigned char** in, long len);
int i2d_RSA_OAEP_PARAMS(const struct rsa_oaep_params_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* RSA_OAEP_PARAMS_it();
int RSA_print_fp(struct _IO_FILE* fp  , const struct rsa_st* r  , int offset);
int RSA_print(struct bio_st* bp  , const struct rsa_st* r  , int offset);
int RSA_sign(int type, const unsigned char* m, unsigned int m_length, unsigned char* sigret, unsigned int* siglen, struct rsa_st* rsa  );
int RSA_verify(int type, const unsigned char* m, unsigned int m_length, const unsigned char* sigbuf, unsigned int siglen, struct rsa_st* rsa  );
int RSA_sign_ASN1_OCTET_STRING(int type, const unsigned char* m, unsigned int m_length, unsigned char* sigret, unsigned int* siglen, struct rsa_st* rsa  );
int RSA_verify_ASN1_OCTET_STRING(int type, const unsigned char* m, unsigned int m_length, unsigned char* sigbuf, unsigned int siglen, struct rsa_st* rsa  );
int RSA_blinding_on(struct rsa_st* rsa  , struct bignum_ctx* ctx  );
void RSA_blinding_off(struct rsa_st* rsa  );
struct bn_blinding_st* RSA_setup_blinding(struct rsa_st* rsa  , struct bignum_ctx* ctx  );
int RSA_padding_add_PKCS1_type_1(unsigned char* to, int tlen, const unsigned char* f, int fl);
int RSA_padding_check_PKCS1_type_1(unsigned char* to, int tlen, const unsigned char* f, int fl, int rsa_len);
int RSA_padding_add_PKCS1_type_2(unsigned char* to, int tlen, const unsigned char* f, int fl);
int RSA_padding_check_PKCS1_type_2(unsigned char* to, int tlen, const unsigned char* f, int fl, int rsa_len);
int PKCS1_MGF1(unsigned char* mask, long len, const unsigned char* seed, long seedlen, const struct evp_md_st* dgst  );
int RSA_padding_add_PKCS1_OAEP(unsigned char* to, int tlen, const unsigned char* f, int fl, const unsigned char* p, int pl);
int RSA_padding_check_PKCS1_OAEP(unsigned char* to, int tlen, const unsigned char* f, int fl, int rsa_len, const unsigned char* p, int pl);
int RSA_padding_add_PKCS1_OAEP_mgf1(unsigned char* to, int tlen, const unsigned char* from, int flen, const unsigned char* param, int plen, const struct evp_md_st* md  , const struct evp_md_st* mgf1md  );
int RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char* to, int tlen, const unsigned char* from, int flen, int num, const unsigned char* param, int plen, const struct evp_md_st* md  , const struct evp_md_st* mgf1md  );
int RSA_padding_add_none(unsigned char* to, int tlen, const unsigned char* f, int fl);
int RSA_padding_check_none(unsigned char* to, int tlen, const unsigned char* f, int fl, int rsa_len);
int RSA_padding_add_X931(unsigned char* to, int tlen, const unsigned char* f, int fl);
int RSA_padding_check_X931(unsigned char* to, int tlen, const unsigned char* f, int fl, int rsa_len);
int RSA_X931_hash_id(int nid);
int RSA_verify_PKCS1_PSS(struct rsa_st* rsa  , const unsigned char* mHash, const struct evp_md_st* Hash  , const unsigned char* EM, int sLen);
int RSA_padding_add_PKCS1_PSS(struct rsa_st* rsa  , unsigned char* EM, const unsigned char* mHash, const struct evp_md_st* Hash  , int sLen);
int RSA_verify_PKCS1_PSS_mgf1(struct rsa_st* rsa  , const unsigned char* mHash, const struct evp_md_st* Hash  , const struct evp_md_st* mgf1Hash  , const unsigned char* EM, int sLen);
int RSA_padding_add_PKCS1_PSS_mgf1(struct rsa_st* rsa  , unsigned char* EM, const unsigned char* mHash, const struct evp_md_st* Hash  , const struct evp_md_st* mgf1Hash  , int sLen);
int RSA_set_ex_data(struct rsa_st* r  , int idx, void* arg);
void* RSA_get_ex_data(const struct rsa_st* r  , int idx);
struct rsa_st* RSAPublicKey_dup(const struct rsa_st* a  );
struct rsa_st* RSAPrivateKey_dup(const struct rsa_st* a  );
struct rsa_meth_st* RSA_meth_new(const char* name, int flags);
void RSA_meth_free(struct rsa_meth_st* meth  );
struct rsa_meth_st* RSA_meth_dup(const struct rsa_meth_st* meth  );
const char* RSA_meth_get0_name(const struct rsa_meth_st* meth  );
int RSA_meth_set1_name(struct rsa_meth_st* meth  , const char* name);
int RSA_meth_get_flags(const struct rsa_meth_st* meth  );
int RSA_meth_set_flags(struct rsa_meth_st* meth  , int flags);
void* RSA_meth_get0_app_data(const struct rsa_meth_st* meth  );
int RSA_meth_set0_app_data(struct rsa_meth_st* meth  , void* app_data);
int (*RSA_meth_get_pub_enc(const struct rsa_meth_st* _function_pointer_result_var_name_a27  ))(int,const unsigned char*,unsigned char*,struct rsa_st*,int);
int RSA_meth_set_pub_enc(struct rsa_meth_st* rsa  , int (*pub_enc)(int,const unsigned char*,unsigned char*,struct rsa_st*,int));
int (*RSA_meth_get_pub_dec(const struct rsa_meth_st* _function_pointer_result_var_name_a28  ))(int,const unsigned char*,unsigned char*,struct rsa_st*,int);
int RSA_meth_set_pub_dec(struct rsa_meth_st* rsa  , int (*pub_dec)(int,const unsigned char*,unsigned char*,struct rsa_st*,int));
int (*RSA_meth_get_priv_enc(const struct rsa_meth_st* _function_pointer_result_var_name_a29  ))(int,const unsigned char*,unsigned char*,struct rsa_st*,int);
int RSA_meth_set_priv_enc(struct rsa_meth_st* rsa  , int (*priv_enc)(int,const unsigned char*,unsigned char*,struct rsa_st*,int));
int (*RSA_meth_get_priv_dec(const struct rsa_meth_st* _function_pointer_result_var_name_a30  ))(int,const unsigned char*,unsigned char*,struct rsa_st*,int);
int RSA_meth_set_priv_dec(struct rsa_meth_st* rsa  , int (*priv_dec)(int,const unsigned char*,unsigned char*,struct rsa_st*,int));
int (*RSA_meth_get_mod_exp(const struct rsa_meth_st* _function_pointer_result_var_name_a31  ))(struct bignum_st*,const struct bignum_st*,struct rsa_st*,struct bignum_ctx*);
int RSA_meth_set_mod_exp(struct rsa_meth_st* rsa  , int (*mod_exp)(struct bignum_st*,const struct bignum_st*,struct rsa_st*,struct bignum_ctx*));
int (*RSA_meth_get_bn_mod_exp(const struct rsa_meth_st* _function_pointer_result_var_name_a32  ))(struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*,struct bn_mont_ctx_st*);
int RSA_meth_set_bn_mod_exp(struct rsa_meth_st* rsa  , int (*bn_mod_exp)(struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*,struct bn_mont_ctx_st*));
int (*RSA_meth_get_init(const struct rsa_meth_st* _function_pointer_result_var_name_a33  ))(struct rsa_st*);
int RSA_meth_set_init(struct rsa_meth_st* rsa  , int (*init)(struct rsa_st*));
int (*RSA_meth_get_finish(const struct rsa_meth_st* _function_pointer_result_var_name_a34  ))(struct rsa_st*);
int RSA_meth_set_finish(struct rsa_meth_st* rsa  , int (*finish)(struct rsa_st*));
int (*RSA_meth_get_sign(const struct rsa_meth_st* _function_pointer_result_var_name_a35  ))(int,const unsigned char*,unsigned int,unsigned char*,unsigned int*,const struct rsa_st*);
int RSA_meth_set_sign(struct rsa_meth_st* rsa  , int (*sign)(int,const unsigned char*,unsigned int,unsigned char*,unsigned int*,const struct rsa_st*));
int (*RSA_meth_get_verify(const struct rsa_meth_st* _function_pointer_result_var_name_a36  ))(int,const unsigned char*,unsigned int,const unsigned char*,unsigned int,const struct rsa_st*);
int RSA_meth_set_verify(struct rsa_meth_st* rsa  , int (*verify)(int,const unsigned char*,unsigned int,const unsigned char*,unsigned int,const struct rsa_st*));
int (*RSA_meth_get_keygen(const struct rsa_meth_st* _function_pointer_result_var_name_a37  ))(struct rsa_st*,int,struct bignum_st*,struct bn_gencb_st*);
int RSA_meth_set_keygen(struct rsa_meth_st* rsa  , int (*keygen)(struct rsa_st*,int,struct bignum_st*,struct bn_gencb_st*));
int (*RSA_meth_get_multi_prime_keygen(const struct rsa_meth_st* _function_pointer_result_var_name_a38  ))(struct rsa_st*,int,int,struct bignum_st*,struct bn_gencb_st*);
int RSA_meth_set_multi_prime_keygen(struct rsa_meth_st* meth  , int (*keygen)(struct rsa_st*,int,int,struct bignum_st*,struct bn_gencb_st*));
int EVP_PKEY_CTX_set_dh_paramgen_type(struct evp_pkey_ctx_st* ctx  , int typ);
int EVP_PKEY_CTX_set_dh_paramgen_gindex(struct evp_pkey_ctx_st* ctx  , int gindex);
int EVP_PKEY_CTX_set_dh_paramgen_seed(struct evp_pkey_ctx_st* ctx  , const unsigned char* seed, unsigned long seedlen  );
int EVP_PKEY_CTX_set_dh_paramgen_prime_len(struct evp_pkey_ctx_st* ctx  , int pbits);
int EVP_PKEY_CTX_set_dh_paramgen_subprime_len(struct evp_pkey_ctx_st* ctx  , int qlen);
int EVP_PKEY_CTX_set_dh_paramgen_generator(struct evp_pkey_ctx_st* ctx  , int gen);
int EVP_PKEY_CTX_set_dh_nid(struct evp_pkey_ctx_st* ctx  , int nid);
int EVP_PKEY_CTX_set_dh_rfc5114(struct evp_pkey_ctx_st* ctx  , int gen);
int EVP_PKEY_CTX_set_dhx_rfc5114(struct evp_pkey_ctx_st* ctx  , int gen);
int EVP_PKEY_CTX_set_dh_pad(struct evp_pkey_ctx_st* ctx  , int pad);
int EVP_PKEY_CTX_set_dh_kdf_type(struct evp_pkey_ctx_st* ctx  , int kdf);
int EVP_PKEY_CTX_get_dh_kdf_type(struct evp_pkey_ctx_st* ctx  );
int EVP_PKEY_CTX_set0_dh_kdf_oid(struct evp_pkey_ctx_st* ctx  , struct asn1_object_st* oid  );
int EVP_PKEY_CTX_get0_dh_kdf_oid(struct evp_pkey_ctx_st* ctx  , struct asn1_object_st** oid  );
int EVP_PKEY_CTX_set_dh_kdf_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st* md  );
int EVP_PKEY_CTX_get_dh_kdf_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st** md  );
int EVP_PKEY_CTX_set_dh_kdf_outlen(struct evp_pkey_ctx_st* ctx  , int len);
int EVP_PKEY_CTX_get_dh_kdf_outlen(struct evp_pkey_ctx_st* ctx  , int* len);
int EVP_PKEY_CTX_set0_dh_kdf_ukm(struct evp_pkey_ctx_st* ctx  , unsigned char* ukm, int len);
int EVP_PKEY_CTX_get0_dh_kdf_ukm(struct evp_pkey_ctx_st* ctx  , unsigned char** ukm);
const struct ASN1_ITEM_st* DHparams_it();
struct dh_st* DHparams_dup(const struct dh_st* a  );
const struct dh_method* DH_OpenSSL();
void DH_set_default_method(const struct dh_method* meth  );
const struct dh_method* DH_get_default_method();
int DH_set_method(struct dh_st* dh  , const struct dh_method* meth  );
struct dh_st* DH_new_method(struct engine_st* engine  );
struct dh_st* DH_new();
void DH_free(struct dh_st* dh  );
int DH_up_ref(struct dh_st* dh  );
int DH_bits(const struct dh_st* dh  );
int DH_size(const struct dh_st* dh  );
int DH_security_bits(const struct dh_st* dh  );
int DH_set_ex_data(struct dh_st* d  , int idx, void* arg);
void* DH_get_ex_data(const struct dh_st* d  , int idx);
int DH_generate_parameters_ex(struct dh_st* dh  , int prime_len, int generator, struct bn_gencb_st* cb  );
int DH_check_params_ex(const struct dh_st* dh  );
int DH_check_ex(const struct dh_st* dh  );
int DH_check_pub_key_ex(const struct dh_st* dh  , const struct bignum_st* pub_key  );
int DH_check_params(const struct dh_st* dh  , int* ret);
int DH_check(const struct dh_st* dh  , int* codes);
int DH_check_pub_key(const struct dh_st* dh  , const struct bignum_st* pub_key  , int* codes);
int DH_generate_key(struct dh_st* dh  );
int DH_compute_key(unsigned char* key, const struct bignum_st* pub_key  , struct dh_st* dh  );
int DH_compute_key_padded(unsigned char* key, const struct bignum_st* pub_key  , struct dh_st* dh  );
struct dh_st* d2i_DHparams(struct dh_st** a  , const unsigned char** in, long len);
int i2d_DHparams(const struct dh_st* a  , unsigned char** out);
struct dh_st* d2i_DHxparams(struct dh_st** a  , const unsigned char** in, long len);
int i2d_DHxparams(const struct dh_st* a  , unsigned char** out);
int DHparams_print_fp(struct _IO_FILE* fp  , const struct dh_st* x  );
int DHparams_print(struct bio_st* bp  , const struct dh_st* x  );
struct dh_st* DH_get_1024_160();
struct dh_st* DH_get_2048_224();
struct dh_st* DH_get_2048_256();
struct dh_st* DH_new_by_nid(int nid);
int DH_get_nid(const struct dh_st* dh  );
int DH_KDF_X9_42(unsigned char* out, unsigned long outlen  , const unsigned char* Z, unsigned long Zlen  , struct asn1_object_st* key_oid  , const unsigned char* ukm, unsigned long ukmlen  , const struct evp_md_st* md  );
void DH_get0_pqg(const struct dh_st* dh  , const struct bignum_st** p  , const struct bignum_st** q  , const struct bignum_st** g  );
int DH_set0_pqg(struct dh_st* dh  , struct bignum_st* p  , struct bignum_st* q  , struct bignum_st* g  );
void DH_get0_key(const struct dh_st* dh  , const struct bignum_st** pub_key  , const struct bignum_st** priv_key  );
int DH_set0_key(struct dh_st* dh  , struct bignum_st* pub_key  , struct bignum_st* priv_key  );
const struct bignum_st* DH_get0_p(const struct dh_st* dh  );
const struct bignum_st* DH_get0_q(const struct dh_st* dh  );
const struct bignum_st* DH_get0_g(const struct dh_st* dh  );
const struct bignum_st* DH_get0_priv_key(const struct dh_st* dh  );
const struct bignum_st* DH_get0_pub_key(const struct dh_st* dh  );
void DH_clear_flags(struct dh_st* dh  , int flags);
int DH_test_flags(const struct dh_st* dh  , int flags);
void DH_set_flags(struct dh_st* dh  , int flags);
struct engine_st* DH_get0_engine(struct dh_st* d  );
long DH_get_length(const struct dh_st* dh  );
int DH_set_length(struct dh_st* dh  , long length);
struct dh_method* DH_meth_new(const char* name, int flags);
void DH_meth_free(struct dh_method* dhm  );
struct dh_method* DH_meth_dup(const struct dh_method* dhm  );
const char* DH_meth_get0_name(const struct dh_method* dhm  );
int DH_meth_set1_name(struct dh_method* dhm  , const char* name);
int DH_meth_get_flags(const struct dh_method* dhm  );
int DH_meth_set_flags(struct dh_method* dhm  , int flags);
void* DH_meth_get0_app_data(const struct dh_method* dhm  );
int DH_meth_set0_app_data(struct dh_method* dhm  , void* app_data);
int (*DH_meth_get_generate_key(const struct dh_method* _function_pointer_result_var_name_a39  ))(struct dh_st*);
int DH_meth_set_generate_key(struct dh_method* dhm  , int (*generate_key)(struct dh_st*));
int (*DH_meth_get_compute_key(const struct dh_method* _function_pointer_result_var_name_a40  ))(unsigned char*,const struct bignum_st*,struct dh_st*);
int DH_meth_set_compute_key(struct dh_method* dhm  , int (*compute_key)(unsigned char*,const struct bignum_st*,struct dh_st*));
int (*DH_meth_get_bn_mod_exp(const struct dh_method* _function_pointer_result_var_name_a41  ))(const struct dh_st*,struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*,struct bn_mont_ctx_st*);
int DH_meth_set_bn_mod_exp(struct dh_method* dhm  , int (*bn_mod_exp)(const struct dh_st*,struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*,struct bn_mont_ctx_st*));
int (*DH_meth_get_init(const struct dh_method* _function_pointer_result_var_name_a42  ))(struct dh_st*);
int DH_meth_set_init(struct dh_method* dhm  , int (*init)(struct dh_st*));
int (*DH_meth_get_finish(const struct dh_method* _function_pointer_result_var_name_a43  ))(struct dh_st*);
int DH_meth_set_finish(struct dh_method* dhm  , int (*finish)(struct dh_st*));
int (*DH_meth_get_generate_params(const struct dh_method* _function_pointer_result_var_name_a44  ))(struct dh_st*,int,int,struct bn_gencb_st*);
int DH_meth_set_generate_params(struct dh_method* dhm  , int (*generate_params)(struct dh_st*,int,int,struct bn_gencb_st*));
struct dh_st* DH_generate_parameters(int prime_len, int generator, void (*callback)(int,int,void*), void* cb_arg);
int EVP_PKEY_CTX_set_dsa_paramgen_bits(struct evp_pkey_ctx_st* ctx  , int nbits);
int EVP_PKEY_CTX_set_dsa_paramgen_q_bits(struct evp_pkey_ctx_st* ctx  , int qbits);
int EVP_PKEY_CTX_set_dsa_paramgen_md_props(struct evp_pkey_ctx_st* ctx  , const char* md_name, const char* md_properties);
int EVP_PKEY_CTX_set_dsa_paramgen_gindex(struct evp_pkey_ctx_st* ctx  , int gindex);
int EVP_PKEY_CTX_set_dsa_paramgen_type(struct evp_pkey_ctx_st* ctx  , const char* name);
int EVP_PKEY_CTX_set_dsa_paramgen_seed(struct evp_pkey_ctx_st* ctx  , const unsigned char* seed, unsigned long seedlen  );
int EVP_PKEY_CTX_set_dsa_paramgen_md(struct evp_pkey_ctx_st* ctx  , const struct evp_md_st* md  );
struct DSA_SIG_st* DSA_SIG_new();
void DSA_SIG_free(struct DSA_SIG_st* a  );
struct DSA_SIG_st* d2i_DSA_SIG(struct DSA_SIG_st** a  , const unsigned char** in, long len);
int i2d_DSA_SIG(const struct DSA_SIG_st* a  , unsigned char** out);
void DSA_SIG_get0(const struct DSA_SIG_st* sig  , const struct bignum_st** pr  , const struct bignum_st** ps  );
int DSA_SIG_set0(struct DSA_SIG_st* sig  , struct bignum_st* r  , struct bignum_st* s  );
struct dsa_st* DSAparams_dup(const struct dsa_st* a  );
struct DSA_SIG_st* DSA_do_sign(const unsigned char* dgst, int dlen, struct dsa_st* dsa  );
int DSA_do_verify(const unsigned char* dgst, int dgst_len, struct DSA_SIG_st* sig  , struct dsa_st* dsa  );
const struct dsa_method* DSA_OpenSSL();
void DSA_set_default_method(const struct dsa_method*   );
const struct dsa_method* DSA_get_default_method();
int DSA_set_method(struct dsa_st* dsa  , const struct dsa_method*   );
const struct dsa_method* DSA_get_method(struct dsa_st* d  );
struct dsa_st* DSA_new();
struct dsa_st* DSA_new_method(struct engine_st* engine  );
void DSA_free(struct dsa_st* r  );
int DSA_up_ref(struct dsa_st* r  );
int DSA_size(const struct dsa_st*   );
int DSA_bits(const struct dsa_st* d  );
int DSA_security_bits(const struct dsa_st* d  );
int DSA_sign_setup(struct dsa_st* dsa  , struct bignum_ctx* ctx_in  , struct bignum_st** kinvp  , struct bignum_st** rp  );
int DSA_sign(int type, const unsigned char* dgst, int dlen, unsigned char* sig, unsigned int* siglen, struct dsa_st* dsa  );
int DSA_verify(int type, const unsigned char* dgst, int dgst_len, const unsigned char* sigbuf, int siglen, struct dsa_st* dsa  );
int DSA_set_ex_data(struct dsa_st* d  , int idx, void* arg);
void* DSA_get_ex_data(const struct dsa_st* d  , int idx);
struct dsa_st* d2i_DSAPublicKey(struct dsa_st** a  , const unsigned char** in, long len);
int i2d_DSAPublicKey(const struct dsa_st* a  , unsigned char** out);
struct dsa_st* d2i_DSAPrivateKey(struct dsa_st** a  , const unsigned char** in, long len);
int i2d_DSAPrivateKey(const struct dsa_st* a  , unsigned char** out);
struct dsa_st* d2i_DSAparams(struct dsa_st** a  , const unsigned char** in, long len);
int i2d_DSAparams(const struct dsa_st* a  , unsigned char** out);
struct dsa_st* DSA_generate_parameters(int bits, unsigned char* seed, int seed_len, int* counter_ret, unsigned long  int* h_ret, void (*callback)(int,int,void*), void* cb_arg);
int DSA_generate_parameters_ex(struct dsa_st* dsa  , int bits, const unsigned char* seed, int seed_len, int* counter_ret, unsigned long  int* h_ret, struct bn_gencb_st* cb  );
int DSA_generate_key(struct dsa_st* a  );
int DSAparams_print(struct bio_st* bp  , const struct dsa_st* x  );
int DSA_print(struct bio_st* bp  , const struct dsa_st* x  , int off);
int DSAparams_print_fp(struct _IO_FILE* fp  , const struct dsa_st* x  );
int DSA_print_fp(struct _IO_FILE* bp  , const struct dsa_st* x  , int off);
struct dh_st* DSA_dup_DH(const struct dsa_st* r  );
void DSA_get0_pqg(const struct dsa_st* d  , const struct bignum_st** p  , const struct bignum_st** q  , const struct bignum_st** g  );
int DSA_set0_pqg(struct dsa_st* d  , struct bignum_st* p  , struct bignum_st* q  , struct bignum_st* g  );
void DSA_get0_key(const struct dsa_st* d  , const struct bignum_st** pub_key  , const struct bignum_st** priv_key  );
int DSA_set0_key(struct dsa_st* d  , struct bignum_st* pub_key  , struct bignum_st* priv_key  );
const struct bignum_st* DSA_get0_p(const struct dsa_st* d  );
const struct bignum_st* DSA_get0_q(const struct dsa_st* d  );
const struct bignum_st* DSA_get0_g(const struct dsa_st* d  );
const struct bignum_st* DSA_get0_pub_key(const struct dsa_st* d  );
const struct bignum_st* DSA_get0_priv_key(const struct dsa_st* d  );
void DSA_clear_flags(struct dsa_st* d  , int flags);
int DSA_test_flags(const struct dsa_st* d  , int flags);
void DSA_set_flags(struct dsa_st* d  , int flags);
struct engine_st* DSA_get0_engine(struct dsa_st* d  );
struct dsa_method* DSA_meth_new(const char* name, int flags);
void DSA_meth_free(struct dsa_method* dsam  );
struct dsa_method* DSA_meth_dup(const struct dsa_method* dsam  );
const char* DSA_meth_get0_name(const struct dsa_method* dsam  );
int DSA_meth_set1_name(struct dsa_method* dsam  , const char* name);
int DSA_meth_get_flags(const struct dsa_method* dsam  );
int DSA_meth_set_flags(struct dsa_method* dsam  , int flags);
void* DSA_meth_get0_app_data(const struct dsa_method* dsam  );
int DSA_meth_set0_app_data(struct dsa_method* dsam  , void* app_data);
struct DSA_SIG_st* (*DSA_meth_get_sign(const struct dsa_method* _function_pointer_result_var_name_a45  ))(const unsigned char*,int,struct dsa_st*);
int DSA_meth_set_sign(struct dsa_method* dsam  , struct DSA_SIG_st* (*sign)(const unsigned char*,int,struct dsa_st*));
int (*DSA_meth_get_sign_setup(const struct dsa_method* _function_pointer_result_var_name_a46  ))(struct dsa_st*,struct bignum_ctx*,struct bignum_st**,struct bignum_st**);
int DSA_meth_set_sign_setup(struct dsa_method* dsam  , int (*sign_setup)(struct dsa_st*,struct bignum_ctx*,struct bignum_st**,struct bignum_st**));
int (*DSA_meth_get_verify(const struct dsa_method* _function_pointer_result_var_name_a47  ))(const unsigned char*,int,struct DSA_SIG_st*,struct dsa_st*);
int DSA_meth_set_verify(struct dsa_method* dsam  , int (*verify)(const unsigned char*,int,struct DSA_SIG_st*,struct dsa_st*));
int (*DSA_meth_get_mod_exp(const struct dsa_method* _function_pointer_result_var_name_a48  ))(struct dsa_st*,struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*,struct bn_mont_ctx_st*);
int DSA_meth_set_mod_exp(struct dsa_method* dsam  , int (*mod_exp)(struct dsa_st*,struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*,struct bn_mont_ctx_st*));
int (*DSA_meth_get_bn_mod_exp(const struct dsa_method* _function_pointer_result_var_name_a49  ))(struct dsa_st*,struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*,struct bn_mont_ctx_st*);
int DSA_meth_set_bn_mod_exp(struct dsa_method* dsam  , int (*bn_mod_exp)(struct dsa_st*,struct bignum_st*,const struct bignum_st*,const struct bignum_st*,const struct bignum_st*,struct bignum_ctx*,struct bn_mont_ctx_st*));
int (*DSA_meth_get_init(const struct dsa_method* _function_pointer_result_var_name_a50  ))(struct dsa_st*);
int DSA_meth_set_init(struct dsa_method* dsam  , int (*init)(struct dsa_st*));
int (*DSA_meth_get_finish(const struct dsa_method* _function_pointer_result_var_name_a51  ))(struct dsa_st*);
int DSA_meth_set_finish(struct dsa_method* dsam  , int (*finish)(struct dsa_st*));
int (*DSA_meth_get_paramgen(const struct dsa_method* _function_pointer_result_var_name_a52  ))(struct dsa_st*,int,const unsigned char*,int,int*,unsigned long  int*,struct bn_gencb_st*);
int DSA_meth_set_paramgen(struct dsa_method* dsam  , int (*paramgen)(struct dsa_st*,int,const unsigned char*,int,int*,unsigned long  int*,struct bn_gencb_st*));
int (*DSA_meth_get_keygen(const struct dsa_method* _function_pointer_result_var_name_a53  ))(struct dsa_st*);
int DSA_meth_set_keygen(struct dsa_method* dsam  , int (*keygen)(struct dsa_st*));
int SHA1_Init(struct SHAstate_st* c  );
int SHA1_Update(struct SHAstate_st* c  , const void* data, unsigned long len  );
int SHA1_Final(unsigned char* md, struct SHAstate_st* c  );
void SHA1_Transform(struct SHAstate_st* c  , const unsigned char* data);
unsigned char* SHA1(const unsigned char* d, unsigned long n  , unsigned char* md);
int SHA224_Init(struct SHA256state_st* c  );
int SHA224_Update(struct SHA256state_st* c  , const void* data, unsigned long len  );
int SHA224_Final(unsigned char* md, struct SHA256state_st* c  );
int SHA256_Init(struct SHA256state_st* c  );
int SHA256_Update(struct SHA256state_st* c  , const void* data, unsigned long len  );
int SHA256_Final(unsigned char* md, struct SHA256state_st* c  );
void SHA256_Transform(struct SHA256state_st* c  , const unsigned char* data);
unsigned char* SHA224(const unsigned char* d, unsigned long n  , unsigned char* md);
unsigned char* SHA256(const unsigned char* d, unsigned long n  , unsigned char* md);
int SHA384_Init(struct SHA512state_st* c  );
int SHA384_Update(struct SHA512state_st* c  , const void* data, unsigned long len  );
int SHA384_Final(unsigned char* md, struct SHA512state_st* c  );
int SHA512_Init(struct SHA512state_st* c  );
int SHA512_Update(struct SHA512state_st* c  , const void* data, unsigned long len  );
int SHA512_Final(unsigned char* md, struct SHA512state_st* c  );
void SHA512_Transform(struct SHA512state_st* c  , const unsigned char* data);
unsigned char* SHA384(const unsigned char* d, unsigned long n  , unsigned char* md);
unsigned char* SHA512(const unsigned char* d, unsigned long n  , unsigned char* md);
static struct X509_name_st* ossl_check_X509_NAME_type(struct X509_name_st* ptr  );
static const struct stack_st* ossl_check_const_X509_NAME_sk_type(const struct stack_st_X509_NAME* sk  );
static struct stack_st* ossl_check_X509_NAME_sk_type(struct stack_st_X509_NAME* sk  );
static int (*ossl_check_X509_NAME_compfunc_type(int (*cmp)(const struct X509_name_st**,const struct X509_name_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_NAME_copyfunc_type(struct X509_name_st* (*cpy)(const struct X509_name_st*)  ))(const void*) ;
static void (*ossl_check_X509_NAME_freefunc_type(void (*fr)(struct X509_name_st*)  ))(void*) ;
static struct x509_st* ossl_check_X509_type(struct x509_st* ptr  );
static const struct stack_st* ossl_check_const_X509_sk_type(const struct stack_st_X509* sk  );
static struct stack_st* ossl_check_X509_sk_type(struct stack_st_X509* sk  );
static int (*ossl_check_X509_compfunc_type(int (*cmp)(const struct x509_st**,const struct x509_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_copyfunc_type(struct x509_st* (*cpy)(const struct x509_st*)  ))(const void*) ;
static void (*ossl_check_X509_freefunc_type(void (*fr)(struct x509_st*)  ))(void*) ;
static struct x509_revoked_st* ossl_check_X509_REVOKED_type(struct x509_revoked_st* ptr  );
static const struct stack_st* ossl_check_const_X509_REVOKED_sk_type(const struct stack_st_X509_REVOKED* sk  );
static struct stack_st* ossl_check_X509_REVOKED_sk_type(struct stack_st_X509_REVOKED* sk  );
static int (*ossl_check_X509_REVOKED_compfunc_type(int (*cmp)(const struct x509_revoked_st**,const struct x509_revoked_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_REVOKED_copyfunc_type(struct x509_revoked_st* (*cpy)(const struct x509_revoked_st*)  ))(const void*) ;
static void (*ossl_check_X509_REVOKED_freefunc_type(void (*fr)(struct x509_revoked_st*)  ))(void*) ;
static struct X509_crl_st* ossl_check_X509_CRL_type(struct X509_crl_st* ptr  );
static const struct stack_st* ossl_check_const_X509_CRL_sk_type(const struct stack_st_X509_CRL* sk  );
static struct stack_st* ossl_check_X509_CRL_sk_type(struct stack_st_X509_CRL* sk  );
static int (*ossl_check_X509_CRL_compfunc_type(int (*cmp)(const struct X509_crl_st**,const struct X509_crl_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_CRL_copyfunc_type(struct X509_crl_st* (*cpy)(const struct X509_crl_st*)  ))(const void*) ;
static void (*ossl_check_X509_CRL_freefunc_type(void (*fr)(struct X509_crl_st*)  ))(void*) ;
static struct X509_name_entry_st* ossl_check_X509_NAME_ENTRY_type(struct X509_name_entry_st* ptr  );
static const struct stack_st* ossl_check_const_X509_NAME_ENTRY_sk_type(const struct stack_st_X509_NAME_ENTRY* sk  );
static struct stack_st* ossl_check_X509_NAME_ENTRY_sk_type(struct stack_st_X509_NAME_ENTRY* sk  );
static int (*ossl_check_X509_NAME_ENTRY_compfunc_type(int (*cmp)(const struct X509_name_entry_st**,const struct X509_name_entry_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_NAME_ENTRY_copyfunc_type(struct X509_name_entry_st* (*cpy)(const struct X509_name_entry_st*)  ))(const void*) ;
static void (*ossl_check_X509_NAME_ENTRY_freefunc_type(void (*fr)(struct X509_name_entry_st*)  ))(void*) ;
static struct X509_extension_st* ossl_check_X509_EXTENSION_type(struct X509_extension_st* ptr  );
static const struct stack_st* ossl_check_const_X509_EXTENSION_sk_type(const struct stack_st_X509_EXTENSION* sk  );
static struct stack_st* ossl_check_X509_EXTENSION_sk_type(struct stack_st_X509_EXTENSION* sk  );
static int (*ossl_check_X509_EXTENSION_compfunc_type(int (*cmp)(const struct X509_extension_st**,const struct X509_extension_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_EXTENSION_copyfunc_type(struct X509_extension_st* (*cpy)(const struct X509_extension_st*)  ))(const void*) ;
static void (*ossl_check_X509_EXTENSION_freefunc_type(void (*fr)(struct X509_extension_st*)  ))(void*) ;
static struct x509_attributes_st* ossl_check_X509_ATTRIBUTE_type(struct x509_attributes_st* ptr  );
static const struct stack_st* ossl_check_const_X509_ATTRIBUTE_sk_type(const struct stack_st_X509_ATTRIBUTE* sk  );
static struct stack_st* ossl_check_X509_ATTRIBUTE_sk_type(struct stack_st_X509_ATTRIBUTE* sk  );
static int (*ossl_check_X509_ATTRIBUTE_compfunc_type(int (*cmp)(const struct x509_attributes_st**,const struct x509_attributes_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_ATTRIBUTE_copyfunc_type(struct x509_attributes_st* (*cpy)(const struct x509_attributes_st*)  ))(const void*) ;
static void (*ossl_check_X509_ATTRIBUTE_freefunc_type(void (*fr)(struct x509_attributes_st*)  ))(void*) ;
static struct X509_info_st* ossl_check_X509_INFO_type(struct X509_info_st* ptr  );
static const struct stack_st* ossl_check_const_X509_INFO_sk_type(const struct stack_st_X509_INFO* sk  );
static struct stack_st* ossl_check_X509_INFO_sk_type(struct stack_st_X509_INFO* sk  );
static int (*ossl_check_X509_INFO_compfunc_type(int (*cmp)(const struct X509_info_st**,const struct X509_info_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_INFO_copyfunc_type(struct X509_info_st* (*cpy)(const struct X509_info_st*)  ))(const void*) ;
static void (*ossl_check_X509_INFO_freefunc_type(void (*fr)(struct X509_info_st*)  ))(void*) ;
int OPENSSL_LH_error(struct lhash_st* lh  );
struct lhash_st* OPENSSL_LH_new(unsigned long  int (*h)(const void*)  , int (*c)(const void*,const void*)  );
struct lhash_st* OPENSSL_LH_set_thunks(struct lhash_st* lh  , unsigned long  int (*hw)(const void*,unsigned long  int (*)(const void*))  , int (*cw)(const void*,const void*,int (*)(const void*,const void*))  , void (*daw)(void*,void (*)(void*))  , void (*daaw)(void*,void*,void (*)(void*,void*))  );
void OPENSSL_LH_free(struct lhash_st* lh  );
void OPENSSL_LH_flush(struct lhash_st* lh  );
void* OPENSSL_LH_insert(struct lhash_st* lh  , void* data);
void* OPENSSL_LH_delete(struct lhash_st* lh  , const void* data);
void* OPENSSL_LH_retrieve(struct lhash_st* lh  , const void* data);
void OPENSSL_LH_doall(struct lhash_st* lh  , void (*func)(void*)  );
void OPENSSL_LH_doall_arg(struct lhash_st* lh  , void (*func)(void*,void*)  , void* arg);
void OPENSSL_LH_doall_arg_thunk(struct lhash_st* lh  , void (*daaw)(void*,void*,void (*)(void*,void*))  , void (*fn)(void*,void*)  , void* arg);
unsigned long  int OPENSSL_LH_strhash(const char* c);
unsigned long  int OPENSSL_LH_num_items(const struct lhash_st* lh  );
unsigned long  int OPENSSL_LH_get_down_load(const struct lhash_st* lh  );
void OPENSSL_LH_set_down_load(struct lhash_st* lh  , unsigned long  int down_load);
void OPENSSL_LH_stats(const struct lhash_st* lh  , struct _IO_FILE* fp  );
void OPENSSL_LH_node_stats(const struct lhash_st* lh  , struct _IO_FILE* fp  );
void OPENSSL_LH_node_usage_stats(const struct lhash_st* lh  , struct _IO_FILE* fp  );
void OPENSSL_LH_stats_bio(const struct lhash_st* lh  , struct bio_st* out  );
void OPENSSL_LH_node_stats_bio(const struct lhash_st* lh  , struct bio_st* out  );
void OPENSSL_LH_node_usage_stats_bio(const struct lhash_st* lh  , struct bio_st* out  );
static unsigned long  int lh_OPENSSL_STRING_hash_thunk(const void* data, unsigned long  int (*hfn)(const void*)  );
static int lh_OPENSSL_STRING_comp_thunk(const void* da, const void* db, int (*cfn)(const void*,const void*)  );
static void lh_OPENSSL_STRING_doall_thunk(void* node, void (*doall)(void*)  );
static void lh_OPENSSL_STRING_doall_arg_thunk(void* node, void* arg, void (*doall)(void*,void*)  );
static char** ossl_check_OPENSSL_STRING_lh_plain_type(char** ptr  );
static const char** ossl_check_const_OPENSSL_STRING_lh_plain_type(const char** ptr  );
static const struct lhash_st* ossl_check_const_OPENSSL_STRING_lh_type(const struct lhash_st_OPENSSL_STRING* lh  );
static struct lhash_st* ossl_check_OPENSSL_STRING_lh_type(struct lhash_st_OPENSSL_STRING* lh  );
static int (*ossl_check_OPENSSL_STRING_lh_compfunc_type(int (*cmp)(const char**,const char**)  ))(const void*,const void*) ;
static unsigned long  int (*ossl_check_OPENSSL_STRING_lh_hashfunc_type(unsigned long  int (*hfn)(const char**)  ))(const void*) ;
static void (*ossl_check_OPENSSL_STRING_lh_doallfunc_type(void (*dfn)(char**)  ))(void*) ;
static unsigned long  int lh_OPENSSL_CSTRING_hash_thunk(const void* data, unsigned long  int (*hfn)(const void*)  );
static int lh_OPENSSL_CSTRING_comp_thunk(const void* da, const void* db, int (*cfn)(const void*,const void*)  );
static void lh_OPENSSL_CSTRING_doall_thunk(void* node, void (*doall)(void*)  );
static void lh_OPENSSL_CSTRING_doall_arg_thunk(void* node, void* arg, void (*doall)(void*,void*)  );
static const char** ossl_check_OPENSSL_CSTRING_lh_plain_type(const char** ptr  );
static const char** ossl_check_const_OPENSSL_CSTRING_lh_plain_type(const char** ptr  );
static const struct lhash_st* ossl_check_const_OPENSSL_CSTRING_lh_type(const struct lhash_st_OPENSSL_CSTRING* lh  );
static struct lhash_st* ossl_check_OPENSSL_CSTRING_lh_type(struct lhash_st_OPENSSL_CSTRING* lh  );
static int (*ossl_check_OPENSSL_CSTRING_lh_compfunc_type(int (*cmp)(const char**,const char**)  ))(const void*,const void*) ;
static unsigned long  int (*ossl_check_OPENSSL_CSTRING_lh_hashfunc_type(unsigned long  int (*hfn)(const char**)  ))(const void*) ;
static void (*ossl_check_OPENSSL_CSTRING_lh_doallfunc_type(void (*dfn)(const char**)  ))(void*) ;
static struct x509_lookup_st* ossl_check_X509_LOOKUP_type(struct x509_lookup_st* ptr  );
static const struct stack_st* ossl_check_const_X509_LOOKUP_sk_type(const struct stack_st_X509_LOOKUP* sk  );
static struct stack_st* ossl_check_X509_LOOKUP_sk_type(struct stack_st_X509_LOOKUP* sk  );
static int (*ossl_check_X509_LOOKUP_compfunc_type(int (*cmp)(const struct x509_lookup_st**,const struct x509_lookup_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_LOOKUP_copyfunc_type(struct x509_lookup_st* (*cpy)(const struct x509_lookup_st*)  ))(const void*) ;
static void (*ossl_check_X509_LOOKUP_freefunc_type(void (*fr)(struct x509_lookup_st*)  ))(void*) ;
static struct x509_object_st* ossl_check_X509_OBJECT_type(struct x509_object_st* ptr  );
static const struct stack_st* ossl_check_const_X509_OBJECT_sk_type(const struct stack_st_X509_OBJECT* sk  );
static struct stack_st* ossl_check_X509_OBJECT_sk_type(struct stack_st_X509_OBJECT* sk  );
static int (*ossl_check_X509_OBJECT_compfunc_type(int (*cmp)(const struct x509_object_st**,const struct x509_object_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_OBJECT_copyfunc_type(struct x509_object_st* (*cpy)(const struct x509_object_st*)  ))(const void*) ;
static void (*ossl_check_X509_OBJECT_freefunc_type(void (*fr)(struct x509_object_st*)  ))(void*) ;
static struct X509_VERIFY_PARAM_st* ossl_check_X509_VERIFY_PARAM_type(struct X509_VERIFY_PARAM_st* ptr  );
static const struct stack_st* ossl_check_const_X509_VERIFY_PARAM_sk_type(const struct stack_st_X509_VERIFY_PARAM* sk  );
static struct stack_st* ossl_check_X509_VERIFY_PARAM_sk_type(struct stack_st_X509_VERIFY_PARAM* sk  );
static int (*ossl_check_X509_VERIFY_PARAM_compfunc_type(int (*cmp)(const struct X509_VERIFY_PARAM_st**,const struct X509_VERIFY_PARAM_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_VERIFY_PARAM_copyfunc_type(struct X509_VERIFY_PARAM_st* (*cpy)(const struct X509_VERIFY_PARAM_st*)  ))(const void*) ;
static void (*ossl_check_X509_VERIFY_PARAM_freefunc_type(void (*fr)(struct X509_VERIFY_PARAM_st*)  ))(void*) ;
static struct x509_trust_st* ossl_check_X509_TRUST_type(struct x509_trust_st* ptr  );
static const struct stack_st* ossl_check_const_X509_TRUST_sk_type(const struct stack_st_X509_TRUST* sk  );
static struct stack_st* ossl_check_X509_TRUST_sk_type(struct stack_st_X509_TRUST* sk  );
static int (*ossl_check_X509_TRUST_compfunc_type(int (*cmp)(const struct x509_trust_st**,const struct x509_trust_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_X509_TRUST_copyfunc_type(struct x509_trust_st* (*cpy)(const struct x509_trust_st*)  ))(const void*) ;
static void (*ossl_check_X509_TRUST_freefunc_type(void (*fr)(struct x509_trust_st*)  ))(void*) ;
int X509_TRUST_set(int* t, int trust);
int X509_TRUST_get_count();
struct x509_trust_st* X509_TRUST_get0(int idx);
int X509_TRUST_get_by_id(int id);
int X509_TRUST_add(int id, int flags, int (*ck)(struct x509_trust_st*,struct x509_st*,int), const char* name, int arg1, void* arg2);
void X509_TRUST_cleanup();
int X509_TRUST_get_flags(const struct x509_trust_st* xp  );
char* X509_TRUST_get0_name(const struct x509_trust_st* xp  );
int X509_TRUST_get_trust(const struct x509_trust_st* xp  );
int X509_trusted(const struct x509_st* x  );
int X509_add1_trust_object(struct x509_st* x  , const struct asn1_object_st* obj  );
int X509_add1_reject_object(struct x509_st* x  , const struct asn1_object_st* obj  );
void X509_trust_clear(struct x509_st* x  );
void X509_reject_clear(struct x509_st* x  );
struct stack_st_ASN1_OBJECT* X509_get0_trust_objects(struct x509_st* x  );
struct stack_st_ASN1_OBJECT* X509_get0_reject_objects(struct x509_st* x  );
int (*X509_TRUST_set_default(int (*_function_pointer_result_var_name_a54)(int,struct x509_st*,int)))(int,struct x509_st*,int);
int X509_check_trust(struct x509_st* x  , int id, int flags);
int X509_verify_cert(struct x509_store_ctx_st* ctx  );
int X509_STORE_CTX_verify(struct x509_store_ctx_st* ctx  );
struct stack_st_X509* X509_build_chain(struct x509_st* target  , struct stack_st_X509* certs  , struct x509_store_st* store  , int with_self_signed, struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_STORE_set_depth(struct x509_store_st* store  , int depth);
int X509_STORE_CTX_print_verify_cb(int ok, struct x509_store_ctx_st* ctx  );
void X509_STORE_CTX_set_depth(struct x509_store_ctx_st* ctx  , int depth);
int X509_OBJECT_idx_by_subject(struct stack_st_X509_OBJECT* h  , enum anonymous_typeY42 type  , const struct X509_name_st* name  );
struct x509_object_st* X509_OBJECT_retrieve_by_subject(struct stack_st_X509_OBJECT* h  , enum anonymous_typeY42 type  , const struct X509_name_st* name  );
struct x509_object_st* X509_OBJECT_retrieve_match(struct stack_st_X509_OBJECT* h  , struct x509_object_st* x  );
int X509_OBJECT_up_ref_count(struct x509_object_st* a  );
struct x509_object_st* X509_OBJECT_new();
void X509_OBJECT_free(struct x509_object_st* a  );
enum anonymous_typeY42 X509_OBJECT_get_type(const struct x509_object_st* a  );
struct x509_st* X509_OBJECT_get0_X509(const struct x509_object_st* a  );
int X509_OBJECT_set1_X509(struct x509_object_st* a  , struct x509_st* obj  );
struct X509_crl_st* X509_OBJECT_get0_X509_CRL(const struct x509_object_st* a  );
int X509_OBJECT_set1_X509_CRL(struct x509_object_st* a  , struct X509_crl_st* obj  );
struct x509_store_st* X509_STORE_new();
void X509_STORE_free(struct x509_store_st* xs  );
int X509_STORE_lock(struct x509_store_st* xs  );
int X509_STORE_unlock(struct x509_store_st* xs  );
int X509_STORE_up_ref(struct x509_store_st* xs  );
struct stack_st_X509_OBJECT* X509_STORE_get0_objects(const struct x509_store_st* xs  );
struct stack_st_X509_OBJECT* X509_STORE_get1_objects(struct x509_store_st* xs  );
struct stack_st_X509* X509_STORE_get1_all_certs(struct x509_store_st* xs  );
struct stack_st_X509* X509_STORE_CTX_get1_certs(struct x509_store_ctx_st* xs  , const struct X509_name_st* nm  );
struct stack_st_X509_CRL* X509_STORE_CTX_get1_crls(const struct x509_store_ctx_st* st  , const struct X509_name_st* nm  );
int X509_STORE_set_flags(struct x509_store_st* xs  , unsigned long  int flags);
int X509_STORE_set_purpose(struct x509_store_st* xs  , int purpose);
int X509_STORE_set_trust(struct x509_store_st* xs  , int trust);
int X509_STORE_set1_param(struct x509_store_st* xs  , const struct X509_VERIFY_PARAM_st* pm  );
struct X509_VERIFY_PARAM_st* X509_STORE_get0_param(const struct x509_store_st* xs  );
void X509_STORE_set_verify(struct x509_store_st* xs  , int (*verify)(struct x509_store_ctx_st*)  );
void X509_STORE_CTX_set_verify(struct x509_store_ctx_st* ctx  , int (*verify)(struct x509_store_ctx_st*)  );
int (*X509_STORE_get_verify(const struct x509_store_st* xs  ))(struct x509_store_ctx_st*) ;
void X509_STORE_set_verify_cb(struct x509_store_st* xs  , int (*verify_cb)(int,struct x509_store_ctx_st*)  );
int (*X509_STORE_get_verify_cb(const struct x509_store_st* xs  ))(int,struct x509_store_ctx_st*) ;
void X509_STORE_set_get_issuer(struct x509_store_st* xs  , int (*get_issuer)(struct x509_st**,struct x509_store_ctx_st*,struct x509_st*)  );
int (*X509_STORE_get_get_issuer(const struct x509_store_st* xs  ))(struct x509_st**,struct x509_store_ctx_st*,struct x509_st*) ;
void X509_STORE_set_check_issued(struct x509_store_st* xs  , int (*check_issued)(struct x509_store_ctx_st*,struct x509_st*,struct x509_st*)  );
int (*X509_STORE_get_check_issued(const struct x509_store_st* s  ))(struct x509_store_ctx_st*,struct x509_st*,struct x509_st*) ;
void X509_STORE_set_check_revocation(struct x509_store_st* xs  , int (*check_revocation)(struct x509_store_ctx_st*)  );
int (*X509_STORE_get_check_revocation(const struct x509_store_st* xs  ))(struct x509_store_ctx_st*) ;
void X509_STORE_set_get_crl(struct x509_store_st* xs  , int (*get_crl)(struct x509_store_ctx_st*,struct X509_crl_st**,struct x509_st*)  );
int (*X509_STORE_get_get_crl(const struct x509_store_st* xs  ))(struct x509_store_ctx_st*,struct X509_crl_st**,struct x509_st*) ;
void X509_STORE_set_check_crl(struct x509_store_st* xs  , int (*check_crl)(struct x509_store_ctx_st*,struct X509_crl_st*)  );
int (*X509_STORE_get_check_crl(const struct x509_store_st* xs  ))(struct x509_store_ctx_st*,struct X509_crl_st*) ;
void X509_STORE_set_cert_crl(struct x509_store_st* xs  , int (*cert_crl)(struct x509_store_ctx_st*,struct X509_crl_st*,struct x509_st*)  );
int (*X509_STORE_get_cert_crl(const struct x509_store_st* xs  ))(struct x509_store_ctx_st*,struct X509_crl_st*,struct x509_st*) ;
void X509_STORE_set_check_policy(struct x509_store_st* xs  , int (*check_policy)(struct x509_store_ctx_st*)  );
int (*X509_STORE_get_check_policy(const struct x509_store_st* s  ))(struct x509_store_ctx_st*) ;
void X509_STORE_set_lookup_certs(struct x509_store_st* xs  , struct stack_st_X509* (*lookup_certs)(struct x509_store_ctx_st*,const struct X509_name_st*)  );
struct stack_st_X509* (*X509_STORE_get_lookup_certs(const struct x509_store_st* s  ))(struct x509_store_ctx_st*,const struct X509_name_st*) ;
void X509_STORE_set_lookup_crls(struct x509_store_st* xs  , struct stack_st_X509_CRL* (*lookup_crls)(const struct x509_store_ctx_st*,const struct X509_name_st*)  );
struct stack_st_X509_CRL* (*X509_STORE_get_lookup_crls(const struct x509_store_st* xs  ))(const struct x509_store_ctx_st*,const struct X509_name_st*) ;
void X509_STORE_set_cleanup(struct x509_store_st* xs  , int (*cleanup)(struct x509_store_ctx_st*)  );
int (*X509_STORE_get_cleanup(const struct x509_store_st* xs  ))(struct x509_store_ctx_st*) ;
int X509_STORE_set_ex_data(struct x509_store_st* xs  , int idx, void* data);
void* X509_STORE_get_ex_data(const struct x509_store_st* xs  , int idx);
struct x509_store_ctx_st* X509_STORE_CTX_new_ex(struct ossl_lib_ctx_st* libctx  , const char* propq);
struct x509_store_ctx_st* X509_STORE_CTX_new();
int X509_STORE_CTX_get1_issuer(struct x509_st** issuer  , struct x509_store_ctx_st* ctx  , struct x509_st* x  );
void X509_STORE_CTX_free(struct x509_store_ctx_st* ctx  );
int X509_STORE_CTX_init(struct x509_store_ctx_st* ctx  , struct x509_store_st* trust_store  , struct x509_st* target  , struct stack_st_X509* untrusted  );
int X509_STORE_CTX_init_rpk(struct x509_store_ctx_st* ctx  , struct x509_store_st* trust_store  , struct evp_pkey_st* rpk  );
void X509_STORE_CTX_set0_trusted_stack(struct x509_store_ctx_st* ctx  , struct stack_st_X509* sk  );
void X509_STORE_CTX_cleanup(struct x509_store_ctx_st* ctx  );
struct x509_store_st* X509_STORE_CTX_get0_store(const struct x509_store_ctx_st* ctx  );
struct x509_st* X509_STORE_CTX_get0_cert(const struct x509_store_ctx_st* ctx  );
struct evp_pkey_st* X509_STORE_CTX_get0_rpk(const struct x509_store_ctx_st* ctx  );
struct stack_st_X509* X509_STORE_CTX_get0_untrusted(const struct x509_store_ctx_st* ctx  );
void X509_STORE_CTX_set0_untrusted(struct x509_store_ctx_st* ctx  , struct stack_st_X509* sk  );
void X509_STORE_CTX_set_verify_cb(struct x509_store_ctx_st* ctx  , int (*verify)(int,struct x509_store_ctx_st*)  );
int (*X509_STORE_CTX_get_verify_cb(const struct x509_store_ctx_st* ctx  ))(int,struct x509_store_ctx_st*) ;
int (*X509_STORE_CTX_get_verify(const struct x509_store_ctx_st* ctx  ))(struct x509_store_ctx_st*) ;
int (*X509_STORE_CTX_get_get_issuer(const struct x509_store_ctx_st* ctx  ))(struct x509_st**,struct x509_store_ctx_st*,struct x509_st*) ;
int (*X509_STORE_CTX_get_check_issued(const struct x509_store_ctx_st* ctx  ))(struct x509_store_ctx_st*,struct x509_st*,struct x509_st*) ;
int (*X509_STORE_CTX_get_check_revocation(const struct x509_store_ctx_st* ctx  ))(struct x509_store_ctx_st*) ;
void X509_STORE_CTX_set_get_crl(struct x509_store_ctx_st* ctx  , int (*get_crl)(struct x509_store_ctx_st*,struct X509_crl_st**,struct x509_st*)  );
int (*X509_STORE_CTX_get_get_crl(const struct x509_store_ctx_st* ctx  ))(struct x509_store_ctx_st*,struct X509_crl_st**,struct x509_st*) ;
int (*X509_STORE_CTX_get_check_crl(const struct x509_store_ctx_st* ctx  ))(struct x509_store_ctx_st*,struct X509_crl_st*) ;
int (*X509_STORE_CTX_get_cert_crl(const struct x509_store_ctx_st* ctx  ))(struct x509_store_ctx_st*,struct X509_crl_st*,struct x509_st*) ;
int (*X509_STORE_CTX_get_check_policy(const struct x509_store_ctx_st* ctx  ))(struct x509_store_ctx_st*) ;
struct stack_st_X509* (*X509_STORE_CTX_get_lookup_certs(const struct x509_store_ctx_st* ctx  ))(struct x509_store_ctx_st*,const struct X509_name_st*) ;
struct stack_st_X509_CRL* (*X509_STORE_CTX_get_lookup_crls(const struct x509_store_ctx_st* ctx  ))(const struct x509_store_ctx_st*,const struct X509_name_st*) ;
int (*X509_STORE_CTX_get_cleanup(const struct x509_store_ctx_st* ctx  ))(struct x509_store_ctx_st*) ;
struct x509_lookup_st* X509_STORE_add_lookup(struct x509_store_st* xs  , struct x509_lookup_method_st* m  );
struct x509_lookup_method_st* X509_LOOKUP_hash_dir();
struct x509_lookup_method_st* X509_LOOKUP_file();
struct x509_lookup_method_st* X509_LOOKUP_store();
struct x509_lookup_method_st* X509_LOOKUP_meth_new(const char* name);
void X509_LOOKUP_meth_free(struct x509_lookup_method_st* method  );
int X509_LOOKUP_meth_set_new_item(struct x509_lookup_method_st* method  , int (*new_item)(struct x509_lookup_st*));
int (*X509_LOOKUP_meth_get_new_item(const struct x509_lookup_method_st* _function_pointer_result_var_name_a55  ))(struct x509_lookup_st*);
int X509_LOOKUP_meth_set_free(struct x509_lookup_method_st* method  , void (*free_fn)(struct x509_lookup_st*));
void (*X509_LOOKUP_meth_get_free(const struct x509_lookup_method_st* _function_pointer_result_var_name_a56  ))(struct x509_lookup_st*);
int X509_LOOKUP_meth_set_init(struct x509_lookup_method_st* method  , int (*init)(struct x509_lookup_st*));
int (*X509_LOOKUP_meth_get_init(const struct x509_lookup_method_st* _function_pointer_result_var_name_a57  ))(struct x509_lookup_st*);
int X509_LOOKUP_meth_set_shutdown(struct x509_lookup_method_st* method  , int (*shutdown)(struct x509_lookup_st*));
int (*X509_LOOKUP_meth_get_shutdown(const struct x509_lookup_method_st* _function_pointer_result_var_name_a58  ))(struct x509_lookup_st*);
int X509_LOOKUP_meth_set_ctrl(struct x509_lookup_method_st* method  , int (*ctrl_fn)(struct x509_lookup_st*,int,const char*,long,char**)  );
int (*X509_LOOKUP_meth_get_ctrl(const struct x509_lookup_method_st* method  ))(struct x509_lookup_st*,int,const char*,long,char**) ;
int X509_LOOKUP_meth_set_get_by_subject(struct x509_lookup_method_st* method  , int (*fn)(struct x509_lookup_st*,enum anonymous_typeY42,const struct X509_name_st*,struct x509_object_st*)  );
int (*X509_LOOKUP_meth_get_get_by_subject(const struct x509_lookup_method_st* method  ))(struct x509_lookup_st*,enum anonymous_typeY42,const struct X509_name_st*,struct x509_object_st*) ;
int X509_LOOKUP_meth_set_get_by_issuer_serial(struct x509_lookup_method_st* method  , int (*fn)(struct x509_lookup_st*,enum anonymous_typeY42,const struct X509_name_st*,const struct asn1_string_st*,struct x509_object_st*)  );
int (*X509_LOOKUP_meth_get_get_by_issuer_serial(const struct x509_lookup_method_st* method  ))(struct x509_lookup_st*,enum anonymous_typeY42,const struct X509_name_st*,const struct asn1_string_st*,struct x509_object_st*) ;
int X509_LOOKUP_meth_set_get_by_fingerprint(struct x509_lookup_method_st* method  , int (*fn)(struct x509_lookup_st*,enum anonymous_typeY42,const unsigned char*,int,struct x509_object_st*)  );
int (*X509_LOOKUP_meth_get_get_by_fingerprint(const struct x509_lookup_method_st* method  ))(struct x509_lookup_st*,enum anonymous_typeY42,const unsigned char*,int,struct x509_object_st*) ;
int X509_LOOKUP_meth_set_get_by_alias(struct x509_lookup_method_st* method  , int (*fn)(struct x509_lookup_st*,enum anonymous_typeY42,const char*,int,struct x509_object_st*)  );
int (*X509_LOOKUP_meth_get_get_by_alias(const struct x509_lookup_method_st* method  ))(struct x509_lookup_st*,enum anonymous_typeY42,const char*,int,struct x509_object_st*) ;
int X509_STORE_add_cert(struct x509_store_st* xs  , struct x509_st* x  );
int X509_STORE_add_crl(struct x509_store_st* xs  , struct X509_crl_st* x  );
int X509_STORE_CTX_get_by_subject(const struct x509_store_ctx_st* vs  , enum anonymous_typeY42 type  , const struct X509_name_st* name  , struct x509_object_st* ret  );
struct x509_object_st* X509_STORE_CTX_get_obj_by_subject(struct x509_store_ctx_st* vs  , enum anonymous_typeY42 type  , const struct X509_name_st* name  );
int X509_LOOKUP_ctrl(struct x509_lookup_st* ctx  , int cmd, const char* argc, long argl, char** ret);
int X509_LOOKUP_ctrl_ex(struct x509_lookup_st* ctx  , int cmd, const char* argc, long argl, char** ret, struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_load_cert_file(struct x509_lookup_st* ctx  , const char* file, int type);
int X509_load_cert_file_ex(struct x509_lookup_st* ctx  , const char* file, int type, struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_load_crl_file(struct x509_lookup_st* ctx  , const char* file, int type);
int X509_load_cert_crl_file(struct x509_lookup_st* ctx  , const char* file, int type);
int X509_load_cert_crl_file_ex(struct x509_lookup_st* ctx  , const char* file, int type, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct x509_lookup_st* X509_LOOKUP_new(struct x509_lookup_method_st* method  );
void X509_LOOKUP_free(struct x509_lookup_st* ctx  );
int X509_LOOKUP_init(struct x509_lookup_st* ctx  );
int X509_LOOKUP_by_subject(struct x509_lookup_st* ctx  , enum anonymous_typeY42 type  , const struct X509_name_st* name  , struct x509_object_st* ret  );
int X509_LOOKUP_by_subject_ex(struct x509_lookup_st* ctx  , enum anonymous_typeY42 type  , const struct X509_name_st* name  , struct x509_object_st* ret  , struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_LOOKUP_by_issuer_serial(struct x509_lookup_st* ctx  , enum anonymous_typeY42 type  , const struct X509_name_st* name  , const struct asn1_string_st* serial  , struct x509_object_st* ret  );
int X509_LOOKUP_by_fingerprint(struct x509_lookup_st* ctx  , enum anonymous_typeY42 type  , const unsigned char* bytes, int len, struct x509_object_st* ret  );
int X509_LOOKUP_by_alias(struct x509_lookup_st* ctx  , enum anonymous_typeY42 type  , const char* str, int len, struct x509_object_st* ret  );
int X509_LOOKUP_set_method_data(struct x509_lookup_st* ctx  , void* data);
void* X509_LOOKUP_get_method_data(const struct x509_lookup_st* ctx  );
struct x509_store_st* X509_LOOKUP_get_store(const struct x509_lookup_st* ctx  );
int X509_LOOKUP_shutdown(struct x509_lookup_st* ctx  );
int X509_STORE_load_file(struct x509_store_st* xs  , const char* file);
int X509_STORE_load_path(struct x509_store_st* xs  , const char* path);
int X509_STORE_load_store(struct x509_store_st* xs  , const char* store);
int X509_STORE_load_locations(struct x509_store_st* s  , const char* file, const char* dir);
int X509_STORE_set_default_paths(struct x509_store_st* xs  );
int X509_STORE_load_file_ex(struct x509_store_st* xs  , const char* file, struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_STORE_load_store_ex(struct x509_store_st* xs  , const char* store, struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_STORE_load_locations_ex(struct x509_store_st* xs  , const char* file, const char* dir, struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_STORE_set_default_paths_ex(struct x509_store_st* xs  , struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_STORE_CTX_set_ex_data(struct x509_store_ctx_st* ctx  , int idx, void* data);
void* X509_STORE_CTX_get_ex_data(const struct x509_store_ctx_st* ctx  , int idx);
int X509_STORE_CTX_get_error(const struct x509_store_ctx_st* ctx  );
void X509_STORE_CTX_set_error(struct x509_store_ctx_st* ctx  , int s);
int X509_STORE_CTX_get_error_depth(const struct x509_store_ctx_st* ctx  );
void X509_STORE_CTX_set_error_depth(struct x509_store_ctx_st* ctx  , int depth);
struct x509_st* X509_STORE_CTX_get_current_cert(const struct x509_store_ctx_st* ctx  );
void X509_STORE_CTX_set_current_cert(struct x509_store_ctx_st* ctx  , struct x509_st* x  );
struct x509_st* X509_STORE_CTX_get0_current_issuer(const struct x509_store_ctx_st* ctx  );
struct X509_crl_st* X509_STORE_CTX_get0_current_crl(const struct x509_store_ctx_st* ctx  );
struct x509_store_ctx_st* X509_STORE_CTX_get0_parent_ctx(const struct x509_store_ctx_st* ctx  );
struct stack_st_X509* X509_STORE_CTX_get0_chain(const struct x509_store_ctx_st* ctx  );
struct stack_st_X509* X509_STORE_CTX_get1_chain(const struct x509_store_ctx_st* ctx  );
void X509_STORE_CTX_set_cert(struct x509_store_ctx_st* ctx  , struct x509_st* target  );
void X509_STORE_CTX_set0_rpk(struct x509_store_ctx_st* ctx  , struct evp_pkey_st* target  );
void X509_STORE_CTX_set0_verified_chain(struct x509_store_ctx_st* c  , struct stack_st_X509* sk  );
void X509_STORE_CTX_set0_crls(struct x509_store_ctx_st* ctx  , struct stack_st_X509_CRL* sk  );
int X509_STORE_CTX_set_purpose(struct x509_store_ctx_st* ctx  , int purpose);
int X509_STORE_CTX_set_trust(struct x509_store_ctx_st* ctx  , int trust);
int X509_STORE_CTX_purpose_inherit(struct x509_store_ctx_st* ctx  , int def_purpose, int purpose, int trust);
void X509_STORE_CTX_set_flags(struct x509_store_ctx_st* ctx  , unsigned long  int flags);
void X509_STORE_CTX_set_time(struct x509_store_ctx_st* ctx  , unsigned long  int flags, long  int t  );
void X509_STORE_CTX_set_current_reasons(struct x509_store_ctx_st* ctx  , unsigned int current_reasons);
struct X509_POLICY_TREE_st* X509_STORE_CTX_get0_policy_tree(const struct x509_store_ctx_st* ctx  );
int X509_STORE_CTX_get_explicit_policy(const struct x509_store_ctx_st* ctx  );
int X509_STORE_CTX_get_num_untrusted(const struct x509_store_ctx_st* ctx  );
struct X509_VERIFY_PARAM_st* X509_STORE_CTX_get0_param(const struct x509_store_ctx_st* ctx  );
void X509_STORE_CTX_set0_param(struct x509_store_ctx_st* ctx  , struct X509_VERIFY_PARAM_st* param  );
int X509_STORE_CTX_set_default(struct x509_store_ctx_st* ctx  , const char* name);
void X509_STORE_CTX_set0_dane(struct x509_store_ctx_st* ctx  , struct ssl_dane_st* dane  );
struct X509_VERIFY_PARAM_st* X509_VERIFY_PARAM_new();
void X509_VERIFY_PARAM_free(struct X509_VERIFY_PARAM_st* param  );
int X509_VERIFY_PARAM_inherit(struct X509_VERIFY_PARAM_st* to  , const struct X509_VERIFY_PARAM_st* from  );
int X509_VERIFY_PARAM_set1(struct X509_VERIFY_PARAM_st* to  , const struct X509_VERIFY_PARAM_st* from  );
int X509_VERIFY_PARAM_set1_name(struct X509_VERIFY_PARAM_st* param  , const char* name);
int X509_VERIFY_PARAM_set_flags(struct X509_VERIFY_PARAM_st* param  , unsigned long  int flags);
int X509_VERIFY_PARAM_clear_flags(struct X509_VERIFY_PARAM_st* param  , unsigned long  int flags);
unsigned long  int X509_VERIFY_PARAM_get_flags(const struct X509_VERIFY_PARAM_st* param  );
int X509_VERIFY_PARAM_set_purpose(struct X509_VERIFY_PARAM_st* param  , int purpose);
int X509_VERIFY_PARAM_get_purpose(const struct X509_VERIFY_PARAM_st* param  );
int X509_VERIFY_PARAM_set_trust(struct X509_VERIFY_PARAM_st* param  , int trust);
void X509_VERIFY_PARAM_set_depth(struct X509_VERIFY_PARAM_st* param  , int depth);
void X509_VERIFY_PARAM_set_auth_level(struct X509_VERIFY_PARAM_st* param  , int auth_level);
long  int X509_VERIFY_PARAM_get_time(const struct X509_VERIFY_PARAM_st* param  );
void X509_VERIFY_PARAM_set_time(struct X509_VERIFY_PARAM_st* param  , long  int t  );
int X509_VERIFY_PARAM_add0_policy(struct X509_VERIFY_PARAM_st* param  , struct asn1_object_st* policy  );
int X509_VERIFY_PARAM_set1_policies(struct X509_VERIFY_PARAM_st* param  , struct stack_st_ASN1_OBJECT* policies  );
int X509_VERIFY_PARAM_set_inh_flags(struct X509_VERIFY_PARAM_st* param  , unsigned int flags  );
unsigned int X509_VERIFY_PARAM_get_inh_flags(const struct X509_VERIFY_PARAM_st* param  );
char* X509_VERIFY_PARAM_get0_host(struct X509_VERIFY_PARAM_st* param  , int idx);
int X509_VERIFY_PARAM_set1_host(struct X509_VERIFY_PARAM_st* param  , const char* name, unsigned long namelen  );
int X509_VERIFY_PARAM_add1_host(struct X509_VERIFY_PARAM_st* param  , const char* name, unsigned long namelen  );
void X509_VERIFY_PARAM_set_hostflags(struct X509_VERIFY_PARAM_st* param  , unsigned int flags);
unsigned int X509_VERIFY_PARAM_get_hostflags(const struct X509_VERIFY_PARAM_st* param  );
char* X509_VERIFY_PARAM_get0_peername(const struct X509_VERIFY_PARAM_st* param  );
void X509_VERIFY_PARAM_move_peername(struct X509_VERIFY_PARAM_st*   , struct X509_VERIFY_PARAM_st*   );
char* X509_VERIFY_PARAM_get0_email(struct X509_VERIFY_PARAM_st* param  );
int X509_VERIFY_PARAM_set1_email(struct X509_VERIFY_PARAM_st* param  , const char* email, unsigned long emaillen  );
char* X509_VERIFY_PARAM_get1_ip_asc(struct X509_VERIFY_PARAM_st* param  );
int X509_VERIFY_PARAM_set1_ip(struct X509_VERIFY_PARAM_st* param  , const unsigned char* ip, unsigned long iplen  );
int X509_VERIFY_PARAM_set1_ip_asc(struct X509_VERIFY_PARAM_st* param  , const char* ipasc);
int X509_VERIFY_PARAM_get_depth(const struct X509_VERIFY_PARAM_st* param  );
int X509_VERIFY_PARAM_get_auth_level(const struct X509_VERIFY_PARAM_st* param  );
const char* X509_VERIFY_PARAM_get0_name(const struct X509_VERIFY_PARAM_st* param  );
int X509_VERIFY_PARAM_add0_table(struct X509_VERIFY_PARAM_st* param  );
int X509_VERIFY_PARAM_get_count();
const struct X509_VERIFY_PARAM_st* X509_VERIFY_PARAM_get0(int id);
const struct X509_VERIFY_PARAM_st* X509_VERIFY_PARAM_lookup(const char* name);
void X509_VERIFY_PARAM_table_cleanup();
int X509_policy_check(struct X509_POLICY_TREE_st** ptree  , int* pexplicit_policy, struct stack_st_X509* certs  , struct stack_st_ASN1_OBJECT* policy_oids  , unsigned int flags);
void X509_policy_tree_free(struct X509_POLICY_TREE_st* tree  );
int X509_policy_tree_level_count(const struct X509_POLICY_TREE_st* tree  );
struct X509_POLICY_LEVEL_st* X509_policy_tree_get0_level(const struct X509_POLICY_TREE_st* tree  , int i);
struct stack_st_X509_POLICY_NODE* X509_policy_tree_get0_policies(const struct X509_POLICY_TREE_st* tree  );
struct stack_st_X509_POLICY_NODE* X509_policy_tree_get0_user_policies(const struct X509_POLICY_TREE_st* tree  );
int X509_policy_level_node_count(struct X509_POLICY_LEVEL_st* level  );
struct X509_POLICY_NODE_st* X509_policy_level_get0_node(const struct X509_POLICY_LEVEL_st* level  , int i);
const struct asn1_object_st* X509_policy_node_get0_policy(const struct X509_POLICY_NODE_st* node  );
struct stack_st_POLICYQUALINFO* X509_policy_node_get0_qualifiers(const struct X509_POLICY_NODE_st* node  );
const struct X509_POLICY_NODE_st* X509_policy_node_get0_parent(const struct X509_POLICY_NODE_st* node  );
static struct pkcs7_signer_info_st* ossl_check_PKCS7_SIGNER_INFO_type(struct pkcs7_signer_info_st* ptr  );
static const struct stack_st* ossl_check_const_PKCS7_SIGNER_INFO_sk_type(const struct stack_st_PKCS7_SIGNER_INFO* sk  );
static struct stack_st* ossl_check_PKCS7_SIGNER_INFO_sk_type(struct stack_st_PKCS7_SIGNER_INFO* sk  );
static int (*ossl_check_PKCS7_SIGNER_INFO_compfunc_type(int (*cmp)(const struct pkcs7_signer_info_st**,const struct pkcs7_signer_info_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_PKCS7_SIGNER_INFO_copyfunc_type(struct pkcs7_signer_info_st* (*cpy)(const struct pkcs7_signer_info_st*)  ))(const void*) ;
static void (*ossl_check_PKCS7_SIGNER_INFO_freefunc_type(void (*fr)(struct pkcs7_signer_info_st*)  ))(void*) ;
static struct pkcs7_recip_info_st* ossl_check_PKCS7_RECIP_INFO_type(struct pkcs7_recip_info_st* ptr  );
static const struct stack_st* ossl_check_const_PKCS7_RECIP_INFO_sk_type(const struct stack_st_PKCS7_RECIP_INFO* sk  );
static struct stack_st* ossl_check_PKCS7_RECIP_INFO_sk_type(struct stack_st_PKCS7_RECIP_INFO* sk  );
static int (*ossl_check_PKCS7_RECIP_INFO_compfunc_type(int (*cmp)(const struct pkcs7_recip_info_st**,const struct pkcs7_recip_info_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_PKCS7_RECIP_INFO_copyfunc_type(struct pkcs7_recip_info_st* (*cpy)(const struct pkcs7_recip_info_st*)  ))(const void*) ;
static void (*ossl_check_PKCS7_RECIP_INFO_freefunc_type(void (*fr)(struct pkcs7_recip_info_st*)  ))(void*) ;
static struct pkcs7_st* ossl_check_PKCS7_type(struct pkcs7_st* ptr  );
static const struct stack_st* ossl_check_const_PKCS7_sk_type(const struct stack_st_PKCS7* sk  );
static struct stack_st* ossl_check_PKCS7_sk_type(struct stack_st_PKCS7* sk  );
static int (*ossl_check_PKCS7_compfunc_type(int (*cmp)(const struct pkcs7_st**,const struct pkcs7_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_PKCS7_copyfunc_type(struct pkcs7_st* (*cpy)(const struct pkcs7_st*)  ))(const void*) ;
static void (*ossl_check_PKCS7_freefunc_type(void (*fr)(struct pkcs7_st*)  ))(void*) ;
struct pkcs7_issuer_and_serial_st* PKCS7_ISSUER_AND_SERIAL_new();
void PKCS7_ISSUER_AND_SERIAL_free(struct pkcs7_issuer_and_serial_st* a  );
struct pkcs7_issuer_and_serial_st* d2i_PKCS7_ISSUER_AND_SERIAL(struct pkcs7_issuer_and_serial_st** a  , const unsigned char** in, long len);
int i2d_PKCS7_ISSUER_AND_SERIAL(const struct pkcs7_issuer_and_serial_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_ISSUER_AND_SERIAL_it();
int PKCS7_ISSUER_AND_SERIAL_digest(struct pkcs7_issuer_and_serial_st* data  , const struct evp_md_st* type  , unsigned char* md, unsigned int* len);
struct pkcs7_st* d2i_PKCS7_fp(struct _IO_FILE* fp  , struct pkcs7_st** p7  );
int i2d_PKCS7_fp(struct _IO_FILE* fp  , const struct pkcs7_st* p7  );
struct pkcs7_st* PKCS7_dup(const struct pkcs7_st* a  );
struct pkcs7_st* d2i_PKCS7_bio(struct bio_st* bp  , struct pkcs7_st** p7  );
int i2d_PKCS7_bio(struct bio_st* bp  , const struct pkcs7_st* p7  );
int i2d_PKCS7_bio_stream(struct bio_st* out  , struct pkcs7_st* p7  , struct bio_st* in  , int flags);
int PEM_write_bio_PKCS7_stream(struct bio_st* out  , struct pkcs7_st* p7  , struct bio_st* in  , int flags);
struct pkcs7_signer_info_st* PKCS7_SIGNER_INFO_new();
void PKCS7_SIGNER_INFO_free(struct pkcs7_signer_info_st* a  );
struct pkcs7_signer_info_st* d2i_PKCS7_SIGNER_INFO(struct pkcs7_signer_info_st** a  , const unsigned char** in, long len);
int i2d_PKCS7_SIGNER_INFO(const struct pkcs7_signer_info_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_SIGNER_INFO_it();
struct pkcs7_recip_info_st* PKCS7_RECIP_INFO_new();
void PKCS7_RECIP_INFO_free(struct pkcs7_recip_info_st* a  );
struct pkcs7_recip_info_st* d2i_PKCS7_RECIP_INFO(struct pkcs7_recip_info_st** a  , const unsigned char** in, long len);
int i2d_PKCS7_RECIP_INFO(const struct pkcs7_recip_info_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_RECIP_INFO_it();
struct pkcs7_signed_st* PKCS7_SIGNED_new();
void PKCS7_SIGNED_free(struct pkcs7_signed_st* a  );
struct pkcs7_signed_st* d2i_PKCS7_SIGNED(struct pkcs7_signed_st** a  , const unsigned char** in, long len);
int i2d_PKCS7_SIGNED(const struct pkcs7_signed_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_SIGNED_it();
struct pkcs7_enc_content_st* PKCS7_ENC_CONTENT_new();
void PKCS7_ENC_CONTENT_free(struct pkcs7_enc_content_st* a  );
struct pkcs7_enc_content_st* d2i_PKCS7_ENC_CONTENT(struct pkcs7_enc_content_st** a  , const unsigned char** in, long len);
int i2d_PKCS7_ENC_CONTENT(const struct pkcs7_enc_content_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_ENC_CONTENT_it();
struct pkcs7_enveloped_st* PKCS7_ENVELOPE_new();
void PKCS7_ENVELOPE_free(struct pkcs7_enveloped_st* a  );
struct pkcs7_enveloped_st* d2i_PKCS7_ENVELOPE(struct pkcs7_enveloped_st** a  , const unsigned char** in, long len);
int i2d_PKCS7_ENVELOPE(const struct pkcs7_enveloped_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_ENVELOPE_it();
struct pkcs7_signedandenveloped_st* PKCS7_SIGN_ENVELOPE_new();
void PKCS7_SIGN_ENVELOPE_free(struct pkcs7_signedandenveloped_st* a  );
struct pkcs7_signedandenveloped_st* d2i_PKCS7_SIGN_ENVELOPE(struct pkcs7_signedandenveloped_st** a  , const unsigned char** in, long len);
int i2d_PKCS7_SIGN_ENVELOPE(const struct pkcs7_signedandenveloped_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_SIGN_ENVELOPE_it();
struct pkcs7_digest_st* PKCS7_DIGEST_new();
void PKCS7_DIGEST_free(struct pkcs7_digest_st* a  );
struct pkcs7_digest_st* d2i_PKCS7_DIGEST(struct pkcs7_digest_st** a  , const unsigned char** in, long len);
int i2d_PKCS7_DIGEST(const struct pkcs7_digest_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_DIGEST_it();
struct pkcs7_encrypted_st* PKCS7_ENCRYPT_new();
void PKCS7_ENCRYPT_free(struct pkcs7_encrypted_st* a  );
struct pkcs7_encrypted_st* d2i_PKCS7_ENCRYPT(struct pkcs7_encrypted_st** a  , const unsigned char** in, long len);
int i2d_PKCS7_ENCRYPT(const struct pkcs7_encrypted_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_ENCRYPT_it();
struct pkcs7_st* PKCS7_new();
void PKCS7_free(struct pkcs7_st* a  );
struct pkcs7_st* d2i_PKCS7(struct pkcs7_st** a  , const unsigned char** in, long len);
int i2d_PKCS7(const struct pkcs7_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS7_it();
struct pkcs7_st* PKCS7_new_ex(struct ossl_lib_ctx_st* libctx  , const char* propq);
const struct ASN1_ITEM_st* PKCS7_ATTR_SIGN_it();
const struct ASN1_ITEM_st* PKCS7_ATTR_VERIFY_it();
int i2d_PKCS7_NDEF(const struct pkcs7_st* a  , unsigned char** out);
int PKCS7_print_ctx(struct bio_st* out  , const struct pkcs7_st* x  , int indent, const struct asn1_pctx_st* pctx  );
long PKCS7_ctrl(struct pkcs7_st* p7  , int cmd, long larg, char* parg);
int PKCS7_type_is_other(struct pkcs7_st* p7  );
int PKCS7_set_type(struct pkcs7_st* p7  , int type);
int PKCS7_set0_type_other(struct pkcs7_st* p7  , int type, struct asn1_type_st* other  );
int PKCS7_set_content(struct pkcs7_st* p7  , struct pkcs7_st* p7_data  );
int PKCS7_SIGNER_INFO_set(struct pkcs7_signer_info_st* p7i  , struct x509_st* x509  , struct evp_pkey_st* pkey  , const struct evp_md_st* dgst  );
int PKCS7_SIGNER_INFO_sign(struct pkcs7_signer_info_st* si  );
int PKCS7_add_signer(struct pkcs7_st* p7  , struct pkcs7_signer_info_st* p7i  );
int PKCS7_add_certificate(struct pkcs7_st* p7  , struct x509_st* cert  );
int PKCS7_add_crl(struct pkcs7_st* p7  , struct X509_crl_st* crl  );
int PKCS7_content_new(struct pkcs7_st* p7  , int nid);
int PKCS7_dataVerify(struct x509_store_st* cert_store  , struct x509_store_ctx_st* ctx  , struct bio_st* bio  , struct pkcs7_st* p7  , struct pkcs7_signer_info_st* si  );
int PKCS7_signatureVerify(struct bio_st* bio  , struct pkcs7_st* p7  , struct pkcs7_signer_info_st* si  , struct x509_st* signer  );
struct bio_st* PKCS7_dataInit(struct pkcs7_st* p7  , struct bio_st* bio  );
int PKCS7_dataFinal(struct pkcs7_st* p7  , struct bio_st* bio  );
struct bio_st* PKCS7_dataDecode(struct pkcs7_st* p7  , struct evp_pkey_st* pkey  , struct bio_st* in_bio  , struct x509_st* pcert  );
struct pkcs7_signer_info_st* PKCS7_add_signature(struct pkcs7_st* p7  , struct x509_st* x509  , struct evp_pkey_st* pkey  , const struct evp_md_st* dgst  );
struct x509_st* PKCS7_cert_from_signer_info(struct pkcs7_st* p7  , struct pkcs7_signer_info_st* si  );
int PKCS7_set_digest(struct pkcs7_st* p7  , const struct evp_md_st* md  );
struct stack_st_PKCS7_SIGNER_INFO* PKCS7_get_signer_info(struct pkcs7_st* p7  );
struct pkcs7_recip_info_st* PKCS7_add_recipient(struct pkcs7_st* p7  , struct x509_st* x509  );
void PKCS7_SIGNER_INFO_get0_algs(struct pkcs7_signer_info_st* si  , struct evp_pkey_st** pk  , struct X509_algor_st** pdig  , struct X509_algor_st** psig  );
void PKCS7_RECIP_INFO_get0_alg(struct pkcs7_recip_info_st* ri  , struct X509_algor_st** penc  );
int PKCS7_add_recipient_info(struct pkcs7_st* p7  , struct pkcs7_recip_info_st* ri  );
int PKCS7_RECIP_INFO_set(struct pkcs7_recip_info_st* p7i  , struct x509_st* x509  );
int PKCS7_set_cipher(struct pkcs7_st* p7  , const struct evp_cipher_st* cipher  );
int PKCS7_stream(unsigned char*** boundary, struct pkcs7_st* p7  );
struct pkcs7_issuer_and_serial_st* PKCS7_get_issuer_and_serial(struct pkcs7_st* p7  , int idx);
struct asn1_string_st* PKCS7_get_octet_string(struct pkcs7_st* p7  );
struct asn1_string_st* PKCS7_digest_from_attributes(struct stack_st_X509_ATTRIBUTE* sk  );
int PKCS7_add_signed_attribute(struct pkcs7_signer_info_st* p7si  , int nid, int type, void* data);
int PKCS7_add_attribute(struct pkcs7_signer_info_st* p7si  , int nid, int atrtype, void* value);
struct asn1_type_st* PKCS7_get_attribute(const struct pkcs7_signer_info_st* si  , int nid);
struct asn1_type_st* PKCS7_get_signed_attribute(const struct pkcs7_signer_info_st* si  , int nid);
int PKCS7_set_signed_attributes(struct pkcs7_signer_info_st* p7si  , struct stack_st_X509_ATTRIBUTE* sk  );
int PKCS7_set_attributes(struct pkcs7_signer_info_st* p7si  , struct stack_st_X509_ATTRIBUTE* sk  );
struct pkcs7_st* PKCS7_sign(struct x509_st* signcert  , struct evp_pkey_st* pkey  , struct stack_st_X509* certs  , struct bio_st* data  , int flags);
struct pkcs7_st* PKCS7_sign_ex(struct x509_st* signcert  , struct evp_pkey_st* pkey  , struct stack_st_X509* certs  , struct bio_st* data  , int flags, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct pkcs7_signer_info_st* PKCS7_sign_add_signer(struct pkcs7_st* p7  , struct x509_st* signcert  , struct evp_pkey_st* pkey  , const struct evp_md_st* md  , int flags);
int PKCS7_final(struct pkcs7_st* p7  , struct bio_st* data  , int flags);
int PKCS7_verify(struct pkcs7_st* p7  , struct stack_st_X509* certs  , struct x509_store_st* store  , struct bio_st* indata  , struct bio_st* out  , int flags);
struct stack_st_X509* PKCS7_get0_signers(struct pkcs7_st* p7  , struct stack_st_X509* certs  , int flags);
struct pkcs7_st* PKCS7_encrypt(struct stack_st_X509* certs  , struct bio_st* in  , const struct evp_cipher_st* cipher  , int flags);
struct pkcs7_st* PKCS7_encrypt_ex(struct stack_st_X509* certs  , struct bio_st* in  , const struct evp_cipher_st* cipher  , int flags, struct ossl_lib_ctx_st* libctx  , const char* propq);
int PKCS7_decrypt(struct pkcs7_st* p7  , struct evp_pkey_st* pkey  , struct x509_st* cert  , struct bio_st* data  , int flags);
int PKCS7_add_attrib_smimecap(struct pkcs7_signer_info_st* si  , struct stack_st_X509_ALGOR* cap  );
struct stack_st_X509_ALGOR* PKCS7_get_smimecap(struct pkcs7_signer_info_st* si  );
int PKCS7_simple_smimecap(struct stack_st_X509_ALGOR* sk  , int nid, int arg);
int PKCS7_add_attrib_content_type(struct pkcs7_signer_info_st* si  , struct asn1_object_st* coid  );
int PKCS7_add0_attrib_signing_time(struct pkcs7_signer_info_st* si  , struct asn1_string_st* t  );
int PKCS7_add1_attrib_digest(struct pkcs7_signer_info_st* si  , const unsigned char* md, int mdlen);
int SMIME_write_PKCS7(struct bio_st* bio  , struct pkcs7_st* p7  , struct bio_st* data  , int flags);
struct pkcs7_st* SMIME_read_PKCS7_ex(struct bio_st* bio  , struct bio_st** bcont  , struct pkcs7_st** p7  );
struct pkcs7_st* SMIME_read_PKCS7(struct bio_st* bio  , struct bio_st** bcont  );
struct bio_st* BIO_new_PKCS7(struct bio_st* out  , struct pkcs7_st* p7  );
void X509_CRL_set_default_method(const struct x509_crl_method_st* meth  );
struct x509_crl_method_st* X509_CRL_METHOD_new(int (*crl_init)(struct X509_crl_st*), int (*crl_free)(struct X509_crl_st*), int (*crl_lookup)(struct X509_crl_st*,struct x509_revoked_st**,const struct asn1_string_st*,const struct X509_name_st*), int (*crl_verify)(struct X509_crl_st*,struct evp_pkey_st*));
void X509_CRL_METHOD_free(struct x509_crl_method_st* m  );
void X509_CRL_set_meth_data(struct X509_crl_st* crl  , void* dat);
void* X509_CRL_get_meth_data(struct X509_crl_st* crl  );
const char* X509_verify_cert_error_string(long n);
int X509_verify(struct x509_st* a  , struct evp_pkey_st* r  );
int X509_self_signed(struct x509_st* cert  , int verify_signature);
int X509_REQ_verify_ex(struct X509_req_st* a  , struct evp_pkey_st* r  , struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_REQ_verify(struct X509_req_st* a  , struct evp_pkey_st* r  );
int X509_CRL_verify(struct X509_crl_st* a  , struct evp_pkey_st* r  );
int NETSCAPE_SPKI_verify(struct Netscape_spki_st* a  , struct evp_pkey_st* r  );
struct Netscape_spki_st* NETSCAPE_SPKI_b64_decode(const char* str, int len);
char* NETSCAPE_SPKI_b64_encode(struct Netscape_spki_st* x  );
struct evp_pkey_st* NETSCAPE_SPKI_get_pubkey(struct Netscape_spki_st* x  );
int NETSCAPE_SPKI_set_pubkey(struct Netscape_spki_st* x  , struct evp_pkey_st* pkey  );
int NETSCAPE_SPKI_print(struct bio_st* out  , struct Netscape_spki_st* spki  );
int X509_signature_dump(struct bio_st* bp  , const struct asn1_string_st* sig  , int indent);
int X509_signature_print(struct bio_st* bp  , const struct X509_algor_st* alg  , const struct asn1_string_st* sig  );
int X509_sign(struct x509_st* x  , struct evp_pkey_st* pkey  , const struct evp_md_st* md  );
int X509_sign_ctx(struct x509_st* x  , struct evp_md_ctx_st* ctx  );
int X509_REQ_sign(struct X509_req_st* x  , struct evp_pkey_st* pkey  , const struct evp_md_st* md  );
int X509_REQ_sign_ctx(struct X509_req_st* x  , struct evp_md_ctx_st* ctx  );
int X509_CRL_sign(struct X509_crl_st* x  , struct evp_pkey_st* pkey  , const struct evp_md_st* md  );
int X509_CRL_sign_ctx(struct X509_crl_st* x  , struct evp_md_ctx_st* ctx  );
int NETSCAPE_SPKI_sign(struct Netscape_spki_st* x  , struct evp_pkey_st* pkey  , const struct evp_md_st* md  );
int X509_pubkey_digest(const struct x509_st* data  , const struct evp_md_st* type  , unsigned char* md, unsigned int* len);
int X509_digest(const struct x509_st* data  , const struct evp_md_st* type  , unsigned char* md, unsigned int* len);
struct asn1_string_st* X509_digest_sig(const struct x509_st* cert  , struct evp_md_st** md_used  , int* md_is_fallback);
int X509_CRL_digest(const struct X509_crl_st* data  , const struct evp_md_st* type  , unsigned char* md, unsigned int* len);
int X509_REQ_digest(const struct X509_req_st* data  , const struct evp_md_st* type  , unsigned char* md, unsigned int* len);
int X509_NAME_digest(const struct X509_name_st* data  , const struct evp_md_st* type  , unsigned char* md, unsigned int* len);
struct x509_st* X509_load_http(const char* url, struct bio_st* bio  , struct bio_st* rbio  , int timeout);
struct X509_crl_st* X509_CRL_load_http(const char* url, struct bio_st* bio  , struct bio_st* rbio  , int timeout);
static struct anonymous_typeX45* ossl_check_CONF_VALUE_type(struct anonymous_typeX45* ptr  );
static const struct stack_st* ossl_check_const_CONF_VALUE_sk_type(const struct stack_st_CONF_VALUE* sk  );
static struct stack_st* ossl_check_CONF_VALUE_sk_type(struct stack_st_CONF_VALUE* sk  );
static int (*ossl_check_CONF_VALUE_compfunc_type(int (*cmp)(const struct anonymous_typeX45**,const struct anonymous_typeX45**)  ))(const void*,const void*) ;
static void* (*ossl_check_CONF_VALUE_copyfunc_type(struct anonymous_typeX45* (*cpy)(const struct anonymous_typeX45*)  ))(const void*) ;
static void (*ossl_check_CONF_VALUE_freefunc_type(void (*fr)(struct anonymous_typeX45*)  ))(void*) ;
static unsigned long  int lh_CONF_VALUE_hash_thunk(const void* data, unsigned long  int (*hfn)(const void*)  );
static int lh_CONF_VALUE_comp_thunk(const void* da, const void* db, int (*cfn)(const void*,const void*)  );
static void lh_CONF_VALUE_doall_thunk(void* node, void (*doall)(void*)  );
static void lh_CONF_VALUE_doall_arg_thunk(void* node, void* arg, void (*doall)(void*,void*)  );
static struct anonymous_typeX45* ossl_check_CONF_VALUE_lh_plain_type(struct anonymous_typeX45* ptr  );
static const struct anonymous_typeX45* ossl_check_const_CONF_VALUE_lh_plain_type(const struct anonymous_typeX45* ptr  );
static const struct lhash_st* ossl_check_const_CONF_VALUE_lh_type(const struct lhash_st_CONF_VALUE* lh  );
static struct lhash_st* ossl_check_CONF_VALUE_lh_type(struct lhash_st_CONF_VALUE* lh  );
static int (*ossl_check_CONF_VALUE_lh_compfunc_type(int (*cmp)(const struct anonymous_typeX45*,const struct anonymous_typeX45*)  ))(const void*,const void*) ;
static unsigned long  int (*ossl_check_CONF_VALUE_lh_hashfunc_type(unsigned long  int (*hfn)(const struct anonymous_typeX45*)  ))(const void*) ;
static void (*ossl_check_CONF_VALUE_lh_doallfunc_type(void (*dfn)(struct anonymous_typeX45*)  ))(void*) ;
int CONF_set_default_method(struct conf_method_st* meth  );
void CONF_set_nconf(struct conf_st* conf  , struct lhash_st_CONF_VALUE* hash  );
struct lhash_st_CONF_VALUE* CONF_load(struct lhash_st_CONF_VALUE* conf  , const char* file, long* eline);
struct lhash_st_CONF_VALUE* CONF_load_fp(struct lhash_st_CONF_VALUE* conf  , struct _IO_FILE* fp  , long* eline);
struct lhash_st_CONF_VALUE* CONF_load_bio(struct lhash_st_CONF_VALUE* conf  , struct bio_st* bp  , long* eline);
struct stack_st_CONF_VALUE* CONF_get_section(struct lhash_st_CONF_VALUE* conf  , const char* section);
char* CONF_get_string(struct lhash_st_CONF_VALUE* conf  , const char* group, const char* name);
long CONF_get_number(struct lhash_st_CONF_VALUE* conf  , const char* group, const char* name);
void CONF_free(struct lhash_st_CONF_VALUE* conf  );
int CONF_dump_fp(struct lhash_st_CONF_VALUE* conf  , struct _IO_FILE* out  );
int CONF_dump_bio(struct lhash_st_CONF_VALUE* conf  , struct bio_st* out  );
void OPENSSL_config(const char* config_name);
struct conf_st* NCONF_new_ex(struct ossl_lib_ctx_st* libctx  , struct conf_method_st* meth  );
struct ossl_lib_ctx_st* NCONF_get0_libctx(const struct conf_st* conf  );
struct conf_st* NCONF_new(struct conf_method_st* meth  );
struct conf_method_st* NCONF_default();
struct conf_method_st* NCONF_WIN32();
void NCONF_free(struct conf_st* conf  );
void NCONF_free_data(struct conf_st* conf  );
int NCONF_load(struct conf_st* conf  , const char* file, long* eline);
int NCONF_load_fp(struct conf_st* conf  , struct _IO_FILE* fp  , long* eline);
int NCONF_load_bio(struct conf_st* conf  , struct bio_st* bp  , long* eline);
struct stack_st_OPENSSL_CSTRING* NCONF_get_section_names(const struct conf_st* conf  );
struct stack_st_CONF_VALUE* NCONF_get_section(const struct conf_st* conf  , const char* section);
char* NCONF_get_string(const struct conf_st* conf  , const char* group, const char* name);
int NCONF_get_number_e(const struct conf_st* conf  , const char* group, const char* name, long* result);
int NCONF_dump_fp(const struct conf_st* conf  , struct _IO_FILE* out  );
int NCONF_dump_bio(const struct conf_st* conf  , struct bio_st* out  );
int CONF_modules_load(const struct conf_st* cnf  , const char* appname, unsigned long  int flags);
int CONF_modules_load_file_ex(struct ossl_lib_ctx_st* libctx  , const char* filename, const char* appname, unsigned long  int flags);
int CONF_modules_load_file(const char* filename, const char* appname, unsigned long  int flags);
void CONF_modules_unload(int all);
void CONF_modules_finish();
int CONF_module_add(const char* name, int (*(*ifunc))(struct conf_imodule_st*,const struct conf_st*)  , void (*(*ffunc))(struct conf_imodule_st*)  );
const char* CONF_imodule_get_name(const struct conf_imodule_st* md  );
const char* CONF_imodule_get_value(const struct conf_imodule_st* md  );
void* CONF_imodule_get_usr_data(const struct conf_imodule_st* md  );
void CONF_imodule_set_usr_data(struct conf_imodule_st* md  , void* usr_data);
struct conf_module_st* CONF_imodule_get_module(const struct conf_imodule_st* md  );
unsigned long  int CONF_imodule_get_flags(const struct conf_imodule_st* md  );
void CONF_imodule_set_flags(struct conf_imodule_st* md  , unsigned long  int flags);
void* CONF_module_get_usr_data(struct conf_module_st* pmod  );
void CONF_module_set_usr_data(struct conf_module_st* pmod  , void* usr_data);
char* CONF_get1_default_config_file();
int CONF_parse_list(const char* list, int sep, int nospc, int (*list_cb)(const char*,int,void*), void* arg);
void OPENSSL_load_builtin_modules();
int OSSL_parse_url(const char* url, char** pscheme, char** puser, char** phost, char** pport, int* pport_num, char** ppath, char** pquery, char** pfrag);
struct ossl_http_req_ctx_st* OSSL_HTTP_REQ_CTX_new(struct bio_st* wbio  , struct bio_st* rbio  , int buf_size);
void OSSL_HTTP_REQ_CTX_free(struct ossl_http_req_ctx_st* rctx  );
int OSSL_HTTP_REQ_CTX_set_request_line(struct ossl_http_req_ctx_st* rctx  , int method_POST, const char* server, const char* port, const char* path);
int OSSL_HTTP_REQ_CTX_add1_header(struct ossl_http_req_ctx_st* rctx  , const char* name, const char* value);
int OSSL_HTTP_REQ_CTX_set_expected(struct ossl_http_req_ctx_st* rctx  , const char* content_type, int asn1, int timeout, int keep_alive);
int OSSL_HTTP_REQ_CTX_set1_req(struct ossl_http_req_ctx_st* rctx  , const char* content_type, const struct ASN1_ITEM_st* it  , const struct ASN1_VALUE_st* req  );
int OSSL_HTTP_REQ_CTX_nbio(struct ossl_http_req_ctx_st* rctx  );
int OSSL_HTTP_REQ_CTX_nbio_d2i(struct ossl_http_req_ctx_st* rctx  , struct ASN1_VALUE_st** pval  , const struct ASN1_ITEM_st* it  );
struct bio_st* OSSL_HTTP_REQ_CTX_exchange(struct ossl_http_req_ctx_st* rctx  );
struct bio_st* OSSL_HTTP_REQ_CTX_get0_mem_bio(const struct ossl_http_req_ctx_st* rctx  );
unsigned long OSSL_HTTP_REQ_CTX_get_resp_len(const struct ossl_http_req_ctx_st* rctx  );
void OSSL_HTTP_REQ_CTX_set_max_response_length(struct ossl_http_req_ctx_st* rctx  , unsigned long  int len);
void OSSL_HTTP_REQ_CTX_set_max_response_hdr_lines(struct ossl_http_req_ctx_st* rctx  , unsigned long count  );
int OSSL_HTTP_is_alive(const struct ossl_http_req_ctx_st* rctx  );
struct ossl_http_req_ctx_st* OSSL_HTTP_open(const char* server, const char* port, const char* proxy, const char* no_proxy, int use_ssl, struct bio_st* bio  , struct bio_st* rbio  , struct bio_st* (*bio_update_fn)(struct bio_st*,void*,int,int)  , void* arg, int buf_size, int overall_timeout);
int OSSL_HTTP_proxy_connect(struct bio_st* bio  , const char* server, const char* port, const char* proxyuser, const char* proxypass, int timeout, struct bio_st* bio_err  , const char* prog);
int OSSL_HTTP_set1_request(struct ossl_http_req_ctx_st* rctx  , const char* path, const struct stack_st_CONF_VALUE* headers  , const char* content_type, struct bio_st* req  , const char* expected_content_type, int expect_asn1, unsigned long max_resp_len  , int timeout, int keep_alive);
struct bio_st* OSSL_HTTP_exchange(struct ossl_http_req_ctx_st* rctx  , char** redirection_url);
struct bio_st* OSSL_HTTP_get(const char* url, const char* proxy, const char* no_proxy, struct bio_st* bio  , struct bio_st* rbio  , struct bio_st* (*bio_update_fn)(struct bio_st*,void*,int,int)  , void* arg, int buf_size, const struct stack_st_CONF_VALUE* headers  , const char* expected_content_type, int expect_asn1, unsigned long max_resp_len  , int timeout);
struct bio_st* OSSL_HTTP_transfer(struct ossl_http_req_ctx_st** prctx  , const char* server, const char* port, const char* path, int use_ssl, const char* proxy, const char* no_proxy, struct bio_st* bio  , struct bio_st* rbio  , struct bio_st* (*bio_update_fn)(struct bio_st*,void*,int,int)  , void* arg, int buf_size, const struct stack_st_CONF_VALUE* headers  , const char* content_type, struct bio_st* req  , const char* expected_content_type, int expect_asn1, unsigned long max_resp_len  , int timeout, int keep_alive);
int OSSL_HTTP_close(struct ossl_http_req_ctx_st* rctx  , int ok);
int OSSL_HTTP_parse_url(const char* url, int* pssl, char** puser, char** phost, char** pport, int* pport_num, char** ppath, char** pquery, char** pfrag);
const char* OSSL_HTTP_adapt_proxy(const char* proxy, const char* no_proxy, const char* server, int use_ssl);
struct x509_st* d2i_X509_fp(struct _IO_FILE* fp  , struct x509_st** x509  );
int i2d_X509_fp(struct _IO_FILE* fp  , const struct x509_st* x509  );
struct X509_crl_st* d2i_X509_CRL_fp(struct _IO_FILE* fp  , struct X509_crl_st** crl  );
int i2d_X509_CRL_fp(struct _IO_FILE* fp  , const struct X509_crl_st* crl  );
struct X509_req_st* d2i_X509_REQ_fp(struct _IO_FILE* fp  , struct X509_req_st** req  );
int i2d_X509_REQ_fp(struct _IO_FILE* fp  , const struct X509_req_st* req  );
struct rsa_st* d2i_RSAPrivateKey_fp(struct _IO_FILE* fp  , struct rsa_st** rsa  );
int i2d_RSAPrivateKey_fp(struct _IO_FILE* fp  , const struct rsa_st* rsa  );
struct rsa_st* d2i_RSAPublicKey_fp(struct _IO_FILE* fp  , struct rsa_st** rsa  );
int i2d_RSAPublicKey_fp(struct _IO_FILE* fp  , const struct rsa_st* rsa  );
struct rsa_st* d2i_RSA_PUBKEY_fp(struct _IO_FILE* fp  , struct rsa_st** rsa  );
int i2d_RSA_PUBKEY_fp(struct _IO_FILE* fp  , const struct rsa_st* rsa  );
struct dsa_st* d2i_DSA_PUBKEY_fp(struct _IO_FILE* fp  , struct dsa_st** dsa  );
int i2d_DSA_PUBKEY_fp(struct _IO_FILE* fp  , const struct dsa_st* dsa  );
struct dsa_st* d2i_DSAPrivateKey_fp(struct _IO_FILE* fp  , struct dsa_st** dsa  );
int i2d_DSAPrivateKey_fp(struct _IO_FILE* fp  , const struct dsa_st* dsa  );
struct ec_key_st* d2i_EC_PUBKEY_fp(struct _IO_FILE* fp  , struct ec_key_st** eckey  );
int i2d_EC_PUBKEY_fp(struct _IO_FILE* fp  , const struct ec_key_st* eckey  );
struct ec_key_st* d2i_ECPrivateKey_fp(struct _IO_FILE* fp  , struct ec_key_st** eckey  );
int i2d_ECPrivateKey_fp(struct _IO_FILE* fp  , const struct ec_key_st* eckey  );
struct X509_sig_st* d2i_PKCS8_fp(struct _IO_FILE* fp  , struct X509_sig_st** p8  );
int i2d_PKCS8_fp(struct _IO_FILE* fp  , const struct X509_sig_st* p8  );
struct X509_pubkey_st* d2i_X509_PUBKEY_fp(struct _IO_FILE* fp  , struct X509_pubkey_st** xpk  );
int i2d_X509_PUBKEY_fp(struct _IO_FILE* fp  , const struct X509_pubkey_st* xpk  );
struct pkcs8_priv_key_info_st* d2i_PKCS8_PRIV_KEY_INFO_fp(struct _IO_FILE* fp  , struct pkcs8_priv_key_info_st** p8inf  );
int i2d_PKCS8_PRIV_KEY_INFO_fp(struct _IO_FILE* fp  , const struct pkcs8_priv_key_info_st* p8inf  );
int i2d_PKCS8PrivateKeyInfo_fp(struct _IO_FILE* fp  , const struct evp_pkey_st* key  );
int i2d_PrivateKey_fp(struct _IO_FILE* fp  , const struct evp_pkey_st* pkey  );
struct evp_pkey_st* d2i_PrivateKey_ex_fp(struct _IO_FILE* fp  , struct evp_pkey_st** a  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* d2i_PrivateKey_fp(struct _IO_FILE* fp  , struct evp_pkey_st** a  );
int i2d_PUBKEY_fp(struct _IO_FILE* fp  , const struct evp_pkey_st* pkey  );
struct evp_pkey_st* d2i_PUBKEY_ex_fp(struct _IO_FILE* fp  , struct evp_pkey_st** a  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* d2i_PUBKEY_fp(struct _IO_FILE* fp  , struct evp_pkey_st** a  );
struct x509_st* d2i_X509_bio(struct bio_st* bp  , struct x509_st** x509  );
int i2d_X509_bio(struct bio_st* bp  , const struct x509_st* x509  );
struct X509_crl_st* d2i_X509_CRL_bio(struct bio_st* bp  , struct X509_crl_st** crl  );
int i2d_X509_CRL_bio(struct bio_st* bp  , const struct X509_crl_st* crl  );
struct X509_req_st* d2i_X509_REQ_bio(struct bio_st* bp  , struct X509_req_st** req  );
int i2d_X509_REQ_bio(struct bio_st* bp  , const struct X509_req_st* req  );
struct rsa_st* d2i_RSAPrivateKey_bio(struct bio_st* bp  , struct rsa_st** rsa  );
int i2d_RSAPrivateKey_bio(struct bio_st* bp  , const struct rsa_st* rsa  );
struct rsa_st* d2i_RSAPublicKey_bio(struct bio_st* bp  , struct rsa_st** rsa  );
int i2d_RSAPublicKey_bio(struct bio_st* bp  , const struct rsa_st* rsa  );
struct rsa_st* d2i_RSA_PUBKEY_bio(struct bio_st* bp  , struct rsa_st** rsa  );
int i2d_RSA_PUBKEY_bio(struct bio_st* bp  , const struct rsa_st* rsa  );
struct dsa_st* d2i_DSA_PUBKEY_bio(struct bio_st* bp  , struct dsa_st** dsa  );
int i2d_DSA_PUBKEY_bio(struct bio_st* bp  , const struct dsa_st* dsa  );
struct dsa_st* d2i_DSAPrivateKey_bio(struct bio_st* bp  , struct dsa_st** dsa  );
int i2d_DSAPrivateKey_bio(struct bio_st* bp  , const struct dsa_st* dsa  );
struct ec_key_st* d2i_EC_PUBKEY_bio(struct bio_st* bp  , struct ec_key_st** eckey  );
int i2d_EC_PUBKEY_bio(struct bio_st* bp  , const struct ec_key_st* eckey  );
struct ec_key_st* d2i_ECPrivateKey_bio(struct bio_st* bp  , struct ec_key_st** eckey  );
int i2d_ECPrivateKey_bio(struct bio_st* bp  , const struct ec_key_st* eckey  );
struct X509_sig_st* d2i_PKCS8_bio(struct bio_st* bp  , struct X509_sig_st** p8  );
int i2d_PKCS8_bio(struct bio_st* bp  , const struct X509_sig_st* p8  );
struct X509_pubkey_st* d2i_X509_PUBKEY_bio(struct bio_st* bp  , struct X509_pubkey_st** xpk  );
int i2d_X509_PUBKEY_bio(struct bio_st* bp  , const struct X509_pubkey_st* xpk  );
struct pkcs8_priv_key_info_st* d2i_PKCS8_PRIV_KEY_INFO_bio(struct bio_st* bp  , struct pkcs8_priv_key_info_st** p8inf  );
int i2d_PKCS8_PRIV_KEY_INFO_bio(struct bio_st* bp  , const struct pkcs8_priv_key_info_st* p8inf  );
int i2d_PKCS8PrivateKeyInfo_bio(struct bio_st* bp  , const struct evp_pkey_st* key  );
int i2d_PrivateKey_bio(struct bio_st* bp  , const struct evp_pkey_st* pkey  );
struct evp_pkey_st* d2i_PrivateKey_ex_bio(struct bio_st* bp  , struct evp_pkey_st** a  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* d2i_PrivateKey_bio(struct bio_st* bp  , struct evp_pkey_st** a  );
int i2d_PUBKEY_bio(struct bio_st* bp  , const struct evp_pkey_st* pkey  );
struct evp_pkey_st* d2i_PUBKEY_ex_bio(struct bio_st* bp  , struct evp_pkey_st** a  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* d2i_PUBKEY_bio(struct bio_st* bp  , struct evp_pkey_st** a  );
struct x509_st* X509_dup(const struct x509_st* a  );
struct X509_algor_st* X509_ALGOR_dup(const struct X509_algor_st* a  );
struct x509_attributes_st* X509_ATTRIBUTE_dup(const struct x509_attributes_st* a  );
struct X509_crl_st* X509_CRL_dup(const struct X509_crl_st* a  );
struct X509_extension_st* X509_EXTENSION_dup(const struct X509_extension_st* a  );
struct X509_pubkey_st* X509_PUBKEY_dup(const struct X509_pubkey_st* a  );
struct X509_req_st* X509_REQ_dup(const struct X509_req_st* a  );
struct x509_revoked_st* X509_REVOKED_dup(const struct x509_revoked_st* a  );
int X509_ALGOR_set0(struct X509_algor_st* alg  , struct asn1_object_st* aobj  , int ptype, void* pval);
void X509_ALGOR_get0(const struct asn1_object_st** paobj  , int* pptype, const void** ppval, const struct X509_algor_st* algor  );
void X509_ALGOR_set_md(struct X509_algor_st* alg  , const struct evp_md_st* md  );
int X509_ALGOR_cmp(const struct X509_algor_st* a  , const struct X509_algor_st* b  );
int X509_ALGOR_copy(struct X509_algor_st* dest  , const struct X509_algor_st* src  );
struct X509_name_st* X509_NAME_dup(const struct X509_name_st* a  );
struct X509_name_entry_st* X509_NAME_ENTRY_dup(const struct X509_name_entry_st* a  );
int X509_cmp_time(const struct asn1_string_st* s  , long  int* t  );
int X509_cmp_current_time(const struct asn1_string_st* s  );
int X509_cmp_timeframe(const struct X509_VERIFY_PARAM_st* vpm  , const struct asn1_string_st* start  , const struct asn1_string_st* end  );
struct asn1_string_st* X509_time_adj(struct asn1_string_st* s  , long adj, long  int* t  );
struct asn1_string_st* X509_time_adj_ex(struct asn1_string_st* s  , int offset_day, long offset_sec, long  int* t  );
struct asn1_string_st* X509_gmtime_adj(struct asn1_string_st* s  , long adj);
const char* X509_get_default_cert_area();
const char* X509_get_default_cert_dir();
const char* X509_get_default_cert_file();
const char* X509_get_default_cert_dir_env();
const char* X509_get_default_cert_file_env();
const char* X509_get_default_private_dir();
struct X509_req_st* X509_to_X509_REQ(struct x509_st* x  , struct evp_pkey_st* pkey  , const struct evp_md_st* md  );
struct x509_st* X509_REQ_to_X509(struct X509_req_st* r  , int days, struct evp_pkey_st* pkey  );
struct X509_algor_st* X509_ALGOR_new();
void X509_ALGOR_free(struct X509_algor_st* a  );
struct X509_algor_st* d2i_X509_ALGOR(struct X509_algor_st** a  , const unsigned char** in, long len);
int i2d_X509_ALGOR(const struct X509_algor_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_ALGOR_it();
struct stack_st_X509_ALGOR* d2i_X509_ALGORS(struct stack_st_X509_ALGOR** a  , const unsigned char** in, long len);
int i2d_X509_ALGORS(const struct stack_st_X509_ALGOR* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_ALGORS_it();
struct X509_val_st* X509_VAL_new();
void X509_VAL_free(struct X509_val_st* a  );
struct X509_val_st* d2i_X509_VAL(struct X509_val_st** a  , const unsigned char** in, long len);
int i2d_X509_VAL(const struct X509_val_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_VAL_it();
struct X509_pubkey_st* X509_PUBKEY_new();
void X509_PUBKEY_free(struct X509_pubkey_st* a  );
struct X509_pubkey_st* d2i_X509_PUBKEY(struct X509_pubkey_st** a  , const unsigned char** in, long len);
int i2d_X509_PUBKEY(const struct X509_pubkey_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_PUBKEY_it();
struct X509_pubkey_st* X509_PUBKEY_new_ex(struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_PUBKEY_set(struct X509_pubkey_st** x  , struct evp_pkey_st* pkey  );
struct evp_pkey_st* X509_PUBKEY_get0(const struct X509_pubkey_st* key  );
struct evp_pkey_st* X509_PUBKEY_get(const struct X509_pubkey_st* key  );
int X509_get_pubkey_parameters(struct evp_pkey_st* pkey  , struct stack_st_X509* chain  );
long X509_get_pathlen(struct x509_st* x  );
struct evp_pkey_st* d2i_PUBKEY(struct evp_pkey_st** a  , const unsigned char** in, long len);
int i2d_PUBKEY(const struct evp_pkey_st* a  , unsigned char** out);
struct evp_pkey_st* d2i_PUBKEY_ex(struct evp_pkey_st** a  , const unsigned char** pp, long length, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct rsa_st* d2i_RSA_PUBKEY(struct rsa_st** a  , const unsigned char** in, long len);
int i2d_RSA_PUBKEY(const struct rsa_st* a  , unsigned char** out);
struct dsa_st* d2i_DSA_PUBKEY(struct dsa_st** a  , const unsigned char** in, long len);
int i2d_DSA_PUBKEY(const struct dsa_st* a  , unsigned char** out);
struct ec_key_st* d2i_EC_PUBKEY(struct ec_key_st** a  , const unsigned char** in, long len);
int i2d_EC_PUBKEY(const struct ec_key_st* a  , unsigned char** out);
struct X509_sig_st* X509_SIG_new();
void X509_SIG_free(struct X509_sig_st* a  );
struct X509_sig_st* d2i_X509_SIG(struct X509_sig_st** a  , const unsigned char** in, long len);
int i2d_X509_SIG(const struct X509_sig_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_SIG_it();
void X509_SIG_get0(const struct X509_sig_st* sig  , const struct X509_algor_st** palg  , const struct asn1_string_st** pdigest  );
void X509_SIG_getm(struct X509_sig_st* sig  , struct X509_algor_st** palg  , struct asn1_string_st** pdigest  );
struct X509_req_info_st* X509_REQ_INFO_new();
void X509_REQ_INFO_free(struct X509_req_info_st* a  );
struct X509_req_info_st* d2i_X509_REQ_INFO(struct X509_req_info_st** a  , const unsigned char** in, long len);
int i2d_X509_REQ_INFO(const struct X509_req_info_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_REQ_INFO_it();
struct X509_req_st* X509_REQ_new();
void X509_REQ_free(struct X509_req_st* a  );
struct X509_req_st* d2i_X509_REQ(struct X509_req_st** a  , const unsigned char** in, long len);
int i2d_X509_REQ(const struct X509_req_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_REQ_it();
struct X509_req_st* X509_REQ_new_ex(struct ossl_lib_ctx_st* libctx  , const char* propq);
struct x509_attributes_st* X509_ATTRIBUTE_new();
void X509_ATTRIBUTE_free(struct x509_attributes_st* a  );
struct x509_attributes_st* d2i_X509_ATTRIBUTE(struct x509_attributes_st** a  , const unsigned char** in, long len);
int i2d_X509_ATTRIBUTE(const struct x509_attributes_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_ATTRIBUTE_it();
struct x509_attributes_st* X509_ATTRIBUTE_create(int nid, int atrtype, void* value);
struct X509_extension_st* X509_EXTENSION_new();
void X509_EXTENSION_free(struct X509_extension_st* a  );
struct X509_extension_st* d2i_X509_EXTENSION(struct X509_extension_st** a  , const unsigned char** in, long len);
int i2d_X509_EXTENSION(const struct X509_extension_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_EXTENSION_it();
struct stack_st_X509_EXTENSION* d2i_X509_EXTENSIONS(struct stack_st_X509_EXTENSION** a  , const unsigned char** in, long len);
int i2d_X509_EXTENSIONS(const struct stack_st_X509_EXTENSION* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_EXTENSIONS_it();
struct X509_name_entry_st* X509_NAME_ENTRY_new();
void X509_NAME_ENTRY_free(struct X509_name_entry_st* a  );
struct X509_name_entry_st* d2i_X509_NAME_ENTRY(struct X509_name_entry_st** a  , const unsigned char** in, long len);
int i2d_X509_NAME_ENTRY(const struct X509_name_entry_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_NAME_ENTRY_it();
struct X509_name_st* X509_NAME_new();
void X509_NAME_free(struct X509_name_st* a  );
struct X509_name_st* d2i_X509_NAME(struct X509_name_st** a  , const unsigned char** in, long len);
int i2d_X509_NAME(const struct X509_name_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_NAME_it();
int X509_NAME_set(struct X509_name_st** xn  , const struct X509_name_st* name  );
struct x509_cinf_st* X509_CINF_new();
void X509_CINF_free(struct x509_cinf_st* a  );
struct x509_cinf_st* d2i_X509_CINF(struct x509_cinf_st** a  , const unsigned char** in, long len);
int i2d_X509_CINF(const struct x509_cinf_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_CINF_it();
struct x509_st* X509_new();
void X509_free(struct x509_st* a  );
struct x509_st* d2i_X509(struct x509_st** a  , const unsigned char** in, long len);
int i2d_X509(const struct x509_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_it();
struct x509_st* X509_new_ex(struct ossl_lib_ctx_st* libctx  , const char* propq);
struct x509_cert_aux_st* X509_CERT_AUX_new();
void X509_CERT_AUX_free(struct x509_cert_aux_st* a  );
struct x509_cert_aux_st* d2i_X509_CERT_AUX(struct x509_cert_aux_st** a  , const unsigned char** in, long len);
int i2d_X509_CERT_AUX(const struct x509_cert_aux_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_CERT_AUX_it();
int X509_set_ex_data(struct x509_st* r  , int idx, void* arg);
void* X509_get_ex_data(const struct x509_st* r  , int idx);
struct x509_st* d2i_X509_AUX(struct x509_st** a  , const unsigned char** in, long len);
int i2d_X509_AUX(const struct x509_st* a  , unsigned char** out);
int i2d_re_X509_tbs(struct x509_st* x  , unsigned char** pp);
int X509_SIG_INFO_get(const struct x509_sig_info_st* siginf  , int* mdnid, int* pknid, int* secbits, unsigned int* flags  );
void X509_SIG_INFO_set(struct x509_sig_info_st* siginf  , int mdnid, int pknid, int secbits, unsigned int flags  );
int X509_get_signature_info(struct x509_st* x  , int* mdnid, int* pknid, int* secbits, unsigned int* flags  );
void X509_get0_signature(const struct asn1_string_st** psig  , const struct X509_algor_st** palg  , const struct x509_st* x  );
int X509_get_signature_nid(const struct x509_st* x  );
void X509_set0_distinguishing_id(struct x509_st* x  , struct asn1_string_st* d_id  );
struct asn1_string_st* X509_get0_distinguishing_id(struct x509_st* x  );
void X509_REQ_set0_distinguishing_id(struct X509_req_st* x  , struct asn1_string_st* d_id  );
struct asn1_string_st* X509_REQ_get0_distinguishing_id(struct X509_req_st* x  );
int X509_alias_set1(struct x509_st* x  , const unsigned char* name, int len);
int X509_keyid_set1(struct x509_st* x  , const unsigned char* id, int len);
unsigned char* X509_alias_get0(struct x509_st* x  , int* len);
unsigned char* X509_keyid_get0(struct x509_st* x  , int* len);
struct x509_revoked_st* X509_REVOKED_new();
void X509_REVOKED_free(struct x509_revoked_st* a  );
struct x509_revoked_st* d2i_X509_REVOKED(struct x509_revoked_st** a  , const unsigned char** in, long len);
int i2d_X509_REVOKED(const struct x509_revoked_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_REVOKED_it();
struct X509_crl_info_st* X509_CRL_INFO_new();
void X509_CRL_INFO_free(struct X509_crl_info_st* a  );
struct X509_crl_info_st* d2i_X509_CRL_INFO(struct X509_crl_info_st** a  , const unsigned char** in, long len);
int i2d_X509_CRL_INFO(const struct X509_crl_info_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_CRL_INFO_it();
struct X509_crl_st* X509_CRL_new();
void X509_CRL_free(struct X509_crl_st* a  );
struct X509_crl_st* d2i_X509_CRL(struct X509_crl_st** a  , const unsigned char** in, long len);
int i2d_X509_CRL(const struct X509_crl_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* X509_CRL_it();
struct X509_crl_st* X509_CRL_new_ex(struct ossl_lib_ctx_st* libctx  , const char* propq);
int X509_CRL_add0_revoked(struct X509_crl_st* crl  , struct x509_revoked_st* rev  );
int X509_CRL_get0_by_serial(struct X509_crl_st* crl  , struct x509_revoked_st** ret  , const struct asn1_string_st* serial  );
int X509_CRL_get0_by_cert(struct X509_crl_st* crl  , struct x509_revoked_st** ret  , struct x509_st* x  );
struct private_key_st* X509_PKEY_new();
void X509_PKEY_free(struct private_key_st* a  );
struct Netscape_spki_st* NETSCAPE_SPKI_new();
void NETSCAPE_SPKI_free(struct Netscape_spki_st* a  );
struct Netscape_spki_st* d2i_NETSCAPE_SPKI(struct Netscape_spki_st** a  , const unsigned char** in, long len);
int i2d_NETSCAPE_SPKI(const struct Netscape_spki_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* NETSCAPE_SPKI_it();
struct Netscape_spkac_st* NETSCAPE_SPKAC_new();
void NETSCAPE_SPKAC_free(struct Netscape_spkac_st* a  );
struct Netscape_spkac_st* d2i_NETSCAPE_SPKAC(struct Netscape_spkac_st** a  , const unsigned char** in, long len);
int i2d_NETSCAPE_SPKAC(const struct Netscape_spkac_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* NETSCAPE_SPKAC_it();
struct Netscape_certificate_sequence* NETSCAPE_CERT_SEQUENCE_new();
void NETSCAPE_CERT_SEQUENCE_free(struct Netscape_certificate_sequence* a  );
struct Netscape_certificate_sequence* d2i_NETSCAPE_CERT_SEQUENCE(struct Netscape_certificate_sequence** a  , const unsigned char** in, long len);
int i2d_NETSCAPE_CERT_SEQUENCE(const struct Netscape_certificate_sequence* a  , unsigned char** out);
const struct ASN1_ITEM_st* NETSCAPE_CERT_SEQUENCE_it();
struct X509_info_st* X509_INFO_new();
void X509_INFO_free(struct X509_info_st* a  );
char* X509_NAME_oneline(const struct X509_name_st* a  , char* buf, int size);
int ASN1_verify(int (*(*i2d))(const void*,unsigned char**)  , struct X509_algor_st* algor1  , struct asn1_string_st* signature  , char* data, struct evp_pkey_st* pkey  );
int ASN1_digest(int (*(*i2d))(const void*,unsigned char**)  , const struct evp_md_st* type  , char* data, unsigned char* md, unsigned int* len);
int ASN1_sign(int (*(*i2d))(const void*,unsigned char**)  , struct X509_algor_st* algor1  , struct X509_algor_st* algor2  , struct asn1_string_st* signature  , char* data, struct evp_pkey_st* pkey  , const struct evp_md_st* type  );
int ASN1_item_digest(const struct ASN1_ITEM_st* it  , const struct evp_md_st* type  , void* data, unsigned char* md, unsigned int* len);
int ASN1_item_verify(const struct ASN1_ITEM_st* it  , const struct X509_algor_st* alg  , const struct asn1_string_st* signature  , const void* data, struct evp_pkey_st* pkey  );
int ASN1_item_verify_ctx(const struct ASN1_ITEM_st* it  , const struct X509_algor_st* alg  , const struct asn1_string_st* signature  , const void* data, struct evp_md_ctx_st* ctx  );
int ASN1_item_sign(const struct ASN1_ITEM_st* it  , struct X509_algor_st* algor1  , struct X509_algor_st* algor2  , struct asn1_string_st* signature  , const void* data, struct evp_pkey_st* pkey  , const struct evp_md_st* md  );
int ASN1_item_sign_ctx(const struct ASN1_ITEM_st* it  , struct X509_algor_st* algor1  , struct X509_algor_st* algor2  , struct asn1_string_st* signature  , const void* data, struct evp_md_ctx_st* ctx  );
long X509_get_version(const struct x509_st* x  );
int X509_set_version(struct x509_st* x  , long version);
int X509_set_serialNumber(struct x509_st* x  , struct asn1_string_st* serial  );
struct asn1_string_st* X509_get_serialNumber(struct x509_st* x  );
const struct asn1_string_st* X509_get0_serialNumber(const struct x509_st* x  );
int X509_set_issuer_name(struct x509_st* x  , const struct X509_name_st* name  );
struct X509_name_st* X509_get_issuer_name(const struct x509_st* a  );
int X509_set_subject_name(struct x509_st* x  , const struct X509_name_st* name  );
struct X509_name_st* X509_get_subject_name(const struct x509_st* a  );
const struct asn1_string_st* X509_get0_notBefore(const struct x509_st* x  );
struct asn1_string_st* X509_getm_notBefore(const struct x509_st* x  );
int X509_set1_notBefore(struct x509_st* x  , const struct asn1_string_st* tm  );
const struct asn1_string_st* X509_get0_notAfter(const struct x509_st* x  );
struct asn1_string_st* X509_getm_notAfter(const struct x509_st* x  );
int X509_set1_notAfter(struct x509_st* x  , const struct asn1_string_st* tm  );
int X509_set_pubkey(struct x509_st* x  , struct evp_pkey_st* pkey  );
int X509_up_ref(struct x509_st* x  );
int X509_get_signature_type(const struct x509_st* x  );
struct X509_pubkey_st* X509_get_X509_PUBKEY(const struct x509_st* x  );
const struct stack_st_X509_EXTENSION* X509_get0_extensions(const struct x509_st* x  );
void X509_get0_uids(const struct x509_st* x  , const struct asn1_string_st** piuid  , const struct asn1_string_st** psuid  );
const struct X509_algor_st* X509_get0_tbs_sigalg(const struct x509_st* x  );
struct evp_pkey_st* X509_get0_pubkey(const struct x509_st* x  );
struct evp_pkey_st* X509_get_pubkey(struct x509_st* x  );
struct asn1_string_st* X509_get0_pubkey_bitstr(const struct x509_st* x  );
long X509_REQ_get_version(const struct X509_req_st* req  );
int X509_REQ_set_version(struct X509_req_st* x  , long version);
struct X509_name_st* X509_REQ_get_subject_name(const struct X509_req_st* req  );
int X509_REQ_set_subject_name(struct X509_req_st* req  , const struct X509_name_st* name  );
void X509_REQ_get0_signature(const struct X509_req_st* req  , const struct asn1_string_st** psig  , const struct X509_algor_st** palg  );
void X509_REQ_set0_signature(struct X509_req_st* req  , struct asn1_string_st* psig  );
int X509_REQ_set1_signature_algo(struct X509_req_st* req  , struct X509_algor_st* palg  );
int X509_REQ_get_signature_nid(const struct X509_req_st* req  );
int i2d_re_X509_REQ_tbs(struct X509_req_st* req  , unsigned char** pp);
int X509_REQ_set_pubkey(struct X509_req_st* x  , struct evp_pkey_st* pkey  );
struct evp_pkey_st* X509_REQ_get_pubkey(struct X509_req_st* req  );
struct evp_pkey_st* X509_REQ_get0_pubkey(const struct X509_req_st* req  );
struct X509_pubkey_st* X509_REQ_get_X509_PUBKEY(struct X509_req_st* req  );
int X509_REQ_extension_nid(int nid);
int* X509_REQ_get_extension_nids();
void X509_REQ_set_extension_nids(int* nids);
struct stack_st_X509_EXTENSION* X509_REQ_get_extensions(struct X509_req_st* req  );
int X509_REQ_add_extensions_nid(struct X509_req_st* req  , const struct stack_st_X509_EXTENSION* exts  , int nid);
int X509_REQ_add_extensions(struct X509_req_st* req  , const struct stack_st_X509_EXTENSION* ext  );
int X509_REQ_get_attr_count(const struct X509_req_st* req  );
int X509_REQ_get_attr_by_NID(const struct X509_req_st* req  , int nid, int lastpos);
int X509_REQ_get_attr_by_OBJ(const struct X509_req_st* req  , const struct asn1_object_st* obj  , int lastpos);
struct x509_attributes_st* X509_REQ_get_attr(const struct X509_req_st* req  , int loc);
struct x509_attributes_st* X509_REQ_delete_attr(struct X509_req_st* req  , int loc);
int X509_REQ_add1_attr(struct X509_req_st* req  , struct x509_attributes_st* attr  );
int X509_REQ_add1_attr_by_OBJ(struct X509_req_st* req  , const struct asn1_object_st* obj  , int type, const unsigned char* bytes, int len);
int X509_REQ_add1_attr_by_NID(struct X509_req_st* req  , int nid, int type, const unsigned char* bytes, int len);
int X509_REQ_add1_attr_by_txt(struct X509_req_st* req  , const char* attrname, int type, const unsigned char* bytes, int len);
int X509_CRL_set_version(struct X509_crl_st* x  , long version);
int X509_CRL_set_issuer_name(struct X509_crl_st* x  , const struct X509_name_st* name  );
int X509_CRL_set1_lastUpdate(struct X509_crl_st* x  , const struct asn1_string_st* tm  );
int X509_CRL_set1_nextUpdate(struct X509_crl_st* x  , const struct asn1_string_st* tm  );
int X509_CRL_sort(struct X509_crl_st* crl  );
int X509_CRL_up_ref(struct X509_crl_st* crl  );
long X509_CRL_get_version(const struct X509_crl_st* crl  );
const struct asn1_string_st* X509_CRL_get0_lastUpdate(const struct X509_crl_st* crl  );
const struct asn1_string_st* X509_CRL_get0_nextUpdate(const struct X509_crl_st* crl  );
struct asn1_string_st* X509_CRL_get_lastUpdate(struct X509_crl_st* crl  );
struct asn1_string_st* X509_CRL_get_nextUpdate(struct X509_crl_st* crl  );
struct X509_name_st* X509_CRL_get_issuer(const struct X509_crl_st* crl  );
const struct stack_st_X509_EXTENSION* X509_CRL_get0_extensions(const struct X509_crl_st* crl  );
struct stack_st_X509_REVOKED* X509_CRL_get_REVOKED(struct X509_crl_st* crl  );
void X509_CRL_get0_signature(const struct X509_crl_st* crl  , const struct asn1_string_st** psig  , const struct X509_algor_st** palg  );
int X509_CRL_get_signature_nid(const struct X509_crl_st* crl  );
int i2d_re_X509_CRL_tbs(struct X509_crl_st* req  , unsigned char** pp);
const struct asn1_string_st* X509_REVOKED_get0_serialNumber(const struct x509_revoked_st* x  );
int X509_REVOKED_set_serialNumber(struct x509_revoked_st* x  , struct asn1_string_st* serial  );
const struct asn1_string_st* X509_REVOKED_get0_revocationDate(const struct x509_revoked_st* x  );
int X509_REVOKED_set_revocationDate(struct x509_revoked_st* r  , struct asn1_string_st* tm  );
const struct stack_st_X509_EXTENSION* X509_REVOKED_get0_extensions(const struct x509_revoked_st* r  );
struct X509_crl_st* X509_CRL_diff(struct X509_crl_st* base  , struct X509_crl_st* newer  , struct evp_pkey_st* skey  , const struct evp_md_st* md  , unsigned int flags);
int X509_REQ_check_private_key(const struct X509_req_st* req  , struct evp_pkey_st* pkey  );
int X509_check_private_key(const struct x509_st* cert  , const struct evp_pkey_st* pkey  );
int X509_chain_check_suiteb(int* perror_depth, struct x509_st* x  , struct stack_st_X509* chain  , unsigned long  int flags);
int X509_CRL_check_suiteb(struct X509_crl_st* crl  , struct evp_pkey_st* pk  , unsigned long  int flags);
void OSSL_STACK_OF_X509_free(struct stack_st_X509* certs  );
struct stack_st_X509* X509_chain_up_ref(struct stack_st_X509* chain  );
int X509_issuer_and_serial_cmp(const struct x509_st* a  , const struct x509_st* b  );
unsigned long  int X509_issuer_and_serial_hash(struct x509_st* a  );
int X509_issuer_name_cmp(const struct x509_st* a  , const struct x509_st* b  );
unsigned long  int X509_issuer_name_hash(struct x509_st* a  );
int X509_subject_name_cmp(const struct x509_st* a  , const struct x509_st* b  );
unsigned long  int X509_subject_name_hash(struct x509_st* x  );
unsigned long  int X509_issuer_name_hash_old(struct x509_st* a  );
unsigned long  int X509_subject_name_hash_old(struct x509_st* x  );
int X509_add_cert(struct stack_st_X509* sk  , struct x509_st* cert  , int flags);
int X509_add_certs(struct stack_st_X509* sk  , struct stack_st_X509* certs  , int flags);
int X509_cmp(const struct x509_st* a  , const struct x509_st* b  );
int X509_NAME_cmp(const struct X509_name_st* a  , const struct X509_name_st* b  );
int X509_certificate_type(const struct x509_st* x  , const struct evp_pkey_st* pubkey  );
unsigned long  int X509_NAME_hash_ex(const struct X509_name_st* x  , struct ossl_lib_ctx_st* libctx  , const char* propq, int* ok);
unsigned long  int X509_NAME_hash_old(const struct X509_name_st* x  );
int X509_CRL_cmp(const struct X509_crl_st* a  , const struct X509_crl_st* b  );
int X509_CRL_match(const struct X509_crl_st* a  , const struct X509_crl_st* b  );
int X509_aux_print(struct bio_st* out  , struct x509_st* x  , int indent);
int X509_print_ex_fp(struct _IO_FILE* bp  , struct x509_st* x  , unsigned long  int nmflag, unsigned long  int cflag);
int X509_print_fp(struct _IO_FILE* bp  , struct x509_st* x  );
int X509_CRL_print_fp(struct _IO_FILE* bp  , struct X509_crl_st* x  );
int X509_REQ_print_fp(struct _IO_FILE* bp  , struct X509_req_st* req  );
int X509_NAME_print_ex_fp(struct _IO_FILE* fp  , const struct X509_name_st* nm  , int indent, unsigned long  int flags);
int X509_NAME_print(struct bio_st* bp  , const struct X509_name_st* name  , int obase);
int X509_NAME_print_ex(struct bio_st* out  , const struct X509_name_st* nm  , int indent, unsigned long  int flags);
int X509_print_ex(struct bio_st* bp  , struct x509_st* x  , unsigned long  int nmflag, unsigned long  int cflag);
int X509_print(struct bio_st* bp  , struct x509_st* x  );
int X509_ocspid_print(struct bio_st* bp  , struct x509_st* x  );
int X509_CRL_print_ex(struct bio_st* out  , struct X509_crl_st* x  , unsigned long  int nmflag);
int X509_CRL_print(struct bio_st* bp  , struct X509_crl_st* x  );
int X509_REQ_print_ex(struct bio_st* bp  , struct X509_req_st* x  , unsigned long  int nmflag, unsigned long  int cflag);
int X509_REQ_print(struct bio_st* bp  , struct X509_req_st* req  );
int X509_NAME_entry_count(const struct X509_name_st* name  );
int X509_NAME_get_text_by_NID(const struct X509_name_st* name  , int nid, char* buf, int len);
int X509_NAME_get_text_by_OBJ(const struct X509_name_st* name  , const struct asn1_object_st* obj  , char* buf, int len);
int X509_NAME_get_index_by_NID(const struct X509_name_st* name  , int nid, int lastpos);
int X509_NAME_get_index_by_OBJ(const struct X509_name_st* name  , const struct asn1_object_st* obj  , int lastpos);
struct X509_name_entry_st* X509_NAME_get_entry(const struct X509_name_st* name  , int loc);
struct X509_name_entry_st* X509_NAME_delete_entry(struct X509_name_st* name  , int loc);
int X509_NAME_add_entry(struct X509_name_st* name  , const struct X509_name_entry_st* ne  , int loc, int set);
int X509_NAME_add_entry_by_OBJ(struct X509_name_st* name  , const struct asn1_object_st* obj  , int type, const unsigned char* bytes, int len, int loc, int set);
int X509_NAME_add_entry_by_NID(struct X509_name_st* name  , int nid, int type, const unsigned char* bytes, int len, int loc, int set);
struct X509_name_entry_st* X509_NAME_ENTRY_create_by_txt(struct X509_name_entry_st** ne  , const char* field, int type, const unsigned char* bytes, int len);
struct X509_name_entry_st* X509_NAME_ENTRY_create_by_NID(struct X509_name_entry_st** ne  , int nid, int type, const unsigned char* bytes, int len);
int X509_NAME_add_entry_by_txt(struct X509_name_st* name  , const char* field, int type, const unsigned char* bytes, int len, int loc, int set);
struct X509_name_entry_st* X509_NAME_ENTRY_create_by_OBJ(struct X509_name_entry_st** ne  , const struct asn1_object_st* obj  , int type, const unsigned char* bytes, int len);
int X509_NAME_ENTRY_set_object(struct X509_name_entry_st* ne  , const struct asn1_object_st* obj  );
int X509_NAME_ENTRY_set_data(struct X509_name_entry_st* ne  , int type, const unsigned char* bytes, int len);
struct asn1_object_st* X509_NAME_ENTRY_get_object(const struct X509_name_entry_st* ne  );
struct asn1_string_st* X509_NAME_ENTRY_get_data(const struct X509_name_entry_st* ne  );
int X509_NAME_ENTRY_set(const struct X509_name_entry_st* ne  );
int X509_NAME_get0_der(const struct X509_name_st* nm  , const unsigned char** pder, unsigned long* pderlen  );
int X509v3_get_ext_count(const struct stack_st_X509_EXTENSION* x  );
int X509v3_get_ext_by_NID(const struct stack_st_X509_EXTENSION* x  , int nid, int lastpos);
int X509v3_get_ext_by_OBJ(const struct stack_st_X509_EXTENSION* x  , const struct asn1_object_st* obj  , int lastpos);
int X509v3_get_ext_by_critical(const struct stack_st_X509_EXTENSION* x  , int crit, int lastpos);
struct X509_extension_st* X509v3_get_ext(const struct stack_st_X509_EXTENSION* x  , int loc);
struct X509_extension_st* X509v3_delete_ext(struct stack_st_X509_EXTENSION* x  , int loc);
struct stack_st_X509_EXTENSION* X509v3_add_ext(struct stack_st_X509_EXTENSION** x  , struct X509_extension_st* ex  , int loc);
struct stack_st_X509_EXTENSION* X509v3_add_extensions(struct stack_st_X509_EXTENSION** target  , const struct stack_st_X509_EXTENSION* exts  );
int X509_get_ext_count(const struct x509_st* x  );
int X509_get_ext_by_NID(const struct x509_st* x  , int nid, int lastpos);
int X509_get_ext_by_OBJ(const struct x509_st* x  , const struct asn1_object_st* obj  , int lastpos);
int X509_get_ext_by_critical(const struct x509_st* x  , int crit, int lastpos);
struct X509_extension_st* X509_get_ext(const struct x509_st* x  , int loc);
struct X509_extension_st* X509_delete_ext(struct x509_st* x  , int loc);
int X509_add_ext(struct x509_st* x  , struct X509_extension_st* ex  , int loc);
void* X509_get_ext_d2i(const struct x509_st* x  , int nid, int* crit, int* idx);
int X509_add1_ext_i2d(struct x509_st* x  , int nid, void* value, int crit, unsigned long  int flags);
int X509_CRL_get_ext_count(const struct X509_crl_st* x  );
int X509_CRL_get_ext_by_NID(const struct X509_crl_st* x  , int nid, int lastpos);
int X509_CRL_get_ext_by_OBJ(const struct X509_crl_st* x  , const struct asn1_object_st* obj  , int lastpos);
int X509_CRL_get_ext_by_critical(const struct X509_crl_st* x  , int crit, int lastpos);
struct X509_extension_st* X509_CRL_get_ext(const struct X509_crl_st* x  , int loc);
struct X509_extension_st* X509_CRL_delete_ext(struct X509_crl_st* x  , int loc);
int X509_CRL_add_ext(struct X509_crl_st* x  , struct X509_extension_st* ex  , int loc);
void* X509_CRL_get_ext_d2i(const struct X509_crl_st* x  , int nid, int* crit, int* idx);
int X509_CRL_add1_ext_i2d(struct X509_crl_st* x  , int nid, void* value, int crit, unsigned long  int flags);
int X509_REVOKED_get_ext_count(const struct x509_revoked_st* x  );
int X509_REVOKED_get_ext_by_NID(const struct x509_revoked_st* x  , int nid, int lastpos);
int X509_REVOKED_get_ext_by_OBJ(const struct x509_revoked_st* x  , const struct asn1_object_st* obj  , int lastpos);
int X509_REVOKED_get_ext_by_critical(const struct x509_revoked_st* x  , int crit, int lastpos);
struct X509_extension_st* X509_REVOKED_get_ext(const struct x509_revoked_st* x  , int loc);
struct X509_extension_st* X509_REVOKED_delete_ext(struct x509_revoked_st* x  , int loc);
int X509_REVOKED_add_ext(struct x509_revoked_st* x  , struct X509_extension_st* ex  , int loc);
void* X509_REVOKED_get_ext_d2i(const struct x509_revoked_st* x  , int nid, int* crit, int* idx);
int X509_REVOKED_add1_ext_i2d(struct x509_revoked_st* x  , int nid, void* value, int crit, unsigned long  int flags);
struct X509_extension_st* X509_EXTENSION_create_by_NID(struct X509_extension_st** ex  , int nid, int crit, struct asn1_string_st* data  );
struct X509_extension_st* X509_EXTENSION_create_by_OBJ(struct X509_extension_st** ex  , const struct asn1_object_st* obj  , int crit, struct asn1_string_st* data  );
int X509_EXTENSION_set_object(struct X509_extension_st* ex  , const struct asn1_object_st* obj  );
int X509_EXTENSION_set_critical(struct X509_extension_st* ex  , int crit);
int X509_EXTENSION_set_data(struct X509_extension_st* ex  , struct asn1_string_st* data  );
struct asn1_object_st* X509_EXTENSION_get_object(struct X509_extension_st* ex  );
struct asn1_string_st* X509_EXTENSION_get_data(struct X509_extension_st* ne  );
int X509_EXTENSION_get_critical(const struct X509_extension_st* ex  );
int X509at_get_attr_count(const struct stack_st_X509_ATTRIBUTE* x  );
int X509at_get_attr_by_NID(const struct stack_st_X509_ATTRIBUTE* x  , int nid, int lastpos);
int X509at_get_attr_by_OBJ(const struct stack_st_X509_ATTRIBUTE* sk  , const struct asn1_object_st* obj  , int lastpos);
struct x509_attributes_st* X509at_get_attr(const struct stack_st_X509_ATTRIBUTE* x  , int loc);
struct x509_attributes_st* X509at_delete_attr(struct stack_st_X509_ATTRIBUTE* x  , int loc);
struct stack_st_X509_ATTRIBUTE* X509at_add1_attr(struct stack_st_X509_ATTRIBUTE** x  , struct x509_attributes_st* attr  );
struct stack_st_X509_ATTRIBUTE* X509at_add1_attr_by_OBJ(struct stack_st_X509_ATTRIBUTE** x  , const struct asn1_object_st* obj  , int type, const unsigned char* bytes, int len);
struct stack_st_X509_ATTRIBUTE* X509at_add1_attr_by_NID(struct stack_st_X509_ATTRIBUTE** x  , int nid, int type, const unsigned char* bytes, int len);
struct stack_st_X509_ATTRIBUTE* X509at_add1_attr_by_txt(struct stack_st_X509_ATTRIBUTE** x  , const char* attrname, int type, const unsigned char* bytes, int len);
void* X509at_get0_data_by_OBJ(const struct stack_st_X509_ATTRIBUTE* x  , const struct asn1_object_st* obj  , int lastpos, int type);
struct x509_attributes_st* X509_ATTRIBUTE_create_by_NID(struct x509_attributes_st** attr  , int nid, int atrtype, const void* data, int len);
struct x509_attributes_st* X509_ATTRIBUTE_create_by_OBJ(struct x509_attributes_st** attr  , const struct asn1_object_st* obj  , int atrtype, const void* data, int len);
struct x509_attributes_st* X509_ATTRIBUTE_create_by_txt(struct x509_attributes_st** attr  , const char* atrname, int type, const unsigned char* bytes, int len);
int X509_ATTRIBUTE_set1_object(struct x509_attributes_st* attr  , const struct asn1_object_st* obj  );
int X509_ATTRIBUTE_set1_data(struct x509_attributes_st* attr  , int attrtype, const void* data, int len);
void* X509_ATTRIBUTE_get0_data(struct x509_attributes_st* attr  , int idx, int atrtype, void* data);
int X509_ATTRIBUTE_count(const struct x509_attributes_st* attr  );
struct asn1_object_st* X509_ATTRIBUTE_get0_object(struct x509_attributes_st* attr  );
struct asn1_type_st* X509_ATTRIBUTE_get0_type(struct x509_attributes_st* attr  , int idx);
int EVP_PKEY_get_attr_count(const struct evp_pkey_st* key  );
int EVP_PKEY_get_attr_by_NID(const struct evp_pkey_st* key  , int nid, int lastpos);
int EVP_PKEY_get_attr_by_OBJ(const struct evp_pkey_st* key  , const struct asn1_object_st* obj  , int lastpos);
struct x509_attributes_st* EVP_PKEY_get_attr(const struct evp_pkey_st* key  , int loc);
struct x509_attributes_st* EVP_PKEY_delete_attr(struct evp_pkey_st* key  , int loc);
int EVP_PKEY_add1_attr(struct evp_pkey_st* key  , struct x509_attributes_st* attr  );
int EVP_PKEY_add1_attr_by_OBJ(struct evp_pkey_st* key  , const struct asn1_object_st* obj  , int type, const unsigned char* bytes, int len);
int EVP_PKEY_add1_attr_by_NID(struct evp_pkey_st* key  , int nid, int type, const unsigned char* bytes, int len);
int EVP_PKEY_add1_attr_by_txt(struct evp_pkey_st* key  , const char* attrname, int type, const unsigned char* bytes, int len);
struct x509_st* X509_find_by_issuer_and_serial(struct stack_st_X509* sk  , const struct X509_name_st* name  , const struct asn1_string_st* serial  );
struct x509_st* X509_find_by_subject(struct stack_st_X509* sk  , const struct X509_name_st* name  );
struct PBEPARAM_st* PBEPARAM_new();
void PBEPARAM_free(struct PBEPARAM_st* a  );
struct PBEPARAM_st* d2i_PBEPARAM(struct PBEPARAM_st** a  , const unsigned char** in, long len);
int i2d_PBEPARAM(const struct PBEPARAM_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PBEPARAM_it();
struct PBE2PARAM_st* PBE2PARAM_new();
void PBE2PARAM_free(struct PBE2PARAM_st* a  );
struct PBE2PARAM_st* d2i_PBE2PARAM(struct PBE2PARAM_st** a  , const unsigned char** in, long len);
int i2d_PBE2PARAM(const struct PBE2PARAM_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PBE2PARAM_it();
struct PBKDF2PARAM_st* PBKDF2PARAM_new();
void PBKDF2PARAM_free(struct PBKDF2PARAM_st* a  );
struct PBKDF2PARAM_st* d2i_PBKDF2PARAM(struct PBKDF2PARAM_st** a  , const unsigned char** in, long len);
int i2d_PBKDF2PARAM(const struct PBKDF2PARAM_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PBKDF2PARAM_it();
struct anonymous_typeX42* PBMAC1PARAM_new();
void PBMAC1PARAM_free(struct anonymous_typeX42* a  );
struct anonymous_typeX42* d2i_PBMAC1PARAM(struct anonymous_typeX42** a  , const unsigned char** in, long len);
int i2d_PBMAC1PARAM(const struct anonymous_typeX42* a  , unsigned char** out);
const struct ASN1_ITEM_st* PBMAC1PARAM_it();
struct SCRYPT_PARAMS_st* SCRYPT_PARAMS_new();
void SCRYPT_PARAMS_free(struct SCRYPT_PARAMS_st* a  );
struct SCRYPT_PARAMS_st* d2i_SCRYPT_PARAMS(struct SCRYPT_PARAMS_st** a  , const unsigned char** in, long len);
int i2d_SCRYPT_PARAMS(const struct SCRYPT_PARAMS_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* SCRYPT_PARAMS_it();
int PKCS5_pbe_set0_algor(struct X509_algor_st* algor  , int alg, int iter, const unsigned char* salt, int saltlen);
int PKCS5_pbe_set0_algor_ex(struct X509_algor_st* algor  , int alg, int iter, const unsigned char* salt, int saltlen, struct ossl_lib_ctx_st* libctx  );
struct X509_algor_st* PKCS5_pbe_set(int alg, int iter, const unsigned char* salt, int saltlen);
struct X509_algor_st* PKCS5_pbe_set_ex(int alg, int iter, const unsigned char* salt, int saltlen, struct ossl_lib_ctx_st* libctx  );
struct X509_algor_st* PKCS5_pbe2_set(const struct evp_cipher_st* cipher  , int iter, unsigned char* salt, int saltlen);
struct X509_algor_st* PKCS5_pbe2_set_iv(const struct evp_cipher_st* cipher  , int iter, unsigned char* salt, int saltlen, unsigned char* aiv, int prf_nid);
struct X509_algor_st* PKCS5_pbe2_set_iv_ex(const struct evp_cipher_st* cipher  , int iter, unsigned char* salt, int saltlen, unsigned char* aiv, int prf_nid, struct ossl_lib_ctx_st* libctx  );
struct X509_algor_st* PKCS5_pbe2_set_scrypt(const struct evp_cipher_st* cipher  , const unsigned char* salt, int saltlen, unsigned char* aiv, unsigned long  int N  , unsigned long  int r  , unsigned long  int p  );
struct X509_algor_st* PKCS5_pbkdf2_set(int iter, unsigned char* salt, int saltlen, int prf_nid, int keylen);
struct X509_algor_st* PKCS5_pbkdf2_set_ex(int iter, unsigned char* salt, int saltlen, int prf_nid, int keylen, struct ossl_lib_ctx_st* libctx  );
struct PBKDF2PARAM_st* PBMAC1_get1_pbkdf2_param(const struct X509_algor_st* macalg  );
struct pkcs8_priv_key_info_st* PKCS8_PRIV_KEY_INFO_new();
void PKCS8_PRIV_KEY_INFO_free(struct pkcs8_priv_key_info_st* a  );
struct pkcs8_priv_key_info_st* d2i_PKCS8_PRIV_KEY_INFO(struct pkcs8_priv_key_info_st** a  , const unsigned char** in, long len);
int i2d_PKCS8_PRIV_KEY_INFO(const struct pkcs8_priv_key_info_st* a  , unsigned char** out);
const struct ASN1_ITEM_st* PKCS8_PRIV_KEY_INFO_it();
struct evp_pkey_st* EVP_PKCS82PKEY(const struct pkcs8_priv_key_info_st* p8  );
struct evp_pkey_st* EVP_PKCS82PKEY_ex(const struct pkcs8_priv_key_info_st* p8  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct pkcs8_priv_key_info_st* EVP_PKEY2PKCS8(const struct evp_pkey_st* pkey  );
int PKCS8_pkey_set0(struct pkcs8_priv_key_info_st* priv  , struct asn1_object_st* aobj  , int version, int ptype, void* pval, unsigned char* penc, int penclen);
int PKCS8_pkey_get0(const struct asn1_object_st** ppkalg  , const unsigned char** pk, int* ppklen, const struct X509_algor_st** pa  , const struct pkcs8_priv_key_info_st* p8  );
const struct stack_st_X509_ATTRIBUTE* PKCS8_pkey_get0_attrs(const struct pkcs8_priv_key_info_st* p8  );
int PKCS8_pkey_add1_attr(struct pkcs8_priv_key_info_st* p8  , struct x509_attributes_st* attr  );
int PKCS8_pkey_add1_attr_by_NID(struct pkcs8_priv_key_info_st* p8  , int nid, int type, const unsigned char* bytes, int len);
int PKCS8_pkey_add1_attr_by_OBJ(struct pkcs8_priv_key_info_st* p8  , const struct asn1_object_st* obj  , int type, const unsigned char* bytes, int len);
void X509_PUBKEY_set0_public_key(struct X509_pubkey_st* pub  , unsigned char* penc, int penclen);
int X509_PUBKEY_set0_param(struct X509_pubkey_st* pub  , struct asn1_object_st* aobj  , int ptype, void* pval, unsigned char* penc, int penclen);
int X509_PUBKEY_get0_param(struct asn1_object_st** ppkalg  , const unsigned char** pk, int* ppklen, struct X509_algor_st** pa  , const struct X509_pubkey_st* pub  );
int X509_PUBKEY_eq(const struct X509_pubkey_st* a  , const struct X509_pubkey_st* b  );
int PEM_get_EVP_CIPHER_INFO(char* header, struct evp_cipher_info_st* cipher  );
int PEM_do_header(struct evp_cipher_info_st* cipher  , unsigned char* data, long* len, int (*(*callback))(char*,int,int,void*)  , void* u);
int PEM_read_bio(struct bio_st* bp  , char** name, char** header, unsigned char** data, long* len);
int PEM_read_bio_ex(struct bio_st* bp  , char** name, char** header, unsigned char** data, long* len, unsigned int flags);
int PEM_bytes_read_bio_secmem(unsigned char** pdata, long* plen, char** pnm, const char* name, struct bio_st* bp  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio(struct bio_st* bp  , const char* name, const char* hdr, const unsigned char* data, long len);
int PEM_bytes_read_bio(unsigned char** pdata, long* plen, char** pnm, const char* name, struct bio_st* bp  , int (*(*cb))(char*,int,int,void*)  , void* u);
void* PEM_ASN1_read_bio(void* (*(*d2i))(void**,const unsigned char**,long)  , const char* name, struct bio_st* bp  , void** x, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_ASN1_write_bio(int (*(*i2d))(const void*,unsigned char**)  , const char* name, struct bio_st* bp  , const void* x, const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_ASN1_write_bio_ctx(int (*(*i2d))(const void*,unsigned char**,void*)  , void* vctx, const char* name, struct bio_st* bp  , const void* x, const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
struct stack_st_X509_INFO* PEM_X509_INFO_read_bio(struct bio_st* bp  , struct stack_st_X509_INFO* sk  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct stack_st_X509_INFO* PEM_X509_INFO_read_bio_ex(struct bio_st* bp  , struct stack_st_X509_INFO* sk  , int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
int PEM_X509_INFO_write_bio(struct bio_st* bp  , const struct X509_info_st* xi  , struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cd))(char*,int,int,void*)  , void* u);
int PEM_read(struct _IO_FILE* fp  , char** name, char** header, unsigned char** data, long* len);
int PEM_write(struct _IO_FILE* fp  , const char* name, const char* hdr, const unsigned char* data, long len);
void* PEM_ASN1_read(void* (*(*d2i))(void**,const unsigned char**,long)  , const char* name, struct _IO_FILE* fp  , void** x, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_ASN1_write(int (*(*i2d))(const void*,unsigned char**)  , const char* name, struct _IO_FILE* fp  , const void* x, const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*callback))(char*,int,int,void*)  , void* u);
struct stack_st_X509_INFO* PEM_X509_INFO_read(struct _IO_FILE* fp  , struct stack_st_X509_INFO* sk  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct stack_st_X509_INFO* PEM_X509_INFO_read_ex(struct _IO_FILE* fp  , struct stack_st_X509_INFO* sk  , int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
int PEM_SignInit(struct evp_md_ctx_st* ctx  , struct evp_md_st* type  );
int PEM_SignUpdate(struct evp_md_ctx_st* ctx  , const unsigned char* d, unsigned int cnt);
int PEM_SignFinal(struct evp_md_ctx_st* ctx  , unsigned char* sigret, unsigned int* siglen, struct evp_pkey_st* pkey  );
int PEM_def_callback(char* buf, int num, int rwflag, void* userdata);
void PEM_proc_type(char* buf, int type);
void PEM_dek_info(char* buf, const char* type, int len, const char* str);
struct x509_st* PEM_read_bio_X509(struct bio_st* out  , struct x509_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct x509_st* PEM_read_X509(struct _IO_FILE* out  , struct x509_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_X509(struct bio_st* out  , const struct x509_st* x  );
int PEM_write_X509(struct _IO_FILE* out  , const struct x509_st* x  );
struct x509_st* PEM_read_bio_X509_AUX(struct bio_st* out  , struct x509_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct x509_st* PEM_read_X509_AUX(struct _IO_FILE* out  , struct x509_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_X509_AUX(struct bio_st* out  , const struct x509_st* x  );
int PEM_write_X509_AUX(struct _IO_FILE* out  , const struct x509_st* x  );
struct X509_req_st* PEM_read_bio_X509_REQ(struct bio_st* out  , struct X509_req_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct X509_req_st* PEM_read_X509_REQ(struct _IO_FILE* out  , struct X509_req_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_X509_REQ(struct bio_st* out  , const struct X509_req_st* x  );
int PEM_write_X509_REQ(struct _IO_FILE* out  , const struct X509_req_st* x  );
int PEM_write_bio_X509_REQ_NEW(struct bio_st* out  , const struct X509_req_st* x  );
int PEM_write_X509_REQ_NEW(struct _IO_FILE* out  , const struct X509_req_st* x  );
struct X509_crl_st* PEM_read_bio_X509_CRL(struct bio_st* out  , struct X509_crl_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct X509_crl_st* PEM_read_X509_CRL(struct _IO_FILE* out  , struct X509_crl_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_X509_CRL(struct bio_st* out  , const struct X509_crl_st* x  );
int PEM_write_X509_CRL(struct _IO_FILE* out  , const struct X509_crl_st* x  );
struct X509_pubkey_st* PEM_read_bio_X509_PUBKEY(struct bio_st* out  , struct X509_pubkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct X509_pubkey_st* PEM_read_X509_PUBKEY(struct _IO_FILE* out  , struct X509_pubkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_X509_PUBKEY(struct bio_st* out  , const struct X509_pubkey_st* x  );
int PEM_write_X509_PUBKEY(struct _IO_FILE* out  , const struct X509_pubkey_st* x  );
struct pkcs7_st* PEM_read_bio_PKCS7(struct bio_st* out  , struct pkcs7_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct pkcs7_st* PEM_read_PKCS7(struct _IO_FILE* out  , struct pkcs7_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_PKCS7(struct bio_st* out  , const struct pkcs7_st* x  );
int PEM_write_PKCS7(struct _IO_FILE* out  , const struct pkcs7_st* x  );
struct Netscape_certificate_sequence* PEM_read_bio_NETSCAPE_CERT_SEQUENCE(struct bio_st* out  , struct Netscape_certificate_sequence** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct Netscape_certificate_sequence* PEM_read_NETSCAPE_CERT_SEQUENCE(struct _IO_FILE* out  , struct Netscape_certificate_sequence** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(struct bio_st* out  , const struct Netscape_certificate_sequence* x  );
int PEM_write_NETSCAPE_CERT_SEQUENCE(struct _IO_FILE* out  , const struct Netscape_certificate_sequence* x  );
struct X509_sig_st* PEM_read_bio_PKCS8(struct bio_st* out  , struct X509_sig_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct X509_sig_st* PEM_read_PKCS8(struct _IO_FILE* out  , struct X509_sig_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_PKCS8(struct bio_st* out  , const struct X509_sig_st* x  );
int PEM_write_PKCS8(struct _IO_FILE* out  , const struct X509_sig_st* x  );
struct pkcs8_priv_key_info_st* PEM_read_bio_PKCS8_PRIV_KEY_INFO(struct bio_st* out  , struct pkcs8_priv_key_info_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct pkcs8_priv_key_info_st* PEM_read_PKCS8_PRIV_KEY_INFO(struct _IO_FILE* out  , struct pkcs8_priv_key_info_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_PKCS8_PRIV_KEY_INFO(struct bio_st* out  , const struct pkcs8_priv_key_info_st* x  );
int PEM_write_PKCS8_PRIV_KEY_INFO(struct _IO_FILE* out  , const struct pkcs8_priv_key_info_st* x  );
struct rsa_st* PEM_read_bio_RSAPrivateKey(struct bio_st* out  , struct rsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct rsa_st* PEM_read_RSAPrivateKey(struct _IO_FILE* out  , struct rsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_RSAPrivateKey(struct bio_st* out  , const struct rsa_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_RSAPrivateKey(struct _IO_FILE* out  , const struct rsa_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
struct rsa_st* PEM_read_bio_RSAPublicKey(struct bio_st* out  , struct rsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct rsa_st* PEM_read_RSAPublicKey(struct _IO_FILE* out  , struct rsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_RSAPublicKey(struct bio_st* out  , const struct rsa_st* x  );
int PEM_write_RSAPublicKey(struct _IO_FILE* out  , const struct rsa_st* x  );
struct rsa_st* PEM_read_bio_RSA_PUBKEY(struct bio_st* out  , struct rsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct rsa_st* PEM_read_RSA_PUBKEY(struct _IO_FILE* out  , struct rsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_RSA_PUBKEY(struct bio_st* out  , const struct rsa_st* x  );
int PEM_write_RSA_PUBKEY(struct _IO_FILE* out  , const struct rsa_st* x  );
struct dsa_st* PEM_read_bio_DSAPrivateKey(struct bio_st* out  , struct dsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct dsa_st* PEM_read_DSAPrivateKey(struct _IO_FILE* out  , struct dsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_DSAPrivateKey(struct bio_st* out  , const struct dsa_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_DSAPrivateKey(struct _IO_FILE* out  , const struct dsa_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
struct dsa_st* PEM_read_bio_DSA_PUBKEY(struct bio_st* out  , struct dsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct dsa_st* PEM_read_DSA_PUBKEY(struct _IO_FILE* out  , struct dsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_DSA_PUBKEY(struct bio_st* out  , const struct dsa_st* x  );
int PEM_write_DSA_PUBKEY(struct _IO_FILE* out  , const struct dsa_st* x  );
struct dsa_st* PEM_read_bio_DSAparams(struct bio_st* out  , struct dsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct dsa_st* PEM_read_DSAparams(struct _IO_FILE* out  , struct dsa_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_DSAparams(struct bio_st* out  , const struct dsa_st* x  );
int PEM_write_DSAparams(struct _IO_FILE* out  , const struct dsa_st* x  );
struct ec_group_st* PEM_read_bio_ECPKParameters(struct bio_st* out  , struct ec_group_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct ec_group_st* PEM_read_ECPKParameters(struct _IO_FILE* out  , struct ec_group_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_ECPKParameters(struct bio_st* out  , const struct ec_group_st* x  );
int PEM_write_ECPKParameters(struct _IO_FILE* out  , const struct ec_group_st* x  );
struct ec_key_st* PEM_read_bio_ECPrivateKey(struct bio_st* out  , struct ec_key_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct ec_key_st* PEM_read_ECPrivateKey(struct _IO_FILE* out  , struct ec_key_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_ECPrivateKey(struct bio_st* out  , const struct ec_key_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_ECPrivateKey(struct _IO_FILE* out  , const struct ec_key_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
struct ec_key_st* PEM_read_bio_EC_PUBKEY(struct bio_st* out  , struct ec_key_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct ec_key_st* PEM_read_EC_PUBKEY(struct _IO_FILE* out  , struct ec_key_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_EC_PUBKEY(struct bio_st* out  , const struct ec_key_st* x  );
int PEM_write_EC_PUBKEY(struct _IO_FILE* out  , const struct ec_key_st* x  );
struct dh_st* PEM_read_bio_DHparams(struct bio_st* out  , struct dh_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct dh_st* PEM_read_DHparams(struct _IO_FILE* out  , struct dh_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_DHparams(struct bio_st* out  , const struct dh_st* x  );
int PEM_write_DHparams(struct _IO_FILE* out  , const struct dh_st* x  );
int PEM_write_bio_DHxparams(struct bio_st* out  , const struct dh_st* x  );
int PEM_write_DHxparams(struct _IO_FILE* out  , const struct dh_st* x  );
struct evp_pkey_st* PEM_read_bio_PrivateKey(struct bio_st* out  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct evp_pkey_st* PEM_read_bio_PrivateKey_ex(struct bio_st* out  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* PEM_read_PrivateKey(struct _IO_FILE* out  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct evp_pkey_st* PEM_read_PrivateKey_ex(struct _IO_FILE* out  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
int PEM_write_bio_PrivateKey(struct bio_st* out  , const struct evp_pkey_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_PrivateKey_ex(struct bio_st* out  , const struct evp_pkey_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
int PEM_write_PrivateKey(struct _IO_FILE* out  , const struct evp_pkey_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_PrivateKey_ex(struct _IO_FILE* out  , const struct evp_pkey_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* PEM_read_bio_PUBKEY(struct bio_st* out  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct evp_pkey_st* PEM_read_bio_PUBKEY_ex(struct bio_st* out  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* PEM_read_PUBKEY(struct _IO_FILE* out  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct evp_pkey_st* PEM_read_PUBKEY_ex(struct _IO_FILE* out  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
int PEM_write_bio_PUBKEY(struct bio_st* out  , const struct evp_pkey_st* x  );
int PEM_write_bio_PUBKEY_ex(struct bio_st* out  , const struct evp_pkey_st* x  , struct ossl_lib_ctx_st* libctx  , const char* propq);
int PEM_write_PUBKEY(struct _IO_FILE* out  , const struct evp_pkey_st* x  );
int PEM_write_PUBKEY_ex(struct _IO_FILE* out  , const struct evp_pkey_st* x  , struct ossl_lib_ctx_st* libctx  , const char* propq);
int PEM_write_bio_PrivateKey_traditional(struct bio_st* bp  , const struct evp_pkey_st* x  , const struct evp_cipher_st* enc  , const unsigned char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_PKCS8PrivateKey_nid(struct bio_st* bp  , const struct evp_pkey_st* x  , int nid, const char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_PKCS8PrivateKey(struct bio_st*   , const struct evp_pkey_st*   , const struct evp_cipher_st*   , const char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int i2d_PKCS8PrivateKey_bio(struct bio_st* bp  , const struct evp_pkey_st* x  , const struct evp_cipher_st* enc  , const char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int i2d_PKCS8PrivateKey_nid_bio(struct bio_st* bp  , const struct evp_pkey_st* x  , int nid, const char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
struct evp_pkey_st* d2i_PKCS8PrivateKey_bio(struct bio_st* bp  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int i2d_PKCS8PrivateKey_fp(struct _IO_FILE* fp  , const struct evp_pkey_st* x  , const struct evp_cipher_st* enc  , const char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int i2d_PKCS8PrivateKey_nid_fp(struct _IO_FILE* fp  , const struct evp_pkey_st* x  , int nid, const char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_PKCS8PrivateKey_nid(struct _IO_FILE* fp  , const struct evp_pkey_st* x  , int nid, const char* kstr, int klen, int (*(*cb))(char*,int,int,void*)  , void* u);
struct evp_pkey_st* d2i_PKCS8PrivateKey_fp(struct _IO_FILE* fp  , struct evp_pkey_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_PKCS8PrivateKey(struct _IO_FILE* fp  , const struct evp_pkey_st* x  , const struct evp_cipher_st* enc  , const char* kstr, int klen, int (*(*cd))(char*,int,int,void*)  , void* u);
struct evp_pkey_st* PEM_read_bio_Parameters_ex(struct bio_st* bp  , struct evp_pkey_st** x  , struct ossl_lib_ctx_st* libctx  , const char* propq);
struct evp_pkey_st* PEM_read_bio_Parameters(struct bio_st* bp  , struct evp_pkey_st** x  );
int PEM_write_bio_Parameters(struct bio_st* bp  , const struct evp_pkey_st* x  );
struct evp_pkey_st* b2i_PrivateKey(const unsigned char** in, long length);
struct evp_pkey_st* b2i_PublicKey(const unsigned char** in, long length);
struct evp_pkey_st* b2i_PrivateKey_bio(struct bio_st* in  );
struct evp_pkey_st* b2i_PublicKey_bio(struct bio_st* in  );
int i2b_PrivateKey_bio(struct bio_st* out  , const struct evp_pkey_st* pk  );
int i2b_PublicKey_bio(struct bio_st* out  , const struct evp_pkey_st* pk  );
struct evp_pkey_st* b2i_PVK_bio(struct bio_st* in  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct evp_pkey_st* b2i_PVK_bio_ex(struct bio_st* in  , int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
int i2b_PVK_bio(struct bio_st* out  , const struct evp_pkey_st* pk  , int enclevel, int (*(*cb))(char*,int,int,void*)  , void* u);
int i2b_PVK_bio_ex(struct bio_st* out  , const struct evp_pkey_st* pk  , int enclevel, int (*(*cb))(char*,int,int,void*)  , void* u, struct ossl_lib_ctx_st* libctx  , const char* propq);
unsigned long HMAC_size(const struct hmac_ctx_st* e  );
struct hmac_ctx_st* HMAC_CTX_new();
int HMAC_CTX_reset(struct hmac_ctx_st* ctx  );
void HMAC_CTX_free(struct hmac_ctx_st* ctx  );
int HMAC_Init(struct hmac_ctx_st* ctx  , const void* key, int len, const struct evp_md_st* md  );
int HMAC_Init_ex(struct hmac_ctx_st* ctx  , const void* key, int len, const struct evp_md_st* md  , struct engine_st* impl  );
int HMAC_Update(struct hmac_ctx_st* ctx  , const unsigned char* data, unsigned long len  );
int HMAC_Final(struct hmac_ctx_st* ctx  , unsigned char* md, unsigned int* len);
int HMAC_CTX_copy(struct hmac_ctx_st* dctx  , struct hmac_ctx_st* sctx  );
void HMAC_CTX_set_flags(struct hmac_ctx_st* ctx  , unsigned long  int flags);
const struct evp_md_st* HMAC_CTX_get_md(const struct hmac_ctx_st* ctx  );
unsigned char* HMAC(const struct evp_md_st* evp_md  , const void* key, int key_len, const unsigned char* data, unsigned long data_len  , unsigned char* md, unsigned int* md_len);
int ASYNC_init_thread(unsigned long max_size  , unsigned long init_size  );
void ASYNC_cleanup_thread();
struct async_wait_ctx_st* ASYNC_WAIT_CTX_new();
void ASYNC_WAIT_CTX_free(struct async_wait_ctx_st* ctx  );
int ASYNC_WAIT_CTX_set_wait_fd(struct async_wait_ctx_st* ctx  , const void* key, int fd, void* custom_data, void (*cleanup)(struct async_wait_ctx_st*,const void*,int,void*));
int ASYNC_WAIT_CTX_get_fd(struct async_wait_ctx_st* ctx  , const void* key, int* fd, void** custom_data);
int ASYNC_WAIT_CTX_get_all_fds(struct async_wait_ctx_st* ctx  , int* fd, unsigned long* numfds  );
int ASYNC_WAIT_CTX_get_callback(struct async_wait_ctx_st* ctx  , int (*(*callback))(void*)  , void** callback_arg);
int ASYNC_WAIT_CTX_set_callback(struct async_wait_ctx_st* ctx  , int (*callback)(void*)  , void* callback_arg);
int ASYNC_WAIT_CTX_set_status(struct async_wait_ctx_st* ctx  , int status);
int ASYNC_WAIT_CTX_get_status(struct async_wait_ctx_st* ctx  );
int ASYNC_WAIT_CTX_get_changed_fds(struct async_wait_ctx_st* ctx  , int* addfd, unsigned long* numaddfds  , int* delfd, unsigned long* numdelfds  );
int ASYNC_WAIT_CTX_clear_fd(struct async_wait_ctx_st* ctx  , const void* key);
int ASYNC_is_capable();
int ASYNC_set_mem_functions(void* (*alloc_fn)(unsigned long*)  , void (*free_fn)(void*)  );
void ASYNC_get_mem_functions(void* (*(*alloc_fn))(unsigned long*)  , void (*(*free_fn))(void*)  );
int ASYNC_start_job(struct async_job_st** job  , struct async_wait_ctx_st* ctx  , int* ret, int (*func)(void*), void* args, unsigned long size  );
int ASYNC_pause_job();
struct async_job_st* ASYNC_get_current_job();
struct async_wait_ctx_st* ASYNC_get_wait_ctx(struct async_job_st* job  );
void ASYNC_block_pause();
void ASYNC_unblock_pause();
static struct sct_st* ossl_check_SCT_type(struct sct_st* ptr  );
static const struct stack_st* ossl_check_const_SCT_sk_type(const struct stack_st_SCT* sk  );
static struct stack_st* ossl_check_SCT_sk_type(struct stack_st_SCT* sk  );
static int (*ossl_check_SCT_compfunc_type(int (*cmp)(const struct sct_st**,const struct sct_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_SCT_copyfunc_type(struct sct_st* (*cpy)(const struct sct_st*)  ))(const void*) ;
static void (*ossl_check_SCT_freefunc_type(void (*fr)(struct sct_st*)  ))(void*) ;
static struct ctlog_st* ossl_check_CTLOG_type(struct ctlog_st* ptr  );
static const struct stack_st* ossl_check_const_CTLOG_sk_type(const struct stack_st_CTLOG* sk  );
static struct stack_st* ossl_check_CTLOG_sk_type(struct stack_st_CTLOG* sk  );
static int (*ossl_check_CTLOG_compfunc_type(int (*cmp)(const struct ctlog_st**,const struct ctlog_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_CTLOG_copyfunc_type(struct ctlog_st* (*cpy)(const struct ctlog_st*)  ))(const void*) ;
static void (*ossl_check_CTLOG_freefunc_type(void (*fr)(struct ctlog_st*)  ))(void*) ;
struct ct_policy_eval_ctx_st* CT_POLICY_EVAL_CTX_new_ex(struct ossl_lib_ctx_st* libctx  , const char* propq);
struct ct_policy_eval_ctx_st* CT_POLICY_EVAL_CTX_new();
void CT_POLICY_EVAL_CTX_free(struct ct_policy_eval_ctx_st* ctx  );
struct x509_st* CT_POLICY_EVAL_CTX_get0_cert(const struct ct_policy_eval_ctx_st* ctx  );
int CT_POLICY_EVAL_CTX_set1_cert(struct ct_policy_eval_ctx_st* ctx  , struct x509_st* cert  );
struct x509_st* CT_POLICY_EVAL_CTX_get0_issuer(const struct ct_policy_eval_ctx_st* ctx  );
int CT_POLICY_EVAL_CTX_set1_issuer(struct ct_policy_eval_ctx_st* ctx  , struct x509_st* issuer  );
const struct ctlog_store_st* CT_POLICY_EVAL_CTX_get0_log_store(const struct ct_policy_eval_ctx_st* ctx  );
void CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(struct ct_policy_eval_ctx_st* ctx  , struct ctlog_store_st* log_store  );
unsigned long  int CT_POLICY_EVAL_CTX_get_time(const struct ct_policy_eval_ctx_st* ctx  );
void CT_POLICY_EVAL_CTX_set_time(struct ct_policy_eval_ctx_st* ctx  , unsigned long  int time_in_ms  );
struct sct_st* SCT_new();
struct sct_st* SCT_new_from_base64(unsigned char version, const char* logid_base64, enum anonymous_typeY45 entry_type  , unsigned long  int timestamp  , const char* extensions_base64, const char* signature_base64);
void SCT_free(struct sct_st* sct  );
void SCT_LIST_free(struct stack_st_SCT* a  );
enum anonymous_typeY45 SCT_get_version(const struct sct_st* sct  );
int SCT_set_version(struct sct_st* sct  , enum anonymous_typeY45 version  );
enum anonymous_typeY45 SCT_get_log_entry_type(const struct sct_st* sct  );
int SCT_set_log_entry_type(struct sct_st* sct  , enum anonymous_typeY45 entry_type  );
unsigned long SCT_get0_log_id(const struct sct_st* sct  , unsigned char** log_id);
int SCT_set0_log_id(struct sct_st* sct  , unsigned char* log_id, unsigned long log_id_len  );
int SCT_set1_log_id(struct sct_st* sct  , const unsigned char* log_id, unsigned long log_id_len  );
unsigned long  int SCT_get_timestamp(const struct sct_st* sct  );
void SCT_set_timestamp(struct sct_st* sct  , unsigned long  int timestamp  );
int SCT_get_signature_nid(const struct sct_st* sct  );
int SCT_set_signature_nid(struct sct_st* sct  , int nid);
unsigned long SCT_get0_extensions(const struct sct_st* sct  , unsigned char** ext);
void SCT_set0_extensions(struct sct_st* sct  , unsigned char* ext, unsigned long ext_len  );
int SCT_set1_extensions(struct sct_st* sct  , const unsigned char* ext, unsigned long ext_len  );
unsigned long SCT_get0_signature(const struct sct_st* sct  , unsigned char** sig);
void SCT_set0_signature(struct sct_st* sct  , unsigned char* sig, unsigned long sig_len  );
int SCT_set1_signature(struct sct_st* sct  , const unsigned char* sig, unsigned long sig_len  );
enum anonymous_typeY45 SCT_get_source(const struct sct_st* sct  );
int SCT_set_source(struct sct_st* sct  , enum anonymous_typeY45 source  );
const char* SCT_validation_status_string(const struct sct_st* sct  );
void SCT_print(const struct sct_st* sct  , struct bio_st* out  , int indent, const struct ctlog_store_st* logs  );
void SCT_LIST_print(const struct stack_st_SCT* sct_list  , struct bio_st* out  , int indent, const char* separator, const struct ctlog_store_st* logs  );
enum anonymous_typeY45 SCT_get_validation_status(const struct sct_st* sct  );
int SCT_validate(struct sct_st* sct  , const struct ct_policy_eval_ctx_st* ctx  );
int SCT_LIST_validate(const struct stack_st_SCT* scts  , struct ct_policy_eval_ctx_st* ctx  );
int i2o_SCT_LIST(const struct stack_st_SCT* a  , unsigned char** pp);
struct stack_st_SCT* o2i_SCT_LIST(struct stack_st_SCT** a  , const unsigned char** pp, unsigned long len  );
int i2d_SCT_LIST(const struct stack_st_SCT* a  , unsigned char** pp);
struct stack_st_SCT* d2i_SCT_LIST(struct stack_st_SCT** a  , const unsigned char** pp, long len);
int i2o_SCT(const struct sct_st* sct  , unsigned char** out);
struct sct_st* o2i_SCT(struct sct_st** psct  , const unsigned char** in, unsigned long len  );
struct ctlog_st* CTLOG_new_ex(struct evp_pkey_st* public_key  , const char* name, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct ctlog_st* CTLOG_new(struct evp_pkey_st* public_key  , const char* name);
int CTLOG_new_from_base64_ex(struct ctlog_st** ct_log  , const char* pkey_base64, const char* name, struct ossl_lib_ctx_st* libctx  , const char* propq);
int CTLOG_new_from_base64(struct ctlog_st** ct_log  , const char* pkey_base64, const char* name);
void CTLOG_free(struct ctlog_st* log  );
const char* CTLOG_get0_name(const struct ctlog_st* log  );
void CTLOG_get0_log_id(const struct ctlog_st* log  , const unsigned char** log_id  , unsigned long* log_id_len  );
struct evp_pkey_st* CTLOG_get0_public_key(const struct ctlog_st* log  );
struct ctlog_store_st* CTLOG_STORE_new_ex(struct ossl_lib_ctx_st* libctx  , const char* propq);
struct ctlog_store_st* CTLOG_STORE_new();
void CTLOG_STORE_free(struct ctlog_store_st* store  );
const struct ctlog_st* CTLOG_STORE_get0_log_by_id(const struct ctlog_store_st* store  , const unsigned char* log_id  , unsigned long log_id_len  );
int CTLOG_STORE_load_file(struct ctlog_store_st* store  , const char* file);
int CTLOG_STORE_load_default_file(struct ctlog_store_st* store  );
int ERR_load_SSL_strings();
static struct srtp_protection_profile_st* ossl_check_SRTP_PROTECTION_PROFILE_type(struct srtp_protection_profile_st* ptr  );
static const struct stack_st* ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(const struct stack_st_SRTP_PROTECTION_PROFILE* sk  );
static struct stack_st* ossl_check_SRTP_PROTECTION_PROFILE_sk_type(struct stack_st_SRTP_PROTECTION_PROFILE* sk  );
static int (*ossl_check_SRTP_PROTECTION_PROFILE_compfunc_type(int (*cmp)(const struct srtp_protection_profile_st**,const struct srtp_protection_profile_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_SRTP_PROTECTION_PROFILE_copyfunc_type(struct srtp_protection_profile_st* (*cpy)(const struct srtp_protection_profile_st*)  ))(const void*) ;
static void (*ossl_check_SRTP_PROTECTION_PROFILE_freefunc_type(void (*fr)(struct srtp_protection_profile_st*)  ))(void*) ;
unsigned long  int SSL_CTX_get_options(const struct ssl_ctx_st* ctx  );
unsigned long  int SSL_get_options(const struct ssl_st* s  );
unsigned long  int SSL_CTX_clear_options(struct ssl_ctx_st* ctx  , unsigned long  int op  );
unsigned long  int SSL_clear_options(struct ssl_st* s  , unsigned long  int op  );
unsigned long  int SSL_CTX_set_options(struct ssl_ctx_st* ctx  , unsigned long  int op  );
unsigned long  int SSL_set_options(struct ssl_st* s  , unsigned long  int op  );
void SSL_CTX_set_msg_callback(struct ssl_ctx_st* ctx  , void (*cb)(int,int,int,const void*,unsigned long,struct ssl_st*,void*));
void SSL_set_msg_callback(struct ssl_st* ssl  , void (*cb)(int,int,int,const void*,unsigned long,struct ssl_st*,void*));
int SSL_SRP_CTX_init(struct ssl_st* s  );
int SSL_CTX_SRP_CTX_init(struct ssl_ctx_st* ctx  );
int SSL_SRP_CTX_free(struct ssl_st* ctx  );
int SSL_CTX_SRP_CTX_free(struct ssl_ctx_st* ctx  );
int SSL_srp_server_param_with_username(struct ssl_st* s  , int* ad);
int SRP_Calc_A_param(struct ssl_st* s  );
struct lhash_st_SSL_SESSION* SSL_CTX_sessions(struct ssl_ctx_st* ctx  );
void SSL_CTX_sess_set_new_cb(struct ssl_ctx_st* ctx  , int (*new_session_cb)(struct ssl_st*,struct ssl_session_st*));
int (*SSL_CTX_sess_get_new_cb(struct ssl_ctx_st* _function_pointer_result_var_name_a59  ))(struct ssl_st*,struct ssl_session_st*);
void SSL_CTX_sess_set_remove_cb(struct ssl_ctx_st* ctx  , void (*remove_session_cb)(struct ssl_ctx_st*,struct ssl_session_st*));
void (*SSL_CTX_sess_get_remove_cb(struct ssl_ctx_st* _function_pointer_result_var_name_a60  ))(struct ssl_ctx_st*,struct ssl_session_st*);
void SSL_CTX_sess_set_get_cb(struct ssl_ctx_st* ctx  , struct ssl_session_st* (*get_session_cb)(struct ssl_st*,const unsigned char*,int,int*));
struct ssl_session_st* (*SSL_CTX_sess_get_get_cb(struct ssl_ctx_st* _function_pointer_result_var_name_a61  ))(struct ssl_st*,const unsigned char*,int,int*);
void SSL_CTX_set_info_callback(struct ssl_ctx_st* ctx  , void (*cb)(const struct ssl_st*,int,int));
void (*SSL_CTX_get_info_callback(struct ssl_ctx_st* _function_pointer_result_var_name_a62  ))(const struct ssl_st*,int,int);
void SSL_CTX_set_client_cert_cb(struct ssl_ctx_st* ctx  , int (*client_cert_cb)(struct ssl_st*,struct x509_st**,struct evp_pkey_st**));
int (*SSL_CTX_get_client_cert_cb(struct ssl_ctx_st* _function_pointer_result_var_name_a63  ))(struct ssl_st*,struct x509_st**,struct evp_pkey_st**);
void SSL_CTX_set_cookie_generate_cb(struct ssl_ctx_st* ctx  , int (*app_gen_cookie_cb)(struct ssl_st*,unsigned char*,unsigned int*));
void SSL_CTX_set_cookie_verify_cb(struct ssl_ctx_st* ctx  , int (*app_verify_cookie_cb)(struct ssl_st*,const unsigned char*,unsigned int));
void SSL_CTX_set_stateless_cookie_generate_cb(struct ssl_ctx_st* ctx  , int (*gen_stateless_cookie_cb)(struct ssl_st*,unsigned char*,unsigned long*));
void SSL_CTX_set_stateless_cookie_verify_cb(struct ssl_ctx_st* ctx  , int (*verify_stateless_cookie_cb)(struct ssl_st*,const unsigned char*,unsigned long));
void SSL_CTX_set_next_protos_advertised_cb(struct ssl_ctx_st* s  , int (*cb)(struct ssl_st*,const unsigned char**,unsigned int*,void*)  , void* arg);
void SSL_CTX_set_next_proto_select_cb(struct ssl_ctx_st* s  , int (*cb)(struct ssl_st*,unsigned char**,unsigned char*,const unsigned char*,unsigned int,void*)  , void* arg);
void SSL_get0_next_proto_negotiated(const struct ssl_st* s  , const unsigned char** data, unsigned int* len);
int SSL_select_next_proto(unsigned char** out, unsigned char* outlen, const unsigned char* in, unsigned int inlen, const unsigned char* client, unsigned int client_len);
int SSL_CTX_set_alpn_protos(struct ssl_ctx_st* ctx  , const unsigned char* protos, unsigned int protos_len);
int SSL_set_alpn_protos(struct ssl_st* ssl  , const unsigned char* protos, unsigned int protos_len);
void SSL_CTX_set_alpn_select_cb(struct ssl_ctx_st* ctx  , int (*cb)(struct ssl_st*,const unsigned char**,unsigned char*,const unsigned char*,unsigned int,void*)  , void* arg);
void SSL_get0_alpn_selected(const struct ssl_st* ssl  , const unsigned char** data, unsigned int* len);
void SSL_CTX_set_psk_client_callback(struct ssl_ctx_st* ctx  , unsigned int (*cb)(struct ssl_st*,const char*,char*,unsigned int,unsigned char*,unsigned int)  );
void SSL_set_psk_client_callback(struct ssl_st* ssl  , unsigned int (*cb)(struct ssl_st*,const char*,char*,unsigned int,unsigned char*,unsigned int)  );
void SSL_CTX_set_psk_server_callback(struct ssl_ctx_st* ctx  , unsigned int (*cb)(struct ssl_st*,const char*,unsigned char*,unsigned int)  );
void SSL_set_psk_server_callback(struct ssl_st* ssl  , unsigned int (*cb)(struct ssl_st*,const char*,unsigned char*,unsigned int)  );
int SSL_CTX_use_psk_identity_hint(struct ssl_ctx_st* ctx  , const char* identity_hint);
int SSL_use_psk_identity_hint(struct ssl_st* s  , const char* identity_hint);
const char* SSL_get_psk_identity_hint(const struct ssl_st* s  );
const char* SSL_get_psk_identity(const struct ssl_st* s  );
void SSL_set_psk_find_session_callback(struct ssl_st* s  , int (*cb)(struct ssl_st*,const unsigned char*,unsigned long,struct ssl_session_st**)  );
void SSL_CTX_set_psk_find_session_callback(struct ssl_ctx_st* ctx  , int (*cb)(struct ssl_st*,const unsigned char*,unsigned long,struct ssl_session_st**)  );
void SSL_set_psk_use_session_callback(struct ssl_st* s  , int (*cb)(struct ssl_st*,const struct evp_md_st*,const unsigned char**,unsigned long*,struct ssl_session_st**)  );
void SSL_CTX_set_psk_use_session_callback(struct ssl_ctx_st* ctx  , int (*cb)(struct ssl_st*,const struct evp_md_st*,const unsigned char**,unsigned long*,struct ssl_session_st**)  );
int SSL_CTX_has_client_custom_ext(const struct ssl_ctx_st* ctx  , unsigned int ext_type);
int SSL_CTX_add_client_custom_ext(struct ssl_ctx_st* ctx  , unsigned int ext_type, int (*add_cb)(struct ssl_st*,unsigned int,const unsigned char**,unsigned long*,int*,void*)  , void (*free_cb)(struct ssl_st*,unsigned int,const unsigned char*,void*)  , void* add_arg, int (*parse_cb)(struct ssl_st*,unsigned int,const unsigned char*,unsigned long,int*,void*)  , void* parse_arg);
int SSL_CTX_add_server_custom_ext(struct ssl_ctx_st* ctx  , unsigned int ext_type, int (*add_cb)(struct ssl_st*,unsigned int,const unsigned char**,unsigned long*,int*,void*)  , void (*free_cb)(struct ssl_st*,unsigned int,const unsigned char*,void*)  , void* add_arg, int (*parse_cb)(struct ssl_st*,unsigned int,const unsigned char*,unsigned long,int*,void*)  , void* parse_arg);
int SSL_CTX_add_custom_ext(struct ssl_ctx_st* ctx  , unsigned int ext_type, unsigned int context, int (*add_cb)(struct ssl_st*,unsigned int,unsigned int,const unsigned char**,unsigned long*,struct x509_st*,unsigned long,int*,void*)  , void (*free_cb)(struct ssl_st*,unsigned int,unsigned int,const unsigned char*,void*)  , void* add_arg, int (*parse_cb)(struct ssl_st*,unsigned int,unsigned int,const unsigned char*,unsigned long,struct x509_st*,unsigned long,int*,void*)  , void* parse_arg);
int SSL_extension_supported(unsigned int ext_type);
void SSL_CTX_set_keylog_callback(struct ssl_ctx_st* ctx  , void (*cb)(const struct ssl_st*,const char*)  );
void (*SSL_CTX_get_keylog_callback(const struct ssl_ctx_st* ctx  ))(const struct ssl_st*,const char*) ;
int SSL_CTX_set_max_early_data(struct ssl_ctx_st* ctx  , unsigned int max_early_data  );
unsigned int SSL_CTX_get_max_early_data(const struct ssl_ctx_st* ctx  );
int SSL_set_max_early_data(struct ssl_st* s  , unsigned int max_early_data  );
unsigned int SSL_get_max_early_data(const struct ssl_st* s  );
int SSL_CTX_set_recv_max_early_data(struct ssl_ctx_st* ctx  , unsigned int recv_max_early_data  );
unsigned int SSL_CTX_get_recv_max_early_data(const struct ssl_ctx_st* ctx  );
int SSL_set_recv_max_early_data(struct ssl_st* s  , unsigned int recv_max_early_data  );
unsigned int SSL_get_recv_max_early_data(const struct ssl_st* s  );
int SSL_CTX_set_tlsext_max_fragment_length(struct ssl_ctx_st* ctx  , unsigned char mode  );
int SSL_set_tlsext_max_fragment_length(struct ssl_st* ssl  , unsigned char mode  );
const char* SSL_get_servername(const struct ssl_st* s  , const int type);
int SSL_get_servername_type(const struct ssl_st* s  );
int SSL_export_keying_material(struct ssl_st* s  , unsigned char* out, unsigned long olen  , const char* label, unsigned long llen  , const unsigned char* context, unsigned long contextlen  , int use_context);
int SSL_export_keying_material_early(struct ssl_st* s  , unsigned char* out, unsigned long olen  , const char* label, unsigned long llen  , const unsigned char* context, unsigned long contextlen  );
int SSL_get_peer_signature_type_nid(const struct ssl_st* s  , int* pnid);
int SSL_get_signature_type_nid(const struct ssl_st* s  , int* pnid);
int SSL_get_sigalgs(struct ssl_st* s  , int idx, int* psign, int* phash, int* psignandhash, unsigned char* rsig, unsigned char* rhash);
char* SSL_get1_builtin_sigalgs(struct ossl_lib_ctx_st* libctx  );
int SSL_get_shared_sigalgs(struct ssl_st* s  , int idx, int* psign, int* phash, int* psignandhash, unsigned char* rsig, unsigned char* rhash);
int SSL_check_chain(struct ssl_st* s  , struct x509_st* x  , struct evp_pkey_st* pk  , struct stack_st_X509* chain  );
int SSL_CTX_set_tlsext_ticket_key_evp_cb(struct ssl_ctx_st* ctx  , int (*fp)(struct ssl_st*,unsigned char*,unsigned char*,struct evp_cipher_ctx_st*,struct evp_mac_ctx_st*,int));
int SSL_CTX_set_tlsext_use_srtp(struct ssl_ctx_st* ctx  , const char* profiles);
int SSL_set_tlsext_use_srtp(struct ssl_st* ssl  , const char* profiles);
struct stack_st_SRTP_PROTECTION_PROFILE* SSL_get_srtp_profiles(struct ssl_st* ssl  );
struct srtp_protection_profile_st* SSL_get_selected_srtp_profile(struct ssl_st* s  );
const struct ssl_method_st* OSSL_QUIC_client_method();
const struct ssl_method_st* OSSL_QUIC_client_thread_method();
const struct ssl_method_st* OSSL_QUIC_server_method();
static const struct ssl_cipher_st* ossl_check_SSL_CIPHER_type(const struct ssl_cipher_st* ptr  );
static const struct stack_st* ossl_check_const_SSL_CIPHER_sk_type(const struct stack_st_SSL_CIPHER* sk  );
static struct stack_st* ossl_check_SSL_CIPHER_sk_type(struct stack_st_SSL_CIPHER* sk  );
static int (*ossl_check_SSL_CIPHER_compfunc_type(int (*cmp)(const struct ssl_cipher_st**,const struct ssl_cipher_st**)  ))(const void*,const void*) ;
static void* (*ossl_check_SSL_CIPHER_copyfunc_type(struct ssl_cipher_st* (*cpy)(const struct ssl_cipher_st*)  ))(const void*) ;
static void (*ossl_check_SSL_CIPHER_freefunc_type(void (*fr)(struct ssl_cipher_st*)  ))(void*) ;
void SSL_set_debug(struct ssl_st* s  , int debug);
int SSL_in_init(const struct ssl_st* s  );
int SSL_in_before(const struct ssl_st* s  );
int SSL_is_init_finished(const struct ssl_st* s  );
unsigned long SSL_get_finished(const struct ssl_st* s  , void* buf, unsigned long count  );
unsigned long SSL_get_peer_finished(const struct ssl_st* s  , void* buf, unsigned long count  );
struct ssl_session_st* PEM_read_bio_SSL_SESSION(struct bio_st* out  , struct ssl_session_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
struct ssl_session_st* PEM_read_SSL_SESSION(struct _IO_FILE* out  , struct ssl_session_st** x  , int (*(*cb))(char*,int,int,void*)  , void* u);
int PEM_write_bio_SSL_SESSION(struct bio_st* out  , const struct ssl_session_st* x  );
int PEM_write_SSL_SESSION(struct _IO_FILE* out  , const struct ssl_session_st* x  );
const char* SSL_get0_group_name(struct ssl_st* s  );
const char* SSL_group_to_name(struct ssl_st* s  , int id);
int SSL_set0_tmp_dh_pkey(struct ssl_st* s  , struct evp_pkey_st* dhpkey  );
int SSL_CTX_set0_tmp_dh_pkey(struct ssl_ctx_st* ctx  , struct evp_pkey_st* dhpkey  );
const struct bio_method_st* BIO_f_ssl();
struct bio_st* BIO_new_ssl(struct ssl_ctx_st* ctx  , int client);
struct bio_st* BIO_new_ssl_connect(struct ssl_ctx_st* ctx  );
struct bio_st* BIO_new_buffer_ssl_connect(struct ssl_ctx_st* ctx  );
int BIO_ssl_copy_session_id(struct bio_st* to  , struct bio_st* from  );
void BIO_ssl_shutdown(struct bio_st* ssl_bio  );
int SSL_CTX_set_cipher_list(struct ssl_ctx_st*   , const char* str);
struct ssl_ctx_st* SSL_CTX_new(const struct ssl_method_st* meth  );
struct ssl_ctx_st* SSL_CTX_new_ex(struct ossl_lib_ctx_st* libctx  , const char* propq, const struct ssl_method_st* meth  );
int SSL_CTX_up_ref(struct ssl_ctx_st* ctx  );
void SSL_CTX_free(struct ssl_ctx_st*   );
long SSL_CTX_set_timeout(struct ssl_ctx_st* ctx  , long t);
long SSL_CTX_get_timeout(const struct ssl_ctx_st* ctx  );
struct x509_store_st* SSL_CTX_get_cert_store(const struct ssl_ctx_st*   );
void SSL_CTX_set_cert_store(struct ssl_ctx_st*   , struct x509_store_st*   );
void SSL_CTX_set1_cert_store(struct ssl_ctx_st*   , struct x509_store_st*   );
int SSL_want(const struct ssl_st* s  );
int SSL_clear(struct ssl_st* s  );
void SSL_CTX_flush_sessions(struct ssl_ctx_st* ctx  , long tm);
void SSL_CTX_flush_sessions_ex(struct ssl_ctx_st* ctx  , long  int tm  );
const struct ssl_cipher_st* SSL_get_current_cipher(const struct ssl_st* s  );
const struct ssl_cipher_st* SSL_get_pending_cipher(const struct ssl_st* s  );
int SSL_CIPHER_get_bits(const struct ssl_cipher_st* c  , int* alg_bits);
const char* SSL_CIPHER_get_version(const struct ssl_cipher_st* c  );
const char* SSL_CIPHER_get_name(const struct ssl_cipher_st* c  );
const char* SSL_CIPHER_standard_name(const struct ssl_cipher_st* c  );
const char* OPENSSL_cipher_name(const char* rfc_name);
unsigned int SSL_CIPHER_get_id(const struct ssl_cipher_st* c  );
unsigned short int SSL_CIPHER_get_protocol_id(const struct ssl_cipher_st* c  );
int SSL_CIPHER_get_kx_nid(const struct ssl_cipher_st* c  );
int SSL_CIPHER_get_auth_nid(const struct ssl_cipher_st* c  );
const struct evp_md_st* SSL_CIPHER_get_handshake_digest(const struct ssl_cipher_st* c  );
int SSL_CIPHER_is_aead(const struct ssl_cipher_st* c  );
int SSL_get_fd(const struct ssl_st* s  );
int SSL_get_rfd(const struct ssl_st* s  );
int SSL_get_wfd(const struct ssl_st* s  );
const char* SSL_get_cipher_list(const struct ssl_st* s  , int n);
char* SSL_get_shared_ciphers(const struct ssl_st* s  , char* buf, int size);
int SSL_get_read_ahead(const struct ssl_st* s  );
int SSL_pending(const struct ssl_st* s  );
int SSL_has_pending(const struct ssl_st* s  );
int SSL_set_fd(struct ssl_st* s  , int fd);
int SSL_set_rfd(struct ssl_st* s  , int fd);
int SSL_set_wfd(struct ssl_st* s  , int fd);
void SSL_set0_rbio(struct ssl_st* s  , struct bio_st* rbio  );
void SSL_set0_wbio(struct ssl_st* s  , struct bio_st* wbio  );
void SSL_set_bio(struct ssl_st* s  , struct bio_st* rbio  , struct bio_st* wbio  );
struct bio_st* SSL_get_rbio(const struct ssl_st* s  );
struct bio_st* SSL_get_wbio(const struct ssl_st* s  );
int SSL_set_cipher_list(struct ssl_st* s  , const char* str);
int SSL_CTX_set_ciphersuites(struct ssl_ctx_st* ctx  , const char* str);
int SSL_set_ciphersuites(struct ssl_st* s  , const char* str);
void SSL_set_read_ahead(struct ssl_st* s  , int yes);
int SSL_get_verify_mode(const struct ssl_st* s  );
int SSL_get_verify_depth(const struct ssl_st* s  );
int (*SSL_get_verify_callback(const struct ssl_st* s  ))(int,struct x509_store_ctx_st*) ;
void SSL_set_verify(struct ssl_st* s  , int mode, int (*callback)(int,struct x509_store_ctx_st*)  );
void SSL_set_verify_depth(struct ssl_st* s  , int depth);
void SSL_set_cert_cb(struct ssl_st* s  , int (*cb)(struct ssl_st*,void*), void* arg);
int SSL_use_RSAPrivateKey(struct ssl_st* ssl  , struct rsa_st* rsa  );
int SSL_use_RSAPrivateKey_ASN1(struct ssl_st* ssl  , const unsigned char* d, long len);
int SSL_use_PrivateKey(struct ssl_st* ssl  , struct evp_pkey_st* pkey  );
int SSL_use_PrivateKey_ASN1(int pk, struct ssl_st* ssl  , const unsigned char* d, long len);
int SSL_use_certificate(struct ssl_st* ssl  , struct x509_st* x  );
int SSL_use_certificate_ASN1(struct ssl_st* ssl  , const unsigned char* d, int len);
int SSL_use_cert_and_key(struct ssl_st* ssl  , struct x509_st* x509  , struct evp_pkey_st* privatekey  , struct stack_st_X509* chain  , int override);
int SSL_CTX_use_serverinfo(struct ssl_ctx_st* ctx  , const unsigned char* serverinfo, unsigned long serverinfo_length  );
int SSL_CTX_use_serverinfo_ex(struct ssl_ctx_st* ctx  , unsigned int version, const unsigned char* serverinfo, unsigned long serverinfo_length  );
int SSL_CTX_use_serverinfo_file(struct ssl_ctx_st* ctx  , const char* file);
int SSL_use_RSAPrivateKey_file(struct ssl_st* ssl  , const char* file, int type);
int SSL_use_PrivateKey_file(struct ssl_st* ssl  , const char* file, int type);
int SSL_use_certificate_file(struct ssl_st* ssl  , const char* file, int type);
int SSL_CTX_use_RSAPrivateKey_file(struct ssl_ctx_st* ctx  , const char* file, int type);
int SSL_CTX_use_PrivateKey_file(struct ssl_ctx_st* ctx  , const char* file, int type);
int SSL_CTX_use_certificate_file(struct ssl_ctx_st* ctx  , const char* file, int type);
int SSL_CTX_use_certificate_chain_file(struct ssl_ctx_st* ctx  , const char* file);
int SSL_use_certificate_chain_file(struct ssl_st* ssl  , const char* file);
struct stack_st_X509_NAME* SSL_load_client_CA_file(const char* file);
struct stack_st_X509_NAME* SSL_load_client_CA_file_ex(const char* file, struct ossl_lib_ctx_st* libctx  , const char* propq);
int SSL_add_file_cert_subjects_to_stack(struct stack_st_X509_NAME* stackCAs  , const char* file);
int SSL_add_dir_cert_subjects_to_stack(struct stack_st_X509_NAME* stackCAs  , const char* dir);
int SSL_add_store_cert_subjects_to_stack(struct stack_st_X509_NAME* stackCAs  , const char* uri);
const char* SSL_state_string(const struct ssl_st* s  );
const char* SSL_rstate_string(const struct ssl_st* s  );
const char* SSL_state_string_long(const struct ssl_st* s  );
const char* SSL_rstate_string_long(const struct ssl_st* s  );
long SSL_SESSION_get_time(const struct ssl_session_st* s  );
long SSL_SESSION_set_time(struct ssl_session_st* s  , long t);
long SSL_SESSION_get_timeout(const struct ssl_session_st* s  );
long SSL_SESSION_set_timeout(struct ssl_session_st* s  , long t);
int SSL_SESSION_get_protocol_version(const struct ssl_session_st* s  );
int SSL_SESSION_set_protocol_version(struct ssl_session_st* s  , int version);
long  int SSL_SESSION_get_time_ex(const struct ssl_session_st* s  );
long  int SSL_SESSION_set_time_ex(struct ssl_session_st* s  , long  int t  );
const char* SSL_SESSION_get0_hostname(const struct ssl_session_st* s  );
int SSL_SESSION_set1_hostname(struct ssl_session_st* s  , const char* hostname);
void SSL_SESSION_get0_alpn_selected(const struct ssl_session_st* s  , const unsigned char** alpn, unsigned long* len  );
int SSL_SESSION_set1_alpn_selected(struct ssl_session_st* s  , const unsigned char* alpn, unsigned long len  );
const struct ssl_cipher_st* SSL_SESSION_get0_cipher(const struct ssl_session_st* s  );
int SSL_SESSION_set_cipher(struct ssl_session_st* s  , const struct ssl_cipher_st* cipher  );
int SSL_SESSION_has_ticket(const struct ssl_session_st* s  );
unsigned long  int SSL_SESSION_get_ticket_lifetime_hint(const struct ssl_session_st* s  );
void SSL_SESSION_get0_ticket(const struct ssl_session_st* s  , const unsigned char** tick, unsigned long* len  );
unsigned int SSL_SESSION_get_max_early_data(const struct ssl_session_st* s  );
int SSL_SESSION_set_max_early_data(struct ssl_session_st* s  , unsigned int max_early_data  );
int SSL_copy_session_id(struct ssl_st* to  , const struct ssl_st* from  );
struct x509_st* SSL_SESSION_get0_peer(struct ssl_session_st* s  );
int SSL_SESSION_set1_id_context(struct ssl_session_st* s  , const unsigned char* sid_ctx, unsigned int sid_ctx_len);
int SSL_SESSION_set1_id(struct ssl_session_st* s  , const unsigned char* sid, unsigned int sid_len);
int SSL_SESSION_is_resumable(const struct ssl_session_st* s  );
struct ssl_session_st* SSL_SESSION_new();
struct ssl_session_st* SSL_SESSION_dup(const struct ssl_session_st* src  );
const unsigned char* SSL_SESSION_get_id(const struct ssl_session_st* s  , unsigned int* len);
const unsigned char* SSL_SESSION_get0_id_context(const struct ssl_session_st* s  , unsigned int* len);
unsigned int SSL_SESSION_get_compress_id(const struct ssl_session_st* s  );
int SSL_SESSION_print_fp(struct _IO_FILE* fp  , const struct ssl_session_st* ses  );
int SSL_SESSION_print(struct bio_st* fp  , const struct ssl_session_st* ses  );
int SSL_SESSION_print_keylog(struct bio_st* bp  , const struct ssl_session_st* x  );
int SSL_SESSION_up_ref(struct ssl_session_st* ses  );
void SSL_SESSION_free(struct ssl_session_st* ses  );
int i2d_SSL_SESSION(const struct ssl_session_st* in  , unsigned char** pp);
int SSL_set_session(struct ssl_st* to  , struct ssl_session_st* session  );
int SSL_CTX_add_session(struct ssl_ctx_st* ctx  , struct ssl_session_st* session  );
int SSL_CTX_remove_session(struct ssl_ctx_st* ctx  , struct ssl_session_st* session  );
int SSL_CTX_set_generate_session_id(struct ssl_ctx_st* ctx  , int (*cb)(struct ssl_st*,unsigned char*,unsigned int*)  );
int SSL_set_generate_session_id(struct ssl_st* s  , int (*cb)(struct ssl_st*,unsigned char*,unsigned int*)  );
int SSL_has_matching_session_id(const struct ssl_st* s  , const unsigned char* id, unsigned int id_len);
struct ssl_session_st* d2i_SSL_SESSION(struct ssl_session_st** a  , const unsigned char** pp, long length);
struct ssl_session_st* d2i_SSL_SESSION_ex(struct ssl_session_st** a  , const unsigned char** pp, long length, struct ossl_lib_ctx_st* libctx  , const char* propq);
struct x509_st* SSL_get0_peer_certificate(const struct ssl_st* s  );
struct x509_st* SSL_get1_peer_certificate(const struct ssl_st* s  );
struct stack_st_X509* SSL_get_peer_cert_chain(const struct ssl_st* s  );
int SSL_CTX_get_verify_mode(const struct ssl_ctx_st* ctx  );
int SSL_CTX_get_verify_depth(const struct ssl_ctx_st* ctx  );
int (*SSL_CTX_get_verify_callback(const struct ssl_ctx_st* ctx  ))(int,struct x509_store_ctx_st*) ;
void SSL_CTX_set_verify(struct ssl_ctx_st* ctx  , int mode, int (*callback)(int,struct x509_store_ctx_st*)  );
void SSL_CTX_set_verify_depth(struct ssl_ctx_st* ctx  , int depth);
void SSL_CTX_set_cert_verify_callback(struct ssl_ctx_st* ctx  , int (*cb)(struct x509_store_ctx_st*,void*), void* arg);
void SSL_CTX_set_cert_cb(struct ssl_ctx_st* c  , int (*cb)(struct ssl_st*,void*), void* arg);
int SSL_CTX_use_RSAPrivateKey(struct ssl_ctx_st* ctx  , struct rsa_st* rsa  );
int SSL_CTX_use_RSAPrivateKey_ASN1(struct ssl_ctx_st* ctx  , const unsigned char* d, long len);
int SSL_CTX_use_PrivateKey(struct ssl_ctx_st* ctx  , struct evp_pkey_st* pkey  );
int SSL_CTX_use_PrivateKey_ASN1(int pk, struct ssl_ctx_st* ctx  , const unsigned char* d, long len);
int SSL_CTX_use_certificate(struct ssl_ctx_st* ctx  , struct x509_st* x  );
int SSL_CTX_use_certificate_ASN1(struct ssl_ctx_st* ctx  , int len, const unsigned char* d);
int SSL_CTX_use_cert_and_key(struct ssl_ctx_st* ctx  , struct x509_st* x509  , struct evp_pkey_st* privatekey  , struct stack_st_X509* chain  , int override);
void SSL_CTX_set_default_passwd_cb(struct ssl_ctx_st* ctx  , int (*(*cb))(char*,int,int,void*)  );
void SSL_CTX_set_default_passwd_cb_userdata(struct ssl_ctx_st* ctx  , void* u);
int (*(*SSL_CTX_get_default_passwd_cb(struct ssl_ctx_st* ctx  )))(char*,int,int,void*) ;
void* SSL_CTX_get_default_passwd_cb_userdata(struct ssl_ctx_st* ctx  );
void SSL_set_default_passwd_cb(struct ssl_st* s  , int (*(*cb))(char*,int,int,void*)  );
void SSL_set_default_passwd_cb_userdata(struct ssl_st* s  , void* u);
int (*(*SSL_get_default_passwd_cb(struct ssl_st* s  )))(char*,int,int,void*) ;
void* SSL_get_default_passwd_cb_userdata(struct ssl_st* s  );
int SSL_CTX_check_private_key(const struct ssl_ctx_st* ctx  );
int SSL_check_private_key(const struct ssl_st* ctx  );
int SSL_CTX_set_session_id_context(struct ssl_ctx_st* ctx  , const unsigned char* sid_ctx, unsigned int sid_ctx_len);
struct ssl_st* SSL_new(struct ssl_ctx_st* ctx  );
int SSL_up_ref(struct ssl_st* s  );
int SSL_is_dtls(const struct ssl_st* s  );
int SSL_is_tls(const struct ssl_st* s  );
int SSL_is_quic(const struct ssl_st* s  );
int SSL_set_session_id_context(struct ssl_st* ssl  , const unsigned char* sid_ctx, unsigned int sid_ctx_len);
int SSL_CTX_set_purpose(struct ssl_ctx_st* ctx  , int purpose);
int SSL_set_purpose(struct ssl_st* ssl  , int purpose);
int SSL_CTX_set_trust(struct ssl_ctx_st* ctx  , int trust);
int SSL_set_trust(struct ssl_st* ssl  , int trust);
int SSL_set1_host(struct ssl_st* s  , const char* host);
int SSL_add1_host(struct ssl_st* s  , const char* host);
const char* SSL_get0_peername(struct ssl_st* s  );
void SSL_set_hostflags(struct ssl_st* s  , unsigned int flags);
int SSL_CTX_dane_enable(struct ssl_ctx_st* ctx  );
int SSL_CTX_dane_mtype_set(struct ssl_ctx_st* ctx  , const struct evp_md_st* md  , unsigned char mtype  , unsigned char ord  );
int SSL_dane_enable(struct ssl_st* s  , const char* basedomain);
int SSL_dane_tlsa_add(struct ssl_st* s  , unsigned char usage  , unsigned char selector  , unsigned char mtype  , const unsigned char* data, unsigned long dlen  );
int SSL_get0_dane_authority(struct ssl_st* s  , struct x509_st** mcert  , struct evp_pkey_st** mspki  );
int SSL_get0_dane_tlsa(struct ssl_st* s  , unsigned char* usage  , unsigned char* selector  , unsigned char* mtype  , const unsigned char** data, unsigned long* dlen  );
struct ssl_dane_st* SSL_get0_dane(struct ssl_st* ssl  );
unsigned long  int SSL_CTX_dane_set_flags(struct ssl_ctx_st* ctx  , unsigned long  int flags);
unsigned long  int SSL_CTX_dane_clear_flags(struct ssl_ctx_st* ctx  , unsigned long  int flags);
unsigned long  int SSL_dane_set_flags(struct ssl_st* ssl  , unsigned long  int flags);
unsigned long  int SSL_dane_clear_flags(struct ssl_st* ssl  , unsigned long  int flags);
int SSL_CTX_set1_param(struct ssl_ctx_st* ctx  , struct X509_VERIFY_PARAM_st* vpm  );
int SSL_set1_param(struct ssl_st* ssl  , struct X509_VERIFY_PARAM_st* vpm  );
struct X509_VERIFY_PARAM_st* SSL_CTX_get0_param(struct ssl_ctx_st* ctx  );
struct X509_VERIFY_PARAM_st* SSL_get0_param(struct ssl_st* ssl  );
int SSL_CTX_set_srp_username(struct ssl_ctx_st* ctx  , char* name);
int SSL_CTX_set_srp_password(struct ssl_ctx_st* ctx  , char* password);
int SSL_CTX_set_srp_strength(struct ssl_ctx_st* ctx  , int strength);
int SSL_CTX_set_srp_client_pwd_callback(struct ssl_ctx_st* ctx  , char* (*cb)(struct ssl_st*,void*));
int SSL_CTX_set_srp_verify_param_callback(struct ssl_ctx_st* ctx  , int (*cb)(struct ssl_st*,void*));
int SSL_CTX_set_srp_username_callback(struct ssl_ctx_st* ctx  , int (*cb)(struct ssl_st*,int*,void*));
int SSL_CTX_set_srp_cb_arg(struct ssl_ctx_st* ctx  , void* arg);
int SSL_set_srp_server_param(struct ssl_st* s  , const struct bignum_st* N  , const struct bignum_st* g  , struct bignum_st* sa  , struct bignum_st* v  , char* info);
int SSL_set_srp_server_param_pw(struct ssl_st* s  , const char* user, const char* pass, const char* grp);
struct bignum_st* SSL_get_srp_g(struct ssl_st* s  );
struct bignum_st* SSL_get_srp_N(struct ssl_st* s  );
char* SSL_get_srp_username(struct ssl_st* s  );
char* SSL_get_srp_userinfo(struct ssl_st* s  );
void SSL_CTX_set_client_hello_cb(struct ssl_ctx_st* c  , int (*cb)(struct ssl_st*,int*,void*)  , void* arg);
void SSL_CTX_set_new_pending_conn_cb(struct ssl_ctx_st* c  , int (*cb)(struct ssl_ctx_st*,struct ssl_st*,void*)  , void* arg);
int SSL_client_hello_isv2(struct ssl_st* s  );
unsigned int SSL_client_hello_get0_legacy_version(struct ssl_st* s  );
unsigned long SSL_client_hello_get0_random(struct ssl_st* s  , const unsigned char** out);
unsigned long SSL_client_hello_get0_session_id(struct ssl_st* s  , const unsigned char** out);
unsigned long SSL_client_hello_get0_ciphers(struct ssl_st* s  , const unsigned char** out);
unsigned long SSL_client_hello_get0_compression_methods(struct ssl_st* s  , const unsigned char** out);
int SSL_client_hello_get1_extensions_present(struct ssl_st* s  , int** out, unsigned long* outlen  );
int SSL_client_hello_get_extension_order(struct ssl_st* s  , unsigned short int* exts  , unsigned long* num_exts  );
int SSL_client_hello_get0_ext(struct ssl_st* s  , unsigned int type, const unsigned char** out, unsigned long* outlen  );
void SSL_certs_clear(struct ssl_st* s  );
void SSL_free(struct ssl_st* ssl  );
int SSL_waiting_for_async(struct ssl_st* s  );
int SSL_get_all_async_fds(struct ssl_st* s  , int* fds, unsigned long* numfds  );
int SSL_get_changed_async_fds(struct ssl_st* s  , int* addfd, unsigned long* numaddfds  , int* delfd, unsigned long* numdelfds  );
int SSL_CTX_set_async_callback(struct ssl_ctx_st* ctx  , int (*callback)(struct ssl_st*,void*)  );
int SSL_CTX_set_async_callback_arg(struct ssl_ctx_st* ctx  , void* arg);
int SSL_set_async_callback(struct ssl_st* s  , int (*callback)(struct ssl_st*,void*)  );
int SSL_set_async_callback_arg(struct ssl_st* s  , void* arg);
int SSL_get_async_status(struct ssl_st* s  , int* status);
int SSL_accept(struct ssl_st* ssl  );
int SSL_stateless(struct ssl_st* s  );
int SSL_connect(struct ssl_st* ssl  );
int SSL_read(struct ssl_st* ssl  , void* buf, int num);
int SSL_read_ex(struct ssl_st* ssl  , void* buf, unsigned long num  , unsigned long* readbytes  );
int SSL_read_early_data(struct ssl_st* s  , void* buf, unsigned long num  , unsigned long* readbytes  );
int SSL_peek(struct ssl_st* ssl  , void* buf, int num);
int SSL_peek_ex(struct ssl_st* ssl  , void* buf, unsigned long num  , unsigned long* readbytes  );
long  int SSL_sendfile(struct ssl_st* s  , int fd, long  int offset  , unsigned long size  , int flags);
int SSL_write(struct ssl_st* ssl  , const void* buf, int num);
int SSL_write_ex(struct ssl_st* s  , const void* buf, unsigned long num  , unsigned long* written  );
int SSL_write_early_data(struct ssl_st* s  , const void* buf, unsigned long num  , unsigned long* written  );
long SSL_ctrl(struct ssl_st* ssl  , int cmd, long larg, void* parg);
long SSL_callback_ctrl(struct ssl_st*   , int , void (*anonymous_lambda_var_nameZ49)());
long SSL_CTX_ctrl(struct ssl_ctx_st* ctx  , int cmd, long larg, void* parg);
long SSL_CTX_callback_ctrl(struct ssl_ctx_st*   , int , void (*anonymous_lambda_var_nameZ50)());
int SSL_write_ex2(struct ssl_st* s  , const void* buf, unsigned long num  , unsigned long  int flags  , unsigned long* written  );
int SSL_get_early_data_status(const struct ssl_st* s  );
int SSL_get_error(const struct ssl_st* s  , int ret_code);
const char* SSL_get_version(const struct ssl_st* s  );
int SSL_get_handshake_rtt(const struct ssl_st* s  , unsigned long  int* rtt  );
int SSL_CTX_set_ssl_version(struct ssl_ctx_st* ctx  , const struct ssl_method_st* meth  );
const struct ssl_method_st* TLS_method();
const struct ssl_method_st* TLS_server_method();
const struct ssl_method_st* TLS_client_method();
const struct ssl_method_st* TLSv1_method();
const struct ssl_method_st* TLSv1_server_method();
const struct ssl_method_st* TLSv1_client_method();
const struct ssl_method_st* TLSv1_1_method();
const struct ssl_method_st* TLSv1_1_server_method();
const struct ssl_method_st* TLSv1_1_client_method();
const struct ssl_method_st* TLSv1_2_method();
const struct ssl_method_st* TLSv1_2_server_method();
const struct ssl_method_st* TLSv1_2_client_method();
const struct ssl_method_st* DTLSv1_method();
const struct ssl_method_st* DTLSv1_server_method();
const struct ssl_method_st* DTLSv1_client_method();
const struct ssl_method_st* DTLSv1_2_method();
const struct ssl_method_st* DTLSv1_2_server_method();
const struct ssl_method_st* DTLSv1_2_client_method();
const struct ssl_method_st* DTLS_method();
const struct ssl_method_st* DTLS_server_method();
const struct ssl_method_st* DTLS_client_method();
unsigned long DTLS_get_data_mtu(const struct ssl_st* s  );
struct stack_st_SSL_CIPHER* SSL_get_ciphers(const struct ssl_st* s  );
struct stack_st_SSL_CIPHER* SSL_CTX_get_ciphers(const struct ssl_ctx_st* ctx  );
struct stack_st_SSL_CIPHER* SSL_get_client_ciphers(const struct ssl_st* s  );
struct stack_st_SSL_CIPHER* SSL_get1_supported_ciphers(struct ssl_st* s  );
int SSL_do_handshake(struct ssl_st* s  );
int SSL_key_update(struct ssl_st* s  , int updatetype);
int SSL_get_key_update_type(const struct ssl_st* s  );
int SSL_renegotiate(struct ssl_st* s  );
int SSL_renegotiate_abbreviated(struct ssl_st* s  );
int SSL_renegotiate_pending(const struct ssl_st* s  );
int SSL_new_session_ticket(struct ssl_st* s  );
int SSL_shutdown(struct ssl_st* s  );
int SSL_verify_client_post_handshake(struct ssl_st* s  );
void SSL_CTX_set_post_handshake_auth(struct ssl_ctx_st* ctx  , int val);
void SSL_set_post_handshake_auth(struct ssl_st* s  , int val);
const struct ssl_method_st* SSL_CTX_get_ssl_method(const struct ssl_ctx_st* ctx  );
const struct ssl_method_st* SSL_get_ssl_method(const struct ssl_st* s  );
int SSL_set_ssl_method(struct ssl_st* s  , const struct ssl_method_st* method  );
const char* SSL_alert_type_string_long(int value);
const char* SSL_alert_type_string(int value);
const char* SSL_alert_desc_string_long(int value);
const char* SSL_alert_desc_string(int value);
void SSL_set0_CA_list(struct ssl_st* s  , struct stack_st_X509_NAME* name_list  );
void SSL_CTX_set0_CA_list(struct ssl_ctx_st* ctx  , struct stack_st_X509_NAME* name_list  );
const struct stack_st_X509_NAME* SSL_get0_CA_list(const struct ssl_st* s  );
const struct stack_st_X509_NAME* SSL_CTX_get0_CA_list(const struct ssl_ctx_st* ctx  );
int SSL_add1_to_CA_list(struct ssl_st* ssl  , const struct x509_st* x  );
int SSL_CTX_add1_to_CA_list(struct ssl_ctx_st* ctx  , const struct x509_st* x  );
const struct stack_st_X509_NAME* SSL_get0_peer_CA_list(const struct ssl_st* s  );
void SSL_set_client_CA_list(struct ssl_st* s  , struct stack_st_X509_NAME* name_list  );
void SSL_CTX_set_client_CA_list(struct ssl_ctx_st* ctx  , struct stack_st_X509_NAME* name_list  );
struct stack_st_X509_NAME* SSL_get_client_CA_list(const struct ssl_st* s  );
struct stack_st_X509_NAME* SSL_CTX_get_client_CA_list(const struct ssl_ctx_st* s  );
int SSL_add_client_CA(struct ssl_st* ssl  , struct x509_st* x  );
int SSL_CTX_add_client_CA(struct ssl_ctx_st* ctx  , struct x509_st* x  );
void SSL_set_connect_state(struct ssl_st* s  );
void SSL_set_accept_state(struct ssl_st* s  );
long SSL_get_default_timeout(const struct ssl_st* s  );
char* SSL_CIPHER_description(const struct ssl_cipher_st*   , char* buf, int size);
struct stack_st_X509_NAME* SSL_dup_CA_list(const struct stack_st_X509_NAME* sk  );
struct ssl_st* SSL_dup(struct ssl_st* ssl  );
struct x509_st* SSL_get_certificate(const struct ssl_st* ssl  );
struct evp_pkey_st* SSL_get_privatekey(const struct ssl_st* ssl  );
struct x509_st* SSL_CTX_get0_certificate(const struct ssl_ctx_st* ctx  );
struct evp_pkey_st* SSL_CTX_get0_privatekey(const struct ssl_ctx_st* ctx  );
void SSL_CTX_set_quiet_shutdown(struct ssl_ctx_st* ctx  , int mode);
int SSL_CTX_get_quiet_shutdown(const struct ssl_ctx_st* ctx  );
void SSL_set_quiet_shutdown(struct ssl_st* ssl  , int mode);
int SSL_get_quiet_shutdown(const struct ssl_st* ssl  );
void SSL_set_shutdown(struct ssl_st* ssl  , int mode);
int SSL_get_shutdown(const struct ssl_st* ssl  );
int SSL_version(const struct ssl_st* ssl  );
int SSL_client_version(const struct ssl_st* s  );
int SSL_CTX_set_default_verify_paths(struct ssl_ctx_st* ctx  );
int SSL_CTX_set_default_verify_dir(struct ssl_ctx_st* ctx  );
int SSL_CTX_set_default_verify_file(struct ssl_ctx_st* ctx  );
int SSL_CTX_set_default_verify_store(struct ssl_ctx_st* ctx  );
int SSL_CTX_load_verify_file(struct ssl_ctx_st* ctx  , const char* CAfile);
int SSL_CTX_load_verify_dir(struct ssl_ctx_st* ctx  , const char* CApath);
int SSL_CTX_load_verify_store(struct ssl_ctx_st* ctx  , const char* CAstore);
int SSL_CTX_load_verify_locations(struct ssl_ctx_st* ctx  , const char* CAfile, const char* CApath);
struct ssl_session_st* SSL_get_session(const struct ssl_st* ssl  );
struct ssl_session_st* SSL_get1_session(struct ssl_st* ssl  );
struct ssl_ctx_st* SSL_get_SSL_CTX(const struct ssl_st* ssl  );
struct ssl_ctx_st* SSL_set_SSL_CTX(struct ssl_st* ssl  , struct ssl_ctx_st* ctx  );
void SSL_set_info_callback(struct ssl_st* ssl  , void (*cb)(const struct ssl_st*,int,int));
void (*SSL_get_info_callback(const struct ssl_st* _function_pointer_result_var_name_a64  ))(const struct ssl_st*,int,int);
enum anonymous_typeY45 SSL_get_state(const struct ssl_st* ssl  );
void SSL_set_verify_result(struct ssl_st* ssl  , long v);
long SSL_get_verify_result(const struct ssl_st* ssl  );
struct stack_st_X509* SSL_get0_verified_chain(const struct ssl_st* s  );
unsigned long SSL_get_client_random(const struct ssl_st* ssl  , unsigned char* out, unsigned long outlen  );
unsigned long SSL_get_server_random(const struct ssl_st* ssl  , unsigned char* out, unsigned long outlen  );
unsigned long SSL_SESSION_get_master_key(const struct ssl_session_st* sess  , unsigned char* out, unsigned long outlen  );
int SSL_SESSION_set1_master_key(struct ssl_session_st* sess  , const unsigned char* in, unsigned long len  );
unsigned char SSL_SESSION_get_max_fragment_length(const struct ssl_session_st* sess  );
int SSL_set_ex_data(struct ssl_st* ssl  , int idx, void* data);
void* SSL_get_ex_data(const struct ssl_st* ssl  , int idx);
int SSL_SESSION_set_ex_data(struct ssl_session_st* ss  , int idx, void* data);
void* SSL_SESSION_get_ex_data(const struct ssl_session_st* ss  , int idx);
int SSL_CTX_set_ex_data(struct ssl_ctx_st* ssl  , int idx, void* data);
void* SSL_CTX_get_ex_data(const struct ssl_ctx_st* ssl  , int idx);
int SSL_get_ex_data_X509_STORE_CTX_idx();
void SSL_CTX_set_default_read_buffer_len(struct ssl_ctx_st* ctx  , unsigned long len  );
void SSL_set_default_read_buffer_len(struct ssl_st* s  , unsigned long len  );
void SSL_CTX_set_tmp_dh_callback(struct ssl_ctx_st* ctx  , struct dh_st* (*dh)(struct ssl_st*,int,int));
void SSL_set_tmp_dh_callback(struct ssl_st* ssl  , struct dh_st* (*dh)(struct ssl_st*,int,int));
const struct comp_method_st* SSL_get_current_compression(const struct ssl_st* s  );
const struct comp_method_st* SSL_get_current_expansion(const struct ssl_st* s  );
const char* SSL_COMP_get_name(const struct comp_method_st* comp  );
const char* SSL_COMP_get0_name(const struct ssl_comp_st* comp  );
int SSL_COMP_get_id(const struct ssl_comp_st* comp  );
struct stack_st_SSL_COMP* SSL_COMP_get_compression_methods();
struct stack_st_SSL_COMP* SSL_COMP_set0_compression_methods(struct stack_st_SSL_COMP* meths  );
int SSL_COMP_add_compression_method(int id, struct comp_method_st* cm  );
const struct ssl_cipher_st* SSL_CIPHER_find(struct ssl_st* ssl  , const unsigned char* ptr);
int SSL_CIPHER_get_cipher_nid(const struct ssl_cipher_st* c  );
int SSL_CIPHER_get_digest_nid(const struct ssl_cipher_st* c  );
int SSL_bytes_to_cipher_list(struct ssl_st* s  , const unsigned char* bytes, unsigned long len  , int isv2format, struct stack_st_SSL_CIPHER** sk  , struct stack_st_SSL_CIPHER** scsvs  );
int SSL_set_session_ticket_ext(struct ssl_st* s  , void* ext_data, int ext_len);
int SSL_set_session_ticket_ext_cb(struct ssl_st* s  , int (*cb)(struct ssl_st*,const unsigned char*,int,void*)  , void* arg);
int SSL_set_session_secret_cb(struct ssl_st* s  , int (*session_secret_cb)(struct ssl_st*,void*,int*,struct stack_st_SSL_CIPHER*,const struct ssl_cipher_st**,void*)  , void* arg);
void SSL_CTX_set_not_resumable_session_callback(struct ssl_ctx_st* ctx  , int (*cb)(struct ssl_st*,int));
void SSL_set_not_resumable_session_callback(struct ssl_st* ssl  , int (*cb)(struct ssl_st*,int));
void SSL_CTX_set_record_padding_callback(struct ssl_ctx_st* ctx  , unsigned long (*cb)(struct ssl_st*,int,unsigned long,void*));
void SSL_CTX_set_record_padding_callback_arg(struct ssl_ctx_st* ctx  , void* arg);
void* SSL_CTX_get_record_padding_callback_arg(const struct ssl_ctx_st* ctx  );
int SSL_CTX_set_block_padding(struct ssl_ctx_st* ctx  , unsigned long block_size  );
int SSL_CTX_set_block_padding_ex(struct ssl_ctx_st* ctx  , unsigned long app_block_size  , unsigned long hs_block_size  );
int SSL_set_record_padding_callback(struct ssl_st* ssl  , unsigned long (*cb)(struct ssl_st*,int,unsigned long,void*));
void SSL_set_record_padding_callback_arg(struct ssl_st* ssl  , void* arg);
void* SSL_get_record_padding_callback_arg(const struct ssl_st* ssl  );
int SSL_set_block_padding(struct ssl_st* ssl  , unsigned long block_size  );
int SSL_set_block_padding_ex(struct ssl_st* ssl  , unsigned long app_block_size  , unsigned long hs_block_size  );
int SSL_set_num_tickets(struct ssl_st* s  , unsigned long num_tickets  );
unsigned long SSL_get_num_tickets(const struct ssl_st* s  );
int SSL_CTX_set_num_tickets(struct ssl_ctx_st* ctx  , unsigned long num_tickets  );
unsigned long SSL_CTX_get_num_tickets(const struct ssl_ctx_st* ctx  );
int SSL_handle_events(struct ssl_st* s  );
int SSL_get_event_timeout(struct ssl_st* s  , struct timeval* tv  , int* is_infinite);
int SSL_get_rpoll_descriptor(struct ssl_st* s  , struct bio_poll_descriptor_st* desc  );
int SSL_get_wpoll_descriptor(struct ssl_st* s  , struct bio_poll_descriptor_st* desc  );
int SSL_net_read_desired(struct ssl_st* s  );
int SSL_net_write_desired(struct ssl_st* s  );
int SSL_set_blocking_mode(struct ssl_st* s  , int blocking);
int SSL_get_blocking_mode(struct ssl_st* s  );
int SSL_set1_initial_peer_addr(struct ssl_st* s  , const union bio_addr_st* peer_addr  );
struct ssl_st* SSL_get0_connection(struct ssl_st* s  );
int SSL_is_connection(struct ssl_st* s  );
int SSL_is_listener(struct ssl_st* ssl  );
struct ssl_st* SSL_get0_listener(struct ssl_st* s  );
struct ssl_st* SSL_new_listener(struct ssl_ctx_st* ctx  , unsigned long  int flags  );
struct ssl_st* SSL_new_listener_from(struct ssl_st* ssl  , unsigned long  int flags  );
struct ssl_st* SSL_new_from_listener(struct ssl_st* ssl  , unsigned long  int flags  );
struct ssl_st* SSL_accept_connection(struct ssl_st* ssl  , unsigned long  int flags  );
unsigned long SSL_get_accept_connection_queue_len(struct ssl_st* ssl  );
int SSL_listen(struct ssl_st* ssl  );
int SSL_is_domain(struct ssl_st* s  );
struct ssl_st* SSL_get0_domain(struct ssl_st* s  );
struct ssl_st* SSL_new_domain(struct ssl_ctx_st* ctx  , unsigned long  int flags  );
int SSL_CTX_set_domain_flags(struct ssl_ctx_st* ctx  , unsigned long  int domain_flags  );
int SSL_CTX_get_domain_flags(const struct ssl_ctx_st* ctx  , unsigned long  int* domain_flags  );
int SSL_get_domain_flags(const struct ssl_st* ssl  , unsigned long  int* domain_flags  );
int SSL_get_stream_type(struct ssl_st* s  );
unsigned long  int SSL_get_stream_id(struct ssl_st* s  );
int SSL_is_stream_local(struct ssl_st* s  );
int SSL_set_default_stream_mode(struct ssl_st* s  , unsigned int mode  );
struct ssl_st* SSL_new_stream(struct ssl_st* s  , unsigned long  int flags  );
int SSL_set_incoming_stream_policy(struct ssl_st* s  , int policy, unsigned long  int aec  );
struct ssl_st* SSL_accept_stream(struct ssl_st* s  , unsigned long  int flags  );
unsigned long SSL_get_accept_stream_queue_len(struct ssl_st* s  );
int SSL_inject_net_dgram(struct ssl_st* s  , const unsigned char* buf, unsigned long buf_len  , const union bio_addr_st* peer  , const union bio_addr_st* local  );
int SSL_shutdown_ex(struct ssl_st* ssl  , unsigned long  int flags  , const struct ssl_shutdown_ex_args_st* args  , unsigned long args_len  );
int SSL_stream_conclude(struct ssl_st* ssl  , unsigned long  int flags  );
int SSL_stream_reset(struct ssl_st* ssl  , const struct ssl_stream_reset_args_st* args  , unsigned long args_len  );
int SSL_get_stream_read_state(struct ssl_st* ssl  );
int SSL_get_stream_write_state(struct ssl_st* ssl  );
int SSL_get_stream_read_error_code(struct ssl_st* ssl  , unsigned long  int* app_error_code  );
int SSL_get_stream_write_error_code(struct ssl_st* ssl  , unsigned long  int* app_error_code  );
int SSL_get_conn_close_info(struct ssl_st* ssl  , struct ssl_conn_close_info_st* info  , unsigned long info_len  );
int SSL_get_value_uint(struct ssl_st* s  , unsigned int class_  , unsigned int id  , unsigned long  int* v  );
int SSL_set_value_uint(struct ssl_st* s  , unsigned int class_  , unsigned int id  , unsigned long  int v  );
int SSL_poll(struct ssl_poll_item_st* items  , unsigned long num_items  , unsigned long stride  , const struct timeval* timeout  , unsigned long  int flags  , unsigned long* result_count  );
static struct bio_poll_descriptor_st SSL_as_poll_descriptor(struct ssl_st* s  );
int SSL_session_reused(const struct ssl_st* s  );
int SSL_is_server(const struct ssl_st* s  );
struct ssl_conf_ctx_st* SSL_CONF_CTX_new();
int SSL_CONF_CTX_finish(struct ssl_conf_ctx_st* cctx  );
void SSL_CONF_CTX_free(struct ssl_conf_ctx_st* cctx  );
unsigned int SSL_CONF_CTX_set_flags(struct ssl_conf_ctx_st* cctx  , unsigned int flags);
unsigned int SSL_CONF_CTX_clear_flags(struct ssl_conf_ctx_st* cctx  , unsigned int flags);
int SSL_CONF_CTX_set1_prefix(struct ssl_conf_ctx_st* cctx  , const char* pre);
void SSL_CONF_CTX_set_ssl(struct ssl_conf_ctx_st* cctx  , struct ssl_st* ssl  );
void SSL_CONF_CTX_set_ssl_ctx(struct ssl_conf_ctx_st* cctx  , struct ssl_ctx_st* ctx  );
int SSL_CONF_cmd(struct ssl_conf_ctx_st* cctx  , const char* cmd, const char* value);
int SSL_CONF_cmd_argv(struct ssl_conf_ctx_st* cctx  , int* pargc, char*** pargv);
int SSL_CONF_cmd_value_type(struct ssl_conf_ctx_st* cctx  , const char* cmd);
void SSL_add_ssl_module();
int SSL_config(struct ssl_st* s  , const char* name);
int SSL_CTX_config(struct ssl_ctx_st* ctx  , const char* name);
void SSL_trace(int write_p, int version, int content_type, const void* buf, unsigned long len  , struct ssl_st* ssl  , void* arg);
int DTLSv1_listen(struct ssl_st* s  , union bio_addr_st* client  );
int SSL_set_ct_validation_callback(struct ssl_st* s  , int (*callback)(const struct ct_policy_eval_ctx_st*,const struct stack_st_SCT*,void*)  , void* arg);
int SSL_CTX_set_ct_validation_callback(struct ssl_ctx_st* ctx  , int (*callback)(const struct ct_policy_eval_ctx_st*,const struct stack_st_SCT*,void*)  , void* arg);
int SSL_enable_ct(struct ssl_st* s  , int validation_mode);
int SSL_CTX_enable_ct(struct ssl_ctx_st* ctx  , int validation_mode);
int SSL_ct_is_enabled(const struct ssl_st* s  );
int SSL_CTX_ct_is_enabled(const struct ssl_ctx_st* ctx  );
const struct stack_st_SCT* SSL_get0_peer_scts(struct ssl_st* s  );
int SSL_CTX_set_default_ctlog_list_file(struct ssl_ctx_st* ctx  );
int SSL_CTX_set_ctlog_list_file(struct ssl_ctx_st* ctx  , const char* path);
void SSL_CTX_set0_ctlog_store(struct ssl_ctx_st* ctx  , struct ctlog_store_st* logs  );
const struct ctlog_store_st* SSL_CTX_get0_ctlog_store(const struct ssl_ctx_st* ctx  );
void SSL_set_security_level(struct ssl_st* s  , int level);
int SSL_get_security_level(const struct ssl_st* s  );
void SSL_set_security_callback(struct ssl_st* s  , int (*cb)(const struct ssl_st*,const struct ssl_ctx_st*,int,int,int,void*,void*));
int (*SSL_get_security_callback(const struct ssl_st* _function_pointer_result_var_name_a65  ))(const struct ssl_st*,const struct ssl_ctx_st*,int,int,int,void*,void*);
void SSL_set0_security_ex_data(struct ssl_st* s  , void* ex);
void* SSL_get0_security_ex_data(const struct ssl_st* s  );
void SSL_CTX_set_security_level(struct ssl_ctx_st* ctx  , int level);
int SSL_CTX_get_security_level(const struct ssl_ctx_st* ctx  );
void SSL_CTX_set_security_callback(struct ssl_ctx_st* ctx  , int (*cb)(const struct ssl_st*,const struct ssl_ctx_st*,int,int,int,void*,void*));
int (*SSL_CTX_get_security_callback(const struct ssl_ctx_st* _function_pointer_result_var_name_a66  ))(const struct ssl_st*,const struct ssl_ctx_st*,int,int,int,void*,void*);
void SSL_CTX_set0_security_ex_data(struct ssl_ctx_st* ctx  , void* ex);
void* SSL_CTX_get0_security_ex_data(const struct ssl_ctx_st* ctx  );
int OPENSSL_init_ssl(unsigned long  int opts  , const struct ossl_init_settings_st* settings  );
int SSL_free_buffers(struct ssl_st* ssl  );
int SSL_alloc_buffers(struct ssl_st* ssl  );
int SSL_CTX_set_session_ticket_cb(struct ssl_ctx_st* ctx  , int (*gen_cb)(struct ssl_st*,void*)  , int (*dec_cb)(struct ssl_st*,struct ssl_session_st*,const unsigned char*,unsigned long,int,void*)  , void* arg);
int SSL_SESSION_set1_ticket_appdata(struct ssl_session_st* ss  , const void* data, unsigned long len  );
int SSL_SESSION_get0_ticket_appdata(struct ssl_session_st* ss  , void** data, unsigned long* len  );
void DTLS_set_timer_cb(struct ssl_st* s  , unsigned int (*cb)(struct ssl_st*,unsigned int)  );
void SSL_CTX_set_allow_early_data_cb(struct ssl_ctx_st* ctx  , int (*cb)(struct ssl_st*,void*)  , void* arg);
void SSL_set_allow_early_data_cb(struct ssl_st* s  , int (*cb)(struct ssl_st*,void*)  , void* arg);
const char* OSSL_default_cipher_list();
const char* OSSL_default_ciphersuites();
int SSL_CTX_compress_certs(struct ssl_ctx_st* ctx  , int alg);
int SSL_compress_certs(struct ssl_st* ssl  , int alg);
int SSL_CTX_set1_cert_comp_preference(struct ssl_ctx_st* ctx  , int* algs, unsigned long len  );
int SSL_set1_cert_comp_preference(struct ssl_st* ssl  , int* algs, unsigned long len  );
int SSL_CTX_set1_compressed_cert(struct ssl_ctx_st* ctx  , int algorithm, unsigned char* comp_data, unsigned long comp_length  , unsigned long orig_length  );
int SSL_set1_compressed_cert(struct ssl_st* ssl  , int algorithm, unsigned char* comp_data, unsigned long comp_length  , unsigned long orig_length  );
unsigned long SSL_CTX_get1_compressed_cert(struct ssl_ctx_st* ctx  , int alg, unsigned char** data, unsigned long* orig_len  );
unsigned long SSL_get1_compressed_cert(struct ssl_st* ssl  , int alg, unsigned char** data, unsigned long* orig_len  );
int SSL_add_expected_rpk(struct ssl_st* s  , struct evp_pkey_st* rpk  );
struct evp_pkey_st* SSL_get0_peer_rpk(const struct ssl_st* s  );
struct evp_pkey_st* SSL_SESSION_get0_peer_rpk(struct ssl_session_st* s  );
int SSL_get_negotiated_client_cert_type(const struct ssl_st* s  );
int SSL_get_negotiated_server_cert_type(const struct ssl_st* s  );
int SSL_set1_client_cert_type(struct ssl_st* s  , const unsigned char* val, unsigned long len  );
int SSL_set1_server_cert_type(struct ssl_st* s  , const unsigned char* val, unsigned long len  );
int SSL_CTX_set1_client_cert_type(struct ssl_ctx_st* ctx  , const unsigned char* val, unsigned long len  );
int SSL_CTX_set1_server_cert_type(struct ssl_ctx_st* ctx  , const unsigned char* val, unsigned long len  );
int SSL_get0_client_cert_type(const struct ssl_st* s  , unsigned char** t, unsigned long* len  );
int SSL_get0_server_cert_type(const struct ssl_st* s  , unsigned char** t, unsigned long* len  );
int SSL_CTX_get0_client_cert_type(const struct ssl_ctx_st* ctx  , unsigned char** t, unsigned long* len  );
int SSL_CTX_get0_server_cert_type(const struct ssl_ctx_st* s  , unsigned char** t, unsigned long* len  );
int SSL_set_quic_tls_cbs(struct ssl_st* s  , const struct ossl_dispatch_st* qtdis  , void* arg);
int SSL_set_quic_tls_transport_params(struct ssl_st* s  , const unsigned char* params, unsigned long params_len  );
int SSL_set_quic_tls_early_data_enabled(struct ssl_st* s  , int enabled);
static int ERR_GET_LIB(unsigned long  int errcode);
static int ERR_GET_RFLAGS(unsigned long  int errcode);
static int ERR_GET_REASON(unsigned long  int errcode);
static int ERR_FATAL_ERROR(unsigned long  int errcode);
static int ERR_COMMON_ERROR(unsigned long  int errcode);
static unsigned long  int lh_ERR_STRING_DATA_hash_thunk(const void* data, unsigned long  int (*hfn)(const void*)  );
static int lh_ERR_STRING_DATA_comp_thunk(const void* da, const void* db, int (*cfn)(const void*,const void*)  );
static void lh_ERR_STRING_DATA_doall_thunk(void* node, void (*doall)(void*)  );
static void lh_ERR_STRING_DATA_doall_arg_thunk(void* node, void* arg, void (*doall)(void*,void*)  );
static struct ERR_string_data_st* ossl_check_ERR_STRING_DATA_lh_plain_type(struct ERR_string_data_st* ptr  );
static const struct ERR_string_data_st* ossl_check_const_ERR_STRING_DATA_lh_plain_type(const struct ERR_string_data_st* ptr  );
static const struct lhash_st* ossl_check_const_ERR_STRING_DATA_lh_type(const struct lhash_st_ERR_STRING_DATA* lh  );
static struct lhash_st* ossl_check_ERR_STRING_DATA_lh_type(struct lhash_st_ERR_STRING_DATA* lh  );
static int (*ossl_check_ERR_STRING_DATA_lh_compfunc_type(int (*cmp)(const struct ERR_string_data_st*,const struct ERR_string_data_st*)  ))(const void*,const void*) ;
static unsigned long  int (*ossl_check_ERR_STRING_DATA_lh_hashfunc_type(unsigned long  int (*hfn)(const struct ERR_string_data_st*)  ))(const void*) ;
static void (*ossl_check_ERR_STRING_DATA_lh_doallfunc_type(void (*dfn)(struct ERR_string_data_st*)  ))(void*) ;
void ERR_new();
void ERR_set_debug(const char* file, int line, const char* func);
void ERR_set_error(int lib, int reason, const char* fmt, ...);
void ERR_vset_error(int lib, int reason, const char* fmt, __builtin_va_list args  );
void ERR_set_error_data(char* data, int flags);
unsigned long  int ERR_get_error();
unsigned long  int ERR_get_error_all(const char** file, int* line, const char** func, const char** data, int* flags);
unsigned long  int ERR_get_error_line(const char** file, int* line);
unsigned long  int ERR_get_error_line_data(const char** file, int* line, const char** data, int* flags);
unsigned long  int ERR_peek_error();
unsigned long  int ERR_peek_error_line(const char** file, int* line);
unsigned long  int ERR_peek_error_func(const char** func);
unsigned long  int ERR_peek_error_data(const char** data, int* flags);
unsigned long  int ERR_peek_error_all(const char** file, int* line, const char** func, const char** data, int* flags);
unsigned long  int ERR_peek_error_line_data(const char** file, int* line, const char** data, int* flags);
unsigned long  int ERR_peek_last_error();
unsigned long  int ERR_peek_last_error_line(const char** file, int* line);
unsigned long  int ERR_peek_last_error_func(const char** func);
unsigned long  int ERR_peek_last_error_data(const char** data, int* flags);
unsigned long  int ERR_peek_last_error_all(const char** file, int* line, const char** func, const char** data, int* flags);
unsigned long  int ERR_peek_last_error_line_data(const char** file, int* line, const char** data, int* flags);
void ERR_clear_error();
char* ERR_error_string(unsigned long  int e, char* buf);
void ERR_error_string_n(unsigned long  int e, char* buf, unsigned long len  );
const char* ERR_lib_error_string(unsigned long  int e);
const char* ERR_func_error_string(unsigned long  int e);
const char* ERR_reason_error_string(unsigned long  int e);
void ERR_print_errors_cb(int (*cb)(const char*,unsigned long,void*), void* u);
void ERR_print_errors(struct bio_st* bp  );
void ERR_add_error_data(int num, ...);
void ERR_add_error_vdata(int num, __builtin_va_list args  );
void ERR_add_error_txt(const char* sepr, const char* txt);
void ERR_add_error_mem_bio(const char* sep, struct bio_st* bio  );
int ERR_load_strings(int lib, struct ERR_string_data_st* str  );
int ERR_load_strings_const(const struct ERR_string_data_st* str  );
int ERR_unload_strings(int lib, struct ERR_string_data_st* str  );
void ERR_remove_thread_state(void* );
void ERR_remove_state(unsigned long  int pid);
struct err_state_st* ERR_get_state();
int ERR_get_next_error_library();
int ERR_set_mark();
int ERR_pop_to_mark();
int ERR_clear_last_mark();
int ERR_count_to_mark();
int ERR_pop();
struct err_state_st* OSSL_ERR_STATE_new();
void OSSL_ERR_STATE_save(struct err_state_st* es  );
void OSSL_ERR_STATE_save_to_mark(struct err_state_st* es  );
void OSSL_ERR_STATE_restore(const struct err_state_st* es  );
void OSSL_ERR_STATE_free(struct err_state_st* es  );
struct sType* sType_initialize(struct sType* self, char* class_name  , int array_num, _Bool auto_increment, _Bool primary_key, _Bool not_null);
char* sType_to_string(struct sType* self);
static void sType_finalize(struct sType* self);
struct Table* Table_initialize(struct Table* self, char* name  , struct list$1tuple2$2char$phsType$ph$ph* types);
char* Table_to_string(struct Table* self);
static struct list$1map$2char$phchar$ph$ph* list$1map$2char$phchar$ph$ph_initialize(struct list$1map$2char$phchar$ph$ph* self);
static void list$1map$2char$phchar$ph$ph$p_finalize(struct list$1map$2char$phchar$ph$ph* self);
static void list_item$1map$2char$phchar$ph$ph$p_finalize(struct list_item$1map$2char$phchar$ph$ph* self);
static void map$2char$phchar$ph$p_finalize(struct map$2char$phchar$ph* self);
static void list$1char$ph$p_finalize(struct list$1char$ph* self);
static void list_item$1char$ph$p_finalize(struct list_item$1char$ph* self);
static void list$1map$2char$phchar$ph$ph_finalize(struct list$1map$2char$phchar$ph$ph* self);
static void list$1tuple2$2char$phsType$ph$ph_finalize(struct list$1tuple2$2char$phsType$ph$ph* self);
static void list_item$1tuple2$2char$phsType$ph$ph$p_finalize(struct list_item$1tuple2$2char$phsType$ph$ph* self);
static void tuple2$2char$phsType$ph$p_finalize(struct tuple2$2char$phsType$ph* self);
static void Table_finalize(struct Table* self);
static void list$1tuple2$2char$phsType$ph$ph$p_finalize(struct list$1tuple2$2char$phsType$ph$ph* self);
static struct tuple2$2char$phsType$ph* list$1tuple2$2char$phsType$ph$ph_begin(struct list$1tuple2$2char$phsType$ph$ph* self);
static _Bool list$1tuple2$2char$phsType$ph$ph_end(struct list$1tuple2$2char$phsType$ph$ph* self);
static struct tuple2$2char$phsType$ph* list$1tuple2$2char$phsType$ph$ph_next(struct list$1tuple2$2char$phsType$ph$ph* self);
struct Database* Database_initialize(struct Database* self, char* name  );
static struct map$2char$phTable$ph* map$2char$phTable$ph_initialize(struct map$2char$phTable$ph* self);
static struct list$1char$ph* list$1char$ph_initialize(struct list$1char$ph* self);
static void list$1char$ph_finalize(struct list$1char$ph* self);
static void map$2char$phTable$ph$p_finalize(struct map$2char$phTable$ph* self);
static void map$2char$phTable$ph_finalize(struct map$2char$phTable$ph* self);
static void Database_finalize(struct Database* self);
void skip_spaces(struct sInfo* info  );
char* parse_word(struct sInfo* info  );
_Bool expected_next_charactor(char c, struct sInfo* info  );
struct tuple3$3char$phsType$ph_Bool$* parse_type(struct sInfo* info  );
static struct tuple3$3char$phsType$phint$* tuple3$3char$phsType$phint$_initialize(struct tuple3$3char$phsType$phint$* self, char* v1  , struct sType* v2  , int v3);
static void tuple3$3char$phsType$phint$$p_finalize(struct tuple3$3char$phsType$phint$* self);
static void tuple3$3char$phsType$ph_Bool$$p_finalize(struct tuple3$3char$phsType$ph_Bool$* self);
_Bool eval_create_table(struct sInfo* info  );
static struct list$1tuple2$2char$phsType$ph$ph* list$1tuple2$2char$phsType$ph$ph_initialize(struct list$1tuple2$2char$phsType$ph$ph* self);
static struct list$1tuple2$2char$phsType$ph$ph* list$1tuple2$2char$phsType$ph$ph_add(struct list$1tuple2$2char$phsType$ph$ph* self, struct tuple2$2char$phsType$ph* item);
static struct tuple2$2char$phsType$ph* tuple2$2char$phsType$ph_initialize(struct tuple2$2char$phsType$ph* self, char* v1  , struct sType* v2  );
static struct Database* map$2char$phDatabase$ph$p_operator_load_element(struct map$2char$phDatabase$ph* self, char* key  );
static struct Database* map$2char$phDatabase$ph_operator_load_element(struct map$2char$phDatabase$ph* self, char* key  );
static struct Table* map$2char$phTable$ph$p_operator_load_element(struct map$2char$phTable$ph* self, char* key  );
static struct Table* map$2char$phTable$ph_operator_load_element(struct map$2char$phTable$ph* self, char* key  );
static struct map$2char$phTable$ph* map$2char$phTable$ph_insert(struct map$2char$phTable$ph* self, char* key  , struct Table* item  );
static void map$2char$phTable$ph_rehash(struct map$2char$phTable$ph* self);
static char* map$2char$phTable$ph_begin(struct map$2char$phTable$ph* self);
static _Bool map$2char$phTable$ph_end(struct map$2char$phTable$ph* self);
static char* map$2char$phTable$ph_next(struct map$2char$phTable$ph* self);
static struct Table* map$2char$phTable$ph_at(struct map$2char$phTable$ph* self, char* key  , struct Table* default_value  );
static struct list$1char$ph* list$1char$ph_remove(struct list$1char$ph* self, char* item  );
static struct list$1char$ph* list$1char$ph_delete(struct list$1char$ph* self, int head, int tail);
static struct list$1char$ph* list$1char$ph_reset(struct list$1char$ph* self);
static char* list$1char$ph_begin(struct list$1char$ph* self);
static _Bool list$1char$ph_end(struct list$1char$ph* self);
static char* list$1char$ph_next(struct list$1char$ph* self);
static struct list$1char$ph* list$1char$ph_push_back(struct list$1char$ph* self, char* item  );
char* parse_value(struct sInfo* info  );
_Bool eval_insert_into(struct sInfo* info  );
static struct list$1char$ph* list$1char$ph_add(struct list$1char$ph* self, char* item  );
static int list$1char$ph_length(struct list$1char$ph* self);
static struct map$2char$phchar$ph* map$2char$phchar$ph_initialize(struct map$2char$phchar$ph* self);
static char* list$1char$ph$p_operator_load_element(struct list$1char$ph* self, int position);
static char* list$1char$ph_operator_load_element(struct list$1char$ph* self, int position);
static void map$2char$phchar$ph_operator_store_element(struct map$2char$phchar$ph* self, char* key  , char* item  );
static struct map$2char$phchar$ph* map$2char$phchar$ph_insert(struct map$2char$phchar$ph* self, char* key  , char* item  );
static void map$2char$phchar$ph_rehash(struct map$2char$phchar$ph* self);
static char* map$2char$phchar$ph_begin(struct map$2char$phchar$ph* self);
static _Bool map$2char$phchar$ph_end(struct map$2char$phchar$ph* self);
static char* map$2char$phchar$ph_next(struct map$2char$phchar$ph* self);
static char* map$2char$phchar$ph_at(struct map$2char$phchar$ph* self, char* key  , char* default_value  );
static int list$1map$2char$phchar$ph$ph_length(struct list$1map$2char$phchar$ph$ph* self);
static struct map$2char$phchar$ph* list$1map$2char$phchar$ph$ph$p_operator_load_element(struct list$1map$2char$phchar$ph$ph* self, int position);
static struct map$2char$phchar$ph* list$1map$2char$phchar$ph$ph_operator_load_element(struct list$1map$2char$phchar$ph$ph* self, int position);
static char* map$2char$phchar$ph$p_operator_load_element(struct map$2char$phchar$ph* self, char* key  );
static char* map$2char$phchar$ph_operator_load_element(struct map$2char$phchar$ph* self, char* key  );
static struct list$1map$2char$phchar$ph$ph* list$1map$2char$phchar$ph$ph_add(struct list$1map$2char$phchar$ph$ph* self, struct map$2char$phchar$ph* item);
static void map$2char$phchar$ph_finalize(struct map$2char$phchar$ph* self);
struct WhereNode* WhereNode_initialize(struct WhereNode* self  , struct WhereNode* left  , struct WhereNode* right  , int op, char* data  );
static struct tuple1$1WhereNode$ph* tuple1$1WhereNode$ph_initialize(struct tuple1$1WhereNode$ph* self, struct WhereNode* v1  );
static void WhereNode_finalize(struct WhereNode* self  );
static void tuple1$1WhereNode$ph$p_finalize(struct tuple1$1WhereNode$ph* self);
struct WhereNode* parse_where(struct sInfo* info  );
_Bool where_select(struct map$2char$phchar$ph* row, struct WhereNode* where_node  );
_Bool like(char* str, char* pattern);
_Bool eval_select_from(char* deliminater, struct sInfo* info  );
static struct map$2char$ph_Bool$* map$2char$ph_Bool$_initialize(struct map$2char$ph_Bool$* self);
static void map$2char$ph_Bool$$p_finalize(struct map$2char$ph_Bool$* self);
static struct map$2char$ph_Bool$* map$2char$ph_Bool$_insert(struct map$2char$ph_Bool$* self, char* key  , _Bool item);
static void map$2char$ph_Bool$_rehash(struct map$2char$ph_Bool$* self);
static char* map$2char$ph_Bool$_begin(struct map$2char$ph_Bool$* self);
static _Bool map$2char$ph_Bool$_end(struct map$2char$ph_Bool$* self);
static char* map$2char$ph_Bool$_next(struct map$2char$ph_Bool$* self);
static _Bool map$2char$ph_Bool$_at(struct map$2char$ph_Bool$* self, char* key  , _Bool default_value);
static void tuple2$2char$phchar$ph$p_finalize(struct tuple2$2char$phchar$ph* self);
static struct tuple2$2char$phchar$ph* tuple2$2char$phchar$ph_initialize(struct tuple2$2char$phchar$ph* self, char* v1  , char* v2  );
static struct map$2char$phchar$ph* list$1map$2char$phchar$ph$ph_begin(struct list$1map$2char$phchar$ph$ph* self);
static _Bool list$1map$2char$phchar$ph$ph_end(struct list$1map$2char$phchar$ph$ph* self);
static struct map$2char$phchar$ph* list$1map$2char$phchar$ph$ph_next(struct list$1map$2char$phchar$ph$ph* self);
static _Bool map$2char$ph_Bool$$p_operator_load_element(struct map$2char$ph_Bool$* self, char* key  );
static _Bool map$2char$ph_Bool$_operator_load_element(struct map$2char$ph_Bool$* self, char* key  );
char* show_tables(struct sInfo* info  );
int main();
static struct map$2char$phDatabase$ph* map$2char$phDatabase$ph_initialize(struct map$2char$phDatabase$ph* self);
static void map$2char$phDatabase$ph$p_finalize(struct map$2char$phDatabase$ph* self);
static void map$2char$phDatabase$ph_finalize(struct map$2char$phDatabase$ph* self);
void fun_block1_mainnc(struct __current_stack1__* parent, int it  , _Bool* it2, _Bool* it3);
static void map$2char$phDatabase$ph_operator_store_element(struct map$2char$phDatabase$ph* self, char* key  , struct Database* item  );
static struct map$2char$phDatabase$ph* map$2char$phDatabase$ph_insert(struct map$2char$phDatabase$ph* self, char* key  , struct Database* item  );
static void map$2char$phDatabase$ph_rehash(struct map$2char$phDatabase$ph* self);
static char* map$2char$phDatabase$ph_begin(struct map$2char$phDatabase$ph* self);
static _Bool map$2char$phDatabase$ph_end(struct map$2char$phDatabase$ph* self);
static char* map$2char$phDatabase$ph_next(struct map$2char$phDatabase$ph* self);
static struct Database* map$2char$phDatabase$ph_at(struct map$2char$phDatabase$ph* self, char* key  , struct Database* default_value  );
static void sInfo_finalize(struct sInfo* self  );
void come_push_stackframe(char* sname, int sline, int id);
void come_pop_stackframe();
void come_save_stackframe(char* sname, int sline);
void stackframe();
char* come_get_stackframe();
_Bool die(char* msg);
void come_heap_init(int come_debug);
void come_heap_final();
void* alloc_from_pages(unsigned long size  );
void come_free_mem_of_heap_pool(void* mem);
void* come_alloc_mem_from_heap_pool(unsigned long size  , char* sname, int sline, char* class_name);
char* come_dynamic_typeof(void* mem);
void* come_calloc(unsigned long count  , unsigned long size  , char* sname, int sline, char* class_name);
void come_free(void* mem);
void* come_memdup(void* block, char* sname, int sline, char* class_name);
void* come_increment_ref_count(void* mem);
void* come_print_ref_count(void* mem);
int come_get_ref_count(void* mem);
void* come_decrement_ref_count(void* mem, void* protocol_fun, void* protocol_obj, _Bool no_decrement, _Bool no_free, void* result_obj);
void come_call_finalizer(void* fun, void* mem, void* protocol_fun, void* protocol_obj, int call_finalizer_only, int no_decrement, int no_free, void* result_obj);
void xassert(char* msg, _Bool test);
char* __builtin_string(char* str);
struct buffer* buffer_initialize(struct buffer* self  );
struct buffer* buffer_initialize_with_value(struct buffer* self  , char* mem, unsigned long size  );
void buffer_finalize(struct buffer* self  );
struct buffer* buffer_clone(struct buffer* self  );
_Bool buffer_equals(struct buffer* left  , struct buffer* right  );
int buffer_length(struct buffer* self  );
void buffer_reset(struct buffer* self  );
void buffer_trim(struct buffer* self  , int len);
struct buffer* buffer_append(struct buffer* self  , char* mem, unsigned long size  );
struct buffer* buffer_append_char(struct buffer* self  , char c);
struct buffer* buffer_append_str(struct buffer* self  , char* mem);
struct buffer* buffer_append_format(struct buffer* self  , char* msg, ...);
struct buffer* buffer_append_nullterminated_str(struct buffer* self  , char* mem);
struct buffer* buffer_append_int(struct buffer* self  , int value);
struct buffer* buffer_append_long(struct buffer* self  , long value);
struct buffer* buffer_append_short(struct buffer* self  , short value);
struct buffer* buffer_alignment(struct buffer* self  );
int buffer_compare(struct buffer* left  , struct buffer* right  );
struct buffer* charp_to_buffer(char* self);
char* buffer_to_string(struct buffer* self  );
unsigned char* buffer_head_pointer(struct buffer* self  );
struct buffer* chara_to_buffer(char* self, unsigned long len  );
struct buffer* charpa_to_buffer(char** self, unsigned long len  );
struct buffer* shorta_to_buffer(short* self, unsigned long len  );
struct buffer* inta_to_buffer(int* self, unsigned long len  );
struct buffer* longa_to_buffer(long* self, unsigned long len  );
struct buffer* floata_to_buffer(float* self, unsigned long len  );
struct buffer* doublea_to_buffer(double* self, unsigned long len  );
char* buffer_printable(struct buffer* self  );
static struct list$1char$* list$1char$_initialize_with_values(struct list$1char$* self, int num_value, char* values);
static struct list$1char$* list$1char$_push_back(struct list$1char$* self, char item);
static void list$1char$$p_finalize(struct list$1char$* self);
static void list_item$1char$$p_finalize(struct list_item$1char$* self);
struct list$1char$* chara_to_list(char* self, unsigned long len  );
static struct list$1char$p* list$1char$p_initialize_with_values(struct list$1char$p* self, int num_value, char** values);
static struct list$1char$p* list$1char$p_push_back(struct list$1char$p* self, char* item);
static void list$1char$p$p_finalize(struct list$1char$p* self);
static void list_item$1char$p$p_finalize(struct list_item$1char$p* self);
struct list$1char$p* charpa_to_list(char** self, unsigned long len  );
static struct list$1short$* list$1short$_initialize_with_values(struct list$1short$* self, int num_value, short* values);
static struct list$1short$* list$1short$_push_back(struct list$1short$* self, short item);
static void list$1short$$p_finalize(struct list$1short$* self);
static void list_item$1short$$p_finalize(struct list_item$1short$* self);
struct list$1short$* shorta_to_list(short* self, unsigned long len  );
static struct list$1int$* list$1int$_initialize_with_values(struct list$1int$* self, int num_value, int* values);
static struct list$1int$* list$1int$_push_back(struct list$1int$* self, int item);
static void list$1int$$p_finalize(struct list$1int$* self);
static void list_item$1int$$p_finalize(struct list_item$1int$* self);
struct list$1int$* inta_to_list(int* self, unsigned long len  );
static struct list$1long$* list$1long$_initialize_with_values(struct list$1long$* self, int num_value, long* values);
static struct list$1long$* list$1long$_push_back(struct list$1long$* self, long item);
static void list$1long$$p_finalize(struct list$1long$* self);
static void list_item$1long$$p_finalize(struct list_item$1long$* self);
struct list$1long$* longa_to_list(long* self, unsigned long len  );
static struct list$1float$* list$1float$_initialize_with_values(struct list$1float$* self, int num_value, float* values);
static struct list$1float$* list$1float$_push_back(struct list$1float$* self, float item);
static void list$1float$$p_finalize(struct list$1float$* self);
static void list_item$1float$$p_finalize(struct list_item$1float$* self);
struct list$1float$* floata_to_list(float* self, unsigned long len  );
static struct list$1double$* list$1double$_initialize_with_values(struct list$1double$* self, int num_value, double* values);
static struct list$1double$* list$1double$_push_back(struct list$1double$* self, double item);
static void list$1double$$p_finalize(struct list$1double$* self);
static void list_item$1double$$p_finalize(struct list_item$1double$* self);
struct list$1double$* doublea_to_list(double* self, unsigned long len  );
_Bool _Bool_equals(_Bool self, _Bool right);
_Bool char_equals(char self, char right);
_Bool short_equals(short self, short right);
_Bool int_equals(int self, int right);
_Bool long_equals(long self, long right);
_Bool size_t_equals(unsigned long self  , unsigned long right  );
_Bool float_equals(float self, float right);
_Bool double_equals(double self, double right);
_Bool _Bool_operator_equals(_Bool self, _Bool right);
_Bool char_operator_equals(char self, char right);
_Bool short_operator_equals(short self, short right);
_Bool int_operator_equals(int self, int right);
_Bool long_operator_equals(long self, long right);
_Bool _Bool_operator_not_equals(_Bool self, _Bool right);
_Bool char_operator_not_equals(char self, char right);
_Bool short_operator_not_equals(short self, short right);
_Bool int_operator_not_equals(int self, int right);
_Bool long_operator_not_equals(long self, long right);
_Bool charp_equals(char* self, char* right);
_Bool string_equals(char* self, char* right);
_Bool voidp_equals(void* self, void* right);
_Bool _Boolp_equals(_Bool* self, _Bool* right);
_Bool string_operator_equals(char* self, char* right);
_Bool charp_operator_equals(char* self, char* right);
_Bool voidp_operator_equals(char* self, char* right);
_Bool voidp_operator_not_equals(char* self, char* right);
_Bool string_operator_not_equals(char* self, char* right);
_Bool charp_operator_not_equals(char* self, char* right);
char* charp_operator_add(char* self, char* right);
char* string_operator_add(char* self, char* right);
char* charp_operator_mult(char* self, int right);
char* string_operator_mult(char* self, int right);
_Bool charpa_contained(char** self, unsigned long len  , char* str);
unsigned long shorta_length(short* self, unsigned long len  );
unsigned long inta_length(int* self, unsigned long len  );
unsigned long longa_length(long* self, unsigned long len  );
unsigned long floata_length(float* self, unsigned long len  );
unsigned long doublea_length(double* self, unsigned long len  );
unsigned int _Bool_get_hash_key(_Bool value);
unsigned int char_get_hash_key(char value);
unsigned int short_get_hash_key(short int value);
unsigned int int_get_hash_key(int value);
unsigned int long_get_hash_key(long value);
unsigned int size_t_get_hash_key(unsigned long value  );
unsigned int float_get_hash_key(float value);
unsigned int double_get_hash_key(double value);
unsigned int charp_get_hash_key(char* value);
unsigned int string_get_hash_key(char* value);
unsigned int voidp_get_hash_key(void* value);
_Bool _Bool_clone(_Bool self);
char char_clone(char self);
short int short_clone(short self);
int int_clone(int self);
long  int long_clone(long self);
unsigned long size_t_clone(unsigned long self  );
double double_clone(double self);
float float_clone(float self);
_Bool xisalpha(char c);
_Bool xisblank(char c);
_Bool xisdigit(char c);
_Bool xisspace(char c);
_Bool xisalnum(char c);
_Bool xisascii(char c);
_Bool xispunct(char c);
int string_length(char* str);
int charp_length(char* str);
int chara_length(char* str);
char* charp_reverse(char* str);
char* string_operator_load_range_element(char* str, int head, int tail);
char* charp_operator_load_range_element(char* str, int head, int tail);
char* charp_substring(char* str, int head, int tail);
char* xsprintf(char* msg, ...);
char* charp_delete(char* str, int head, int tail);
struct list$1char$ph* charp_split_char(char* self, char c);
char* charp_xsprintf(char* self, char* msg, ...);
char* int_xsprintf(int self, char* msg, ...);
char* charp_printable(char* str);
char* chara_printable(char* str);
char* charp_sub_plain(char* self, char* str, char* replace);
char* xbasename(char* path);
char* xnoextname(char* path);
char* xextname(char* path);
char* _Bool_to_string(_Bool self);
char* char_to_string(char self);
char* short_to_string(short self);
char* int_to_string(int self);
char* long_to_string(long self);
char* size_t_to_string(unsigned long self  );
char* float_to_string(float self);
char* double_to_string(double self);
char* string_to_string(char* self);
char* charp_to_string(char* self);
int _Bool_compare(_Bool left, _Bool right);
int char_compare(char left, char right);
int short_compare(short left, short right);
int int_compare(int left, int right);
int long_compare(long left, long right);
int size_t_compare(unsigned long left  , unsigned long right  );
int float_compare(float left, float right);
int double_compare(double left, double right);
int string_compare(char* left, char* right);
int charp_compare(char* left, char* right);
char* charp_puts(char* self);
char* charp_print(char* self);
char* charp_printf(char* self, ...);
int int_printf(int self, char* msg);
long long_printf(long self, char* msg);
void int_times(int self, void* parent, void (*block)(void*,int));
static void match_context_finalize(struct anonymous_typeX25* self  );
int re_matchp_ex(struct re_program* pattern  , const char* text, int* matchlength, struct re_capture* captures  , int max_captures, _Bool ignore_case);
int re_matchp(struct re_program* pattern  , const char* text, int* matchlength, struct re_capture* captures  , int max_captures);
int re_match(const char* pattern, const char* text, int* matchlength);
static void regex_program_t_finalize(struct re_program* self  );
static void compiler_state_finalize(struct anonymous_typeX24* self  );
struct re_program* re_compile(const char* pattern);
void re_print(struct re_program* pattern  );
void clear_captures(struct anonymous_typeX25* ctx  );
void snapshot_captures(const struct anonymous_typeX25* ctx  , struct re_capture* buffer_  );
void restore_captures(struct anonymous_typeX25* ctx  , const struct re_capture* buffer_  );
struct regex_t* new_token(struct anonymous_typeX24* st  );
int append_token(struct regex_t** head  , struct regex_t** tail  , struct regex_t* token  );
struct regex_t* compile_sequence(struct anonymous_typeX24* st  , const char* pattern, int* pos, int in_group);
const char* matchpattern(struct regex_t* pattern  , const char* text, struct anonymous_typeX25* ctx  );
const char* matchgroup(struct regex_t* token  , struct regex_t* rest  , const char* text, struct anonymous_typeX25* ctx  );
const char* matchstar(struct regex_t* token  , struct regex_t* rest  , const char* text, struct anonymous_typeX25* ctx  );
const char* matchplus(struct regex_t* token  , struct regex_t* rest  , const char* text, struct anonymous_typeX25* ctx  );
const char* matchquestion(struct regex_t* token  , struct regex_t* rest  , const char* text, struct anonymous_typeX25* ctx  );
unsigned char re_fold_char(unsigned char c, _Bool ignore_case);
const char* matchtoken(struct regex_t* token  , const char* text, struct anonymous_typeX25* ctx  );
int matchdigit(char c);
int matchalpha(char c);
int matchwhitespace(char c);
int matchalphanum(char c);
int matchrange(char c, const char* str, _Bool ignore_case);
int matchdot(char c);
int ismetachar(char c);
int matchmetachar(char c, const char* str);
int matchcharclass(char c, const char* str, _Bool ignore_case);
void re_print_internal(struct regex_t* pattern  , int depth);
int re_get_group_count(struct re_program* pattern  );
int charp_index_regex(char* self, char* reg, int default_value, _Bool ignore_case);
int charp_rindex_regex(char* self, char* reg, int default_value, _Bool ignore_case);
char* string_chomp(char* str);
int string_rindex_regex(char* self, char* reg, int default_value, _Bool ignore_case);
int string_index_regex(char* self, char* reg, int default_value, _Bool ignore_case);
_Bool charp_match(char* self, char* reg, _Bool ignore_case);
struct list$1char$ph* charp_scan(char* self, char* reg, _Bool ignore_case);
struct list$1char$ph* charp_split(char* self, char* reg, _Bool ignore_case);
char* string_sub(char* self, char* reg, char* replace, _Bool ignore_case);
struct list$1char$ph* string_scan(char* self, char* reg, _Bool ignore_case);
struct list$1char$ph* string_split(char* self, char* reg, _Bool ignore_case);
_Bool string_match(char* self, char* reg, _Bool ignore_case);
char* charp_sub(char* self, char* reg, char* replace, _Bool global, _Bool ignore_case);
char* charp_sub_block(char* self, char* reg, _Bool global, _Bool ignore_case, void* parent, char* (*block)(void*,char*,struct list$1char$ph*));
struct list$1char$ph* charp_scan_block(char* self, char* reg, _Bool ignore_case, void* parent, char* (*block)(void*,char*,struct list$1char$ph*));
char* string_sub_block(char* self, char* reg, _Bool global, _Bool ignore_case, void* parent, char* (*block)(void*,char*,struct list$1char$ph*));
int* __builtin_wstring(char* str);
int wchar_tp_length(int* str  );
int wchar_ta_length(int* str  );
int wstring_length(int* str  );
char* string_lower_case(char* str);
char* string_upper_case(char* str);
int* wchar_tp_substring(int* str  , int head, int tail);
int charp_index_count(char* str, char* search_str, int count, int default_value);
int charp_rindex(char* str, char* search_str, int default_value);
int charp_rindex_count(char* str, char* search_str, int count, int default_value);
char* charp_strip(char* self);
char* wchar_tp_to_string(int* wstr  );
char* wchar_ta_to_string(int* wstr  );
int* charp_to_wstring(char* str);
int* chara_to_wstring(char* str);
int* wchar_tp_delete(int* str  , int head, int tail);
int wchar_tp_index(int* str  , int* search_str  , int default_value);
int wchar_tp_rindex(int* str  , int* search_str  , int default_value);
int* wchar_tp_reverse(int* str  );
int* wchar_tp_multiply(int* str  , int n);
int* wchar_tp_printable(int* str  );
int wchar_tp_compare(int* left  , int* right  );
int wstring_compare(int* left  , int* right  );
int* wchar_tp_operator_mult(int* str  , int n);
int* wstring_operator_mult(int* str  , int n);
_Bool wstring_operator_equals(int* left  , int* right  );
_Bool wstring_operator_not_equals(int* left  , int* right  );
int* wchar_tp_operator_add(int* left  , int* right  );
int* wstring_operator_add(int* left  , int* right  );
int charp_index(char* str, char* search_str, int default_value);
char* charp_replace(char* self, int index, char c);
char* charp_multiply(char* str, int n);
struct list$1char$ph* charp_split_str(char* self, char* str);
unsigned int wchar_tp_get_hash_key(int* value  );
_Bool wstring_equals(int* left  , int* right  );
_Bool wchar_t_operator_equals(int left  , int right  );
_Bool wchar_t_operator_not_equals(int left  , int right  );
unsigned int wchar_t_get_hash_key(int value  );
_Bool wchar_t_equals(int left  , int right  );
char* wchar_t_to_string(int wc  );
char* xrealpath(char* path);
char* xdirname(char* path);
unsigned long xwcslen(int* wstr  );
int* wstring_substring(int* str  , int head, int tail);
int string_index_count(char* str, char* search_str, int count, int default_value);
int string_rindex(char* str, char* search_str, int default_value);
int string_rindex_count(char* str, char* search_str, int count, int default_value);
char* string_strip(char* self);
char* wstring_to_string(int* wstr  );
int* int_to_wstring(int self);
int* wstring_delete(int* str  , int head, int tail);
int wstring_index(int* str  , int* search_str  , int default_value);
int wstring_rindex(int* str  , int* search_str  , int default_value);
int* wstring_reverse(int* str  );
int* wstring_multiply(int* str  , int n);
int* wstring_printable(int* str  );
unsigned int wstring_get_hash_key(int* value  );
int string_index(char* str, char* search_str, int default_value);
char* string_replace(char* self, int index, char c);
char* string_multiply(char* str, int n);
struct list$1char$ph* string_split_str(char* self, char* str);
int* string_to_wstring(char* str);
char* charp_chomp(char* str);
_Bool wchar_tp_equals(int* left  , int* right  );
_Bool wchar_tp_operator_equals(int* left  , int* right  );
_Bool wchar_tp_operator_not_equals(int* left  , int* right  );
char* FILE_read(struct _IO_FILE* f  );
int FILE_write(struct _IO_FILE* f  , char* str);
int FILE_fclose(struct _IO_FILE* f  );
struct _IO_FILE* FILE_fprintf(struct _IO_FILE* f  , const char* msg, ...);
int charp_write(char* self, char* file_name, _Bool append);
char* charp_read(char* file_name);
struct list$1char$ph* FILE_readlines(struct _IO_FILE* f  );
_Bool xiswalpha(int c  );
_Bool xiswblank(int c  );
_Bool xiswdigit(int c  );
_Bool xiswalnum(int c  );
_Bool xiswascii(int c  );
int socket_fd_write(int self  , char* str  );
static void sockaddr_in_finalize(struct sockaddr_in* self  );
int server_socket(int port, int socket_family, int socket_type, int protocol, _Bool reuse, void* parent, void (*block)(void*,int,_Bool*,_Bool*));
int client_socket(int port, char* address, void* parent, void (*block)(void*,int,_Bool*));
char* client_socket2(int port, char* data, char* address);
int httpd_socket(int port, int socket_family, int socket_type, int protocol, _Bool reuse, void* parent, void (*block)(void*,int,_Bool*));
void ERR_print_errors_fp(struct _IO_FILE* f  );
int httpsd_socket(int port, _Bool reuse, void* parent, void (*block)(void*,struct ssl_st*,_Bool*));
// uniq global variable
char* gComeStackFrameSName[128];

int gComeStackFrameSLine[128];

int gComeStackFrameID[128];

int gNumComeStackFrame=0;

char* gComeStackFrameBuffer=((void*)0);

struct sMemHeader* gAllocMem  ;

int gComeDebugLib=0;

int gNumAlloc=0;

int gNumFree=0;

// inline function
static inline unsigned short int __bswap_16(unsigned short int __bsx  )
{
    return ((unsigned short int)((((__bsx)>>8)&0xff)|(((__bsx)&0xff)<<8)));
}
static inline unsigned int __bswap_32(unsigned int __bsx  )
{
    return ((((__bsx)&0xff000000u)>>24)|(((__bsx)&0x00ff0000u)>>8)|(((__bsx)&0x0000ff00u)<<8)|(((__bsx)&0x000000ffu)<<24));
}
static inline unsigned long  int __bswap_64(unsigned long  int __bsx  )
{
    return ((((__bsx)&0xff00000000000000ull)>>56)|(((__bsx)&0x00ff000000000000ull)>>40)|(((__bsx)&0x0000ff0000000000ull)>>24)|(((__bsx)&0x000000ff00000000ull)>>8)|(((__bsx)&0x00000000ff000000ull)<<8)|(((__bsx)&0x0000000000ff0000ull)<<24)|(((__bsx)&0x000000000000ff00ull)<<40)|(((__bsx)&0x00000000000000ffull)<<56));
}
static inline unsigned short int __uint16_identity(unsigned short int __x  )
{
    return __x;
}
static inline unsigned int __uint32_identity(unsigned int __x  )
{
    return __x;
}
static inline unsigned long  int __uint64_identity(unsigned long  int __x  )
{
    return __x;
}

// body function
static char* ossl_check_OPENSSL_STRING_type(char* ptr)
{
    return ptr;
}

static const struct stack_st* ossl_check_const_OPENSSL_STRING_sk_type(const struct stack_st_OPENSSL_STRING* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_OPENSSL_STRING_sk_type(struct stack_st_OPENSSL_STRING* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_OPENSSL_STRING_compfunc_type(int (*cmp)(const char**,const char**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_OPENSSL_STRING_copyfunc_type(char* (*cpy)(const char*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_OPENSSL_STRING_freefunc_type(void (*fr)(char*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static const char* ossl_check_OPENSSL_CSTRING_type(const char* ptr)
{
    return ptr;
}

static const struct stack_st* ossl_check_const_OPENSSL_CSTRING_sk_type(const struct stack_st_OPENSSL_CSTRING* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_OPENSSL_CSTRING_sk_type(struct stack_st_OPENSSL_CSTRING* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_OPENSSL_CSTRING_compfunc_type(int (*cmp)(const char**,const char**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_OPENSSL_CSTRING_copyfunc_type(char* (*cpy)(const char*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_OPENSSL_CSTRING_freefunc_type(void (*fr)(char*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static void* ossl_check_OPENSSL_BLOCK_type(void* ptr)
{
    return ptr;
}

static const struct stack_st* ossl_check_const_OPENSSL_BLOCK_sk_type(const struct stack_st_OPENSSL_BLOCK* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_OPENSSL_BLOCK_sk_type(struct stack_st_OPENSSL_BLOCK* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_OPENSSL_BLOCK_compfunc_type(int (*cmp)(const void**,const void**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_OPENSSL_BLOCK_copyfunc_type(void* (*cpy)(const void*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_OPENSSL_BLOCK_freefunc_type(void (*fr)(void*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static void* ossl_check_void_type(void* ptr)
{
    return ptr;
}

static const struct stack_st* ossl_check_const_void_sk_type(const struct stack_st_void* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_void_sk_type(struct stack_st_void* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_void_compfunc_type(int (*cmp)(const void**,const void**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_void_copyfunc_type(void* (*cpy)(const void*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_void_freefunc_type(void (*fr)(void*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct ssl_comp_st* ossl_check_SSL_COMP_type(struct ssl_comp_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_SSL_COMP_sk_type(const struct stack_st_SSL_COMP* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_SSL_COMP_sk_type(struct stack_st_SSL_COMP* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_SSL_COMP_compfunc_type(int (*cmp)(const struct ssl_comp_st**,const struct ssl_comp_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_SSL_COMP_copyfunc_type(struct ssl_comp_st* (*cpy)(const struct ssl_comp_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_SSL_COMP_freefunc_type(void (*fr)(struct ssl_comp_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct bio_st* ossl_check_BIO_type(struct bio_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_BIO_sk_type(const struct stack_st_BIO* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_BIO_sk_type(struct stack_st_BIO* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_BIO_compfunc_type(int (*cmp)(const struct bio_st**,const struct bio_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_BIO_copyfunc_type(struct bio_st* (*cpy)(const struct bio_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_BIO_freefunc_type(void (*fr)(struct bio_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_core_gettable_params(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (const struct ossl_param_st* (*)(const struct ossl_core_handle_st*))opf->function;
}

static int (*(*OSSL_FUNC_core_get_params(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,struct ossl_param_st) 
{
    return (int (*)(const struct ossl_core_handle_st*,struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_core_thread_start(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,void (*)(void*),void*) 
{
    return (int (*)(const struct ossl_core_handle_st*,void (*)(void*),void*))opf->function;
}

static struct openssl_core_ctx_st* (*(*OSSL_FUNC_core_get_libctx(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (struct openssl_core_ctx_st* (*)(const struct ossl_core_handle_st*))opf->function;
}

static void (*(*OSSL_FUNC_core_new_error(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (void (*)(const struct ossl_core_handle_st*))opf->function;
}

static void (*(*OSSL_FUNC_core_set_error_debug(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,const char*,int,const char*) 
{
    return (void (*)(const struct ossl_core_handle_st*,const char*,int,const char*))opf->function;
}

static void (*(*OSSL_FUNC_core_vset_error(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned int,const char*,__builtin_va_list) 
{
    return (void (*)(const struct ossl_core_handle_st*,unsigned int,const char*,__builtin_va_list))opf->function;
}

static int (*(*OSSL_FUNC_core_set_error_mark(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (int (*)(const struct ossl_core_handle_st*))opf->function;
}

static int (*(*OSSL_FUNC_core_clear_last_error_mark(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (int (*)(const struct ossl_core_handle_st*))opf->function;
}

static int (*(*OSSL_FUNC_core_pop_error_to_mark(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (int (*)(const struct ossl_core_handle_st*))opf->function;
}

static int (*(*OSSL_FUNC_core_obj_add_sigid(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,const char*,const char*,const char*) 
{
    return (int (*)(const struct ossl_core_handle_st*,const char*,const char*,const char*))opf->function;
}

static int (*(*OSSL_FUNC_core_obj_create(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,const char*,const char*,const char*) 
{
    return (int (*)(const struct ossl_core_handle_st*,const char*,const char*,const char*))opf->function;
}

static void* (*(*OSSL_FUNC_CRYPTO_malloc(const struct ossl_dispatch_st* opf  )))(unsigned long,const char*,int) 
{
    return (void* (*)(unsigned long,const char*,int))opf->function;
}

static void* (*(*OSSL_FUNC_CRYPTO_zalloc(const struct ossl_dispatch_st* opf  )))(unsigned long,const char*,int) 
{
    return (void* (*)(unsigned long,const char*,int))opf->function;
}

static void (*(*OSSL_FUNC_CRYPTO_free(const struct ossl_dispatch_st* opf  )))(void*,const char*,int) 
{
    return (void (*)(void*,const char*,int))opf->function;
}

static void (*(*OSSL_FUNC_CRYPTO_clear_free(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,const char*,int) 
{
    return (void (*)(void*,unsigned long,const char*,int))opf->function;
}

static void* (*(*OSSL_FUNC_CRYPTO_realloc(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,const char*,int) 
{
    return (void* (*)(void*,unsigned long,const char*,int))opf->function;
}

static void* (*(*OSSL_FUNC_CRYPTO_clear_realloc(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,unsigned long,const char*,int) 
{
    return (void* (*)(void*,unsigned long,unsigned long,const char*,int))opf->function;
}

static void* (*(*OSSL_FUNC_CRYPTO_secure_malloc(const struct ossl_dispatch_st* opf  )))(unsigned long,const char*,int) 
{
    return (void* (*)(unsigned long,const char*,int))opf->function;
}

static void* (*(*OSSL_FUNC_CRYPTO_secure_zalloc(const struct ossl_dispatch_st* opf  )))(unsigned long,const char*,int) 
{
    return (void* (*)(unsigned long,const char*,int))opf->function;
}

static void (*(*OSSL_FUNC_CRYPTO_secure_free(const struct ossl_dispatch_st* opf  )))(void*,const char*,int) 
{
    return (void (*)(void*,const char*,int))opf->function;
}

static void (*(*OSSL_FUNC_CRYPTO_secure_clear_free(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,const char*,int) 
{
    return (void (*)(void*,unsigned long,const char*,int))opf->function;
}

static int (*(*OSSL_FUNC_CRYPTO_secure_allocated(const struct ossl_dispatch_st* opf  )))(const void*) 
{
    return (int (*)(const void*))opf->function;
}

static void (*(*OSSL_FUNC_OPENSSL_cleanse(const struct ossl_dispatch_st* opf  )))(void*,unsigned long) 
{
    return (void (*)(void*,unsigned long))opf->function;
}

static struct ossl_core_bio_st* (*(*OSSL_FUNC_BIO_new_file(const struct ossl_dispatch_st* opf  )))(const char*,const char*) 
{
    return (struct ossl_core_bio_st* (*)(const char*,const char*))opf->function;
}

static struct ossl_core_bio_st* (*(*OSSL_FUNC_BIO_new_membuf(const struct ossl_dispatch_st* opf  )))(const void*,int) 
{
    return (struct ossl_core_bio_st* (*)(const void*,int))opf->function;
}

static int (*(*OSSL_FUNC_BIO_read_ex(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,void*,unsigned long,unsigned long*) 
{
    return (int (*)(struct ossl_core_bio_st*,void*,unsigned long,unsigned long*))opf->function;
}

static int (*(*OSSL_FUNC_BIO_write_ex(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,const void*,unsigned long,unsigned long*) 
{
    return (int (*)(struct ossl_core_bio_st*,const void*,unsigned long,unsigned long*))opf->function;
}

static int (*(*OSSL_FUNC_BIO_gets(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,char*,int) 
{
    return (int (*)(struct ossl_core_bio_st*,char*,int))opf->function;
}

static int (*(*OSSL_FUNC_BIO_puts(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,const char*) 
{
    return (int (*)(struct ossl_core_bio_st*,const char*))opf->function;
}

static int (*(*OSSL_FUNC_BIO_up_ref(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*) 
{
    return (int (*)(struct ossl_core_bio_st*))opf->function;
}

static int (*(*OSSL_FUNC_BIO_free(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*) 
{
    return (int (*)(struct ossl_core_bio_st*))opf->function;
}

static int (*(*OSSL_FUNC_BIO_vprintf(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,const char*,__builtin_va_list) 
{
    return (int (*)(struct ossl_core_bio_st*,const char*,__builtin_va_list))opf->function;
}

static int (*(*OSSL_FUNC_BIO_vsnprintf(const struct ossl_dispatch_st* opf  )))(char*,unsigned long,const char*,__builtin_va_list) 
{
    return (int (*)(char*,unsigned long,const char*,__builtin_va_list))opf->function;
}

static int (*(*OSSL_FUNC_BIO_ctrl(const struct ossl_dispatch_st* opf  )))(struct ossl_core_bio_st*,int,long,void*) 
{
    return (int (*)(struct ossl_core_bio_st*,int,long,void*))opf->function;
}

static void (*(*OSSL_FUNC_indicator_cb(const struct ossl_dispatch_st* opf  )))(struct openssl_core_ctx_st*,int (*)(const char*,const char*,const struct ossl_param_st)) 
{
    return (void (*)(struct openssl_core_ctx_st*,int (*)(const char*,const char*,const struct ossl_param_st)))opf->function;
}

static void (*(*OSSL_FUNC_self_test_cb(const struct ossl_dispatch_st* opf  )))(struct openssl_core_ctx_st*,int (*)(const struct ossl_param_st,void*),void**) 
{
    return (void (*)(struct openssl_core_ctx_st*,int (*)(const struct ossl_param_st,void*),void**))opf->function;
}

static unsigned long (*(*OSSL_FUNC_get_entropy(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char**,int,unsigned long,unsigned long) 
{
    return (unsigned long (*)(const struct ossl_core_handle_st*,unsigned char**,int,unsigned long,unsigned long))opf->function;
}

static unsigned long (*(*OSSL_FUNC_get_user_entropy(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char**,int,unsigned long,unsigned long) 
{
    return (unsigned long (*)(const struct ossl_core_handle_st*,unsigned char**,int,unsigned long,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_cleanup_entropy(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char*,unsigned long) 
{
    return (void (*)(const struct ossl_core_handle_st*,unsigned char*,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_cleanup_user_entropy(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char*,unsigned long) 
{
    return (void (*)(const struct ossl_core_handle_st*,unsigned char*,unsigned long))opf->function;
}

static unsigned long (*(*OSSL_FUNC_get_nonce(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char**,unsigned long,unsigned long,const void*,unsigned long) 
{
    return (unsigned long (*)(const struct ossl_core_handle_st*,unsigned char**,unsigned long,unsigned long,const void*,unsigned long))opf->function;
}

static unsigned long (*(*OSSL_FUNC_get_user_nonce(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char**,unsigned long,unsigned long,const void*,unsigned long) 
{
    return (unsigned long (*)(const struct ossl_core_handle_st*,unsigned char**,unsigned long,unsigned long,const void*,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_cleanup_nonce(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char*,unsigned long) 
{
    return (void (*)(const struct ossl_core_handle_st*,unsigned char*,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_cleanup_user_nonce(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,unsigned char*,unsigned long) 
{
    return (void (*)(const struct ossl_core_handle_st*,unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_provider_register_child_cb(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,int (*)(const struct ossl_core_handle_st*,void*),int (*)(const struct ossl_core_handle_st*,void*),int (*)(const char*,void*),void*) 
{
    return (int (*)(const struct ossl_core_handle_st*,int (*)(const struct ossl_core_handle_st*,void*),int (*)(const struct ossl_core_handle_st*,void*),int (*)(const char*,void*),void*))opf->function;
}

static void (*(*OSSL_FUNC_provider_deregister_child_cb(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (void (*)(const struct ossl_core_handle_st*))opf->function;
}

static const char* (*(*OSSL_FUNC_provider_name(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (const char* (*)(const struct ossl_core_handle_st*))opf->function;
}

static void* (*(*OSSL_FUNC_provider_get0_provider_ctx(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (void* (*)(const struct ossl_core_handle_st*))opf->function;
}

static const struct ossl_dispatch_st* (*(*OSSL_FUNC_provider_get0_dispatch(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (const struct ossl_dispatch_st* (*)(const struct ossl_core_handle_st*))opf->function;
}

static int (*(*OSSL_FUNC_provider_up_ref(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,int) 
{
    return (int (*)(const struct ossl_core_handle_st*,int))opf->function;
}

static int (*(*OSSL_FUNC_provider_free(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*,int) 
{
    return (int (*)(const struct ossl_core_handle_st*,int))opf->function;
}

static int (*(*OSSL_FUNC_core_count_to_mark(const struct ossl_dispatch_st* opf  )))(const struct ossl_core_handle_st*) 
{
    return (int (*)(const struct ossl_core_handle_st*))opf->function;
}

static void (*(*OSSL_FUNC_provider_teardown(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_provider_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_provider_get_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static const struct ossl_algorithm_st* (*(*OSSL_FUNC_provider_query_operation(const struct ossl_dispatch_st* opf  )))(void*,int,int*) 
{
    return (const struct ossl_algorithm_st* (*)(void*,int,int*))opf->function;
}

static void (*(*OSSL_FUNC_provider_unquery_operation(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_algorithm_st*) 
{
    return (void (*)(void*,int,const struct ossl_algorithm_st*))opf->function;
}

static const struct ossl_item_st* (*(*OSSL_FUNC_provider_get_reason_strings(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_item_st* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_provider_get_capabilities(const struct ossl_dispatch_st* opf  )))(void*,const char*,int (*)(const struct ossl_param_st,void*),void*) 
{
    return (int (*)(void*,const char*,int (*)(const struct ossl_param_st,void*),void*))opf->function;
}

static int (*(*OSSL_FUNC_provider_self_test(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (int (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_provider_random_bytes(const struct ossl_dispatch_st* opf  )))(void*,int,void*,unsigned long,unsigned int) 
{
    return (int (*)(void*,int,void*,unsigned long,unsigned int))opf->function;
}

static int (*(*OSSL_FUNC_SSL_QUIC_TLS_crypto_send(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,const unsigned char*,unsigned long,unsigned long*,void*) 
{
    return (int (*)(struct ssl_st*,const unsigned char*,unsigned long,unsigned long*,void*))opf->function;
}

static int (*(*OSSL_FUNC_SSL_QUIC_TLS_crypto_recv_rcd(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,const unsigned char**,unsigned long*,void*) 
{
    return (int (*)(struct ssl_st*,const unsigned char**,unsigned long*,void*))opf->function;
}

static int (*(*OSSL_FUNC_SSL_QUIC_TLS_crypto_release_rcd(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,unsigned long,void*) 
{
    return (int (*)(struct ssl_st*,unsigned long,void*))opf->function;
}

static int (*(*OSSL_FUNC_SSL_QUIC_TLS_yield_secret(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,unsigned int,int,const unsigned char*,unsigned long,void*) 
{
    return (int (*)(struct ssl_st*,unsigned int,int,const unsigned char*,unsigned long,void*))opf->function;
}

static int (*(*OSSL_FUNC_SSL_QUIC_TLS_got_transport_params(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,const unsigned char*,unsigned long,void*) 
{
    return (int (*)(struct ssl_st*,const unsigned char*,unsigned long,void*))opf->function;
}

static int (*(*OSSL_FUNC_SSL_QUIC_TLS_alert(const struct ossl_dispatch_st* opf  )))(struct ssl_st*,unsigned char,void*) 
{
    return (int (*)(struct ssl_st*,unsigned char,void*))opf->function;
}

static void* (*(*OSSL_FUNC_digest_newctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_digest_init(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_digest_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_digest_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_digest_squeeze(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_digest_digest(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,unsigned char*,unsigned long*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long,unsigned char*,unsigned long*,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_digest_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_digest_dupctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static void (*(*OSSL_FUNC_digest_copyctx(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (void (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_digest_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) 
{
    return (int (*)(struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_digest_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_digest_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_digest_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_digest_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_digest_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static void* (*(*OSSL_FUNC_cipher_newctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_cipher_encrypt_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long,const struct ossl_param_st) 
{
    return (int (*)(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_cipher_decrypt_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long,const struct ossl_param_st) 
{
    return (int (*)(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_cipher_update(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_cipher_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_cipher_cipher(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_cipher_pipeline_encrypt_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,unsigned long,const unsigned char**,unsigned long,const struct ossl_param_st) 
{
    return (int (*)(void*,const unsigned char*,unsigned long,unsigned long,const unsigned char**,unsigned long,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_cipher_pipeline_decrypt_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,unsigned long,const unsigned char**,unsigned long,const struct ossl_param_st) 
{
    return (int (*)(void*,const unsigned char*,unsigned long,unsigned long,const unsigned char**,unsigned long,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_cipher_pipeline_update(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,unsigned char**,unsigned long*,const unsigned long*,const unsigned char**,const unsigned long*) 
{
    return (int (*)(void*,unsigned long,unsigned char**,unsigned long*,const unsigned long*,const unsigned char**,const unsigned long*))opf->function;
}

static int (*(*OSSL_FUNC_cipher_pipeline_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned long,unsigned char**,unsigned long*,const unsigned long*) 
{
    return (int (*)(void*,unsigned long,unsigned char**,unsigned long*,const unsigned long*))opf->function;
}

static void (*(*OSSL_FUNC_cipher_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_cipher_dupctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_cipher_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) 
{
    return (int (*)(struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_cipher_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_cipher_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_cipher_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_cipher_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_cipher_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_cipher_encrypt_skey_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const unsigned char*,unsigned long,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const unsigned char*,unsigned long,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_cipher_decrypt_skey_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const unsigned char*,unsigned long,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const unsigned char*,unsigned long,const struct ossl_param_st))opf->function;
}

static void* (*(*OSSL_FUNC_mac_newctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_mac_dupctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static void (*(*OSSL_FUNC_mac_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_mac_init(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const struct ossl_param_st) 
{
    return (int (*)(void*,const unsigned char*,unsigned long,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_mac_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_mac_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_mac_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_mac_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_mac_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_mac_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) 
{
    return (int (*)(struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_mac_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_mac_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_mac_init_skey(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static void* (*(*OSSL_FUNC_kdf_newctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_kdf_dupctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static void (*(*OSSL_FUNC_kdf_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static void (*(*OSSL_FUNC_kdf_reset(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_kdf_derive(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long,const struct ossl_param_st) 
{
    return (int (*)(void*,unsigned char*,unsigned long,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_kdf_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_kdf_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_kdf_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_kdf_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) 
{
    return (int (*)(struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_kdf_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_kdf_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static void* (*(*OSSL_FUNC_rand_newctx(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_dispatch_st*) 
{
    return (void* (*)(void*,void*,const struct ossl_dispatch_st*))opf->function;
}

static void (*(*OSSL_FUNC_rand_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_rand_instantiate(const struct ossl_dispatch_st* opf  )))(void*,unsigned int,int,const unsigned char*,unsigned long,const struct ossl_param_st) 
{
    return (int (*)(void*,unsigned int,int,const unsigned char*,unsigned long,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_rand_uninstantiate(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (int (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_rand_generate(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long,unsigned int,int,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long,unsigned int,int,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_rand_reseed(const struct ossl_dispatch_st* opf  )))(void*,int,const unsigned char*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,int,const unsigned char*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static unsigned long (*(*OSSL_FUNC_rand_nonce(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned int,unsigned long,unsigned long) 
{
    return (unsigned long (*)(void*,unsigned char*,unsigned int,unsigned long,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_rand_enable_locking(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (int (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_rand_lock(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (int (*)(void*))opf->function;
}

static void (*(*OSSL_FUNC_rand_unlock(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_rand_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_rand_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_rand_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_rand_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) 
{
    return (int (*)(struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_rand_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_rand_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static void (*(*OSSL_FUNC_rand_set_callbacks(const struct ossl_dispatch_st* opf  )))(void*,int (*)(const struct ossl_param_st,struct ossl_param_st,void*),int (*)(const struct ossl_param_st,void*),int (*)(const struct ossl_param_st,struct ossl_param_st,void*),int (*)(const struct ossl_param_st,void*),void*) 
{
    return (void (*)(void*,int (*)(const struct ossl_param_st,struct ossl_param_st,void*),int (*)(const struct ossl_param_st,void*),int (*)(const struct ossl_param_st,struct ossl_param_st,void*),int (*)(const struct ossl_param_st,void*),void*))opf->function;
}

static int (*(*OSSL_FUNC_rand_verify_zeroization(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (int (*)(void*))opf->function;
}

static unsigned long (*(*OSSL_FUNC_rand_get_seed(const struct ossl_dispatch_st* opf  )))(void*,unsigned char**,int,unsigned long,unsigned long,int,const unsigned char*,unsigned long) 
{
    return (unsigned long (*)(void*,unsigned char**,int,unsigned long,unsigned long,int,const unsigned char*,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_rand_clear_seed(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long) 
{
    return (void (*)(void*,unsigned char*,unsigned long))opf->function;
}

static void* (*(*OSSL_FUNC_keymgmt_new(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_keymgmt_gen_init(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_param_st) 
{
    return (void* (*)(void*,int,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_gen_set_template(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (int (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_gen_set_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_gen_settable_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_gen_get_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_gen_gettable_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static void* (*(*OSSL_FUNC_keymgmt_gen(const struct ossl_dispatch_st* opf  )))(void*,int (*)(const struct ossl_param_st,void*),void*) 
{
    return (void* (*)(void*,int (*)(const struct ossl_param_st,void*),void*))opf->function;
}

static void (*(*OSSL_FUNC_keymgmt_gen_cleanup(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_keymgmt_load(const struct ossl_dispatch_st* opf  )))(const void*,unsigned long) 
{
    return (void* (*)(const void*,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_keymgmt_free(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_get_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_set_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_settable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static const char* (*(*OSSL_FUNC_keymgmt_query_operation_name(const struct ossl_dispatch_st* opf  )))(int) 
{
    return (const char* (*)(int))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_has(const struct ossl_dispatch_st* opf  )))(const void*,int) 
{
    return (int (*)(const void*,int))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_validate(const struct ossl_dispatch_st* opf  )))(const void*,int,int) 
{
    return (int (*)(const void*,int,int))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_match(const struct ossl_dispatch_st* opf  )))(const void*,const void*,int) 
{
    return (int (*)(const void*,const void*,int))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_import(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_param_st) 
{
    return (int (*)(void*,int,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_import_types(const struct ossl_dispatch_st* opf  )))(int) 
{
    return (const struct ossl_param_st* (*)(int))opf->function;
}

static int (*(*OSSL_FUNC_keymgmt_export(const struct ossl_dispatch_st* opf  )))(void*,int,int (*)(const struct ossl_param_st,void*),void*) 
{
    return (int (*)(void*,int,int (*)(const struct ossl_param_st,void*),void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_export_types(const struct ossl_dispatch_st* opf  )))(int) 
{
    return (const struct ossl_param_st* (*)(int))opf->function;
}

static void* (*(*OSSL_FUNC_keymgmt_dup(const struct ossl_dispatch_st* opf  )))(const void*,int) 
{
    return (void* (*)(const void*,int))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_import_types_ex(const struct ossl_dispatch_st* opf  )))(void*,int) 
{
    return (const struct ossl_param_st* (*)(void*,int))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keymgmt_export_types_ex(const struct ossl_dispatch_st* opf  )))(void*,int) 
{
    return (const struct ossl_param_st* (*)(void*,int))opf->function;
}

static void* (*(*OSSL_FUNC_keyexch_newctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_keyexch_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_keyexch_derive(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_keyexch_set_peer(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (int (*)(void*,void*))opf->function;
}

static void (*(*OSSL_FUNC_keyexch_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_keyexch_dupctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_keyexch_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keyexch_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_keyexch_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_keyexch_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static void* (*(*OSSL_FUNC_signature_newctx(const struct ossl_dispatch_st* opf  )))(void*,const char*) 
{
    return (void* (*)(void*,const char*))opf->function;
}

static int (*(*OSSL_FUNC_signature_sign_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_signature_sign(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_sign_message_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_signature_sign_message_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_sign_message_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_verify_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_signature_verify(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_verify_message_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_signature_verify_message_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_verify_message_final(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (int (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_signature_verify_recover_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_signature_verify_recover(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_digest_sign_init(const struct ossl_dispatch_st* opf  )))(void*,const char*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const char*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_signature_digest_sign_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_digest_sign_final(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_digest_sign(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_digest_verify_init(const struct ossl_dispatch_st* opf  )))(void*,const char*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const char*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_signature_digest_verify_update(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_digest_verify_final(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_signature_digest_verify(const struct ossl_dispatch_st* opf  )))(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,const unsigned char*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_signature_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_signature_dupctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_signature_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_signature_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_signature_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_signature_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_signature_get_ctx_md_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_signature_gettable_ctx_md_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_signature_set_ctx_md_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_signature_settable_ctx_md_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static const char** (*(*OSSL_FUNC_signature_query_key_types(const struct ossl_dispatch_st* opf  )))() 
{
    return (const char** (*)())opf->function;
}

static void (*(*OSSL_FUNC_skeymgmt_free(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_skeymgmt_imp_settable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_skeymgmt_import(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_param_st) 
{
    return (void* (*)(void*,int,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_skeymgmt_export(const struct ossl_dispatch_st* opf  )))(void*,int,int (*)(const struct ossl_param_st,void*),void*) 
{
    return (int (*)(void*,int,int (*)(const struct ossl_param_st,void*),void*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_skeymgmt_gen_settable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_skeymgmt_generate(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (void* (*)(void*,const struct ossl_param_st))opf->function;
}

static const char* (*(*OSSL_FUNC_skeymgmt_get_key_id(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const char* (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_asym_cipher_newctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_asym_cipher_encrypt_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_asym_cipher_encrypt(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static int (*(*OSSL_FUNC_asym_cipher_decrypt_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_asym_cipher_decrypt(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned long,const unsigned char*,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_asym_cipher_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_asym_cipher_dupctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_asym_cipher_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_asym_cipher_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_asym_cipher_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_asym_cipher_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static void* (*(*OSSL_FUNC_kem_newctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_kem_encapsulate_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_kem_auth_encapsulate_init(const struct ossl_dispatch_st* opf  )))(void*,void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_kem_encapsulate(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,unsigned char*,unsigned long*) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,unsigned char*,unsigned long*))opf->function;
}

static int (*(*OSSL_FUNC_kem_decapsulate_init(const struct ossl_dispatch_st* opf  )))(void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_kem_auth_decapsulate_init(const struct ossl_dispatch_st* opf  )))(void*,void*,void*,const struct ossl_param_st) 
{
    return (int (*)(void*,void*,void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_kem_decapsulate(const struct ossl_dispatch_st* opf  )))(void*,unsigned char*,unsigned long*,const unsigned char*,unsigned long) 
{
    return (int (*)(void*,unsigned char*,unsigned long*,const unsigned char*,unsigned long))opf->function;
}

static void (*(*OSSL_FUNC_kem_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_kem_dupctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_kem_get_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_param_st) 
{
    return (int (*)(void*,struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_kem_gettable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static int (*(*OSSL_FUNC_kem_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_kem_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,void*) 
{
    return (const struct ossl_param_st* (*)(void*,void*))opf->function;
}

static void* (*(*OSSL_FUNC_encoder_newctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static void (*(*OSSL_FUNC_encoder_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_encoder_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) 
{
    return (int (*)(struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_encoder_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_encoder_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_encoder_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_encoder_does_selection(const struct ossl_dispatch_st* opf  )))(void*,int) 
{
    return (int (*)(void*,int))opf->function;
}

static int (*(*OSSL_FUNC_encoder_encode(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_core_bio_st*,const void*,const struct ossl_param_st,int,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) 
{
    return (int (*)(void*,struct ossl_core_bio_st*,const void*,const struct ossl_param_st,int,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*))opf->function;
}

static void* (*(*OSSL_FUNC_encoder_import_object(const struct ossl_dispatch_st* opf  )))(void*,int,const struct ossl_param_st) 
{
    return (void* (*)(void*,int,const struct ossl_param_st))opf->function;
}

static void (*(*OSSL_FUNC_encoder_free_object(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static void* (*(*OSSL_FUNC_decoder_newctx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void* (*)(void*))opf->function;
}

static void (*(*OSSL_FUNC_decoder_freectx(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (void (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_decoder_get_params(const struct ossl_dispatch_st* opf  )))(struct ossl_param_st) 
{
    return (int (*)(struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_decoder_gettable_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_decoder_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_decoder_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_decoder_does_selection(const struct ossl_dispatch_st* opf  )))(void*,int) 
{
    return (int (*)(void*,int))opf->function;
}

static int (*(*OSSL_FUNC_decoder_decode(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_core_bio_st*,int,int (*)(const struct ossl_param_st,void*),void*,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) 
{
    return (int (*)(void*,struct ossl_core_bio_st*,int,int (*)(const struct ossl_param_st,void*),void*,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*))opf->function;
}

static int (*(*OSSL_FUNC_decoder_export_object(const struct ossl_dispatch_st* opf  )))(void*,const void*,unsigned long,int (*)(const struct ossl_param_st,void*),void*) 
{
    return (int (*)(void*,const void*,unsigned long,int (*)(const struct ossl_param_st,void*),void*))opf->function;
}

static void* (*(*OSSL_FUNC_store_open(const struct ossl_dispatch_st* opf  )))(void*,const char*) 
{
    return (void* (*)(void*,const char*))opf->function;
}

static void* (*(*OSSL_FUNC_store_attach(const struct ossl_dispatch_st* opf  )))(void*,struct ossl_core_bio_st*) 
{
    return (void* (*)(void*,struct ossl_core_bio_st*))opf->function;
}

static const struct ossl_param_st* (*(*OSSL_FUNC_store_settable_ctx_params(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (const struct ossl_param_st* (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_store_set_ctx_params(const struct ossl_dispatch_st* opf  )))(void*,const struct ossl_param_st) 
{
    return (int (*)(void*,const struct ossl_param_st))opf->function;
}

static int (*(*OSSL_FUNC_store_load(const struct ossl_dispatch_st* opf  )))(void*,int (*)(const struct ossl_param_st,void*),void*,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) 
{
    return (int (*)(void*,int (*)(const struct ossl_param_st,void*),void*,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*))opf->function;
}

static int (*(*OSSL_FUNC_store_eof(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (int (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_store_close(const struct ossl_dispatch_st* opf  )))(void*) 
{
    return (int (*)(void*))opf->function;
}

static int (*(*OSSL_FUNC_store_export_object(const struct ossl_dispatch_st* opf  )))(void*,const void*,unsigned long,int (*)(const struct ossl_param_st,void*),void*) 
{
    return (int (*)(void*,const void*,unsigned long,int (*)(const struct ossl_param_st,void*),void*))opf->function;
}

static int (*(*OSSL_FUNC_store_delete(const struct ossl_dispatch_st* opf  )))(void*,const char*,const struct ossl_param_st,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) 
{
    return (int (*)(void*,const char*,const struct ossl_param_st,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*))opf->function;
}

static void* (*(*OSSL_FUNC_store_open_ex(const struct ossl_dispatch_st* opf  )))(void*,const char*,const struct ossl_param_st,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*) 
{
    return (void* (*)(void*,const char*,const struct ossl_param_st,int (*)(char*,unsigned long,unsigned long*,const struct ossl_param_st,void*),void*))opf->function;
}

static struct X509_algor_st* ossl_check_X509_ALGOR_type(struct X509_algor_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_ALGOR_sk_type(const struct stack_st_X509_ALGOR* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_ALGOR_sk_type(struct stack_st_X509_ALGOR* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_ALGOR_compfunc_type(int (*cmp)(const struct X509_algor_st**,const struct X509_algor_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_ALGOR_copyfunc_type(struct X509_algor_st* (*cpy)(const struct X509_algor_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_ALGOR_freefunc_type(void (*fr)(struct X509_algor_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct asn1_string_table_st* ossl_check_ASN1_STRING_TABLE_type(struct asn1_string_table_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_ASN1_STRING_TABLE_sk_type(const struct stack_st_ASN1_STRING_TABLE* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_ASN1_STRING_TABLE_sk_type(struct stack_st_ASN1_STRING_TABLE* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_ASN1_STRING_TABLE_compfunc_type(int (*cmp)(const struct asn1_string_table_st**,const struct asn1_string_table_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_ASN1_STRING_TABLE_copyfunc_type(struct asn1_string_table_st* (*cpy)(const struct asn1_string_table_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_ASN1_STRING_TABLE_freefunc_type(void (*fr)(struct asn1_string_table_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct asn1_type_st* ossl_check_ASN1_TYPE_type(struct asn1_type_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_ASN1_TYPE_sk_type(const struct stack_st_ASN1_TYPE* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_ASN1_TYPE_sk_type(struct stack_st_ASN1_TYPE* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_ASN1_TYPE_compfunc_type(int (*cmp)(const struct asn1_type_st**,const struct asn1_type_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_ASN1_TYPE_copyfunc_type(struct asn1_type_st* (*cpy)(const struct asn1_type_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_ASN1_TYPE_freefunc_type(void (*fr)(struct asn1_type_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct asn1_object_st* ossl_check_ASN1_OBJECT_type(struct asn1_object_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_ASN1_OBJECT_sk_type(const struct stack_st_ASN1_OBJECT* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_ASN1_OBJECT_sk_type(struct stack_st_ASN1_OBJECT* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_ASN1_OBJECT_compfunc_type(int (*cmp)(const struct asn1_object_st**,const struct asn1_object_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_ASN1_OBJECT_copyfunc_type(struct asn1_object_st* (*cpy)(const struct asn1_object_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_ASN1_OBJECT_freefunc_type(void (*fr)(struct asn1_object_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct asn1_string_st* ossl_check_ASN1_INTEGER_type(struct asn1_string_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_ASN1_INTEGER_sk_type(const struct stack_st_ASN1_INTEGER* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_ASN1_INTEGER_sk_type(struct stack_st_ASN1_INTEGER* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_ASN1_INTEGER_compfunc_type(int (*cmp)(const struct asn1_string_st**,const struct asn1_string_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_ASN1_INTEGER_copyfunc_type(struct asn1_string_st* (*cpy)(const struct asn1_string_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_ASN1_INTEGER_freefunc_type(void (*fr)(struct asn1_string_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct asn1_string_st* ossl_check_ASN1_UTF8STRING_type(struct asn1_string_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_ASN1_UTF8STRING_sk_type(const struct stack_st_ASN1_UTF8STRING* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_ASN1_UTF8STRING_sk_type(struct stack_st_ASN1_UTF8STRING* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_ASN1_UTF8STRING_compfunc_type(int (*cmp)(const struct asn1_string_st**,const struct asn1_string_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_ASN1_UTF8STRING_copyfunc_type(struct asn1_string_st* (*cpy)(const struct asn1_string_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_ASN1_UTF8STRING_freefunc_type(void (*fr)(struct asn1_string_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct asn1_string_st* ossl_check_ASN1_GENERALSTRING_type(struct asn1_string_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_ASN1_GENERALSTRING_sk_type(const struct stack_st_ASN1_GENERALSTRING* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_ASN1_GENERALSTRING_sk_type(struct stack_st_ASN1_GENERALSTRING* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_ASN1_GENERALSTRING_compfunc_type(int (*cmp)(const struct asn1_string_st**,const struct asn1_string_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_ASN1_GENERALSTRING_copyfunc_type(struct asn1_string_st* (*cpy)(const struct asn1_string_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_ASN1_GENERALSTRING_freefunc_type(void (*fr)(struct asn1_string_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct X509_name_st* ossl_check_X509_NAME_type(struct X509_name_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_NAME_sk_type(const struct stack_st_X509_NAME* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_NAME_sk_type(struct stack_st_X509_NAME* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_NAME_compfunc_type(int (*cmp)(const struct X509_name_st**,const struct X509_name_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_NAME_copyfunc_type(struct X509_name_st* (*cpy)(const struct X509_name_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_NAME_freefunc_type(void (*fr)(struct X509_name_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct x509_st* ossl_check_X509_type(struct x509_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_sk_type(const struct stack_st_X509* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_sk_type(struct stack_st_X509* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_compfunc_type(int (*cmp)(const struct x509_st**,const struct x509_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_copyfunc_type(struct x509_st* (*cpy)(const struct x509_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_freefunc_type(void (*fr)(struct x509_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct x509_revoked_st* ossl_check_X509_REVOKED_type(struct x509_revoked_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_REVOKED_sk_type(const struct stack_st_X509_REVOKED* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_REVOKED_sk_type(struct stack_st_X509_REVOKED* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_REVOKED_compfunc_type(int (*cmp)(const struct x509_revoked_st**,const struct x509_revoked_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_REVOKED_copyfunc_type(struct x509_revoked_st* (*cpy)(const struct x509_revoked_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_REVOKED_freefunc_type(void (*fr)(struct x509_revoked_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct X509_crl_st* ossl_check_X509_CRL_type(struct X509_crl_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_CRL_sk_type(const struct stack_st_X509_CRL* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_CRL_sk_type(struct stack_st_X509_CRL* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_CRL_compfunc_type(int (*cmp)(const struct X509_crl_st**,const struct X509_crl_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_CRL_copyfunc_type(struct X509_crl_st* (*cpy)(const struct X509_crl_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_CRL_freefunc_type(void (*fr)(struct X509_crl_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct X509_name_entry_st* ossl_check_X509_NAME_ENTRY_type(struct X509_name_entry_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_NAME_ENTRY_sk_type(const struct stack_st_X509_NAME_ENTRY* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_NAME_ENTRY_sk_type(struct stack_st_X509_NAME_ENTRY* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_NAME_ENTRY_compfunc_type(int (*cmp)(const struct X509_name_entry_st**,const struct X509_name_entry_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_NAME_ENTRY_copyfunc_type(struct X509_name_entry_st* (*cpy)(const struct X509_name_entry_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_NAME_ENTRY_freefunc_type(void (*fr)(struct X509_name_entry_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct X509_extension_st* ossl_check_X509_EXTENSION_type(struct X509_extension_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_EXTENSION_sk_type(const struct stack_st_X509_EXTENSION* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_EXTENSION_sk_type(struct stack_st_X509_EXTENSION* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_EXTENSION_compfunc_type(int (*cmp)(const struct X509_extension_st**,const struct X509_extension_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_EXTENSION_copyfunc_type(struct X509_extension_st* (*cpy)(const struct X509_extension_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_EXTENSION_freefunc_type(void (*fr)(struct X509_extension_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct x509_attributes_st* ossl_check_X509_ATTRIBUTE_type(struct x509_attributes_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_ATTRIBUTE_sk_type(const struct stack_st_X509_ATTRIBUTE* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_ATTRIBUTE_sk_type(struct stack_st_X509_ATTRIBUTE* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_ATTRIBUTE_compfunc_type(int (*cmp)(const struct x509_attributes_st**,const struct x509_attributes_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_ATTRIBUTE_copyfunc_type(struct x509_attributes_st* (*cpy)(const struct x509_attributes_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_ATTRIBUTE_freefunc_type(void (*fr)(struct x509_attributes_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct X509_info_st* ossl_check_X509_INFO_type(struct X509_info_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_INFO_sk_type(const struct stack_st_X509_INFO* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_INFO_sk_type(struct stack_st_X509_INFO* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_INFO_compfunc_type(int (*cmp)(const struct X509_info_st**,const struct X509_info_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_INFO_copyfunc_type(struct X509_info_st* (*cpy)(const struct X509_info_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_INFO_freefunc_type(void (*fr)(struct X509_info_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static unsigned long  int lh_OPENSSL_STRING_hash_thunk(const void* data, unsigned long  int (*hfn)(const void*)  )
{
    unsigned long  int (*hfn_conv)(const char**);
    hfn_conv=(unsigned long  int (*)(const char**))hfn;
    return hfn_conv((const char**)data);
}

static int lh_OPENSSL_STRING_comp_thunk(const void* da, const void* db, int (*cfn)(const void*,const void*)  )
{
    int (*cfn_conv)(const char**,const char**);
    cfn_conv=(int (*)(const char**,const char**))cfn;
    return cfn_conv((const char**)da,(const char**)db);
}

static void lh_OPENSSL_STRING_doall_thunk(void* node, void (*doall)(void*)  )
{
    void (*doall_conv)(char**);
    doall_conv=(void (*)(char**))doall;
    doall_conv((char**)node);
}

static void lh_OPENSSL_STRING_doall_arg_thunk(void* node, void* arg, void (*doall)(void*,void*)  )
{
    void (*doall_conv)(char**,void*);
    doall_conv=(void (*)(char**,void*))doall;
    doall_conv((char**)node,arg);
}

static char** ossl_check_OPENSSL_STRING_lh_plain_type(char** ptr  )
{
    return ptr;
}

static const char** ossl_check_const_OPENSSL_STRING_lh_plain_type(const char** ptr  )
{
    return ptr;
}

static const struct lhash_st* ossl_check_const_OPENSSL_STRING_lh_type(const struct lhash_st_OPENSSL_STRING* lh  )
{
    return (const struct lhash_st*)lh;
}

static struct lhash_st* ossl_check_OPENSSL_STRING_lh_type(struct lhash_st_OPENSSL_STRING* lh  )
{
    return (struct lhash_st*)lh;
}

static int (*ossl_check_OPENSSL_STRING_lh_compfunc_type(int (*cmp)(const char**,const char**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static unsigned long  int (*ossl_check_OPENSSL_STRING_lh_hashfunc_type(unsigned long  int (*hfn)(const char**)  ))(const void*) 
{
    return (unsigned long  int (*)(const void*))hfn;
}

static void (*ossl_check_OPENSSL_STRING_lh_doallfunc_type(void (*dfn)(char**)  ))(void*) 
{
    return (void (*)(void*))dfn;
}

static unsigned long  int lh_OPENSSL_CSTRING_hash_thunk(const void* data, unsigned long  int (*hfn)(const void*)  )
{
    unsigned long  int (*hfn_conv)(const char**);
    hfn_conv=(unsigned long  int (*)(const char**))hfn;
    return hfn_conv((const char**)data);
}

static int lh_OPENSSL_CSTRING_comp_thunk(const void* da, const void* db, int (*cfn)(const void*,const void*)  )
{
    int (*cfn_conv)(const char**,const char**);
    cfn_conv=(int (*)(const char**,const char**))cfn;
    return cfn_conv((const char**)da,(const char**)db);
}

static void lh_OPENSSL_CSTRING_doall_thunk(void* node, void (*doall)(void*)  )
{
    void (*doall_conv)(const char**);
    doall_conv=(void (*)(const char**))doall;
    doall_conv((const char**)node);
}

static void lh_OPENSSL_CSTRING_doall_arg_thunk(void* node, void* arg, void (*doall)(void*,void*)  )
{
    void (*doall_conv)(const char**,void*);
    doall_conv=(void (*)(const char**,void*))doall;
    doall_conv((const char**)node,arg);
}

static const char** ossl_check_OPENSSL_CSTRING_lh_plain_type(const char** ptr  )
{
    return ptr;
}

static const char** ossl_check_const_OPENSSL_CSTRING_lh_plain_type(const char** ptr  )
{
    return ptr;
}

static const struct lhash_st* ossl_check_const_OPENSSL_CSTRING_lh_type(const struct lhash_st_OPENSSL_CSTRING* lh  )
{
    return (const struct lhash_st*)lh;
}

static struct lhash_st* ossl_check_OPENSSL_CSTRING_lh_type(struct lhash_st_OPENSSL_CSTRING* lh  )
{
    return (struct lhash_st*)lh;
}

static int (*ossl_check_OPENSSL_CSTRING_lh_compfunc_type(int (*cmp)(const char**,const char**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static unsigned long  int (*ossl_check_OPENSSL_CSTRING_lh_hashfunc_type(unsigned long  int (*hfn)(const char**)  ))(const void*) 
{
    return (unsigned long  int (*)(const void*))hfn;
}

static void (*ossl_check_OPENSSL_CSTRING_lh_doallfunc_type(void (*dfn)(const char**)  ))(void*) 
{
    return (void (*)(void*))dfn;
}

static struct x509_lookup_st* ossl_check_X509_LOOKUP_type(struct x509_lookup_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_LOOKUP_sk_type(const struct stack_st_X509_LOOKUP* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_LOOKUP_sk_type(struct stack_st_X509_LOOKUP* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_LOOKUP_compfunc_type(int (*cmp)(const struct x509_lookup_st**,const struct x509_lookup_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_LOOKUP_copyfunc_type(struct x509_lookup_st* (*cpy)(const struct x509_lookup_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_LOOKUP_freefunc_type(void (*fr)(struct x509_lookup_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct x509_object_st* ossl_check_X509_OBJECT_type(struct x509_object_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_OBJECT_sk_type(const struct stack_st_X509_OBJECT* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_OBJECT_sk_type(struct stack_st_X509_OBJECT* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_OBJECT_compfunc_type(int (*cmp)(const struct x509_object_st**,const struct x509_object_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_OBJECT_copyfunc_type(struct x509_object_st* (*cpy)(const struct x509_object_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_OBJECT_freefunc_type(void (*fr)(struct x509_object_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct X509_VERIFY_PARAM_st* ossl_check_X509_VERIFY_PARAM_type(struct X509_VERIFY_PARAM_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_VERIFY_PARAM_sk_type(const struct stack_st_X509_VERIFY_PARAM* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_VERIFY_PARAM_sk_type(struct stack_st_X509_VERIFY_PARAM* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_VERIFY_PARAM_compfunc_type(int (*cmp)(const struct X509_VERIFY_PARAM_st**,const struct X509_VERIFY_PARAM_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_VERIFY_PARAM_copyfunc_type(struct X509_VERIFY_PARAM_st* (*cpy)(const struct X509_VERIFY_PARAM_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_VERIFY_PARAM_freefunc_type(void (*fr)(struct X509_VERIFY_PARAM_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct x509_trust_st* ossl_check_X509_TRUST_type(struct x509_trust_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_X509_TRUST_sk_type(const struct stack_st_X509_TRUST* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_X509_TRUST_sk_type(struct stack_st_X509_TRUST* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_X509_TRUST_compfunc_type(int (*cmp)(const struct x509_trust_st**,const struct x509_trust_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_X509_TRUST_copyfunc_type(struct x509_trust_st* (*cpy)(const struct x509_trust_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_X509_TRUST_freefunc_type(void (*fr)(struct x509_trust_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct pkcs7_signer_info_st* ossl_check_PKCS7_SIGNER_INFO_type(struct pkcs7_signer_info_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_PKCS7_SIGNER_INFO_sk_type(const struct stack_st_PKCS7_SIGNER_INFO* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_PKCS7_SIGNER_INFO_sk_type(struct stack_st_PKCS7_SIGNER_INFO* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_PKCS7_SIGNER_INFO_compfunc_type(int (*cmp)(const struct pkcs7_signer_info_st**,const struct pkcs7_signer_info_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_PKCS7_SIGNER_INFO_copyfunc_type(struct pkcs7_signer_info_st* (*cpy)(const struct pkcs7_signer_info_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_PKCS7_SIGNER_INFO_freefunc_type(void (*fr)(struct pkcs7_signer_info_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct pkcs7_recip_info_st* ossl_check_PKCS7_RECIP_INFO_type(struct pkcs7_recip_info_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_PKCS7_RECIP_INFO_sk_type(const struct stack_st_PKCS7_RECIP_INFO* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_PKCS7_RECIP_INFO_sk_type(struct stack_st_PKCS7_RECIP_INFO* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_PKCS7_RECIP_INFO_compfunc_type(int (*cmp)(const struct pkcs7_recip_info_st**,const struct pkcs7_recip_info_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_PKCS7_RECIP_INFO_copyfunc_type(struct pkcs7_recip_info_st* (*cpy)(const struct pkcs7_recip_info_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_PKCS7_RECIP_INFO_freefunc_type(void (*fr)(struct pkcs7_recip_info_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct pkcs7_st* ossl_check_PKCS7_type(struct pkcs7_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_PKCS7_sk_type(const struct stack_st_PKCS7* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_PKCS7_sk_type(struct stack_st_PKCS7* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_PKCS7_compfunc_type(int (*cmp)(const struct pkcs7_st**,const struct pkcs7_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_PKCS7_copyfunc_type(struct pkcs7_st* (*cpy)(const struct pkcs7_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_PKCS7_freefunc_type(void (*fr)(struct pkcs7_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct anonymous_typeX45* ossl_check_CONF_VALUE_type(struct anonymous_typeX45* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_CONF_VALUE_sk_type(const struct stack_st_CONF_VALUE* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_CONF_VALUE_sk_type(struct stack_st_CONF_VALUE* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_CONF_VALUE_compfunc_type(int (*cmp)(const struct anonymous_typeX45**,const struct anonymous_typeX45**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_CONF_VALUE_copyfunc_type(struct anonymous_typeX45* (*cpy)(const struct anonymous_typeX45*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_CONF_VALUE_freefunc_type(void (*fr)(struct anonymous_typeX45*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static unsigned long  int lh_CONF_VALUE_hash_thunk(const void* data, unsigned long  int (*hfn)(const void*)  )
{
    unsigned long  int (*hfn_conv)(const struct anonymous_typeX45*);
    hfn_conv=(unsigned long  int (*)(const struct anonymous_typeX45*))hfn;
    return hfn_conv((const struct anonymous_typeX45*)data);
}

static int lh_CONF_VALUE_comp_thunk(const void* da, const void* db, int (*cfn)(const void*,const void*)  )
{
    int (*cfn_conv)(const struct anonymous_typeX45*,const struct anonymous_typeX45*);
    cfn_conv=(int (*)(const struct anonymous_typeX45*,const struct anonymous_typeX45*))cfn;
    return cfn_conv((const struct anonymous_typeX45*)da,(const struct anonymous_typeX45*)db);
}

static void lh_CONF_VALUE_doall_thunk(void* node, void (*doall)(void*)  )
{
    void (*doall_conv)(struct anonymous_typeX45*);
    doall_conv=(void (*)(struct anonymous_typeX45*))doall;
    doall_conv((struct anonymous_typeX45*)node);
}

static void lh_CONF_VALUE_doall_arg_thunk(void* node, void* arg, void (*doall)(void*,void*)  )
{
    void (*doall_conv)(struct anonymous_typeX45*,void*);
    doall_conv=(void (*)(struct anonymous_typeX45*,void*))doall;
    doall_conv((struct anonymous_typeX45*)node,arg);
}

static struct anonymous_typeX45* ossl_check_CONF_VALUE_lh_plain_type(struct anonymous_typeX45* ptr  )
{
    return ptr;
}

static const struct anonymous_typeX45* ossl_check_const_CONF_VALUE_lh_plain_type(const struct anonymous_typeX45* ptr  )
{
    return ptr;
}

static const struct lhash_st* ossl_check_const_CONF_VALUE_lh_type(const struct lhash_st_CONF_VALUE* lh  )
{
    return (const struct lhash_st*)lh;
}

static struct lhash_st* ossl_check_CONF_VALUE_lh_type(struct lhash_st_CONF_VALUE* lh  )
{
    return (struct lhash_st*)lh;
}

static int (*ossl_check_CONF_VALUE_lh_compfunc_type(int (*cmp)(const struct anonymous_typeX45*,const struct anonymous_typeX45*)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static unsigned long  int (*ossl_check_CONF_VALUE_lh_hashfunc_type(unsigned long  int (*hfn)(const struct anonymous_typeX45*)  ))(const void*) 
{
    return (unsigned long  int (*)(const void*))hfn;
}

static void (*ossl_check_CONF_VALUE_lh_doallfunc_type(void (*dfn)(struct anonymous_typeX45*)  ))(void*) 
{
    return (void (*)(void*))dfn;
}

static struct sct_st* ossl_check_SCT_type(struct sct_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_SCT_sk_type(const struct stack_st_SCT* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_SCT_sk_type(struct stack_st_SCT* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_SCT_compfunc_type(int (*cmp)(const struct sct_st**,const struct sct_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_SCT_copyfunc_type(struct sct_st* (*cpy)(const struct sct_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_SCT_freefunc_type(void (*fr)(struct sct_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct ctlog_st* ossl_check_CTLOG_type(struct ctlog_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_CTLOG_sk_type(const struct stack_st_CTLOG* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_CTLOG_sk_type(struct stack_st_CTLOG* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_CTLOG_compfunc_type(int (*cmp)(const struct ctlog_st**,const struct ctlog_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_CTLOG_copyfunc_type(struct ctlog_st* (*cpy)(const struct ctlog_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_CTLOG_freefunc_type(void (*fr)(struct ctlog_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct srtp_protection_profile_st* ossl_check_SRTP_PROTECTION_PROFILE_type(struct srtp_protection_profile_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(const struct stack_st_SRTP_PROTECTION_PROFILE* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_SRTP_PROTECTION_PROFILE_sk_type(struct stack_st_SRTP_PROTECTION_PROFILE* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_SRTP_PROTECTION_PROFILE_compfunc_type(int (*cmp)(const struct srtp_protection_profile_st**,const struct srtp_protection_profile_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_SRTP_PROTECTION_PROFILE_copyfunc_type(struct srtp_protection_profile_st* (*cpy)(const struct srtp_protection_profile_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_SRTP_PROTECTION_PROFILE_freefunc_type(void (*fr)(struct srtp_protection_profile_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static const struct ssl_cipher_st* ossl_check_SSL_CIPHER_type(const struct ssl_cipher_st* ptr  )
{
    return ptr;
}

static const struct stack_st* ossl_check_const_SSL_CIPHER_sk_type(const struct stack_st_SSL_CIPHER* sk  )
{
    return (const struct stack_st*)sk;
}

static struct stack_st* ossl_check_SSL_CIPHER_sk_type(struct stack_st_SSL_CIPHER* sk  )
{
    return (struct stack_st*)sk;
}

static int (*ossl_check_SSL_CIPHER_compfunc_type(int (*cmp)(const struct ssl_cipher_st**,const struct ssl_cipher_st**)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static void* (*ossl_check_SSL_CIPHER_copyfunc_type(struct ssl_cipher_st* (*cpy)(const struct ssl_cipher_st*)  ))(const void*) 
{
    return (void* (*)(const void*))cpy;
}

static void (*ossl_check_SSL_CIPHER_freefunc_type(void (*fr)(struct ssl_cipher_st*)  ))(void*) 
{
    return (void (*)(void*))fr;
}

static struct bio_poll_descriptor_st SSL_as_poll_descriptor(struct ssl_st* s  )
{
    struct bio_poll_descriptor_st d  ;
    memset(&d, 0, sizeof(d));
    d.type=2;
    d.value.ssl=s;
    return d;
}

static int ERR_GET_LIB(unsigned long  int errcode)
{
    if((((errcode)&((unsigned int)2147483647+1))!=0)) {
        return 2;
    }
    return (errcode>>23L)&0xFF;
}

static int ERR_GET_RFLAGS(unsigned long  int errcode)
{
    if((((errcode)&((unsigned int)2147483647+1))!=0)) {
        return 0;
    }
    return errcode&(0x1F<<18L);
}

static int ERR_GET_REASON(unsigned long  int errcode)
{
    if((((errcode)&((unsigned int)2147483647+1))!=0)) {
        return errcode&((unsigned int)2147483647);
    }
    return errcode&0x7FFFFF;
}

static int ERR_FATAL_ERROR(unsigned long  int errcode)
{
    return (ERR_GET_RFLAGS(errcode)&(0x1<<18L))!=0;
}

static int ERR_COMMON_ERROR(unsigned long  int errcode)
{
    return (ERR_GET_RFLAGS(errcode)&(0x2<<18L))!=0;
}

static unsigned long  int lh_ERR_STRING_DATA_hash_thunk(const void* data, unsigned long  int (*hfn)(const void*)  )
{
    unsigned long  int (*hfn_conv)(const struct ERR_string_data_st*);
    hfn_conv=(unsigned long  int (*)(const struct ERR_string_data_st*))hfn;
    return hfn_conv((const struct ERR_string_data_st*)data);
}

static int lh_ERR_STRING_DATA_comp_thunk(const void* da, const void* db, int (*cfn)(const void*,const void*)  )
{
    int (*cfn_conv)(const struct ERR_string_data_st*,const struct ERR_string_data_st*);
    cfn_conv=(int (*)(const struct ERR_string_data_st*,const struct ERR_string_data_st*))cfn;
    return cfn_conv((const struct ERR_string_data_st*)da,(const struct ERR_string_data_st*)db);
}

static void lh_ERR_STRING_DATA_doall_thunk(void* node, void (*doall)(void*)  )
{
    void (*doall_conv)(struct ERR_string_data_st*);
    doall_conv=(void (*)(struct ERR_string_data_st*))doall;
    doall_conv((struct ERR_string_data_st*)node);
}

static void lh_ERR_STRING_DATA_doall_arg_thunk(void* node, void* arg, void (*doall)(void*,void*)  )
{
    void (*doall_conv)(struct ERR_string_data_st*,void*);
    doall_conv=(void (*)(struct ERR_string_data_st*,void*))doall;
    doall_conv((struct ERR_string_data_st*)node,arg);
}

static struct ERR_string_data_st* ossl_check_ERR_STRING_DATA_lh_plain_type(struct ERR_string_data_st* ptr  )
{
    return ptr;
}

static const struct ERR_string_data_st* ossl_check_const_ERR_STRING_DATA_lh_plain_type(const struct ERR_string_data_st* ptr  )
{
    return ptr;
}

static const struct lhash_st* ossl_check_const_ERR_STRING_DATA_lh_type(const struct lhash_st_ERR_STRING_DATA* lh  )
{
    return (const struct lhash_st*)lh;
}

static struct lhash_st* ossl_check_ERR_STRING_DATA_lh_type(struct lhash_st_ERR_STRING_DATA* lh  )
{
    return (struct lhash_st*)lh;
}

static int (*ossl_check_ERR_STRING_DATA_lh_compfunc_type(int (*cmp)(const struct ERR_string_data_st*,const struct ERR_string_data_st*)  ))(const void*,const void*) 
{
    return (int (*)(const void*,const void*))cmp;
}

static unsigned long  int (*ossl_check_ERR_STRING_DATA_lh_hashfunc_type(unsigned long  int (*hfn)(const struct ERR_string_data_st*)  ))(const void*) 
{
    return (unsigned long  int (*)(const void*))hfn;
}

static void (*ossl_check_ERR_STRING_DATA_lh_doallfunc_type(void (*dfn)(struct ERR_string_data_st*)  ))(void*) 
{
    return (void (*)(void*))dfn;
}

struct sType* sType_initialize(struct sType* self, char* class_name  , int array_num, _Bool auto_increment, _Bool primary_key, _Bool not_null)
{
    char* __dec_obj1  ;
    struct sType* __result_obj__0;
    __dec_obj1=self->class_name,
    self->class_name=(char*)come_increment_ref_count(class_name);
    __dec_obj1 = come_decrement_ref_count(__dec_obj1, (void*)0, (void*)0, 0,0, (void*)0);
    self->array_num=array_num;
    self->auto_increment=auto_increment;
    self->primary_key=primary_key;
    self->not_null=not_null;
    __result_obj__0 = (struct sType*)come_increment_ref_count(self);
    come_call_finalizer(sType_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    (class_name = come_decrement_ref_count(class_name, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(sType_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

char* sType_to_string(struct sType* self)
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    char* __result_obj__0  ;
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "main.nc", 23, "struct buffer*"))));
    buffer_append_str(buf,self->class_name);
    if(self->array_num>0) {
        buffer_append_str(buf,"(");
        buffer_append_str(buf,((char*)(__right_value0=int_to_string(self->array_num))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        buffer_append_str(buf,")");
    }
    if(self->auto_increment) {
        buffer_append_str(buf," AUTO INCREMENT");
    }
    if(self->primary_key) {
        buffer_append_str(buf," PRIMARY KEY");
    }
    if(self->not_null) {
        buffer_append_str(buf," NOT NULL");
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(buf))));
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

static void sType_finalize(struct sType* self)
{
    if(self!=((void*)0)&&self->class_name!=((void*)0)) {
        (self->class_name = come_decrement_ref_count(self->class_name, (void*)0, (void*)0, 0, 0, (void*)0));
    }
}

struct Table* Table_initialize(struct Table* self, char* name  , struct list$1tuple2$2char$phsType$ph$ph* types)
{
    char* __dec_obj2  ;
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1map$2char$phchar$ph$ph* __dec_obj3;
    struct list$1tuple2$2char$phsType$ph$ph* __dec_obj4;
    struct Table* __result_obj__0;
    __dec_obj2=self->name,
    self->name=(char*)come_increment_ref_count(name);
    __dec_obj2 = come_decrement_ref_count(__dec_obj2, (void*)0, (void*)0, 0,0, (void*)0);
    __dec_obj3=self->rows,
    self->rows=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(list$1map$2char$phchar$ph$ph_initialize((struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count((struct list$1map$2char$phchar$ph$ph*)come_calloc(1, sizeof(struct list$1map$2char$phchar$ph$ph)*(1), "main.nc", 55, "struct list$1map$2char$phchar$ph$ph*"))));
    come_call_finalizer(list$1map$2char$phchar$ph$ph_finalize, __dec_obj3,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    __dec_obj4=self->types,
    self->types=(struct list$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(types);
    come_call_finalizer(list$1tuple2$2char$phsType$ph$ph_finalize, __dec_obj4,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    __result_obj__0 = (struct Table*)come_increment_ref_count(self);
    come_call_finalizer(Table_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    (name = come_decrement_ref_count(name, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, types, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

char* Table_to_string(struct Table* self)
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    struct list$1tuple2$2char$phsType$ph$ph* o2_saved;
    struct tuple2$2char$phsType$ph* it;
    struct tuple2$2char$phsType$ph* multiple_assign_var1
;    char* name  =0;
    struct sType* type  =0;
    char* __result_obj__0  ;
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "main.nc", 60, "struct buffer*"))));
    for(o2_saved=(struct list$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(self->types),it=list$1tuple2$2char$phsType$ph$ph_begin(o2_saved);!list$1tuple2$2char$phsType$ph$ph_end(o2_saved);it=list$1tuple2$2char$phsType$ph$ph_next(o2_saved)){
        multiple_assign_var1=it;
        name=(char*)come_increment_ref_count(multiple_assign_var1->v1);
        type=(struct sType*)come_increment_ref_count(multiple_assign_var1->v2);
        buffer_append_str(buf,name);
        buffer_append_str(buf,":");
        buffer_append_str(buf,((char*)(__right_value0=sType_to_string(type))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        buffer_append_str(buf,"\n");
        (name = come_decrement_ref_count(name, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(sType_finalize, type, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, o2_saved, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(buf))));
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

static struct list$1map$2char$phchar$ph$ph* list$1map$2char$phchar$ph$ph_initialize(struct list$1map$2char$phchar$ph$ph* self)
{
    struct list$1map$2char$phchar$ph$ph* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    __result_obj__0 = (struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(self);
    come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static void list$1map$2char$phchar$ph$ph$p_finalize(struct list$1map$2char$phchar$ph$ph* self)
{
    struct list_item$1map$2char$phchar$ph$ph* it;
    struct list_item$1map$2char$phchar$ph$ph* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1map$2char$phchar$ph$ph$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1map$2char$phchar$ph$ph$p_finalize(struct list_item$1map$2char$phchar$ph$ph* self)
{
    if(self!=((void*)0)&&self->item!=((void*)0)) {
        come_call_finalizer(map$2char$phchar$ph$p_finalize, self->item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void map$2char$phchar$ph$p_finalize(struct map$2char$phchar$ph* self)
{
    int i;
    int i_0;
    for(i=0;i<self->size;i++){
        if(self->item_existance[i]) {
            if(1) {
                (self->items[i] = come_decrement_ref_count(self->items[i], (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
    }
    come_free((char*)self->items);
    for(i_0=0;i_0<self->size;i_0++){
        if(self->item_existance[i_0]) {
            if(1) {
                (self->keys[i_0] = come_decrement_ref_count(self->keys[i_0], (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
    }
    come_free((char*)self->keys);
    come_call_finalizer(list$1char$ph$p_finalize, self->key_list, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
}

static void list$1char$ph$p_finalize(struct list$1char$ph* self)
{
    struct list_item$1char$ph* it;
    struct list_item$1char$ph* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1char$ph$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1char$ph$p_finalize(struct list_item$1char$ph* self)
{
    if(self!=((void*)0)&&self->item!=((void*)0)) {
        (self->item = come_decrement_ref_count(self->item, (void*)0, (void*)0, 0, 0, (void*)0));
    }
}

static void list$1map$2char$phchar$ph$ph_finalize(struct list$1map$2char$phchar$ph$ph* self)
{
    struct list_item$1map$2char$phchar$ph$ph* it;
    struct list_item$1map$2char$phchar$ph$ph* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1map$2char$phchar$ph$ph$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list$1tuple2$2char$phsType$ph$ph_finalize(struct list$1tuple2$2char$phsType$ph$ph* self)
{
    struct list_item$1tuple2$2char$phsType$ph$ph* it;
    struct list_item$1tuple2$2char$phsType$ph$ph* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1tuple2$2char$phsType$ph$ph$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1tuple2$2char$phsType$ph$ph$p_finalize(struct list_item$1tuple2$2char$phsType$ph$ph* self)
{
    if(self!=((void*)0)&&self->item!=((void*)0)) {
        come_call_finalizer(tuple2$2char$phsType$ph$p_finalize, self->item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void tuple2$2char$phsType$ph$p_finalize(struct tuple2$2char$phsType$ph* self)
{
    if(self!=((void*)0)&&self->v1!=((void*)0)) {
        (self->v1 = come_decrement_ref_count(self->v1, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    if(self!=((void*)0)&&self->v2!=((void*)0)) {
        come_call_finalizer(sType_finalize, self->v2, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void Table_finalize(struct Table* self)
{
    if(self!=((void*)0)&&self->name!=((void*)0)) {
        (self->name = come_decrement_ref_count(self->name, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    if(self!=((void*)0)&&self->rows!=((void*)0)) {
        come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, self->rows, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    if(self!=((void*)0)&&self->types!=((void*)0)) {
        come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, self->types, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list$1tuple2$2char$phsType$ph$ph$p_finalize(struct list$1tuple2$2char$phsType$ph$ph* self)
{
    struct list_item$1tuple2$2char$phsType$ph$ph* it;
    struct list_item$1tuple2$2char$phsType$ph$ph* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1tuple2$2char$phsType$ph$ph$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static struct tuple2$2char$phsType$ph* list$1tuple2$2char$phsType$ph$ph_begin(struct list$1tuple2$2char$phsType$ph$ph* self)
{
    struct tuple2$2char$phsType$ph* result;
    struct tuple2$2char$phsType$ph* __result_obj__0;
    struct tuple2$2char$phsType$ph* result_1;
    if(self==((void*)0)) {
        memset(&result,0,sizeof(struct tuple2$2char$phsType$ph*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->it=self->head;
    if(self->it) {
        __result_obj__0 = self->it->item;
        return __result_obj__0;
    }
    memset(&result_1,0,sizeof(struct tuple2$2char$phsType$ph*));
    __result_obj__0 = result_1;
    return __result_obj__0;
}

static _Bool list$1tuple2$2char$phsType$ph$ph_end(struct list$1tuple2$2char$phsType$ph$ph* self)
{
    return self==((void*)0)||self->it==((void*)0);
}

static struct tuple2$2char$phsType$ph* list$1tuple2$2char$phsType$ph$ph_next(struct list$1tuple2$2char$phsType$ph$ph* self)
{
    struct tuple2$2char$phsType$ph* result;
    struct tuple2$2char$phsType$ph* __result_obj__0;
    struct tuple2$2char$phsType$ph* result_2;
    if(self==((void*)0)||self->it==((void*)0)) {
        memset(&result,0,sizeof(struct tuple2$2char$phsType$ph*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->it=self->it->next;
    if(self->it) {
        __result_obj__0 = self->it->item;
        return __result_obj__0;
    }
    memset(&result_2,0,sizeof(struct tuple2$2char$phsType$ph*));
    __result_obj__0 = result_2;
    return __result_obj__0;
}

struct Database* Database_initialize(struct Database* self, char* name  )
{
    char* __dec_obj5  ;
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct map$2char$phTable$ph* __dec_obj7;
    struct Database* __result_obj__0;
    __dec_obj5=self->name,
    self->name=(char*)come_increment_ref_count(name);
    __dec_obj5 = come_decrement_ref_count(__dec_obj5, (void*)0, (void*)0, 0,0, (void*)0);
    __dec_obj7=self->tables,
    self->tables=(struct map$2char$phTable$ph*)come_increment_ref_count(map$2char$phTable$ph_initialize((struct map$2char$phTable$ph*)come_increment_ref_count((struct map$2char$phTable$ph*)come_calloc(1, sizeof(struct map$2char$phTable$ph)*(1), "main.nc", 82, "struct map$2char$phTable$ph*"))));
    come_call_finalizer(map$2char$phTable$ph_finalize, __dec_obj7,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    __result_obj__0 = (struct Database*)come_increment_ref_count(self);
    come_call_finalizer(Database_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    (name = come_decrement_ref_count(name, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct map$2char$phTable$ph* map$2char$phTable$ph_initialize(struct map$2char$phTable$ph* self)
{
    void* __right_value0 = (void*)0;
    int i;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* __dec_obj6;
    struct map$2char$phTable$ph* __result_obj__0;
    self->keys=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(128)), "/usr/local/include/neo-c.h", 1999, "char**"))));
    self->items=(struct Table**)come_increment_ref_count(((struct Table**)(__right_value0=(struct Table**)come_calloc(1, sizeof(struct Table*)*(1*(128)), "/usr/local/include/neo-c.h", 2000, "struct Table**"))));
    self->item_existance=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(128)), "/usr/local/include/neo-c.h", 2001, "_Bool*"))));
    for(i=0;i<128;i++){
        self->item_existance[i]=0;
    }
    self->size=128;
    self->len=0;
    __dec_obj6=self->key_list,
    self->key_list=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 2011, "struct list$1char$ph*"))));
    come_call_finalizer(list$1char$ph_finalize, __dec_obj6,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    self->it=0;
    __result_obj__0 = (struct map$2char$phTable$ph*)come_increment_ref_count(self);
    come_call_finalizer(map$2char$phTable$ph$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(map$2char$phTable$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1char$ph* list$1char$ph_initialize(struct list$1char$ph* self)
{
    struct list$1char$ph* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(self);
    come_call_finalizer(list$1char$ph$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static void list$1char$ph_finalize(struct list$1char$ph* self)
{
    struct list_item$1char$ph* it;
    struct list_item$1char$ph* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1char$ph$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void map$2char$phTable$ph$p_finalize(struct map$2char$phTable$ph* self)
{
    int i;
    int i_3;
    for(i=0;i<self->size;i++){
        if(self->item_existance[i]) {
            if(1) {
                come_call_finalizer(Table_finalize, self->items[i], (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
    }
    come_free((char*)self->items);
    for(i_3=0;i_3<self->size;i_3++){
        if(self->item_existance[i_3]) {
            if(1) {
                (self->keys[i_3] = come_decrement_ref_count(self->keys[i_3], (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
    }
    come_free((char*)self->keys);
    come_call_finalizer(list$1char$ph$p_finalize, self->key_list, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
}

static void map$2char$phTable$ph_finalize(struct map$2char$phTable$ph* self)
{
    int i;
    int i_4;
    for(i=0;i<self->size;i++){
        if(self->item_existance[i]) {
            if(1) {
                come_call_finalizer(Table_finalize, self->items[i], (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
    }
    come_free((char*)self->items);
    for(i_4=0;i_4<self->size;i_4++){
        if(self->item_existance[i_4]) {
            if(1) {
                (self->keys[i_4] = come_decrement_ref_count(self->keys[i_4], (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
    }
    come_free((char*)self->keys);
    come_call_finalizer(list$1char$ph$p_finalize, self->key_list, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
}

static void Database_finalize(struct Database* self)
{
    if(self!=((void*)0)&&self->name!=((void*)0)) {
        (self->name = come_decrement_ref_count(self->name, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    if(self!=((void*)0)&&self->tables!=((void*)0)) {
        come_call_finalizer(map$2char$phTable$ph$p_finalize, self->tables, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

void skip_spaces(struct sInfo* info  )
{
    while(*info->p==32||*info->p==9) {
        info->p++;
    }
}

char* parse_word(struct sInfo* info  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    char* __result_obj__0  ;
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "main.nc", 106, "struct buffer*"))));
    while(*info->p) {
        if(*info->p==32||*info->p==9||*info->p==10||*info->p==13) {
            break;
        }
        else if(!xisalnum(*info->p)&&*info->p!=95&&*info->p!=45) {
            break;
        }
        else {
            buffer_append_char(buf,*info->p);
            info->p++;
        }
    }
    skip_spaces(info);
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(buf))));
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

_Bool expected_next_charactor(char c, struct sInfo* info  )
{
    if(*info->p==c) {
        info->p++;
        skip_spaces(info);
    }
    else {
        printf("expected character(%c), but it is %c.\n",c,*info->p);
        return 0;
    }
    return 1;
}

struct tuple3$3char$phsType$ph_Bool$* parse_type(struct sInfo* info  )
{
    void* __right_value0 = (void*)0;
    char* field_name  ;
    char* class_name  ;
    int array_num;
    _Bool auto_increment;
    _Bool primary_key;
    _Bool not_null;
    int n;
    void* __right_value1 = (void*)0;
    struct sType* type_  ;
    struct tuple3$3char$phsType$ph_Bool$* __result_obj__0;
    field_name=(char*)come_increment_ref_count(parse_word(info));
    class_name=(char*)come_increment_ref_count(parse_word(info));
    array_num=0;
    auto_increment=0;
    primary_key=0;
    not_null=0;
    while(1) {
        if(*info->p==40) {
            info->p++;
            skip_spaces(info);
            n=0;
            while(xisdigit(*info->p)) {
                n=n*10+*info->p-48;
                info->p++;
                skip_spaces(info);
            }
            skip_spaces(info);
            array_num=n;
            expected_next_charactor(41,info);
        }
        else if(strncmp(info->p,"AUTO_INCREMENT",strlen("AUTO_INCREMENT"))==0) {
            info->p+=strlen("AUTO_INCREMENT");
            skip_spaces(info);
            auto_increment=1;
        }
        else if(strncmp(info->p,"PRIMARY KEY",strlen("PRIMARY KEY"))==0) {
            info->p+=strlen("PRIMARY KEY");
            skip_spaces(info);
            primary_key=1;
        }
        else if(strncmp(info->p,"NOT NULL",strlen("NOT NULL"))==0) {
            info->p+=strlen("NOT NULL");
            skip_spaces(info);
            not_null=1;
        }
        else {
            break;
        }
    }
    type_=(struct sType*)come_increment_ref_count(sType_initialize((struct sType*)come_increment_ref_count((struct sType*)come_calloc(1, sizeof(struct sType)*(1), "main.nc", 190, "struct sType*")),(char*)come_increment_ref_count(class_name),array_num,auto_increment,primary_key,not_null));
    __result_obj__0 = (struct tuple3$3char$phsType$ph_Bool$*)come_increment_ref_count(((struct tuple3$3char$phsType$phint$*)(__right_value1=tuple3$3char$phsType$phint$_initialize((struct tuple3$3char$phsType$phint$*)come_increment_ref_count((struct tuple3$3char$phsType$phint$*)come_calloc(1, sizeof(struct tuple3$3char$phsType$phint$)*(1), "main.nc", 192, "struct tuple3$3char$phsType$phint$")),(char*)come_increment_ref_count(field_name),(struct sType*)come_increment_ref_count(type_),0))));
    (field_name = come_decrement_ref_count(field_name, (void*)0, (void*)0, 0, 0, (void*)0));
    (class_name = come_decrement_ref_count(class_name, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(sType_finalize, type_, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(tuple3$3char$phsType$phint$$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(tuple3$3char$phsType$ph_Bool$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct tuple3$3char$phsType$phint$* tuple3$3char$phsType$phint$_initialize(struct tuple3$3char$phsType$phint$* self, char* v1  , struct sType* v2  , int v3)
{
    char* __dec_obj8  ;
    struct sType* __dec_obj9  ;
    struct tuple3$3char$phsType$phint$* __result_obj__0;
    __dec_obj8=self->v1,
    self->v1=(char*)come_increment_ref_count(v1);
    __dec_obj8 = come_decrement_ref_count(__dec_obj8, (void*)0, (void*)0, 0,0, (void*)0);
    __dec_obj9=self->v2,
    self->v2=(struct sType*)come_increment_ref_count(v2);
    come_call_finalizer(sType_finalize, __dec_obj9,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    self->v3=v3;
    __result_obj__0 = (struct tuple3$3char$phsType$phint$*)come_increment_ref_count(self);
    come_call_finalizer(tuple3$3char$phsType$phint$$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    (v1 = come_decrement_ref_count(v1, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(sType_finalize, v2, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(tuple3$3char$phsType$phint$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static void tuple3$3char$phsType$phint$$p_finalize(struct tuple3$3char$phsType$phint$* self)
{
    if(self!=((void*)0)&&self->v1!=((void*)0)) {
        (self->v1 = come_decrement_ref_count(self->v1, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    if(self!=((void*)0)&&self->v2!=((void*)0)) {
        come_call_finalizer(sType_finalize, self->v2, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void tuple3$3char$phsType$ph_Bool$$p_finalize(struct tuple3$3char$phsType$ph_Bool$* self)
{
    if(self!=((void*)0)&&self->v1!=((void*)0)) {
        (self->v1 = come_decrement_ref_count(self->v1, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    if(self!=((void*)0)&&self->v2!=((void*)0)) {
        come_call_finalizer(sType_finalize, self->v2, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

_Bool eval_create_table(struct sInfo* info  )
{
    _Bool if_not_exists;
    void* __right_value0 = (void*)0;
    char* table_name  ;
    void* __right_value1 = (void*)0;
    struct list$1tuple2$2char$phsType$ph$ph* types;
    struct tuple3$3char$phsType$ph_Bool$* multiple_assign_var2
;    char* field_name  =0;
    struct sType* type  =0;
    _Bool err=0;
    struct Database* current_db  ;
    _Bool _conditional_value_X0;
    _Bool __result_obj__0;
    info->p+=strlen("CREATE TABLE");
    skip_spaces(info);
    if_not_exists=0;
    if(strncmp(info->p,"IF NOT EXISTS",strlen("IF NOT EXISTS"))==0) {
        info->p+=strlen("IF NOT EXISTS");
        skip_spaces(info);
        if_not_exists=1;
    }
    table_name=(char*)come_increment_ref_count(parse_word(info));
    expected_next_charactor(40,info);
    types=(struct list$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(list$1tuple2$2char$phsType$ph$ph_initialize((struct list$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count((struct list$1tuple2$2char$phsType$ph$ph*)come_calloc(1, sizeof(struct list$1tuple2$2char$phsType$ph$ph)*(1), "main.nc", 212, "struct list$1tuple2$2char$phsType$ph$ph*"))));
    while(1) {
        multiple_assign_var2=((struct tuple3$3char$phsType$ph_Bool$*)(__right_value0=parse_type(info)));
        field_name=(char*)come_increment_ref_count(multiple_assign_var2->v1);
        type=(struct sType*)come_increment_ref_count(multiple_assign_var2->v2);
        err=multiple_assign_var2->v3;
        come_call_finalizer(tuple3$3char$phsType$ph_Bool$$p_finalize, __right_value0, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        list$1tuple2$2char$phsType$ph$ph_add(types,(struct tuple2$2char$phsType$ph*)come_increment_ref_count(tuple2$2char$phsType$ph_initialize((struct tuple2$2char$phsType$ph*)come_increment_ref_count((struct tuple2$2char$phsType$ph*)come_calloc(1, sizeof(struct tuple2$2char$phsType$ph)*(1), "main.nc", 218, "struct tuple2$2char$phsType$ph")),(char*)come_increment_ref_count(field_name),(struct sType*)come_increment_ref_count(type))));
        if(*info->p==41) {
            (field_name = come_decrement_ref_count(field_name, (void*)0, (void*)0, 0, 0, (void*)0));
            come_call_finalizer(sType_finalize, type, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            break;
        }
        expected_next_charactor(44,info);
        (field_name = come_decrement_ref_count(field_name, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(sType_finalize, type, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    expected_next_charactor(41,info);
    current_db=(struct Database*)come_increment_ref_count(map$2char$phDatabase$ph_operator_load_element(gDatabases,info->current_db_name));
    if(({(_conditional_value_X0=(((struct Table*)(__right_value0=map$2char$phTable$ph_operator_load_element(current_db->tables,table_name)))==((void*)0)));    come_call_finalizer(Table_finalize, __right_value0, (void*)0, (void*)0, 0, 1, 0, (void*)0);
_conditional_value_X0;})) {
        map$2char$phTable$ph_insert(current_db->tables,(char*)come_increment_ref_count(table_name),(struct Table*)come_increment_ref_count(Table_initialize((struct Table*)come_increment_ref_count((struct Table*)come_calloc(1, sizeof(struct Table)*(1), "main.nc", 232, "struct Table*")),(char*)come_increment_ref_count(table_name),(struct list$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(types))));
        __result_obj__0 = 1;
        (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, types, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(Database_finalize, current_db, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    else if(if_not_exists) {
        __result_obj__0 = 1;
        (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, types, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(Database_finalize, current_db, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    else {
        __result_obj__0 = 0;
        (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, types, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(Database_finalize, current_db, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, types, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(Database_finalize, current_db, (void*)0, (void*)0, 0, 0, 0, (void*)0);
}

static struct list$1tuple2$2char$phsType$ph$ph* list$1tuple2$2char$phsType$ph$ph_initialize(struct list$1tuple2$2char$phsType$ph$ph* self)
{
    struct list$1tuple2$2char$phsType$ph$ph* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    __result_obj__0 = (struct list$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(self);
    come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1tuple2$2char$phsType$ph$ph* list$1tuple2$2char$phsType$ph$ph_add(struct list$1tuple2$2char$phsType$ph$ph* self, struct tuple2$2char$phsType$ph* item)
{
    struct list$1tuple2$2char$phsType$ph$ph* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1tuple2$2char$phsType$ph$ph* litem;
    struct tuple2$2char$phsType$ph* __dec_obj10;
    struct list_item$1tuple2$2char$phsType$ph$ph* litem_5;
    struct tuple2$2char$phsType$ph* __dec_obj11;
    struct list_item$1tuple2$2char$phsType$ph$ph* litem_6;
    struct tuple2$2char$phsType$ph* __dec_obj12;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        come_call_finalizer(tuple2$2char$phsType$ph$p_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(((struct list_item$1tuple2$2char$phsType$ph$ph*)(__right_value0=(struct list_item$1tuple2$2char$phsType$ph$ph*)come_calloc(1, sizeof(struct list_item$1tuple2$2char$phsType$ph$ph)*(1), "/usr/local/include/neo-c.h", 954, "struct list_item$1tuple2$2char$phsType$ph$ph*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        __dec_obj10=litem->item,
        litem->item=(struct tuple2$2char$phsType$ph*)come_increment_ref_count(item);
        come_call_finalizer(tuple2$2char$phsType$ph$p_finalize, __dec_obj10,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_5=(struct list_item$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(((struct list_item$1tuple2$2char$phsType$ph$ph*)(__right_value0=(struct list_item$1tuple2$2char$phsType$ph$ph*)come_calloc(1, sizeof(struct list_item$1tuple2$2char$phsType$ph$ph)*(1), "/usr/local/include/neo-c.h", 964, "struct list_item$1tuple2$2char$phsType$ph$ph*"))));
        litem_5->prev=self->head;
        litem_5->next=((void*)0);
        __dec_obj11=litem_5->item,
        litem_5->item=(struct tuple2$2char$phsType$ph*)come_increment_ref_count(item);
        come_call_finalizer(tuple2$2char$phsType$ph$p_finalize, __dec_obj11,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        self->tail=litem_5;
        self->head->next=litem_5;
    }
    else {
        litem_6=(struct list_item$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(((struct list_item$1tuple2$2char$phsType$ph$ph*)(__right_value0=(struct list_item$1tuple2$2char$phsType$ph$ph*)come_calloc(1, sizeof(struct list_item$1tuple2$2char$phsType$ph$ph)*(1), "/usr/local/include/neo-c.h", 974, "struct list_item$1tuple2$2char$phsType$ph$ph*"))));
        litem_6->prev=self->tail;
        litem_6->next=((void*)0);
        __dec_obj12=litem_6->item,
        litem_6->item=(struct tuple2$2char$phsType$ph*)come_increment_ref_count(item);
        come_call_finalizer(tuple2$2char$phsType$ph$p_finalize, __dec_obj12,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        self->tail->next=litem_6;
        self->tail=litem_6;
    }
    self->len++;
    __result_obj__0 = self;
    come_call_finalizer(tuple2$2char$phsType$ph$p_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    return __result_obj__0;
}

static struct tuple2$2char$phsType$ph* tuple2$2char$phsType$ph_initialize(struct tuple2$2char$phsType$ph* self, char* v1  , struct sType* v2  )
{
    char* __dec_obj13  ;
    struct sType* __dec_obj14  ;
    struct tuple2$2char$phsType$ph* __result_obj__0;
    __dec_obj13=self->v1,
    self->v1=(char*)come_increment_ref_count(v1);
    __dec_obj13 = come_decrement_ref_count(__dec_obj13, (void*)0, (void*)0, 0,0, (void*)0);
    __dec_obj14=self->v2,
    self->v2=(struct sType*)come_increment_ref_count(v2);
    come_call_finalizer(sType_finalize, __dec_obj14,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    __result_obj__0 = (struct tuple2$2char$phsType$ph*)come_increment_ref_count(self);
    come_call_finalizer(tuple2$2char$phsType$ph$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    (v1 = come_decrement_ref_count(v1, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(sType_finalize, v2, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(tuple2$2char$phsType$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct Database* map$2char$phDatabase$ph$p_operator_load_element(struct map$2char$phDatabase$ph* self, char* key  )
{
    struct Database* default_value  ;
    struct Database* __result_obj__0  ;
    unsigned int hash;
    unsigned int it;
    memset(&default_value,0,sizeof(struct Database*));
    if(self==((void*)0)) {
        __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
        come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                __result_obj__0 = (struct Database*)come_increment_ref_count(self->items[it]);
                come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
                come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
        }
        else {
            __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
            come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            return __result_obj__0;
        }
    }
    __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
    come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct Database* map$2char$phDatabase$ph_operator_load_element(struct map$2char$phDatabase$ph* self, char* key  )
{
    struct Database* default_value  ;
    struct Database* __result_obj__0  ;
    unsigned int hash;
    unsigned int it;
    memset(&default_value,0,sizeof(struct Database*));
    if(self==((void*)0)) {
        __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
        come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                __result_obj__0 = (struct Database*)come_increment_ref_count(self->items[it]);
                come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
                come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
        }
        else {
            __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
            come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            return __result_obj__0;
        }
    }
    __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
    come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct Table* map$2char$phTable$ph$p_operator_load_element(struct map$2char$phTable$ph* self, char* key  )
{
    struct Table* default_value  ;
    struct Table* __result_obj__0  ;
    unsigned int hash;
    unsigned int it;
    memset(&default_value,0,sizeof(struct Table*));
    if(self==((void*)0)) {
        __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
        come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                __result_obj__0 = (struct Table*)come_increment_ref_count(self->items[it]);
                come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
                come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
        }
        else {
            __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
            come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            return __result_obj__0;
        }
    }
    __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
    come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct Table* map$2char$phTable$ph_operator_load_element(struct map$2char$phTable$ph* self, char* key  )
{
    struct Table* default_value  ;
    struct Table* __result_obj__0  ;
    unsigned int hash;
    unsigned int it;
    memset(&default_value,0,sizeof(struct Table*));
    if(self==((void*)0)) {
        __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
        come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                __result_obj__0 = (struct Table*)come_increment_ref_count(self->items[it]);
                come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
                come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
        }
        else {
            __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
            come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            return __result_obj__0;
        }
    }
    __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
    come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct map$2char$phTable$ph* map$2char$phTable$ph_insert(struct map$2char$phTable$ph* self, char* key  , struct Table* item  )
{
    struct map$2char$phTable$ph* __result_obj__0;
    unsigned int hash;
    unsigned int it;
    _Bool same_key_exist;
    char* it2  ;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(Table_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    if(self->len*10>=self->size) {
        map$2char$phTable$ph_rehash(self);
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                if(1) {
                    list$1char$ph_remove(self->key_list,self->keys[it]);
                    (self->keys[it] = come_decrement_ref_count(self->keys[it], (void*)0, (void*)0, 0, 0, (void*)0));
                    self->keys[it]=(char*)come_increment_ref_count(key);
                }
                else {
                    list$1char$ph_remove(self->key_list,self->keys[it]);
                    self->keys[it]=key;
                }
                if(1) {
                    come_call_finalizer(Table_finalize, self->items[it], (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    self->items[it]=(struct Table*)come_increment_ref_count(item);
                }
                else {
                    self->items[it]=item;
                }
                break;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                printf("unexpected error in map.insert\n");
                stackframe();
                exit(2);
            }
        }
        else {
            self->item_existance[it]=1;
            if(1) {
                self->keys[it]=(char*)come_increment_ref_count(key);
            }
            else {
                self->keys[it]=key;
            }
            if(1) {
                self->items[it]=(struct Table*)come_increment_ref_count(item);
            }
            else {
                self->items[it]=item;
            }
            self->len++;
            break;
        }
    }
    same_key_exist=0;
    for(it2=list$1char$ph_begin(self->key_list);!list$1char$ph_end(self->key_list);it2=list$1char$ph_next(self->key_list)){
        if(string_equals(it2,key)) {
            same_key_exist=1;
        }
    }
    if(!same_key_exist) {
        list$1char$ph_push_back(self->key_list,(char*)come_increment_ref_count(key));
    }
    __result_obj__0 = self;
    (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(Table_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    return __result_obj__0;
}

static void map$2char$phTable$ph_rehash(struct map$2char$phTable$ph* self)
{
    int size;
    void* __right_value0 = (void*)0;
    char** keys  ;
    struct Table** items  ;
    _Bool* item_existance;
    int len;
    char* it  ;
    struct Table* default_value  ;
    struct Table* it2  ;
    unsigned int hash;
    int n;
    struct Table* default_value_9  ;
    size=self->size*10;
    keys=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(size)), "/usr/local/include/neo-c.h", 2299, "char**"))));
    items=(struct Table**)come_increment_ref_count(((struct Table**)(__right_value0=(struct Table**)come_calloc(1, sizeof(struct Table*)*(1*(size)), "/usr/local/include/neo-c.h", 2300, "struct Table**"))));
    item_existance=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(size)), "/usr/local/include/neo-c.h", 2301, "_Bool*"))));
    len=0;
    for(it=map$2char$phTable$ph_begin(self);!map$2char$phTable$ph_end(self);it=map$2char$phTable$ph_next(self)){
        memset(&default_value,0,sizeof(struct Table*));
        it2=((struct Table*)(__right_value0=map$2char$phTable$ph_at(self,it,(struct Table*)come_increment_ref_count(default_value))));
        hash=string_get_hash_key(((char*)it))%size;
        n=hash;
        while(1) {
            if(item_existance[n]) {
                n++;
                if(n>=size) {
                    n=0;
                }
                else if(n==hash) {
                    printf("unexpected error in map.rehash(1)\n");
                    stackframe();
                    exit(2);
                }
            }
            else {
                item_existance[n]=1;
                keys[n]=it;
                memset(&default_value_9,0,sizeof(struct Table*));
                items[n]=((struct Table*)(__right_value0=map$2char$phTable$ph_at(self,it,(struct Table*)come_increment_ref_count(default_value_9))));
                len++;
                come_call_finalizer(Table_finalize, default_value_9, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                break;
                come_call_finalizer(Table_finalize, default_value_9, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
        come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    come_free((char*)self->items);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
    come_free((char*)self->keys);
    self->keys=keys;
    self->items=items;
    self->item_existance=item_existance;
    self->size=size;
    self->len=len;
}

static char* map$2char$phTable$ph_begin(struct map$2char$phTable$ph* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_7  ;
    if(self==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->key_list->it=self->key_list->head;
    if(self->key_list->it) {
        __result_obj__0 = self->key_list->it->item;
        return __result_obj__0;
    }
    memset(&result_7,0,sizeof(char*));
    __result_obj__0 = result_7;
    return __result_obj__0;
}

static _Bool map$2char$phTable$ph_end(struct map$2char$phTable$ph* self)
{
    return self==((void*)0)||self->key_list==((void*)0)||self->key_list->it==((void*)0);
}

static char* map$2char$phTable$ph_next(struct map$2char$phTable$ph* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_8  ;
    if(self==((void*)0)||self->key_list->it==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->key_list->it=self->key_list->it->next;
    if(self->key_list->it) {
        __result_obj__0 = self->key_list->it->item;
        return __result_obj__0;
    }
    memset(&result_8,0,sizeof(char*));
    __result_obj__0 = result_8;
    return __result_obj__0;
}

static struct Table* map$2char$phTable$ph_at(struct map$2char$phTable$ph* self, char* key  , struct Table* default_value  )
{
    struct Table* __result_obj__0  ;
    unsigned int hash;
    unsigned int it;
    if(self==((void*)0)) {
        __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
        come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                __result_obj__0 = (struct Table*)come_increment_ref_count(self->items[it]);
                come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
                come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
        }
        else {
            __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
            come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            return __result_obj__0;
        }
    }
    __result_obj__0 = (struct Table*)come_increment_ref_count(default_value);
    come_call_finalizer(Table_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(Table_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1char$ph* list$1char$ph_remove(struct list$1char$ph* self, char* item  )
{
    struct list$1char$ph* __result_obj__0;
    int it2;
    struct list_item$1char$ph* it;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    it2=0;
    it=self->head;
    while(it!=((void*)0)) {
        if(string_equals(it->item,item)) {
            list$1char$ph_delete(self,it2,it2+1);
            break;
        }
        it2++;
        it=it->next;
    }
    __result_obj__0 = self;
    return __result_obj__0;
}

static struct list$1char$ph* list$1char$ph_delete(struct list$1char$ph* self, int head, int tail)
{
    struct list$1char$ph* __result_obj__0;
    int tmp;
    struct list_item$1char$ph* it;
    int i;
    struct list_item$1char$ph* prev_it;
    struct list_item$1char$ph* it_10;
    int i_11;
    struct list_item$1char$ph* prev_it_12;
    struct list_item$1char$ph* it_13;
    struct list_item$1char$ph* head_prev_it;
    struct list_item$1char$ph* tail_it;
    int i_14;
    struct list_item$1char$ph* prev_it_15;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(head<0) {
        head+=self->len;
    }
    if(tail<0) {
        tail+=self->len+1;
    }
    if(head>tail) {
        tmp=tail;
        tail=head;
        head=tmp;
    }
    if(head<0) {
        head=0;
    }
    if(tail>self->len) {
        tail=self->len;
    }
    if(head>=self->len) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(head==tail) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(head==0&&tail==self->len) {
        list$1char$ph_reset(self);
    }
    else if(head==0) {
        it=self->head;
        i=0;
        while(it!=((void*)0)) {
            if(i<tail) {
                prev_it=it;
                it=it->next;
                i++;
                come_call_finalizer(list_item$1char$ph$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                self->len--;
            }
            else if(i==tail) {
                self->head=it;
                self->head->prev=((void*)0);
                break;
            }
            else {
                it=it->next;
                i++;
            }
        }
    }
    else if(tail==self->len) {
        it_10=self->head;
        i_11=0;
        while(it_10!=((void*)0)) {
            if(i_11==head) {
                self->tail=it_10->prev;
                self->tail->next=((void*)0);
            }
            if(i_11>=head) {
                prev_it_12=it_10;
                it_10=it_10->next;
                i_11++;
                come_call_finalizer(list_item$1char$ph$p_finalize, prev_it_12, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                self->len--;
            }
            else {
                it_10=it_10->next;
                i_11++;
            }
        }
    }
    else {
        it_13=self->head;
        head_prev_it=((void*)0);
        tail_it=((void*)0);
        i_14=0;
        while(it_13!=((void*)0)) {
            if(i_14==head) {
                head_prev_it=it_13->prev;
            }
            if(i_14==tail) {
                tail_it=it_13;
            }
            if(i_14>=head&&i_14<tail) {
                prev_it_15=it_13;
                it_13=it_13->next;
                i_14++;
                come_call_finalizer(list_item$1char$ph$p_finalize, prev_it_15, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                self->len--;
            }
            else {
                it_13=it_13->next;
                i_14++;
            }
        }
        if(head_prev_it!=((void*)0)) {
            head_prev_it->next=tail_it;
        }
        if(tail_it!=((void*)0)) {
            tail_it->prev=head_prev_it;
        }
    }
    __result_obj__0 = self;
    return __result_obj__0;
}

static struct list$1char$ph* list$1char$ph_reset(struct list$1char$ph* self)
{
    struct list$1char$ph* __result_obj__0;
    struct list_item$1char$ph* it;
    struct list_item$1char$ph* prev_it;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1char$ph$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    __result_obj__0 = self;
    return __result_obj__0;
}

static char* list$1char$ph_begin(struct list$1char$ph* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_16  ;
    if(self==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->it=self->head;
    if(self->it) {
        __result_obj__0 = self->it->item;
        return __result_obj__0;
    }
    memset(&result_16,0,sizeof(char*));
    __result_obj__0 = result_16;
    return __result_obj__0;
}

static _Bool list$1char$ph_end(struct list$1char$ph* self)
{
    return self==((void*)0)||self->it==((void*)0);
}

static char* list$1char$ph_next(struct list$1char$ph* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_17  ;
    if(self==((void*)0)||self->it==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->it=self->it->next;
    if(self->it) {
        __result_obj__0 = self->it->item;
        return __result_obj__0;
    }
    memset(&result_17,0,sizeof(char*));
    __result_obj__0 = result_17;
    return __result_obj__0;
}

static struct list$1char$ph* list$1char$ph_push_back(struct list$1char$ph* self, char* item  )
{
    struct list$1char$ph* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1char$ph* litem;
    char* __dec_obj15  ;
    struct list_item$1char$ph* litem_18;
    char* __dec_obj16  ;
    struct list_item$1char$ph* litem_19;
    char* __dec_obj17  ;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        (item = come_decrement_ref_count(item, (void*)0, (void*)0, 0, 0, (void*)0));
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1char$ph*)come_increment_ref_count(((struct list_item$1char$ph*)(__right_value0=(struct list_item$1char$ph*)come_calloc(1, sizeof(struct list_item$1char$ph)*(1), "/usr/local/include/neo-c.h", 1039, "struct list_item$1char$ph*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        __dec_obj15=litem->item,
        litem->item=(char*)come_increment_ref_count(item);
        __dec_obj15 = come_decrement_ref_count(__dec_obj15, (void*)0, (void*)0, 0,0, (void*)0);
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_18=(struct list_item$1char$ph*)come_increment_ref_count(((struct list_item$1char$ph*)(__right_value0=(struct list_item$1char$ph*)come_calloc(1, sizeof(struct list_item$1char$ph)*(1), "/usr/local/include/neo-c.h", 1049, "struct list_item$1char$ph*"))));
        litem_18->prev=self->head;
        litem_18->next=((void*)0);
        __dec_obj16=litem_18->item,
        litem_18->item=(char*)come_increment_ref_count(item);
        __dec_obj16 = come_decrement_ref_count(__dec_obj16, (void*)0, (void*)0, 0,0, (void*)0);
        self->tail=litem_18;
        self->head->next=litem_18;
    }
    else {
        litem_19=(struct list_item$1char$ph*)come_increment_ref_count(((struct list_item$1char$ph*)(__right_value0=(struct list_item$1char$ph*)come_calloc(1, sizeof(struct list_item$1char$ph)*(1), "/usr/local/include/neo-c.h", 1059, "struct list_item$1char$ph*"))));
        litem_19->prev=self->tail;
        litem_19->next=((void*)0);
        __dec_obj17=litem_19->item,
        litem_19->item=(char*)come_increment_ref_count(item);
        __dec_obj17 = come_decrement_ref_count(__dec_obj17, (void*)0, (void*)0, 0,0, (void*)0);
        self->tail->next=litem_19;
        self->tail=litem_19;
    }
    self->len++;
    __result_obj__0 = self;
    (item = come_decrement_ref_count(item, (void*)0, (void*)0, 0, 0, (void*)0));
    return __result_obj__0;
}

char* parse_value(struct sInfo* info  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    char* __result_obj__0  ;
    if(*info->p==39) {
        info->p++;
        skip_spaces(info);
        buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "main.nc", 250, "struct buffer*"))));
        while(1) {
            if(*info->p==92) {
                info->p++;
                if(*info->p!=0) {
                    buffer_append_char(buf,*info->p);
                    info->p++;
                }
            }
            else if(*info->p==0) {
                break;
            }
            else if(*info->p==39) {
                info->p++;
                break;
            }
            else {
                buffer_append_char(buf,*info->p);
                info->p++;
            }
        }
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(buf))));
        come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
        come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    else {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=parse_word(info))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
}

_Bool eval_insert_into(struct sInfo* info  )
{
    void* __right_value0 = (void*)0;
    char* table_name  ;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* field_names;
    char* field  ;
    struct list$1char$ph* values;
    char* value  ;
    _Bool __result_obj__0;
    struct Database* current_db  ;
    struct Table* table  ;
    struct map$2char$phchar$ph* row;
    int n;
    struct list$1char$ph* o2_saved;
    char* it  ;
    char* name  ;
    char* value_22  ;
    int last_index;
    struct map$2char$phchar$ph* last_row;
    struct list$1tuple2$2char$phsType$ph$ph* o2_saved_30;
    struct tuple2$2char$phsType$ph* it_31;
    struct tuple2$2char$phsType$ph* multiple_assign_var3
;    char* name_32  =0;
    struct sType* type  =0;
    void* __right_value2 = (void*)0;
    void* __right_value3 = (void*)0;
    struct list$1tuple2$2char$phsType$ph$ph* o2_saved_33;
    struct tuple2$2char$phsType$ph* it_34;
    struct tuple2$2char$phsType$ph* multiple_assign_var4
;    char* name_35  =0;
    struct sType* type_36  =0;
    info->p+=strlen("INSERT INTO");
    skip_spaces(info);
    table_name=(char*)come_increment_ref_count(parse_word(info));
    skip_spaces(info);
    expected_next_charactor(40,info);
    field_names=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "main.nc", 292, "struct list$1char$ph*"))));
    while(1) {
        field=(char*)come_increment_ref_count(parse_word(info));
        list$1char$ph_add(field_names,(char*)come_increment_ref_count(field));
        if(*info->p==41) {
            (field = come_decrement_ref_count(field, (void*)0, (void*)0, 0, 0, (void*)0));
            break;
        }
        expected_next_charactor(44,info);
        (field = come_decrement_ref_count(field, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    expected_next_charactor(41,info);
    if(strncmp(info->p,"VALUES",strlen("VALUES"))==0) {
        info->p+=strlen("VALUES");
    }
    skip_spaces(info);
    expected_next_charactor(40,info);
    values=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "main.nc", 315, "struct list$1char$ph*"))));
    while(1) {
        value=(char*)come_increment_ref_count(parse_value(info));
        list$1char$ph_add(values,(char*)come_increment_ref_count(value));
        if(*info->p==41) {
            (value = come_decrement_ref_count(value, (void*)0, (void*)0, 0, 0, (void*)0));
            break;
        }
        expected_next_charactor(44,info);
        (value = come_decrement_ref_count(value, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    expected_next_charactor(41,info);
    if(list$1char$ph_length(field_names)!=list$1char$ph_length(values)) {
        __result_obj__0 = 0;
        (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(list$1char$ph$p_finalize, field_names, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    current_db=(struct Database*)come_increment_ref_count(map$2char$phDatabase$ph_operator_load_element(gDatabases,info->current_db_name));
    table=(struct Table*)come_increment_ref_count(map$2char$phTable$ph_operator_load_element(current_db->tables,table_name));
    if(table) {
        row=(struct map$2char$phchar$ph*)come_increment_ref_count(map$2char$phchar$ph_initialize((struct map$2char$phchar$ph*)come_increment_ref_count((struct map$2char$phchar$ph*)come_calloc(1, sizeof(struct map$2char$phchar$ph)*(1), "main.nc", 339, "struct map$2char$phchar$ph*"))));
        n=0;
        for(o2_saved=(struct list$1char$ph*)come_increment_ref_count(field_names),it=list$1char$ph_begin(o2_saved);!list$1char$ph_end(o2_saved);it=list$1char$ph_next(o2_saved)){
            name=(char*)come_increment_ref_count(__builtin_string(it));
            value_22=(char*)come_increment_ref_count(__builtin_string(((char*)(__right_value0=list$1char$ph_operator_load_element(values,n)))));
            (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
            map$2char$phchar$ph_operator_store_element(row,(char*)come_increment_ref_count(name),(char*)come_increment_ref_count(value_22));
            n++;
            (name = come_decrement_ref_count(name, (void*)0, (void*)0, 0, 0, (void*)0));
            (value_22 = come_decrement_ref_count(value_22, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        come_call_finalizer(list$1char$ph$p_finalize, o2_saved, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        last_index=list$1map$2char$phchar$ph$ph_length(table->rows);
        last_row=((struct map$2char$phchar$ph*)(__right_value0=list$1map$2char$phchar$ph$ph_operator_load_element(table->rows,last_index-1)));
        come_call_finalizer(map$2char$phchar$ph$p_finalize, __right_value0, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        if(last_row) {
            for(o2_saved_30=(struct list$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(table->types),it_31=list$1tuple2$2char$phsType$ph$ph_begin(o2_saved_30);!list$1tuple2$2char$phsType$ph$ph_end(o2_saved_30);it_31=list$1tuple2$2char$phsType$ph$ph_next(o2_saved_30)){
                multiple_assign_var3=it_31;
                name_32=(char*)come_increment_ref_count(multiple_assign_var3->v1);
                type=(struct sType*)come_increment_ref_count(multiple_assign_var3->v2);
                if(type->auto_increment) {
                    map$2char$phchar$ph_operator_store_element(row,(char*)come_increment_ref_count(name_32),(char*)come_increment_ref_count(xsprintf("%d",atoi(((char*)(__right_value2=map$2char$phchar$ph_operator_load_element(last_row,name_32))))+1)));
                    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
                    (__right_value2 = come_decrement_ref_count(__right_value2, (void*)0, (void*)0, 1, 0, (void*)0));
                }
                (name_32 = come_decrement_ref_count(name_32, (void*)0, (void*)0, 0, 0, (void*)0));
                come_call_finalizer(sType_finalize, type, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, o2_saved_30, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        }
        else {
            for(o2_saved_33=(struct list$1tuple2$2char$phsType$ph$ph*)come_increment_ref_count(table->types),it_34=list$1tuple2$2char$phsType$ph$ph_begin(o2_saved_33);!list$1tuple2$2char$phsType$ph$ph_end(o2_saved_33);it_34=list$1tuple2$2char$phsType$ph$ph_next(o2_saved_33)){
                multiple_assign_var4=it_34;
                name_35=(char*)come_increment_ref_count(multiple_assign_var4->v1);
                type_36=(struct sType*)come_increment_ref_count(multiple_assign_var4->v2);
                if(type_36->auto_increment) {
                    map$2char$phchar$ph_operator_store_element(row,(char*)come_increment_ref_count(name_35),(char*)come_increment_ref_count(xsprintf("%d",1)));
                }
                (name_35 = come_decrement_ref_count(name_35, (void*)0, (void*)0, 0, 0, (void*)0));
                come_call_finalizer(sType_finalize, type_36, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            come_call_finalizer(list$1tuple2$2char$phsType$ph$ph$p_finalize, o2_saved_33, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        }
        list$1map$2char$phchar$ph$ph_add(table->rows,(struct map$2char$phchar$ph*)come_increment_ref_count(row));
        come_call_finalizer(map$2char$phchar$ph$p_finalize, row, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    else {
        __result_obj__0 = 0;
        (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(list$1char$ph$p_finalize, field_names, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(Database_finalize, current_db, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(Table_finalize, table, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    __result_obj__0 = 1;
    (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(list$1char$ph$p_finalize, field_names, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(Database_finalize, current_db, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(Table_finalize, table, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    return __result_obj__0;
}

static struct list$1char$ph* list$1char$ph_add(struct list$1char$ph* self, char* item  )
{
    struct list$1char$ph* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1char$ph* litem;
    char* __dec_obj18  ;
    struct list_item$1char$ph* litem_20;
    char* __dec_obj19  ;
    struct list_item$1char$ph* litem_21;
    char* __dec_obj20  ;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        (item = come_decrement_ref_count(item, (void*)0, (void*)0, 0, 0, (void*)0));
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1char$ph*)come_increment_ref_count(((struct list_item$1char$ph*)(__right_value0=(struct list_item$1char$ph*)come_calloc(1, sizeof(struct list_item$1char$ph)*(1), "/usr/local/include/neo-c.h", 954, "struct list_item$1char$ph*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        __dec_obj18=litem->item,
        litem->item=(char*)come_increment_ref_count(item);
        __dec_obj18 = come_decrement_ref_count(__dec_obj18, (void*)0, (void*)0, 0,0, (void*)0);
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_20=(struct list_item$1char$ph*)come_increment_ref_count(((struct list_item$1char$ph*)(__right_value0=(struct list_item$1char$ph*)come_calloc(1, sizeof(struct list_item$1char$ph)*(1), "/usr/local/include/neo-c.h", 964, "struct list_item$1char$ph*"))));
        litem_20->prev=self->head;
        litem_20->next=((void*)0);
        __dec_obj19=litem_20->item,
        litem_20->item=(char*)come_increment_ref_count(item);
        __dec_obj19 = come_decrement_ref_count(__dec_obj19, (void*)0, (void*)0, 0,0, (void*)0);
        self->tail=litem_20;
        self->head->next=litem_20;
    }
    else {
        litem_21=(struct list_item$1char$ph*)come_increment_ref_count(((struct list_item$1char$ph*)(__right_value0=(struct list_item$1char$ph*)come_calloc(1, sizeof(struct list_item$1char$ph)*(1), "/usr/local/include/neo-c.h", 974, "struct list_item$1char$ph*"))));
        litem_21->prev=self->tail;
        litem_21->next=((void*)0);
        __dec_obj20=litem_21->item,
        litem_21->item=(char*)come_increment_ref_count(item);
        __dec_obj20 = come_decrement_ref_count(__dec_obj20, (void*)0, (void*)0, 0,0, (void*)0);
        self->tail->next=litem_21;
        self->tail=litem_21;
    }
    self->len++;
    __result_obj__0 = self;
    (item = come_decrement_ref_count(item, (void*)0, (void*)0, 0, 0, (void*)0));
    return __result_obj__0;
}

static int list$1char$ph_length(struct list$1char$ph* self)
{
    if(self==((void*)0)) {
        return 0;
    }
    return self->len;
}

static struct map$2char$phchar$ph* map$2char$phchar$ph_initialize(struct map$2char$phchar$ph* self)
{
    void* __right_value0 = (void*)0;
    int i;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* __dec_obj21;
    struct map$2char$phchar$ph* __result_obj__0;
    self->keys=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(128)), "/usr/local/include/neo-c.h", 1999, "char**"))));
    self->items=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(128)), "/usr/local/include/neo-c.h", 2000, "char**"))));
    self->item_existance=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(128)), "/usr/local/include/neo-c.h", 2001, "_Bool*"))));
    for(i=0;i<128;i++){
        self->item_existance[i]=0;
    }
    self->size=128;
    self->len=0;
    __dec_obj21=self->key_list,
    self->key_list=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 2011, "struct list$1char$ph*"))));
    come_call_finalizer(list$1char$ph_finalize, __dec_obj21,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    self->it=0;
    __result_obj__0 = (struct map$2char$phchar$ph*)come_increment_ref_count(self);
    come_call_finalizer(map$2char$phchar$ph$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(map$2char$phchar$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static char* list$1char$ph$p_operator_load_element(struct list$1char$ph* self, int position)
{
    char* default_value  ;
    char* __result_obj__0  ;
    struct list_item$1char$ph* it;
    int i;
    char* default_value_23  ;
    if(self==((void*)0)) {
        memset(&default_value,0,sizeof(char*));
        __result_obj__0 = (char*)come_increment_ref_count(default_value);
        (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
        (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    if(position<0) {
        position+=self->len;
    }
    it=self->head;
    i=0;
    while(it!=((void*)0)) {
        if(position==i) {
            __result_obj__0 = (char*)come_increment_ref_count(it->item);
            (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
            return __result_obj__0;
        }
        it=it->next;
        i++;
    }
    memset(&default_value_23,0,sizeof(char*));
    __result_obj__0 = (char*)come_increment_ref_count(default_value_23);
    (default_value_23 = come_decrement_ref_count(default_value_23, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

static char* list$1char$ph_operator_load_element(struct list$1char$ph* self, int position)
{
    char* default_value  ;
    char* __result_obj__0  ;
    struct list_item$1char$ph* it;
    int i;
    char* default_value_24  ;
    if(self==((void*)0)) {
        memset(&default_value,0,sizeof(char*));
        __result_obj__0 = (char*)come_increment_ref_count(default_value);
        (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
        (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    if(position<0) {
        position+=self->len;
    }
    it=self->head;
    i=0;
    while(it!=((void*)0)) {
        if(position==i) {
            __result_obj__0 = (char*)come_increment_ref_count(it->item);
            (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
            return __result_obj__0;
        }
        it=it->next;
        i++;
    }
    memset(&default_value_24,0,sizeof(char*));
    __result_obj__0 = (char*)come_increment_ref_count(default_value_24);
    (default_value_24 = come_decrement_ref_count(default_value_24, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

static void map$2char$phchar$ph_operator_store_element(struct map$2char$phchar$ph* self, char* key  , char* item  )
{
    if(self==((void*)0)) {
        (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
        (item = come_decrement_ref_count(item, (void*)0, (void*)0, 0, 0, (void*)0));
        return;
    }
    map$2char$phchar$ph_insert(self,(char*)come_increment_ref_count(key),(char*)come_increment_ref_count(item));
    (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
    (item = come_decrement_ref_count(item, (void*)0, (void*)0, 0, 0, (void*)0));
}

static struct map$2char$phchar$ph* map$2char$phchar$ph_insert(struct map$2char$phchar$ph* self, char* key  , char* item  )
{
    struct map$2char$phchar$ph* __result_obj__0;
    unsigned int hash;
    unsigned int it;
    _Bool same_key_exist;
    char* it2  ;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
        (item = come_decrement_ref_count(item, (void*)0, (void*)0, 0, 0, (void*)0));
        return __result_obj__0;
    }
    if(self->len*10>=self->size) {
        map$2char$phchar$ph_rehash(self);
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                if(1) {
                    list$1char$ph_remove(self->key_list,self->keys[it]);
                    (self->keys[it] = come_decrement_ref_count(self->keys[it], (void*)0, (void*)0, 0, 0, (void*)0));
                    self->keys[it]=(char*)come_increment_ref_count(key);
                }
                else {
                    list$1char$ph_remove(self->key_list,self->keys[it]);
                    self->keys[it]=key;
                }
                if(1) {
                    (self->items[it] = come_decrement_ref_count(self->items[it], (void*)0, (void*)0, 0, 0, (void*)0));
                    self->items[it]=(char*)come_increment_ref_count(item);
                }
                else {
                    self->items[it]=item;
                }
                break;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                printf("unexpected error in map.insert\n");
                stackframe();
                exit(2);
            }
        }
        else {
            self->item_existance[it]=1;
            if(1) {
                self->keys[it]=(char*)come_increment_ref_count(key);
            }
            else {
                self->keys[it]=key;
            }
            if(1) {
                self->items[it]=(char*)come_increment_ref_count(item);
            }
            else {
                self->items[it]=item;
            }
            self->len++;
            break;
        }
    }
    same_key_exist=0;
    for(it2=list$1char$ph_begin(self->key_list);!list$1char$ph_end(self->key_list);it2=list$1char$ph_next(self->key_list)){
        if(string_equals(it2,key)) {
            same_key_exist=1;
        }
    }
    if(!same_key_exist) {
        list$1char$ph_push_back(self->key_list,(char*)come_increment_ref_count(key));
    }
    __result_obj__0 = self;
    (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
    (item = come_decrement_ref_count(item, (void*)0, (void*)0, 0, 0, (void*)0));
    return __result_obj__0;
}

static void map$2char$phchar$ph_rehash(struct map$2char$phchar$ph* self)
{
    int size;
    void* __right_value0 = (void*)0;
    char** keys  ;
    char** items  ;
    _Bool* item_existance;
    int len;
    char* it  ;
    char* default_value  ;
    char* it2  ;
    unsigned int hash;
    int n;
    char* default_value_27  ;
    size=self->size*10;
    keys=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(size)), "/usr/local/include/neo-c.h", 2299, "char**"))));
    items=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(size)), "/usr/local/include/neo-c.h", 2300, "char**"))));
    item_existance=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(size)), "/usr/local/include/neo-c.h", 2301, "_Bool*"))));
    len=0;
    for(it=map$2char$phchar$ph_begin(self);!map$2char$phchar$ph_end(self);it=map$2char$phchar$ph_next(self)){
        memset(&default_value,0,sizeof(char*));
        it2=((char*)(__right_value0=map$2char$phchar$ph_at(self,it,(char*)come_increment_ref_count(default_value))));
        hash=string_get_hash_key(((char*)it))%size;
        n=hash;
        while(1) {
            if(item_existance[n]) {
                n++;
                if(n>=size) {
                    n=0;
                }
                else if(n==hash) {
                    printf("unexpected error in map.rehash(1)\n");
                    stackframe();
                    exit(2);
                }
            }
            else {
                item_existance[n]=1;
                keys[n]=it;
                memset(&default_value_27,0,sizeof(char*));
                items[n]=((char*)(__right_value0=map$2char$phchar$ph_at(self,it,(char*)come_increment_ref_count(default_value_27))));
                len++;
                (default_value_27 = come_decrement_ref_count(default_value_27, (void*)0, (void*)0, 0, 0, (void*)0));
                break;
                (default_value_27 = come_decrement_ref_count(default_value_27, (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
        (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    come_free((char*)self->items);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
    come_free((char*)self->keys);
    self->keys=keys;
    self->items=items;
    self->item_existance=item_existance;
    self->size=size;
    self->len=len;
}

static char* map$2char$phchar$ph_begin(struct map$2char$phchar$ph* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_25  ;
    if(self==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->key_list->it=self->key_list->head;
    if(self->key_list->it) {
        __result_obj__0 = self->key_list->it->item;
        return __result_obj__0;
    }
    memset(&result_25,0,sizeof(char*));
    __result_obj__0 = result_25;
    return __result_obj__0;
}

static _Bool map$2char$phchar$ph_end(struct map$2char$phchar$ph* self)
{
    return self==((void*)0)||self->key_list==((void*)0)||self->key_list->it==((void*)0);
}

static char* map$2char$phchar$ph_next(struct map$2char$phchar$ph* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_26  ;
    if(self==((void*)0)||self->key_list->it==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->key_list->it=self->key_list->it->next;
    if(self->key_list->it) {
        __result_obj__0 = self->key_list->it->item;
        return __result_obj__0;
    }
    memset(&result_26,0,sizeof(char*));
    __result_obj__0 = result_26;
    return __result_obj__0;
}

static char* map$2char$phchar$ph_at(struct map$2char$phchar$ph* self, char* key  , char* default_value  )
{
    char* __result_obj__0  ;
    unsigned int hash;
    unsigned int it;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(default_value);
        (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                __result_obj__0 = (char*)come_increment_ref_count(self->items[it]);
                (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 0, (void*)0));
                (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
                return __result_obj__0;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                __result_obj__0 = (char*)come_increment_ref_count(default_value);
                (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
                (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
                return __result_obj__0;
            }
        }
        else {
            __result_obj__0 = (char*)come_increment_ref_count(default_value);
            (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
            (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
            return __result_obj__0;
        }
    }
    __result_obj__0 = (char*)come_increment_ref_count(default_value);
    (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

static int list$1map$2char$phchar$ph$ph_length(struct list$1map$2char$phchar$ph$ph* self)
{
    if(self==((void*)0)) {
        return 0;
    }
    return self->len;
}

static struct map$2char$phchar$ph* list$1map$2char$phchar$ph$ph$p_operator_load_element(struct list$1map$2char$phchar$ph$ph* self, int position)
{
    struct map$2char$phchar$ph* default_value;
    struct map$2char$phchar$ph* __result_obj__0;
    struct list_item$1map$2char$phchar$ph$ph* it;
    int i;
    struct map$2char$phchar$ph* default_value_28;
    if(self==((void*)0)) {
        memset(&default_value,0,sizeof(struct map$2char$phchar$ph*));
        __result_obj__0 = (struct map$2char$phchar$ph*)come_increment_ref_count(default_value);
        come_call_finalizer(map$2char$phchar$ph$p_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(map$2char$phchar$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
        come_call_finalizer(map$2char$phchar$ph$p_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    if(position<0) {
        position+=self->len;
    }
    it=self->head;
    i=0;
    while(it!=((void*)0)) {
        if(position==i) {
            __result_obj__0 = (struct map$2char$phchar$ph*)come_increment_ref_count(it->item);
            come_call_finalizer(map$2char$phchar$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            return __result_obj__0;
        }
        it=it->next;
        i++;
    }
    memset(&default_value_28,0,sizeof(struct map$2char$phchar$ph*));
    __result_obj__0 = (struct map$2char$phchar$ph*)come_increment_ref_count(default_value_28);
    come_call_finalizer(map$2char$phchar$ph$p_finalize, default_value_28, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(map$2char$phchar$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct map$2char$phchar$ph* list$1map$2char$phchar$ph$ph_operator_load_element(struct list$1map$2char$phchar$ph$ph* self, int position)
{
    struct map$2char$phchar$ph* default_value;
    struct map$2char$phchar$ph* __result_obj__0;
    struct list_item$1map$2char$phchar$ph$ph* it;
    int i;
    struct map$2char$phchar$ph* default_value_29;
    if(self==((void*)0)) {
        memset(&default_value,0,sizeof(struct map$2char$phchar$ph*));
        __result_obj__0 = (struct map$2char$phchar$ph*)come_increment_ref_count(default_value);
        come_call_finalizer(map$2char$phchar$ph$p_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(map$2char$phchar$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
        come_call_finalizer(map$2char$phchar$ph$p_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    if(position<0) {
        position+=self->len;
    }
    it=self->head;
    i=0;
    while(it!=((void*)0)) {
        if(position==i) {
            __result_obj__0 = (struct map$2char$phchar$ph*)come_increment_ref_count(it->item);
            come_call_finalizer(map$2char$phchar$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            return __result_obj__0;
        }
        it=it->next;
        i++;
    }
    memset(&default_value_29,0,sizeof(struct map$2char$phchar$ph*));
    __result_obj__0 = (struct map$2char$phchar$ph*)come_increment_ref_count(default_value_29);
    come_call_finalizer(map$2char$phchar$ph$p_finalize, default_value_29, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(map$2char$phchar$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static char* map$2char$phchar$ph$p_operator_load_element(struct map$2char$phchar$ph* self, char* key  )
{
    char* default_value  ;
    char* __result_obj__0  ;
    unsigned int hash;
    unsigned int it;
    memset(&default_value,0,sizeof(char*));
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(default_value);
        (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                __result_obj__0 = (char*)come_increment_ref_count(self->items[it]);
                (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 0, (void*)0));
                (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
                return __result_obj__0;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                __result_obj__0 = (char*)come_increment_ref_count(default_value);
                (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
                (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
                return __result_obj__0;
            }
        }
        else {
            __result_obj__0 = (char*)come_increment_ref_count(default_value);
            (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
            (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
            return __result_obj__0;
        }
    }
    __result_obj__0 = (char*)come_increment_ref_count(default_value);
    (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

static char* map$2char$phchar$ph_operator_load_element(struct map$2char$phchar$ph* self, char* key  )
{
    char* default_value  ;
    char* __result_obj__0  ;
    unsigned int hash;
    unsigned int it;
    memset(&default_value,0,sizeof(char*));
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(default_value);
        (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                __result_obj__0 = (char*)come_increment_ref_count(self->items[it]);
                (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 0, (void*)0));
                (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
                return __result_obj__0;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                __result_obj__0 = (char*)come_increment_ref_count(default_value);
                (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
                (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
                return __result_obj__0;
            }
        }
        else {
            __result_obj__0 = (char*)come_increment_ref_count(default_value);
            (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
            (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
            return __result_obj__0;
        }
    }
    __result_obj__0 = (char*)come_increment_ref_count(default_value);
    (default_value = come_decrement_ref_count(default_value, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

static struct list$1map$2char$phchar$ph$ph* list$1map$2char$phchar$ph$ph_add(struct list$1map$2char$phchar$ph$ph* self, struct map$2char$phchar$ph* item)
{
    struct list$1map$2char$phchar$ph$ph* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1map$2char$phchar$ph$ph* litem;
    struct map$2char$phchar$ph* __dec_obj22;
    struct list_item$1map$2char$phchar$ph$ph* litem_38;
    struct map$2char$phchar$ph* __dec_obj23;
    struct list_item$1map$2char$phchar$ph$ph* litem_39;
    struct map$2char$phchar$ph* __dec_obj24;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        come_call_finalizer(map$2char$phchar$ph$p_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1map$2char$phchar$ph$ph*)come_increment_ref_count(((struct list_item$1map$2char$phchar$ph$ph*)(__right_value0=(struct list_item$1map$2char$phchar$ph$ph*)come_calloc(1, sizeof(struct list_item$1map$2char$phchar$ph$ph)*(1), "/usr/local/include/neo-c.h", 954, "struct list_item$1map$2char$phchar$ph$ph*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        __dec_obj22=litem->item,
        litem->item=(struct map$2char$phchar$ph*)come_increment_ref_count(item);
        come_call_finalizer(map$2char$phchar$ph_finalize, __dec_obj22,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_38=(struct list_item$1map$2char$phchar$ph$ph*)come_increment_ref_count(((struct list_item$1map$2char$phchar$ph$ph*)(__right_value0=(struct list_item$1map$2char$phchar$ph$ph*)come_calloc(1, sizeof(struct list_item$1map$2char$phchar$ph$ph)*(1), "/usr/local/include/neo-c.h", 964, "struct list_item$1map$2char$phchar$ph$ph*"))));
        litem_38->prev=self->head;
        litem_38->next=((void*)0);
        __dec_obj23=litem_38->item,
        litem_38->item=(struct map$2char$phchar$ph*)come_increment_ref_count(item);
        come_call_finalizer(map$2char$phchar$ph_finalize, __dec_obj23,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        self->tail=litem_38;
        self->head->next=litem_38;
    }
    else {
        litem_39=(struct list_item$1map$2char$phchar$ph$ph*)come_increment_ref_count(((struct list_item$1map$2char$phchar$ph$ph*)(__right_value0=(struct list_item$1map$2char$phchar$ph$ph*)come_calloc(1, sizeof(struct list_item$1map$2char$phchar$ph$ph)*(1), "/usr/local/include/neo-c.h", 974, "struct list_item$1map$2char$phchar$ph$ph*"))));
        litem_39->prev=self->tail;
        litem_39->next=((void*)0);
        __dec_obj24=litem_39->item,
        litem_39->item=(struct map$2char$phchar$ph*)come_increment_ref_count(item);
        come_call_finalizer(map$2char$phchar$ph_finalize, __dec_obj24,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        self->tail->next=litem_39;
        self->tail=litem_39;
    }
    self->len++;
    __result_obj__0 = self;
    come_call_finalizer(map$2char$phchar$ph$p_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    return __result_obj__0;
}

static void map$2char$phchar$ph_finalize(struct map$2char$phchar$ph* self)
{
    int i;
    int i_37;
    for(i=0;i<self->size;i++){
        if(self->item_existance[i]) {
            if(1) {
                (self->items[i] = come_decrement_ref_count(self->items[i], (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
    }
    come_free((char*)self->items);
    for(i_37=0;i_37<self->size;i_37++){
        if(self->item_existance[i_37]) {
            if(1) {
                (self->keys[i_37] = come_decrement_ref_count(self->keys[i_37], (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
    }
    come_free((char*)self->keys);
    come_call_finalizer(list$1char$ph$p_finalize, self->key_list, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
}

struct WhereNode* WhereNode_initialize(struct WhereNode* self  , struct WhereNode* left  , struct WhereNode* right  , int op, char* data  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct tuple1$1WhereNode$ph* __dec_obj26;
    struct tuple1$1WhereNode$ph* __dec_obj27;
    char* __dec_obj28  ;
    struct WhereNode* __result_obj__0  ;
    self->op=op;
    __dec_obj26=self->left,
    self->left=(struct tuple1$1WhereNode$ph*)come_increment_ref_count(tuple1$1WhereNode$ph_initialize((struct tuple1$1WhereNode$ph*)come_increment_ref_count((struct tuple1$1WhereNode$ph*)come_calloc(1, sizeof(struct tuple1$1WhereNode$ph)*(1), "main.nc", 397, "struct tuple1$1WhereNode$ph*")),(struct WhereNode*)come_increment_ref_count(left)));
    come_call_finalizer(tuple1$1WhereNode$ph$p_finalize, __dec_obj26,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    __dec_obj27=self->right,
    self->right=(struct tuple1$1WhereNode$ph*)come_increment_ref_count(tuple1$1WhereNode$ph_initialize((struct tuple1$1WhereNode$ph*)come_increment_ref_count((struct tuple1$1WhereNode$ph*)come_calloc(1, sizeof(struct tuple1$1WhereNode$ph)*(1), "main.nc", 398, "struct tuple1$1WhereNode$ph*")),(struct WhereNode*)come_increment_ref_count(right)));
    come_call_finalizer(tuple1$1WhereNode$ph$p_finalize, __dec_obj27,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    __dec_obj28=self->data,
    self->data=(char*)come_increment_ref_count(data);
    __dec_obj28 = come_decrement_ref_count(__dec_obj28, (void*)0, (void*)0, 0,0, (void*)0);
    __result_obj__0 = (struct WhereNode*)come_increment_ref_count(self);
    come_call_finalizer(WhereNode_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(WhereNode_finalize, left, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(WhereNode_finalize, right, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (data = come_decrement_ref_count(data, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(WhereNode_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct tuple1$1WhereNode$ph* tuple1$1WhereNode$ph_initialize(struct tuple1$1WhereNode$ph* self, struct WhereNode* v1  )
{
    struct WhereNode* __dec_obj25  ;
    struct tuple1$1WhereNode$ph* __result_obj__0;
    __dec_obj25=self->v1,
    self->v1=(struct WhereNode*)come_increment_ref_count(v1);
    come_call_finalizer(WhereNode_finalize, __dec_obj25,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    __result_obj__0 = (struct tuple1$1WhereNode$ph*)come_increment_ref_count(self);
    come_call_finalizer(tuple1$1WhereNode$ph$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(WhereNode_finalize, v1, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(tuple1$1WhereNode$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static void WhereNode_finalize(struct WhereNode* self  )
{
    if(self!=((void*)0)&&self->left!=((void*)0)) {
        come_call_finalizer(tuple1$1WhereNode$ph$p_finalize, self->left, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    if(self!=((void*)0)&&self->right!=((void*)0)) {
        come_call_finalizer(tuple1$1WhereNode$ph$p_finalize, self->right, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    if(self!=((void*)0)&&self->data!=((void*)0)) {
        (self->data = come_decrement_ref_count(self->data, (void*)0, (void*)0, 0, 0, (void*)0));
    }
}

static void tuple1$1WhereNode$ph$p_finalize(struct tuple1$1WhereNode$ph* self)
{
    if(self!=((void*)0)&&self->v1!=((void*)0)) {
        come_call_finalizer(WhereNode_finalize, self->v1, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

struct WhereNode* parse_where(struct sInfo* info  )
{
    void* __right_value0 = (void*)0;
    char* str  ;
    void* __right_value1 = (void*)0;
    struct WhereNode* left  ;
    struct WhereNode* result  ;
    char* str2  ;
    char* __dec_obj29  ;
    char* __dec_obj30  ;
    struct WhereNode* right  ;
    struct WhereNode* __dec_obj31  ;
    char* str2_40  ;
    char* __dec_obj32  ;
    char* __dec_obj33  ;
    struct WhereNode* right_41  ;
    struct WhereNode* __dec_obj34  ;
    char* str2_42  ;
    char* __dec_obj35  ;
    char* __dec_obj36  ;
    struct WhereNode* right_43  ;
    struct WhereNode* __dec_obj37  ;
    char* str2_44  ;
    char* __dec_obj38  ;
    char* __dec_obj39  ;
    struct WhereNode* right_45  ;
    struct WhereNode* __dec_obj40  ;
    char* str2_46  ;
    char* __dec_obj41  ;
    char* __dec_obj42  ;
    struct WhereNode* right_47  ;
    struct WhereNode* __dec_obj43  ;
    char* str2_48  ;
    char* __dec_obj44  ;
    char* __dec_obj45  ;
    struct WhereNode* right_49  ;
    struct WhereNode* __dec_obj46  ;
    struct WhereNode* right_50  ;
    struct WhereNode* __dec_obj47  ;
    struct WhereNode* right_51  ;
    struct WhereNode* __dec_obj48  ;
    struct WhereNode* __result_obj__0  ;
    memset(&str2, 0, sizeof(str2));
    memset(&str2_40, 0, sizeof(str2_40));
    memset(&str2_42, 0, sizeof(str2_42));
    memset(&str2_44, 0, sizeof(str2_44));
    memset(&str2_46, 0, sizeof(str2_46));
    memset(&str2_48, 0, sizeof(str2_48));
    str=(char*)come_increment_ref_count(parse_word(info));
    left=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 408, "struct WhereNode*")),((void*)0),((void*)0),(8),(char*)come_increment_ref_count(str)));
    result=((void*)0);
    if(*info->p==61) {
        info->p++;
        skip_spaces(info);
        if(*info->p==39) {
            __dec_obj29=str2,
            str2=(char*)come_increment_ref_count(parse_value(info));
            __dec_obj29 = come_decrement_ref_count(__dec_obj29, (void*)0, (void*)0, 0,0, (void*)0);
        }
        else {
            __dec_obj30=str2,
            str2=(char*)come_increment_ref_count(parse_word(info));
            __dec_obj30 = come_decrement_ref_count(__dec_obj30, (void*)0, (void*)0, 0,0, (void*)0);
        }
        right=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 423, "struct WhereNode*")),((void*)0),((void*)0),(8),(char*)come_increment_ref_count(str2)));
        __dec_obj31=result,
        result=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 425, "struct WhereNode*")),(struct WhereNode*)come_increment_ref_count(left),(struct WhereNode*)come_increment_ref_count(right),(0),((void*)0)));
        come_call_finalizer(WhereNode_finalize, __dec_obj31,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        (str2 = come_decrement_ref_count(str2, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(WhereNode_finalize, right, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    else if(strncmp(info->p,"!=",2)==0) {
        info->p+=2;
        skip_spaces(info);
        if(*info->p==39) {
            __dec_obj32=str2_40,
            str2_40=(char*)come_increment_ref_count(parse_value(info));
            __dec_obj32 = come_decrement_ref_count(__dec_obj32, (void*)0, (void*)0, 0,0, (void*)0);
        }
        else {
            __dec_obj33=str2_40,
            str2_40=(char*)come_increment_ref_count(parse_word(info));
            __dec_obj33 = come_decrement_ref_count(__dec_obj33, (void*)0, (void*)0, 0,0, (void*)0);
        }
        right_41=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 439, "struct WhereNode*")),((void*)0),((void*)0),(8),(char*)come_increment_ref_count(str2_40)));
        __dec_obj34=result,
        result=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 441, "struct WhereNode*")),(struct WhereNode*)come_increment_ref_count(left),(struct WhereNode*)come_increment_ref_count(right_41),(1),((void*)0)));
        come_call_finalizer(WhereNode_finalize, __dec_obj34,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        (str2_40 = come_decrement_ref_count(str2_40, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(WhereNode_finalize, right_41, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    else if(strncmp(info->p,">=",2)==0) {
        info->p+=2;
        skip_spaces(info);
        if(*info->p==39) {
            __dec_obj35=str2_42,
            str2_42=(char*)come_increment_ref_count(parse_value(info));
            __dec_obj35 = come_decrement_ref_count(__dec_obj35, (void*)0, (void*)0, 0,0, (void*)0);
        }
        else {
            __dec_obj36=str2_42,
            str2_42=(char*)come_increment_ref_count(parse_word(info));
            __dec_obj36 = come_decrement_ref_count(__dec_obj36, (void*)0, (void*)0, 0,0, (void*)0);
        }
        right_43=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 455, "struct WhereNode*")),((void*)0),((void*)0),(8),(char*)come_increment_ref_count(str2_42)));
        __dec_obj37=result,
        result=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 457, "struct WhereNode*")),(struct WhereNode*)come_increment_ref_count(left),(struct WhereNode*)come_increment_ref_count(right_43),(5),((void*)0)));
        come_call_finalizer(WhereNode_finalize, __dec_obj37,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        (str2_42 = come_decrement_ref_count(str2_42, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(WhereNode_finalize, right_43, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    else if(strncmp(info->p,"<=",2)==0) {
        info->p+=2;
        skip_spaces(info);
        if(*info->p==39) {
            __dec_obj38=str2_44,
            str2_44=(char*)come_increment_ref_count(parse_value(info));
            __dec_obj38 = come_decrement_ref_count(__dec_obj38, (void*)0, (void*)0, 0,0, (void*)0);
        }
        else {
            __dec_obj39=str2_44,
            str2_44=(char*)come_increment_ref_count(parse_word(info));
            __dec_obj39 = come_decrement_ref_count(__dec_obj39, (void*)0, (void*)0, 0,0, (void*)0);
        }
        right_45=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 471, "struct WhereNode*")),((void*)0),((void*)0),(8),(char*)come_increment_ref_count(str2_44)));
        __dec_obj40=result,
        result=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 473, "struct WhereNode*")),(struct WhereNode*)come_increment_ref_count(left),(struct WhereNode*)come_increment_ref_count(right_45),(3),((void*)0)));
        come_call_finalizer(WhereNode_finalize, __dec_obj40,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        (str2_44 = come_decrement_ref_count(str2_44, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(WhereNode_finalize, right_45, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    else if(*info->p==62) {
        info->p++;
        skip_spaces(info);
        if(*info->p==39) {
            __dec_obj41=str2_46,
            str2_46=(char*)come_increment_ref_count(parse_value(info));
            __dec_obj41 = come_decrement_ref_count(__dec_obj41, (void*)0, (void*)0, 0,0, (void*)0);
        }
        else {
            __dec_obj42=str2_46,
            str2_46=(char*)come_increment_ref_count(parse_word(info));
            __dec_obj42 = come_decrement_ref_count(__dec_obj42, (void*)0, (void*)0, 0,0, (void*)0);
        }
        right_47=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 487, "struct WhereNode*")),((void*)0),((void*)0),(8),(char*)come_increment_ref_count(str2_46)));
        __dec_obj43=result,
        result=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 489, "struct WhereNode*")),(struct WhereNode*)come_increment_ref_count(left),(struct WhereNode*)come_increment_ref_count(right_47),(4),((void*)0)));
        come_call_finalizer(WhereNode_finalize, __dec_obj43,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        (str2_46 = come_decrement_ref_count(str2_46, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(WhereNode_finalize, right_47, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    else if(*info->p==60) {
        info->p++;
        skip_spaces(info);
        if(*info->p==39) {
            __dec_obj44=str2_48,
            str2_48=(char*)come_increment_ref_count(parse_value(info));
            __dec_obj44 = come_decrement_ref_count(__dec_obj44, (void*)0, (void*)0, 0,0, (void*)0);
        }
        else {
            __dec_obj45=str2_48,
            str2_48=(char*)come_increment_ref_count(parse_word(info));
            __dec_obj45 = come_decrement_ref_count(__dec_obj45, (void*)0, (void*)0, 0,0, (void*)0);
        }
        right_49=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 503, "struct WhereNode*")),((void*)0),((void*)0),(8),(char*)come_increment_ref_count(str2_48)));
        __dec_obj46=result,
        result=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 505, "struct WhereNode*")),(struct WhereNode*)come_increment_ref_count(left),(struct WhereNode*)come_increment_ref_count(right_49),(2),((void*)0)));
        come_call_finalizer(WhereNode_finalize, __dec_obj46,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        (str2_48 = come_decrement_ref_count(str2_48, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(WhereNode_finalize, right_49, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    skip_spaces(info);
    if(strncmp(info->p,"AND",strlen("AND"))==0) {
        info->p+=strlen("AND");
        skip_spaces(info);
        right_50=(struct WhereNode*)come_increment_ref_count(parse_where(info));
        __dec_obj47=result,
        result=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 516, "struct WhereNode*")),(struct WhereNode*)come_increment_ref_count(result),(struct WhereNode*)come_increment_ref_count(right_50),(6),((void*)0)));
        come_call_finalizer(WhereNode_finalize, __dec_obj47,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(WhereNode_finalize, right_50, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    else if(strncmp(info->p,"OR",strlen("OR"))==0) {
        info->p+=strlen("OR");
        skip_spaces(info);
        right_51=(struct WhereNode*)come_increment_ref_count(parse_where(info));
        __dec_obj48=result,
        result=(struct WhereNode*)come_increment_ref_count(WhereNode_initialize((struct WhereNode*)come_increment_ref_count((struct WhereNode*)come_calloc(1, sizeof(struct WhereNode)*(1), "main.nc", 524, "struct WhereNode*")),(struct WhereNode*)come_increment_ref_count(result),(struct WhereNode*)come_increment_ref_count(right_51),(7),((void*)0)));
        come_call_finalizer(WhereNode_finalize, __dec_obj48,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(WhereNode_finalize, right_51, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    __result_obj__0 = (struct WhereNode*)come_increment_ref_count(result);
    (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(WhereNode_finalize, left, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(WhereNode_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(WhereNode_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

_Bool where_select(struct map$2char$phchar$ph* row, struct WhereNode* where_node  )
{
    void* __right_value0 = (void*)0;
    char* left;
    char* right;
    int right_int_value;
    _Bool __result_obj__0;
    char* left_52;
    char* right_53;
    int right_int_value_54;
    char* left_55;
    char* right_56;
    int right_int_value_57;
    char* left_58;
    char* right_59;
    int right_int_value_60;
    char* left_61;
    char* right_62;
    int right_int_value_63;
    char* left_64;
    char* right_65;
    int right_int_value_66;
    _Bool left_67;
    _Bool right_68;
    _Bool left_69;
    _Bool right_70;
    switch (    where_node->op) {
        case (0):
        {
            if(where_node->left->v1->op==(8)&&where_node->right->v1->op==(8)) {
                left=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row,where_node->left->v1->data));
                right=where_node->right->v1->data;
                right_int_value=atoi(right);
                if(right_int_value==0) {
                    __result_obj__0 = charp_operator_equals(left,right);
                    (left = come_decrement_ref_count(left, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                else {
                    __result_obj__0 = atoi(left)==right;
                    (left = come_decrement_ref_count(left, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                (left = come_decrement_ref_count(left, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            else {
                return 0;
            }
        }
        break;
        case (1):
        {
            if(where_node->left->v1->op==(8)&&where_node->right->v1->op==(8)) {
                left_52=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row,where_node->left->v1->data));
                right_53=where_node->right->v1->data;
                right_int_value_54=atoi(right_53);
                if(right_int_value_54==0) {
                    __result_obj__0 = charp_operator_not_equals(left_52,right_53);
                    (left_52 = come_decrement_ref_count(left_52, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                else {
                    __result_obj__0 = atoi(left_52)!=right_53;
                    (left_52 = come_decrement_ref_count(left_52, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                (left_52 = come_decrement_ref_count(left_52, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            else {
                return 0;
            }
        }
        break;
        case (2):
        {
            if(where_node->left->v1->op==(8)&&where_node->right->v1->op==(8)) {
                left_55=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row,where_node->left->v1->data));
                right_56=where_node->right->v1->data;
                right_int_value_57=atoi(right_56);
                if(right_int_value_57==0) {
                    __result_obj__0 = 0;
                    (left_55 = come_decrement_ref_count(left_55, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                else {
                    __result_obj__0 = atoi(left_55)<right_56;
                    (left_55 = come_decrement_ref_count(left_55, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                (left_55 = come_decrement_ref_count(left_55, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            else {
                return 0;
            }
        }
        break;
        case (3):
        {
            if(where_node->left->v1->op==(8)&&where_node->right->v1->op==(8)) {
                left_58=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row,where_node->left->v1->data));
                right_59=where_node->right->v1->data;
                right_int_value_60=atoi(right_59);
                if(right_int_value_60==0) {
                    __result_obj__0 = 0;
                    (left_58 = come_decrement_ref_count(left_58, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                else {
                    __result_obj__0 = atoi(left_58)<=right_59;
                    (left_58 = come_decrement_ref_count(left_58, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                (left_58 = come_decrement_ref_count(left_58, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            else {
                return 0;
            }
        }
        break;
        case (4):
        {
            if(where_node->left->v1->op==(8)&&where_node->right->v1->op==(8)) {
                left_61=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row,where_node->left->v1->data));
                right_62=where_node->right->v1->data;
                right_int_value_63=atoi(right_62);
                if(right_int_value_63==0) {
                    __result_obj__0 = 0;
                    (left_61 = come_decrement_ref_count(left_61, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                else {
                    __result_obj__0 = atoi(left_61)>right_62;
                    (left_61 = come_decrement_ref_count(left_61, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                (left_61 = come_decrement_ref_count(left_61, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            else {
                return 0;
            }
        }
        break;
        case (5):
        {
            if(where_node->left->v1->op==(8)&&where_node->right->v1->op==(8)) {
                left_64=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row,where_node->left->v1->data));
                right_65=where_node->right->v1->data;
                right_int_value_66=atoi(right_65);
                if(right_int_value_66==0) {
                    __result_obj__0 = 0;
                    (left_64 = come_decrement_ref_count(left_64, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                else {
                    __result_obj__0 = atoi(left_64)>=right_65;
                    (left_64 = come_decrement_ref_count(left_64, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                (left_64 = come_decrement_ref_count(left_64, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            else {
                return 0;
            }
        }
        break;
        case (6):
        {
            left_67=where_select(row,where_node->left->v1);
            right_68=where_select(row,where_node->right->v1);
            return left_67&&right_68;
        }
        break;
        case (7):
        {
            left_69=where_select(row,where_node->left->v1);
            right_70=where_select(row,where_node->right->v1);
            return left_69||right_70;
        }
        break;
        case (8):
        return 0;
    }
    return 0;
}

_Bool like(char* str, char* pattern)
{
    if(*pattern==0) {
        return *str==0;
    }
    if(*pattern==37) {
        return like(str,pattern+1)||(*str&&like(str+1,pattern));
    }
    if(*pattern==95) {
        return *str&&like(str+1,pattern+1);
    }
    return *str==*pattern&&like(str+1,pattern+1);
}

_Bool eval_select_from(char* deliminater, struct sInfo* info  )
{
    _Bool all_;
    _Bool max_;
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* field_names;
    struct map$2char$ph_Bool$* max_field;
    char* field  ;
    _Bool max_flag;
    char* __dec_obj50  ;
    char* __dec_obj51  ;
    char* table_name  ;
    struct WhereNode* where_node  ;
    char* in_target  ;
    struct list$1char$ph* in_values;
    _Bool not_in;
    char* between_target  ;
    char* like_target  ;
    char* not_like_target  ;
    struct tuple2$2char$phchar$ph* between_values;
    char* like_value  ;
    char* not_like_value  ;
    char* p;
    char* tmp  ;
    char* __dec_obj52  ;
    char* value  ;
    _Bool __result_obj__0;
    char* __dec_obj53  ;
    char* value_75  ;
    char* value2  ;
    struct tuple2$2char$phchar$ph* __dec_obj56;
    char* __dec_obj57  ;
    char* value_76  ;
    char* __dec_obj58  ;
    char* __dec_obj59  ;
    char* value_77  ;
    char* __dec_obj60  ;
    struct WhereNode* __dec_obj61  ;
    struct Database* current_db  ;
    struct Table* table  ;
    struct buffer* buf  ;
    struct list$1map$2char$phchar$ph$ph* rows;
    struct list$1map$2char$phchar$ph$ph* o2_saved;
    struct map$2char$phchar$ph* it;
    struct map$2char$phchar$ph* row;
    _Bool check;
    struct list$1char$ph* o2_saved_80;
    char* it2  ;
    _Bool _conditional_value_X0;
    struct map$2char$phchar$ph* o2_saved_81;
    char* it3  ;
    char* value_82;
    void* __right_value2 = (void*)0;
    char* value2_83  ;
    struct list$1map$2char$phchar$ph$ph* rows_84;
    struct list$1map$2char$phchar$ph$ph* o2_saved_85;
    struct map$2char$phchar$ph* it_86;
    struct map$2char$phchar$ph* row_87;
    _Bool check_88;
    struct list$1char$ph* o2_saved_89;
    char* it2_90  ;
    _Bool _conditional_value_X1;
    struct list$1char$ph* o2_saved_91;
    char* it3_92  ;
    char* value_93;
    char* value2_94  ;
    struct list$1map$2char$phchar$ph$ph* rows_95;
    struct list$1map$2char$phchar$ph$ph* o2_saved_96;
    struct map$2char$phchar$ph* it_97;
    struct map$2char$phchar$ph* row_98;
    struct list$1char$ph* o2_saved_99;
    char* it2_100  ;
    _Bool _conditional_value_X2;
    struct map$2char$phchar$ph* o2_saved_101;
    char* it3_102  ;
    char* value_103;
    char* value2_104  ;
    struct list$1map$2char$phchar$ph$ph* rows_105;
    struct list$1map$2char$phchar$ph$ph* o2_saved_106;
    struct map$2char$phchar$ph* it_107;
    struct map$2char$phchar$ph* row_108;
    struct list$1char$ph* o2_saved_109;
    char* it2_110  ;
    _Bool _conditional_value_X3;
    struct list$1char$ph* o2_saved_111;
    char* it3_112  ;
    char* value_113;
    char* value2_114  ;
    struct list$1map$2char$phchar$ph$ph* rows_115;
    struct list$1map$2char$phchar$ph$ph* o2_saved_116;
    struct map$2char$phchar$ph* it_117;
    struct map$2char$phchar$ph* row_118;
    char* value_119;
    char* start;
    char* end;
    struct map$2char$phchar$ph* o2_saved_120;
    char* it3_121  ;
    char* value_122;
    char* value2_123  ;
    struct list$1map$2char$phchar$ph$ph* rows_124;
    struct list$1map$2char$phchar$ph$ph* o2_saved_125;
    struct map$2char$phchar$ph* it_126;
    struct map$2char$phchar$ph* row_127;
    char* value_128;
    char* start_129;
    char* end_130;
    struct list$1char$ph* o2_saved_131;
    char* it3_132  ;
    char* value_133;
    char* value2_134  ;
    struct list$1map$2char$phchar$ph$ph* rows_135;
    struct list$1map$2char$phchar$ph$ph* o2_saved_136;
    struct map$2char$phchar$ph* it_137;
    struct map$2char$phchar$ph* row_138;
    char* value_139;
    char* pattern;
    struct map$2char$phchar$ph* o2_saved_140;
    char* it3_141  ;
    char* value_142;
    char* value2_143  ;
    struct list$1map$2char$phchar$ph$ph* rows_144;
    struct list$1map$2char$phchar$ph$ph* o2_saved_145;
    struct map$2char$phchar$ph* it_146;
    struct map$2char$phchar$ph* row_147;
    char* value_148;
    char* pattern_149;
    struct list$1char$ph* o2_saved_150;
    char* it3_151  ;
    char* value_152;
    char* value2_153  ;
    struct list$1map$2char$phchar$ph$ph* rows_154;
    struct list$1map$2char$phchar$ph$ph* o2_saved_155;
    struct map$2char$phchar$ph* it_156;
    struct map$2char$phchar$ph* row_157;
    char* value_158;
    char* pattern_159;
    struct map$2char$phchar$ph* o2_saved_160;
    char* it3_161  ;
    char* value_162;
    char* value2_163  ;
    struct list$1map$2char$phchar$ph$ph* rows_164;
    struct list$1map$2char$phchar$ph$ph* o2_saved_165;
    struct map$2char$phchar$ph* it_166;
    struct map$2char$phchar$ph* row_167;
    char* value_168;
    char* pattern_169;
    struct list$1char$ph* o2_saved_170;
    char* it3_171  ;
    char* value_172;
    char* value2_173  ;
    struct list$1map$2char$phchar$ph$ph* rows_174;
    struct list$1map$2char$phchar$ph$ph* o2_saved_175;
    struct map$2char$phchar$ph* it_176;
    struct map$2char$phchar$ph* row_177;
    struct map$2char$phchar$ph* o2_saved_178;
    char* it2_179  ;
    char* value_180;
    char* value2_181  ;
    struct list$1map$2char$phchar$ph$ph* rows_182;
    int max_value;
    struct map$2char$phchar$ph* max_row;
    struct list$1map$2char$phchar$ph$ph* o2_saved_183;
    struct map$2char$phchar$ph* it_184;
    struct map$2char$phchar$ph* row_185;
    struct list$1char$ph* o2_saved_186;
    char* it2_187  ;
    char* value_188;
    struct list$1char$ph* o2_saved_189;
    char* it2_190  ;
    char* value_191;
    char* value2_192  ;
    struct list$1map$2char$phchar$ph$ph* rows_193;
    struct list$1map$2char$phchar$ph$ph* o2_saved_194;
    struct map$2char$phchar$ph* it_195;
    struct map$2char$phchar$ph* row_196;
    int max_value_197;
    struct list$1char$ph* o2_saved_198;
    char* it2_199  ;
    char* value_200;
    char* value2_201  ;
    struct list$1map$2char$phchar$ph$ph* rows_202;
    struct list$1map$2char$phchar$ph$ph* o2_saved_203;
    struct map$2char$phchar$ph* it_204;
    struct map$2char$phchar$ph* row_205;
    struct map$2char$phchar$ph* o2_saved_206;
    char* it2_207  ;
    void* __right_value3 = (void*)0;
    void* __right_value4 = (void*)0;
    char* value_208  ;
    struct list$1map$2char$phchar$ph$ph* rows_209;
    struct list$1map$2char$phchar$ph$ph* o2_saved_210;
    struct map$2char$phchar$ph* it_211;
    struct map$2char$phchar$ph* row_212;
    struct list$1char$ph* o2_saved_213;
    char* it2_214  ;
    char* str  ;
    char* str_215  ;
    struct _IO_FILE* f  ;
    struct _IO_FILE* f_216  ;
    info->p+=strlen("SELECT");
    skip_spaces(info);
    all_=0;
    max_=0;
    field_names=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "main.nc", 699, "struct list$1char$ph*"))));
    max_field=(struct map$2char$ph_Bool$*)come_increment_ref_count(map$2char$ph_Bool$_initialize((struct map$2char$ph_Bool$*)come_increment_ref_count((struct map$2char$ph_Bool$*)come_calloc(1, sizeof(struct map$2char$ph_Bool$)*(1), "main.nc", 700, "struct map$2char$ph_Bool$*"))));
    if(*info->p==42) {
        info->p++;
        skip_spaces(info);
        all_=1;
        if(strncmp(info->p,"FROM",strlen("FROM"))==0) {
            info->p+=strlen("FROM");
            skip_spaces(info);
        }
    }
    else {
        while(1) {
            field=((void*)0);
            max_flag=0;
            if(strncmp(info->p,"MAX(",strlen("MAX("))==0) {
                info->p+=strlen("MAX(");
                __dec_obj50=field,
                field=(char*)come_increment_ref_count(parse_word(info));
                __dec_obj50 = come_decrement_ref_count(__dec_obj50, (void*)0, (void*)0, 0,0, (void*)0);
                expected_next_charactor(41,info);
                max_flag=max_=1;
            }
            else {
                __dec_obj51=field,
                field=(char*)come_increment_ref_count(parse_word(info));
                __dec_obj51 = come_decrement_ref_count(__dec_obj51, (void*)0, (void*)0, 0,0, (void*)0);
            }
            list$1char$ph_add(field_names,(char*)come_increment_ref_count(field));
            map$2char$ph_Bool$_insert(max_field,(char*)come_increment_ref_count(field),max_flag);
            if(strncmp(info->p,"FROM",strlen("FROM"))==0) {
                info->p+=strlen("FROM");
                skip_spaces(info);
                (field = come_decrement_ref_count(field, (void*)0, (void*)0, 0, 0, (void*)0));
                break;
            }
            expected_next_charactor(44,info);
            (field = come_decrement_ref_count(field, (void*)0, (void*)0, 0, 0, (void*)0));
        }
    }
    table_name=(char*)come_increment_ref_count(parse_word(info));
    skip_spaces(info);
    where_node=((void*)0);
    in_target=((void*)0);
    in_values=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "main.nc", 744, "struct list$1char$ph*"))));
    not_in=0;
    between_target=((void*)0);
    like_target=((void*)0);
    not_like_target=((void*)0);
    between_values=((void*)0);
    like_value=((void*)0);
    not_like_value=((void*)0);
    if(strncmp(info->p,"WHERE",strlen("WHERE"))==0) {
        info->p+=strlen("WHERE");
        skip_spaces(info);
        p=info->p;
        tmp=(char*)come_increment_ref_count(parse_word(info));
        if(strncmp(info->p,"IN",strlen("IN"))==0||strncmp(info->p,"NOT IN",strlen("NOT IN"))==0) {
            if(strncmp(info->p,"IN",strlen("IN"))==0) {
                info->p+=strlen("IN");
                skip_spaces(info);
            }
            else {
                info->p+=strlen("NOT IN");
                skip_spaces(info);
                not_in=1;
            }
            __dec_obj52=in_target,
            in_target=(char*)come_increment_ref_count(tmp);
            __dec_obj52 = come_decrement_ref_count(__dec_obj52, (void*)0, (void*)0, 0,0, (void*)0);
            expected_next_charactor(40,info);
            while(1) {
                value=(char*)come_increment_ref_count(parse_value(info));
                list$1char$ph_add(in_values,(char*)come_increment_ref_count(value));
                if(*info->p==0) {
                    __result_obj__0 = 0;
                    (value = come_decrement_ref_count(value, (void*)0, (void*)0, 0, 0, (void*)0));
                    (tmp = come_decrement_ref_count(tmp, (void*)0, (void*)0, 0, 0, (void*)0));
                    come_call_finalizer(list$1char$ph$p_finalize, field_names, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    come_call_finalizer(map$2char$ph_Bool$$p_finalize, max_field, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
                    come_call_finalizer(WhereNode_finalize, where_node, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    (in_target = come_decrement_ref_count(in_target, (void*)0, (void*)0, 0, 0, (void*)0));
                    come_call_finalizer(list$1char$ph$p_finalize, in_values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    (between_target = come_decrement_ref_count(between_target, (void*)0, (void*)0, 0, 0, (void*)0));
                    (like_target = come_decrement_ref_count(like_target, (void*)0, (void*)0, 0, 0, (void*)0));
                    (not_like_target = come_decrement_ref_count(not_like_target, (void*)0, (void*)0, 0, 0, (void*)0));
                    come_call_finalizer(tuple2$2char$phchar$ph$p_finalize, between_values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    (like_value = come_decrement_ref_count(like_value, (void*)0, (void*)0, 0, 0, (void*)0));
                    (not_like_value = come_decrement_ref_count(not_like_value, (void*)0, (void*)0, 0, 0, (void*)0));
                    return __result_obj__0;
                }
                else if(*info->p==41) {
                    info->p++;
                    skip_spaces(info);
                    (value = come_decrement_ref_count(value, (void*)0, (void*)0, 0, 0, (void*)0));
                    break;
                }
                expected_next_charactor(44,info);
                (value = come_decrement_ref_count(value, (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
        else if(strncmp(info->p,"BETWEEN",strlen("BETWEEN"))==0) {
            info->p+=strlen("BETWEEN");
            skip_spaces(info);
            __dec_obj53=between_target,
            between_target=(char*)come_increment_ref_count(tmp);
            __dec_obj53 = come_decrement_ref_count(__dec_obj53, (void*)0, (void*)0, 0,0, (void*)0);
            value_75=(char*)come_increment_ref_count(parse_value(info));
            skip_spaces(info);
            if(strncmp(info->p,"AND",strlen("AND"))==0) {
                info->p+=strlen("AND");
                skip_spaces(info);
            }
            value2=(char*)come_increment_ref_count(parse_value(info));
            skip_spaces(info);
            __dec_obj56=between_values,
            between_values=(struct tuple2$2char$phchar$ph*)come_increment_ref_count(tuple2$2char$phchar$ph_initialize((struct tuple2$2char$phchar$ph*)come_increment_ref_count((struct tuple2$2char$phchar$ph*)come_calloc(1, sizeof(struct tuple2$2char$phchar$ph)*(1), "main.nc", 809, "struct tuple2$2char$phchar$ph")),(char*)come_increment_ref_count(value_75),(char*)come_increment_ref_count(value2)));
            come_call_finalizer(tuple2$2char$phchar$ph$p_finalize, __dec_obj56,(void*)0, (void*)0, 0, 0, 0, (void*)0);
            (value_75 = come_decrement_ref_count(value_75, (void*)0, (void*)0, 0, 0, (void*)0));
            (value2 = come_decrement_ref_count(value2, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else if(strncmp(info->p,"LIKE",strlen("LIKE"))==0) {
            info->p+=strlen("LIKE");
            skip_spaces(info);
            __dec_obj57=like_target,
            like_target=(char*)come_increment_ref_count(tmp);
            __dec_obj57 = come_decrement_ref_count(__dec_obj57, (void*)0, (void*)0, 0,0, (void*)0);
            value_76=(char*)come_increment_ref_count(parse_value(info));
            __dec_obj58=like_value,
            like_value=(char*)come_increment_ref_count(value_76);
            __dec_obj58 = come_decrement_ref_count(__dec_obj58, (void*)0, (void*)0, 0,0, (void*)0);
            (value_76 = come_decrement_ref_count(value_76, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else if(strncmp(info->p,"NOT LIKE",strlen("NOT LIKE"))==0) {
            info->p+=strlen("NOT LIKE");
            skip_spaces(info);
            __dec_obj59=not_like_target,
            not_like_target=(char*)come_increment_ref_count(tmp);
            __dec_obj59 = come_decrement_ref_count(__dec_obj59, (void*)0, (void*)0, 0,0, (void*)0);
            value_77=(char*)come_increment_ref_count(parse_value(info));
            __dec_obj60=not_like_value,
            not_like_value=(char*)come_increment_ref_count(value_77);
            __dec_obj60 = come_decrement_ref_count(__dec_obj60, (void*)0, (void*)0, 0,0, (void*)0);
            (value_77 = come_decrement_ref_count(value_77, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else {
            info->p=p;
            __dec_obj61=where_node,
            where_node=(struct WhereNode*)come_increment_ref_count(parse_where(info));
            come_call_finalizer(WhereNode_finalize, __dec_obj61,(void*)0, (void*)0, 0, 0, 0, (void*)0);
        }
        (tmp = come_decrement_ref_count(tmp, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    if(list$1char$ph_length(field_names)==0&&!all_) {
        __result_obj__0 = 0;
        come_call_finalizer(list$1char$ph$p_finalize, field_names, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(map$2char$ph_Bool$$p_finalize, max_field, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(WhereNode_finalize, where_node, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (in_target = come_decrement_ref_count(in_target, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(list$1char$ph$p_finalize, in_values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (between_target = come_decrement_ref_count(between_target, (void*)0, (void*)0, 0, 0, (void*)0));
        (like_target = come_decrement_ref_count(like_target, (void*)0, (void*)0, 0, 0, (void*)0));
        (not_like_target = come_decrement_ref_count(not_like_target, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(tuple2$2char$phchar$ph$p_finalize, between_values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (like_value = come_decrement_ref_count(like_value, (void*)0, (void*)0, 0, 0, (void*)0));
        (not_like_value = come_decrement_ref_count(not_like_value, (void*)0, (void*)0, 0, 0, (void*)0));
        return __result_obj__0;
    }
    current_db=(struct Database*)come_increment_ref_count(map$2char$phDatabase$ph_operator_load_element(gDatabases,info->current_db_name));
    table=(struct Table*)come_increment_ref_count(map$2char$phTable$ph_operator_load_element(current_db->tables,table_name));
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "main.nc", 846, "struct buffer*"))));
    if(table) {
        if(in_target&&not_in) {
            if(all_) {
                rows=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows),it=list$1map$2char$phchar$ph$ph_begin(o2_saved);!list$1map$2char$phchar$ph$ph_end(o2_saved);it=list$1map$2char$phchar$ph$ph_next(o2_saved)){
                    row=it;
                    check=1;
                    for(o2_saved_80=(struct list$1char$ph*)come_increment_ref_count(in_values),it2=list$1char$ph_begin(o2_saved_80);!list$1char$ph_end(o2_saved_80);it2=list$1char$ph_next(o2_saved_80)){
                        if(({(_conditional_value_X0=(string_operator_equals(((char*)(__right_value1=map$2char$phchar$ph_operator_load_element(row,in_target))),it2)));                        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
_conditional_value_X0;})) {
                            check=0;
                        }
                    }
                    come_call_finalizer(list$1char$ph$p_finalize, o2_saved_80, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    if(check) {
                        for(o2_saved_81=row,it3=map$2char$phchar$ph_begin(o2_saved_81);!map$2char$phchar$ph_end(o2_saved_81);it3=map$2char$phchar$ph_next(o2_saved_81)){
                            value_82=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row,it3));
                            value2_83=(char*)come_increment_ref_count(charp_operator_add(value_82,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_83);
                            (value_82 = come_decrement_ref_count(value_82, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_83 = come_decrement_ref_count(value2_83, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                    }
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            else {
                rows_84=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_85=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_84),it_86=list$1map$2char$phchar$ph$ph_begin(o2_saved_85);!list$1map$2char$phchar$ph$ph_end(o2_saved_85);it_86=list$1map$2char$phchar$ph$ph_next(o2_saved_85)){
                    row_87=it_86;
                    check_88=1;
                    for(o2_saved_89=(struct list$1char$ph*)come_increment_ref_count(in_values),it2_90=list$1char$ph_begin(o2_saved_89);!list$1char$ph_end(o2_saved_89);it2_90=list$1char$ph_next(o2_saved_89)){
                        if(({(_conditional_value_X1=(string_operator_equals(((char*)(__right_value1=map$2char$phchar$ph_operator_load_element(row_87,in_target))),it2_90)));                        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
_conditional_value_X1;})) {
                            check_88=0;
                        }
                    }
                    come_call_finalizer(list$1char$ph$p_finalize, o2_saved_89, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    if(check_88) {
                        for(o2_saved_91=(struct list$1char$ph*)come_increment_ref_count(field_names),it3_92=list$1char$ph_begin(o2_saved_91);!list$1char$ph_end(o2_saved_91);it3_92=list$1char$ph_next(o2_saved_91)){
                            value_93=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_87,it3_92));
                            value2_94=(char*)come_increment_ref_count(charp_operator_add(value_93,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_94);
                            (value_93 = come_decrement_ref_count(value_93, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_94 = come_decrement_ref_count(value2_94, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                        come_call_finalizer(list$1char$ph$p_finalize, o2_saved_91, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    }
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_85, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_84, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
        else if(in_target) {
            if(all_) {
                rows_95=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_96=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_95),it_97=list$1map$2char$phchar$ph$ph_begin(o2_saved_96);!list$1map$2char$phchar$ph$ph_end(o2_saved_96);it_97=list$1map$2char$phchar$ph$ph_next(o2_saved_96)){
                    row_98=it_97;
                    for(o2_saved_99=(struct list$1char$ph*)come_increment_ref_count(in_values),it2_100=list$1char$ph_begin(o2_saved_99);!list$1char$ph_end(o2_saved_99);it2_100=list$1char$ph_next(o2_saved_99)){
                        if(({(_conditional_value_X2=(string_operator_equals(((char*)(__right_value1=map$2char$phchar$ph_operator_load_element(row_98,in_target))),it2_100)));                        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
_conditional_value_X2;})) {
                            for(o2_saved_101=row_98,it3_102=map$2char$phchar$ph_begin(o2_saved_101);!map$2char$phchar$ph_end(o2_saved_101);it3_102=map$2char$phchar$ph_next(o2_saved_101)){
                                value_103=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_98,it3_102));
                                value2_104=(char*)come_increment_ref_count(charp_operator_add(value_103,((char*)(__right_value1=__builtin_string(deliminater)))));
                                (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                                buffer_append_str(buf,value2_104);
                                (value_103 = come_decrement_ref_count(value_103, (void*)0, (void*)0, 0, 0, (void*)0));
                                (value2_104 = come_decrement_ref_count(value2_104, (void*)0, (void*)0, 0, 0, (void*)0));
                            }
                            break;
                        }
                    }
                    come_call_finalizer(list$1char$ph$p_finalize, o2_saved_99, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_96, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_95, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            else {
                rows_105=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_106=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_105),it_107=list$1map$2char$phchar$ph$ph_begin(o2_saved_106);!list$1map$2char$phchar$ph$ph_end(o2_saved_106);it_107=list$1map$2char$phchar$ph$ph_next(o2_saved_106)){
                    row_108=it_107;
                    for(o2_saved_109=(struct list$1char$ph*)come_increment_ref_count(in_values),it2_110=list$1char$ph_begin(o2_saved_109);!list$1char$ph_end(o2_saved_109);it2_110=list$1char$ph_next(o2_saved_109)){
                        if(({(_conditional_value_X3=(string_operator_equals(((char*)(__right_value1=map$2char$phchar$ph_operator_load_element(row_108,in_target))),it2_110)));                        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
_conditional_value_X3;})) {
                            for(o2_saved_111=(struct list$1char$ph*)come_increment_ref_count(field_names),it3_112=list$1char$ph_begin(o2_saved_111);!list$1char$ph_end(o2_saved_111);it3_112=list$1char$ph_next(o2_saved_111)){
                                value_113=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_108,it3_112));
                                value2_114=(char*)come_increment_ref_count(charp_operator_add(value_113,((char*)(__right_value1=__builtin_string(deliminater)))));
                                (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                                buffer_append_str(buf,value2_114);
                                (value_113 = come_decrement_ref_count(value_113, (void*)0, (void*)0, 0, 0, (void*)0));
                                (value2_114 = come_decrement_ref_count(value2_114, (void*)0, (void*)0, 0, 0, (void*)0));
                            }
                            come_call_finalizer(list$1char$ph$p_finalize, o2_saved_111, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                            break;
                        }
                    }
                    come_call_finalizer(list$1char$ph$p_finalize, o2_saved_109, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_106, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_105, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
        else if(between_target) {
            if(all_) {
                rows_115=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_116=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_115),it_117=list$1map$2char$phchar$ph$ph_begin(o2_saved_116);!list$1map$2char$phchar$ph$ph_end(o2_saved_116);it_117=list$1map$2char$phchar$ph$ph_next(o2_saved_116)){
                    row_118=it_117;
                    value_119=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_118,between_target));
                    start=between_values->v1;
                    end=between_values->v2;
                    if(atoi(value_119)>=atoi(start)&&atoi(value_119)<=atoi(end)) {
                        for(o2_saved_120=row_118,it3_121=map$2char$phchar$ph_begin(o2_saved_120);!map$2char$phchar$ph_end(o2_saved_120);it3_121=map$2char$phchar$ph_next(o2_saved_120)){
                            value_122=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_118,it3_121));
                            value2_123=(char*)come_increment_ref_count(charp_operator_add(value_122,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_123);
                            (value_122 = come_decrement_ref_count(value_122, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_123 = come_decrement_ref_count(value2_123, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                        (value_119 = come_decrement_ref_count(value_119, (void*)0, (void*)0, 0, 0, (void*)0));
                        break;
                    }
                    (value_119 = come_decrement_ref_count(value_119, (void*)0, (void*)0, 0, 0, (void*)0));
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_116, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_115, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            else {
                rows_124=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_125=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_124),it_126=list$1map$2char$phchar$ph$ph_begin(o2_saved_125);!list$1map$2char$phchar$ph$ph_end(o2_saved_125);it_126=list$1map$2char$phchar$ph$ph_next(o2_saved_125)){
                    row_127=it_126;
                    value_128=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_127,between_target));
                    start_129=between_values->v1;
                    end_130=between_values->v2;
                    if(atoi(value_128)>=atoi(start_129)&&atoi(value_128)<=atoi(end_130)) {
                        for(o2_saved_131=(struct list$1char$ph*)come_increment_ref_count(field_names),it3_132=list$1char$ph_begin(o2_saved_131);!list$1char$ph_end(o2_saved_131);it3_132=list$1char$ph_next(o2_saved_131)){
                            value_133=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_127,it3_132));
                            value2_134=(char*)come_increment_ref_count(charp_operator_add(value_133,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_134);
                            (value_133 = come_decrement_ref_count(value_133, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_134 = come_decrement_ref_count(value2_134, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                        come_call_finalizer(list$1char$ph$p_finalize, o2_saved_131, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                        (value_128 = come_decrement_ref_count(value_128, (void*)0, (void*)0, 0, 0, (void*)0));
                        break;
                    }
                    (value_128 = come_decrement_ref_count(value_128, (void*)0, (void*)0, 0, 0, (void*)0));
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_125, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_124, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
        else if(like_target) {
            if(all_) {
                rows_135=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_136=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_135),it_137=list$1map$2char$phchar$ph$ph_begin(o2_saved_136);!list$1map$2char$phchar$ph$ph_end(o2_saved_136);it_137=list$1map$2char$phchar$ph$ph_next(o2_saved_136)){
                    row_138=it_137;
                    value_139=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_138,like_target));
                    pattern=like_value;
                    if(like(value_139,pattern)) {
                        for(o2_saved_140=row_138,it3_141=map$2char$phchar$ph_begin(o2_saved_140);!map$2char$phchar$ph_end(o2_saved_140);it3_141=map$2char$phchar$ph_next(o2_saved_140)){
                            value_142=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_138,it3_141));
                            value2_143=(char*)come_increment_ref_count(charp_operator_add(value_142,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_143);
                            (value_142 = come_decrement_ref_count(value_142, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_143 = come_decrement_ref_count(value2_143, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                        (value_139 = come_decrement_ref_count(value_139, (void*)0, (void*)0, 0, 0, (void*)0));
                        break;
                    }
                    (value_139 = come_decrement_ref_count(value_139, (void*)0, (void*)0, 0, 0, (void*)0));
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_136, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_135, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            else {
                rows_144=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_145=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_144),it_146=list$1map$2char$phchar$ph$ph_begin(o2_saved_145);!list$1map$2char$phchar$ph$ph_end(o2_saved_145);it_146=list$1map$2char$phchar$ph$ph_next(o2_saved_145)){
                    row_147=it_146;
                    value_148=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_147,like_target));
                    pattern_149=like_value;
                    if(like(value_148,pattern_149)) {
                        for(o2_saved_150=(struct list$1char$ph*)come_increment_ref_count(field_names),it3_151=list$1char$ph_begin(o2_saved_150);!list$1char$ph_end(o2_saved_150);it3_151=list$1char$ph_next(o2_saved_150)){
                            value_152=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_147,it3_151));
                            value2_153=(char*)come_increment_ref_count(charp_operator_add(value_152,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_153);
                            (value_152 = come_decrement_ref_count(value_152, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_153 = come_decrement_ref_count(value2_153, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                        come_call_finalizer(list$1char$ph$p_finalize, o2_saved_150, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                        (value_148 = come_decrement_ref_count(value_148, (void*)0, (void*)0, 0, 0, (void*)0));
                        break;
                    }
                    (value_148 = come_decrement_ref_count(value_148, (void*)0, (void*)0, 0, 0, (void*)0));
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_145, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_144, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
        else if(not_like_target) {
            if(all_) {
                rows_154=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_155=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_154),it_156=list$1map$2char$phchar$ph$ph_begin(o2_saved_155);!list$1map$2char$phchar$ph$ph_end(o2_saved_155);it_156=list$1map$2char$phchar$ph$ph_next(o2_saved_155)){
                    row_157=it_156;
                    value_158=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_157,not_like_target));
                    pattern_159=not_like_value;
                    if(!like(value_158,pattern_159)) {
                        for(o2_saved_160=row_157,it3_161=map$2char$phchar$ph_begin(o2_saved_160);!map$2char$phchar$ph_end(o2_saved_160);it3_161=map$2char$phchar$ph_next(o2_saved_160)){
                            value_162=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_157,it3_161));
                            value2_163=(char*)come_increment_ref_count(charp_operator_add(value_162,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_163);
                            (value_162 = come_decrement_ref_count(value_162, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_163 = come_decrement_ref_count(value2_163, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                        (value_158 = come_decrement_ref_count(value_158, (void*)0, (void*)0, 0, 0, (void*)0));
                        break;
                    }
                    (value_158 = come_decrement_ref_count(value_158, (void*)0, (void*)0, 0, 0, (void*)0));
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_155, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_154, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            else {
                rows_164=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_165=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_164),it_166=list$1map$2char$phchar$ph$ph_begin(o2_saved_165);!list$1map$2char$phchar$ph$ph_end(o2_saved_165);it_166=list$1map$2char$phchar$ph$ph_next(o2_saved_165)){
                    row_167=it_166;
                    value_168=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_167,not_like_target));
                    pattern_169=not_like_value;
                    if(!like(value_168,pattern_169)) {
                        for(o2_saved_170=(struct list$1char$ph*)come_increment_ref_count(field_names),it3_171=list$1char$ph_begin(o2_saved_170);!list$1char$ph_end(o2_saved_170);it3_171=list$1char$ph_next(o2_saved_170)){
                            value_172=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_167,it3_171));
                            value2_173=(char*)come_increment_ref_count(charp_operator_add(value_172,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_173);
                            (value_172 = come_decrement_ref_count(value_172, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_173 = come_decrement_ref_count(value2_173, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                        come_call_finalizer(list$1char$ph$p_finalize, o2_saved_170, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                        (value_168 = come_decrement_ref_count(value_168, (void*)0, (void*)0, 0, 0, (void*)0));
                        break;
                    }
                    (value_168 = come_decrement_ref_count(value_168, (void*)0, (void*)0, 0, 0, (void*)0));
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_165, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_164, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
        else if(where_node) {
            if(all_) {
                rows_174=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_175=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_174),it_176=list$1map$2char$phchar$ph$ph_begin(o2_saved_175);!list$1map$2char$phchar$ph$ph_end(o2_saved_175);it_176=list$1map$2char$phchar$ph$ph_next(o2_saved_175)){
                    row_177=it_176;
                    if(where_select(row_177,where_node)) {
                        for(o2_saved_178=row_177,it2_179=map$2char$phchar$ph_begin(o2_saved_178);!map$2char$phchar$ph_end(o2_saved_178);it2_179=map$2char$phchar$ph_next(o2_saved_178)){
                            value_180=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_177,it2_179));
                            value2_181=(char*)come_increment_ref_count(charp_operator_add(value_180,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_181);
                            (value_180 = come_decrement_ref_count(value_180, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_181 = come_decrement_ref_count(value2_181, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                    }
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_175, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_174, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            else if(max_) {
                rows_182=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                max_value=0;
                max_row=((void*)0);
                for(o2_saved_183=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_182),it_184=list$1map$2char$phchar$ph$ph_begin(o2_saved_183);!list$1map$2char$phchar$ph$ph_end(o2_saved_183);it_184=list$1map$2char$phchar$ph$ph_next(o2_saved_183)){
                    row_185=it_184;
                    if(where_select(row_185,where_node)) {
                        for(o2_saved_186=(struct list$1char$ph*)come_increment_ref_count(field_names),it2_187=list$1char$ph_begin(o2_saved_186);!list$1char$ph_end(o2_saved_186);it2_187=list$1char$ph_next(o2_saved_186)){
                            value_188=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_185,it2_187));
                            if(map$2char$ph_Bool$_operator_load_element(max_field,it2_187)) {
                                if(atoi(value_188)>max_value) {
                                    max_value=atoi(value_188);
                                    max_row=row_185;
                                }
                            }
                            (value_188 = come_decrement_ref_count(value_188, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                        come_call_finalizer(list$1char$ph$p_finalize, o2_saved_186, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    }
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_183, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                if(max_row) {
                    for(o2_saved_189=(struct list$1char$ph*)come_increment_ref_count(field_names),it2_190=list$1char$ph_begin(o2_saved_189);!list$1char$ph_end(o2_saved_189);it2_190=list$1char$ph_next(o2_saved_189)){
                        value_191=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(max_row,it2_190));
                        value2_192=(char*)come_increment_ref_count(charp_operator_add(value_191,((char*)(__right_value1=__builtin_string(deliminater)))));
                        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                        buffer_append_str(buf,value2_192);
                        (value_191 = come_decrement_ref_count(value_191, (void*)0, (void*)0, 0, 0, (void*)0));
                        (value2_192 = come_decrement_ref_count(value2_192, (void*)0, (void*)0, 0, 0, (void*)0));
                    }
                    come_call_finalizer(list$1char$ph$p_finalize, o2_saved_189, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_182, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            else {
                rows_193=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
                for(o2_saved_194=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_193),it_195=list$1map$2char$phchar$ph$ph_begin(o2_saved_194);!list$1map$2char$phchar$ph$ph_end(o2_saved_194);it_195=list$1map$2char$phchar$ph$ph_next(o2_saved_194)){
                    row_196=it_195;
                    max_value_197=0;
                    if(where_select(row_196,where_node)) {
                        for(o2_saved_198=(struct list$1char$ph*)come_increment_ref_count(field_names),it2_199=list$1char$ph_begin(o2_saved_198);!list$1char$ph_end(o2_saved_198);it2_199=list$1char$ph_next(o2_saved_198)){
                            value_200=(char*)come_increment_ref_count(map$2char$phchar$ph_operator_load_element(row_196,it2_199));
                            value2_201=(char*)come_increment_ref_count(charp_operator_add(value_200,((char*)(__right_value1=__builtin_string(deliminater)))));
                            (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
                            buffer_append_str(buf,value2_201);
                            (value_200 = come_decrement_ref_count(value_200, (void*)0, (void*)0, 0, 0, (void*)0));
                            (value2_201 = come_decrement_ref_count(value2_201, (void*)0, (void*)0, 0, 0, (void*)0));
                        }
                        come_call_finalizer(list$1char$ph$p_finalize, o2_saved_198, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    }
                }
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_194, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_193, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
        else if(all_) {
            rows_202=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
            for(o2_saved_203=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_202),it_204=list$1map$2char$phchar$ph$ph_begin(o2_saved_203);!list$1map$2char$phchar$ph$ph_end(o2_saved_203);it_204=list$1map$2char$phchar$ph$ph_next(o2_saved_203)){
                row_205=it_204;
                for(o2_saved_206=row_205,it2_207=map$2char$phchar$ph_begin(o2_saved_206);!map$2char$phchar$ph_end(o2_saved_206);it2_207=map$2char$phchar$ph_next(o2_saved_206)){
                    value_208=(char*)come_increment_ref_count(string_operator_add(((char*)(__right_value2=map$2char$phchar$ph_operator_load_element(row_205,it2_207))),((char*)(__right_value3=__builtin_string(deliminater)))));
                    (__right_value2 = come_decrement_ref_count(__right_value2, (void*)0, (void*)0, 1, 0, (void*)0));
                    (__right_value3 = come_decrement_ref_count(__right_value3, (void*)0, (void*)0, 1, 0, (void*)0));
                    buffer_append_str(buf,value_208);
                    (value_208 = come_decrement_ref_count(value_208, (void*)0, (void*)0, 0, 0, (void*)0));
                }
            }
            come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_203, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_202, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        }
        else {
            rows_209=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(table->rows);
            for(o2_saved_210=(struct list$1map$2char$phchar$ph$ph*)come_increment_ref_count(rows_209),it_211=list$1map$2char$phchar$ph$ph_begin(o2_saved_210);!list$1map$2char$phchar$ph$ph_end(o2_saved_210);it_211=list$1map$2char$phchar$ph$ph_next(o2_saved_210)){
                row_212=it_211;
                for(o2_saved_213=(struct list$1char$ph*)come_increment_ref_count(field_names),it2_214=list$1char$ph_begin(o2_saved_213);!list$1char$ph_end(o2_saved_213);it2_214=list$1char$ph_next(o2_saved_213)){
                    str=(char*)come_increment_ref_count(string_operator_add(((char*)(__right_value2=map$2char$phchar$ph_operator_load_element(row_212,it2_214))),((char*)(__right_value3=__builtin_string(deliminater)))));
                    (__right_value2 = come_decrement_ref_count(__right_value2, (void*)0, (void*)0, 1, 0, (void*)0));
                    (__right_value3 = come_decrement_ref_count(__right_value3, (void*)0, (void*)0, 1, 0, (void*)0));
                    buffer_append_str(buf,str);
                    (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
                }
                come_call_finalizer(list$1char$ph$p_finalize, o2_saved_213, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
            come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, o2_saved_210, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            come_call_finalizer(list$1map$2char$phchar$ph$ph$p_finalize, rows_209, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        }
        str_215=(char*)come_increment_ref_count(buffer_to_string(buf));
        if(string_operator_equals(str_215,"")) {
            char* not_found="NOT FOUND\n";
            write(info->socket,not_found,strlen(not_found));
            f=fopen("database.log","a");
            fprintf(f,"%s\n",not_found);
            fclose(f);
        }
        else {
            write(info->socket,str_215,string_length(str_215));
            f_216=fopen("database.log","a");
            fprintf(f_216,"%s\n",str_215);
            fclose(f_216);
        }
        (str_215 = come_decrement_ref_count(str_215, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    else {
        __result_obj__0 = 0;
        come_call_finalizer(list$1char$ph$p_finalize, field_names, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(map$2char$ph_Bool$$p_finalize, max_field, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(WhereNode_finalize, where_node, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (in_target = come_decrement_ref_count(in_target, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(list$1char$ph$p_finalize, in_values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (between_target = come_decrement_ref_count(between_target, (void*)0, (void*)0, 0, 0, (void*)0));
        (like_target = come_decrement_ref_count(like_target, (void*)0, (void*)0, 0, 0, (void*)0));
        (not_like_target = come_decrement_ref_count(not_like_target, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(tuple2$2char$phchar$ph$p_finalize, between_values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (like_value = come_decrement_ref_count(like_value, (void*)0, (void*)0, 0, 0, (void*)0));
        (not_like_value = come_decrement_ref_count(not_like_value, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(Database_finalize, current_db, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(Table_finalize, table, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    __result_obj__0 = 1;
    come_call_finalizer(list$1char$ph$p_finalize, field_names, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(map$2char$ph_Bool$$p_finalize, max_field, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (table_name = come_decrement_ref_count(table_name, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(WhereNode_finalize, where_node, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (in_target = come_decrement_ref_count(in_target, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(list$1char$ph$p_finalize, in_values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (between_target = come_decrement_ref_count(between_target, (void*)0, (void*)0, 0, 0, (void*)0));
    (like_target = come_decrement_ref_count(like_target, (void*)0, (void*)0, 0, 0, (void*)0));
    (not_like_target = come_decrement_ref_count(not_like_target, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(tuple2$2char$phchar$ph$p_finalize, between_values, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (like_value = come_decrement_ref_count(like_value, (void*)0, (void*)0, 0, 0, (void*)0));
    (not_like_value = come_decrement_ref_count(not_like_value, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(Database_finalize, current_db, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(Table_finalize, table, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    return __result_obj__0;
}

static struct map$2char$ph_Bool$* map$2char$ph_Bool$_initialize(struct map$2char$ph_Bool$* self)
{
    void* __right_value0 = (void*)0;
    int i;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* __dec_obj49;
    struct map$2char$ph_Bool$* __result_obj__0;
    self->keys=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(128)), "/usr/local/include/neo-c.h", 1999, "char**"))));
    self->items=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(128)), "/usr/local/include/neo-c.h", 2000, "_Bool*"))));
    self->item_existance=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(128)), "/usr/local/include/neo-c.h", 2001, "_Bool*"))));
    for(i=0;i<128;i++){
        self->item_existance[i]=0;
    }
    self->size=128;
    self->len=0;
    __dec_obj49=self->key_list,
    self->key_list=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 2011, "struct list$1char$ph*"))));
    come_call_finalizer(list$1char$ph_finalize, __dec_obj49,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    self->it=0;
    __result_obj__0 = (struct map$2char$ph_Bool$*)come_increment_ref_count(self);
    come_call_finalizer(map$2char$ph_Bool$$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(map$2char$ph_Bool$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static void map$2char$ph_Bool$$p_finalize(struct map$2char$ph_Bool$* self)
{
    int i;
    int i_71;
    for(i=0;i<self->size;i++){
        if(self->item_existance[i]) {
            if(0) {
            }
        }
    }
    come_free((char*)self->items);
    for(i_71=0;i_71<self->size;i_71++){
        if(self->item_existance[i_71]) {
            if(1) {
                (self->keys[i_71] = come_decrement_ref_count(self->keys[i_71], (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
    }
    come_free((char*)self->keys);
    come_call_finalizer(list$1char$ph$p_finalize, self->key_list, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
}

static struct map$2char$ph_Bool$* map$2char$ph_Bool$_insert(struct map$2char$ph_Bool$* self, char* key  , _Bool item)
{
    struct map$2char$ph_Bool$* __result_obj__0;
    unsigned int hash;
    unsigned int it;
    _Bool same_key_exist;
    char* it2  ;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
        return __result_obj__0;
    }
    if(self->len*10>=self->size) {
        map$2char$ph_Bool$_rehash(self);
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                if(1) {
                    list$1char$ph_remove(self->key_list,self->keys[it]);
                    (self->keys[it] = come_decrement_ref_count(self->keys[it], (void*)0, (void*)0, 0, 0, (void*)0));
                    self->keys[it]=(char*)come_increment_ref_count(key);
                }
                else {
                    list$1char$ph_remove(self->key_list,self->keys[it]);
                    self->keys[it]=key;
                }
                if(0) {
                    self->items[it]=item;
                }
                else {
                    self->items[it]=item;
                }
                break;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                printf("unexpected error in map.insert\n");
                stackframe();
                exit(2);
            }
        }
        else {
            self->item_existance[it]=1;
            if(1) {
                self->keys[it]=(char*)come_increment_ref_count(key);
            }
            else {
                self->keys[it]=key;
            }
            if(0) {
                self->items[it]=item;
            }
            else {
                self->items[it]=item;
            }
            self->len++;
            break;
        }
    }
    same_key_exist=0;
    for(it2=list$1char$ph_begin(self->key_list);!list$1char$ph_end(self->key_list);it2=list$1char$ph_next(self->key_list)){
        if(string_equals(it2,key)) {
            same_key_exist=1;
        }
    }
    if(!same_key_exist) {
        list$1char$ph_push_back(self->key_list,(char*)come_increment_ref_count(key));
    }
    __result_obj__0 = self;
    (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
    return __result_obj__0;
}

static void map$2char$ph_Bool$_rehash(struct map$2char$ph_Bool$* self)
{
    int size;
    void* __right_value0 = (void*)0;
    char** keys  ;
    _Bool* items;
    _Bool* item_existance;
    int len;
    char* it  ;
    _Bool default_value;
    _Bool it2;
    unsigned int hash;
    int n;
    _Bool default_value_74;
    size=self->size*10;
    keys=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(size)), "/usr/local/include/neo-c.h", 2299, "char**"))));
    items=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(size)), "/usr/local/include/neo-c.h", 2300, "_Bool*"))));
    item_existance=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(size)), "/usr/local/include/neo-c.h", 2301, "_Bool*"))));
    len=0;
    for(it=map$2char$ph_Bool$_begin(self);!map$2char$ph_Bool$_end(self);it=map$2char$ph_Bool$_next(self)){
        memset(&default_value,0,sizeof(_Bool));
        it2=map$2char$ph_Bool$_at(self,it,default_value);
        hash=string_get_hash_key(((char*)it))%size;
        n=hash;
        while(1) {
            if(item_existance[n]) {
                n++;
                if(n>=size) {
                    n=0;
                }
                else if(n==hash) {
                    printf("unexpected error in map.rehash(1)\n");
                    stackframe();
                    exit(2);
                }
            }
            else {
                item_existance[n]=1;
                keys[n]=it;
                memset(&default_value_74,0,sizeof(_Bool));
                items[n]=map$2char$ph_Bool$_at(self,it,default_value_74);
                len++;
                break;
            }
        }
    }
    come_free((char*)self->items);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
    come_free((char*)self->keys);
    self->keys=keys;
    self->items=items;
    self->item_existance=item_existance;
    self->size=size;
    self->len=len;
}

static char* map$2char$ph_Bool$_begin(struct map$2char$ph_Bool$* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_72  ;
    if(self==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->key_list->it=self->key_list->head;
    if(self->key_list->it) {
        __result_obj__0 = self->key_list->it->item;
        return __result_obj__0;
    }
    memset(&result_72,0,sizeof(char*));
    __result_obj__0 = result_72;
    return __result_obj__0;
}

static _Bool map$2char$ph_Bool$_end(struct map$2char$ph_Bool$* self)
{
    return self==((void*)0)||self->key_list==((void*)0)||self->key_list->it==((void*)0);
}

static char* map$2char$ph_Bool$_next(struct map$2char$ph_Bool$* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_73  ;
    if(self==((void*)0)||self->key_list->it==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->key_list->it=self->key_list->it->next;
    if(self->key_list->it) {
        __result_obj__0 = self->key_list->it->item;
        return __result_obj__0;
    }
    memset(&result_73,0,sizeof(char*));
    __result_obj__0 = result_73;
    return __result_obj__0;
}

static _Bool map$2char$ph_Bool$_at(struct map$2char$ph_Bool$* self, char* key  , _Bool default_value)
{
    unsigned int hash;
    unsigned int it;
    if(self==((void*)0)) {
        return default_value;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                return self->items[it];
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                return default_value;
            }
        }
        else {
            return default_value;
        }
    }
    return default_value;
}

static void tuple2$2char$phchar$ph$p_finalize(struct tuple2$2char$phchar$ph* self)
{
    if(self!=((void*)0)&&self->v1!=((void*)0)) {
        (self->v1 = come_decrement_ref_count(self->v1, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    if(self!=((void*)0)&&self->v2!=((void*)0)) {
        (self->v2 = come_decrement_ref_count(self->v2, (void*)0, (void*)0, 0, 0, (void*)0));
    }
}

static struct tuple2$2char$phchar$ph* tuple2$2char$phchar$ph_initialize(struct tuple2$2char$phchar$ph* self, char* v1  , char* v2  )
{
    char* __dec_obj54  ;
    char* __dec_obj55  ;
    struct tuple2$2char$phchar$ph* __result_obj__0;
    __dec_obj54=self->v1,
    self->v1=(char*)come_increment_ref_count(v1);
    __dec_obj54 = come_decrement_ref_count(__dec_obj54, (void*)0, (void*)0, 0,0, (void*)0);
    __dec_obj55=self->v2,
    self->v2=(char*)come_increment_ref_count(v2);
    __dec_obj55 = come_decrement_ref_count(__dec_obj55, (void*)0, (void*)0, 0,0, (void*)0);
    __result_obj__0 = (struct tuple2$2char$phchar$ph*)come_increment_ref_count(self);
    come_call_finalizer(tuple2$2char$phchar$ph$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    (v1 = come_decrement_ref_count(v1, (void*)0, (void*)0, 0, 0, (void*)0));
    (v2 = come_decrement_ref_count(v2, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(tuple2$2char$phchar$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct map$2char$phchar$ph* list$1map$2char$phchar$ph$ph_begin(struct list$1map$2char$phchar$ph$ph* self)
{
    struct map$2char$phchar$ph* result;
    struct map$2char$phchar$ph* __result_obj__0;
    struct map$2char$phchar$ph* result_78;
    if(self==((void*)0)) {
        memset(&result,0,sizeof(struct map$2char$phchar$ph*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->it=self->head;
    if(self->it) {
        __result_obj__0 = self->it->item;
        return __result_obj__0;
    }
    memset(&result_78,0,sizeof(struct map$2char$phchar$ph*));
    __result_obj__0 = result_78;
    return __result_obj__0;
}

static _Bool list$1map$2char$phchar$ph$ph_end(struct list$1map$2char$phchar$ph$ph* self)
{
    return self==((void*)0)||self->it==((void*)0);
}

static struct map$2char$phchar$ph* list$1map$2char$phchar$ph$ph_next(struct list$1map$2char$phchar$ph$ph* self)
{
    struct map$2char$phchar$ph* result;
    struct map$2char$phchar$ph* __result_obj__0;
    struct map$2char$phchar$ph* result_79;
    if(self==((void*)0)||self->it==((void*)0)) {
        memset(&result,0,sizeof(struct map$2char$phchar$ph*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->it=self->it->next;
    if(self->it) {
        __result_obj__0 = self->it->item;
        return __result_obj__0;
    }
    memset(&result_79,0,sizeof(struct map$2char$phchar$ph*));
    __result_obj__0 = result_79;
    return __result_obj__0;
}

static _Bool map$2char$ph_Bool$$p_operator_load_element(struct map$2char$ph_Bool$* self, char* key  )
{
    _Bool default_value;
    unsigned int hash;
    unsigned int it;
    memset(&default_value,0,sizeof(_Bool));
    if(self==((void*)0)) {
        return default_value;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                return self->items[it];
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                return default_value;
            }
        }
        else {
            return default_value;
        }
    }
    return default_value;
}

static _Bool map$2char$ph_Bool$_operator_load_element(struct map$2char$ph_Bool$* self, char* key  )
{
    _Bool default_value;
    unsigned int hash;
    unsigned int it;
    memset(&default_value,0,sizeof(_Bool));
    if(self==((void*)0)) {
        return default_value;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                return self->items[it];
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                return default_value;
            }
        }
        else {
            return default_value;
        }
    }
    return default_value;
}

char* show_tables(struct sInfo* info  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    struct Database* current_db  ;
    struct map$2char$phTable$ph* o2_saved;
    char* it  ;
    struct Table* table  ;
    char* __result_obj__0  ;
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "main.nc", 1169, "struct buffer*"))));
    current_db=(struct Database*)come_increment_ref_count(map$2char$phDatabase$ph_operator_load_element(gDatabases,info->current_db_name));
    for(o2_saved=(struct map$2char$phTable$ph*)come_increment_ref_count(current_db->tables),it=map$2char$phTable$ph_begin(o2_saved);!map$2char$phTable$ph_end(o2_saved);it=map$2char$phTable$ph_next(o2_saved)){
        table=(struct Table*)come_increment_ref_count(map$2char$phTable$ph_operator_load_element(current_db->tables,it));
        buffer_append_str(buf,table->name);
        buffer_append_str(buf,"\n");
        buffer_append_str(buf,((char*)(__right_value0=Table_to_string(table))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        buffer_append_str(buf,"\n");
        come_call_finalizer(Table_finalize, table, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    come_call_finalizer(map$2char$phTable$ph$p_finalize, o2_saved, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(buf))));
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(Database_finalize, current_db, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int main()
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct map$2char$phDatabase$ph* __dec_obj63;
    struct sInfo info  ;
    char* __dec_obj64  ;
    struct __current_stack1__ __current_stack1__;
    int __result_obj__0;
    memset(&info, 0, sizeof(info));
    memset(&__current_stack1__, 0, sizeof(struct __current_stack1__));
    come_heap_init(0);
    setlocale(6,"");
    __dec_obj63=gDatabases,
    gDatabases=(struct map$2char$phDatabase$ph*)come_increment_ref_count(map$2char$phDatabase$ph_initialize((struct map$2char$phDatabase$ph*)come_increment_ref_count((struct map$2char$phDatabase$ph*)come_calloc(1, sizeof(struct map$2char$phDatabase$ph)*(1), "main.nc", 1186, "struct map$2char$phDatabase$ph*"))));
    come_call_finalizer(map$2char$phDatabase$ph_finalize, __dec_obj63,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    __dec_obj64=info.current_db_name,
    info.current_db_name=((void*)0);
    __dec_obj64 = come_decrement_ref_count(__dec_obj64, (void*)0, (void*)0, 0,0, (void*)0);
    ({    __current_stack1__.info = &info;
    })    ,    server_socket(3366,2,(1),0,1,&__current_stack1__,(void*)fun_block1_mainnc);
    __result_obj__0 = 0;
    come_call_finalizer(sInfo_finalize, (&info), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    come_call_finalizer(map$2char$phDatabase$ph$p_finalize, gDatabases, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_heap_final();
    return __result_obj__0;
}

static struct map$2char$phDatabase$ph* map$2char$phDatabase$ph_initialize(struct map$2char$phDatabase$ph* self)
{
    void* __right_value0 = (void*)0;
    int i;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* __dec_obj62;
    struct map$2char$phDatabase$ph* __result_obj__0;
    self->keys=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(128)), "/usr/local/include/neo-c.h", 1999, "char**"))));
    self->items=(struct Database**)come_increment_ref_count(((struct Database**)(__right_value0=(struct Database**)come_calloc(1, sizeof(struct Database*)*(1*(128)), "/usr/local/include/neo-c.h", 2000, "struct Database**"))));
    self->item_existance=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(128)), "/usr/local/include/neo-c.h", 2001, "_Bool*"))));
    for(i=0;i<128;i++){
        self->item_existance[i]=0;
    }
    self->size=128;
    self->len=0;
    __dec_obj62=self->key_list,
    self->key_list=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 2011, "struct list$1char$ph*"))));
    come_call_finalizer(list$1char$ph_finalize, __dec_obj62,(void*)0, (void*)0, 0, 0, 0, (void*)0);
    self->it=0;
    __result_obj__0 = (struct map$2char$phDatabase$ph*)come_increment_ref_count(self);
    come_call_finalizer(map$2char$phDatabase$ph$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(map$2char$phDatabase$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static void map$2char$phDatabase$ph$p_finalize(struct map$2char$phDatabase$ph* self)
{
    int i;
    int i_217;
    for(i=0;i<self->size;i++){
        if(self->item_existance[i]) {
            if(1) {
                come_call_finalizer(Database_finalize, self->items[i], (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
    }
    come_free((char*)self->items);
    for(i_217=0;i_217<self->size;i_217++){
        if(self->item_existance[i_217]) {
            if(1) {
                (self->keys[i_217] = come_decrement_ref_count(self->keys[i_217], (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
    }
    come_free((char*)self->keys);
    come_call_finalizer(list$1char$ph$p_finalize, self->key_list, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
}

static void map$2char$phDatabase$ph_finalize(struct map$2char$phDatabase$ph* self)
{
    int i;
    int i_218;
    for(i=0;i<self->size;i++){
        if(self->item_existance[i]) {
            if(1) {
                come_call_finalizer(Database_finalize, self->items[i], (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
    }
    come_free((char*)self->items);
    for(i_218=0;i_218<self->size;i_218++){
        if(self->item_existance[i_218]) {
            if(1) {
                (self->keys[i_218] = come_decrement_ref_count(self->keys[i_218], (void*)0, (void*)0, 0, 0, (void*)0));
            }
        }
    }
    come_free((char*)self->keys);
    come_call_finalizer(list$1char$ph$p_finalize, self->key_list, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
}

void fun_block1_mainnc(struct __current_stack1__* parent, int it  , _Bool* it2, _Bool* it3)
{
    int size;
    struct _IO_FILE* f  ;
    char* p;
    void* __right_value0 = (void*)0;
    char* word  ;
    _Bool _conditional_value_X0;
    char* __dec_obj65  ;
    struct _IO_FILE* f_219  ;
    struct _IO_FILE* f_220  ;
    char* str  ;
    struct _IO_FILE* f_221  ;
    struct _IO_FILE* f_223  ;
    char* word_224  ;
    _Bool _conditional_value_X1;
    void* __right_value1 = (void*)0;
    void* __right_value2 = (void*)0;
    void* __right_value3 = (void*)0;
    struct _IO_FILE* f_229  ;
    struct _IO_FILE* f_230  ;
    struct _IO_FILE* f_232  ;
    struct _IO_FILE* f_234  ;
    char data[1024]={0};
    size=read(it,data,1023);
    if(size<=0) {
        *it3=1;
        return;
    }
    data[size]=0;
    f=fopen("database.log","a");
    fprintf(f,"Recived: %s\n",data);
    fclose(f);
    p=data;
    (*(parent->info)).p=p;
    (*(parent->info)).socket=it;
    if(strncmp((*(parent->info)).p,"use",strlen("use"))==0) {
        (*(parent->info)).p+=strlen("use");
        skip_spaces(&(*(parent->info)));
        word=(char*)come_increment_ref_count(parse_word(&(*(parent->info))));
        if(({(_conditional_value_X0=(((struct Database*)(__right_value0=map$2char$phDatabase$ph_operator_load_element(gDatabases,word)))));        come_call_finalizer(Database_finalize, __right_value0, (void*)0, (void*)0, 0, 1, 0, (void*)0);
_conditional_value_X0;})) {
            __dec_obj65=(*(parent->info)).current_db_name,
            (*(parent->info)).current_db_name=(char*)come_increment_ref_count(word);
            __dec_obj65 = come_decrement_ref_count(__dec_obj65, (void*)0, (void*)0, 0,0, (void*)0);
            char* ok_message="OK\n";
            write(it,ok_message,strlen(ok_message));
            f_219=fopen("database.log","a");
            fprintf(f_219,"%s\n",ok_message);
            fclose(f_219);
        }
        else {
            char* not_found="NOT FOUND\n";
            write(it,not_found,strlen(not_found));
            f_220=fopen("database.log","a");
            fprintf(f_220,"%s\n",not_found);
            fclose(f_220);
        }
        (word = come_decrement_ref_count(word, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    else if(strncmp((*(parent->info)).p,"show tables",strlen("show tables"))==0) {
        (*(parent->info)).p+=strlen("show tables");
        skip_spaces(&(*(parent->info)));
        if((*(parent->info)).current_db_name) {
            str=(char*)come_increment_ref_count(show_tables(&(*(parent->info))));
            write(it,str,strlen(str));
            f_221=fopen("database.log","a");
            fprintf(f_221,"%s\n",str);
            fclose(f_221);
            (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else {
            char* not_found_222="NOT FOUND\n";
            write(it,not_found_222,strlen(not_found_222));
            f_223=fopen("database.log","a");
            fprintf(f_223,"%s\n",not_found_222);
            fclose(f_223);
        }
    }
    else if(strncmp((*(parent->info)).p,"CREATE DATABASE",strlen("CREATE DATABASE"))==0) {
        (*(parent->info)).p+=strlen("CREATE DATABASE");
        skip_spaces(&(*(parent->info)));
        word_224=(char*)come_increment_ref_count(parse_word(&(*(parent->info))));
        if(({(_conditional_value_X1=(((struct Database*)(__right_value0=map$2char$phDatabase$ph_operator_load_element(gDatabases,word_224)))==((void*)0)));        come_call_finalizer(Database_finalize, __right_value0, (void*)0, (void*)0, 0, 1, 0, (void*)0);
_conditional_value_X1;})) {
            map$2char$phDatabase$ph_operator_store_element(gDatabases,(char*)come_increment_ref_count(word_224),(struct Database*)come_increment_ref_count(Database_initialize((struct Database*)come_increment_ref_count((struct Database*)come_calloc(1, sizeof(struct Database)*(1), "main.nc", 1260, "struct Database*")),(char*)come_increment_ref_count(word_224))));
        }
        char* ok_message_228="OK\n";
        write(it,ok_message_228,strlen(ok_message_228));
        f_229=fopen("database.log","a");
        fprintf(f_229,"%s\n",ok_message_228);
        fclose(f_229);
        (word_224 = come_decrement_ref_count(word_224, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    else if(strncmp((*(parent->info)).p,"CREATE TABLE",strlen("CREATE TABLE"))==0) {
        if(!eval_create_table(&(*(parent->info)))) {
            f_230=fopen("database.log","a");
            fprintf(f_230,"FAILED\n");
            fclose(f_230);
            return;
        }
        char* ok_message_231="OK\n";
        write(it,ok_message_231,strlen(ok_message_231));
        f_232=fopen("database.log","a");
        fprintf(f_232,"%s\n",ok_message_231);
        fclose(f_232);
    }
    else if(strncmp((*(parent->info)).p,"INSERT INTO",strlen("INSERT INTO"))==0) {
        if(!eval_insert_into(&(*(parent->info)))) {
            return;
        }
        char* ok_message_233="OK\n";
        write(it,ok_message_233,strlen(ok_message_233));
        f_234=fopen("database.log","a");
        fprintf(f_234,"%s\n",ok_message_233);
        fclose(f_234);
    }
    else if(strncmp((*(parent->info)).p,"SELECT",strlen("SELECT"))==0) {
        if(!eval_select_from("\n",&(*(parent->info)))) {
            return;
        }
    }
    else if(strncmp((*(parent->info)).p,"exit",strlen("exit"))==0) {
        *it2=1;
        return;
    }
}

static void map$2char$phDatabase$ph_operator_store_element(struct map$2char$phDatabase$ph* self, char* key  , struct Database* item  )
{
    if(self==((void*)0)) {
        (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(Database_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return;
    }
    map$2char$phDatabase$ph_insert(self,(char*)come_increment_ref_count(key),(struct Database*)come_increment_ref_count(item));
    (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(Database_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
}

static struct map$2char$phDatabase$ph* map$2char$phDatabase$ph_insert(struct map$2char$phDatabase$ph* self, char* key  , struct Database* item  )
{
    struct map$2char$phDatabase$ph* __result_obj__0;
    unsigned int hash;
    unsigned int it;
    _Bool same_key_exist;
    char* it2  ;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
        come_call_finalizer(Database_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        return __result_obj__0;
    }
    if(self->len*10>=self->size) {
        map$2char$phDatabase$ph_rehash(self);
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                if(1) {
                    list$1char$ph_remove(self->key_list,self->keys[it]);
                    (self->keys[it] = come_decrement_ref_count(self->keys[it], (void*)0, (void*)0, 0, 0, (void*)0));
                    self->keys[it]=(char*)come_increment_ref_count(key);
                }
                else {
                    list$1char$ph_remove(self->key_list,self->keys[it]);
                    self->keys[it]=key;
                }
                if(1) {
                    come_call_finalizer(Database_finalize, self->items[it], (void*)0, (void*)0, 0, 0, 0, (void*)0);
                    self->items[it]=(struct Database*)come_increment_ref_count(item);
                }
                else {
                    self->items[it]=item;
                }
                break;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                printf("unexpected error in map.insert\n");
                stackframe();
                exit(2);
            }
        }
        else {
            self->item_existance[it]=1;
            if(1) {
                self->keys[it]=(char*)come_increment_ref_count(key);
            }
            else {
                self->keys[it]=key;
            }
            if(1) {
                self->items[it]=(struct Database*)come_increment_ref_count(item);
            }
            else {
                self->items[it]=item;
            }
            self->len++;
            break;
        }
    }
    same_key_exist=0;
    for(it2=list$1char$ph_begin(self->key_list);!list$1char$ph_end(self->key_list);it2=list$1char$ph_next(self->key_list)){
        if(string_equals(it2,key)) {
            same_key_exist=1;
        }
    }
    if(!same_key_exist) {
        list$1char$ph_push_back(self->key_list,(char*)come_increment_ref_count(key));
    }
    __result_obj__0 = self;
    (key = come_decrement_ref_count(key, (void*)0, (void*)0, 0, 0, (void*)0));
    come_call_finalizer(Database_finalize, item, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    return __result_obj__0;
}

static void map$2char$phDatabase$ph_rehash(struct map$2char$phDatabase$ph* self)
{
    int size;
    void* __right_value0 = (void*)0;
    char** keys  ;
    struct Database** items  ;
    _Bool* item_existance;
    int len;
    char* it  ;
    struct Database* default_value  ;
    struct Database* it2  ;
    unsigned int hash;
    int n;
    struct Database* default_value_227  ;
    size=self->size*10;
    keys=(char**)come_increment_ref_count(((char**)(__right_value0=(char**)come_calloc(1, sizeof(char*)*(1*(size)), "/usr/local/include/neo-c.h", 2299, "char**"))));
    items=(struct Database**)come_increment_ref_count(((struct Database**)(__right_value0=(struct Database**)come_calloc(1, sizeof(struct Database*)*(1*(size)), "/usr/local/include/neo-c.h", 2300, "struct Database**"))));
    item_existance=(_Bool*)come_increment_ref_count(((_Bool*)(__right_value0=(_Bool*)come_calloc(1, sizeof(_Bool)*(1*(size)), "/usr/local/include/neo-c.h", 2301, "_Bool*"))));
    len=0;
    for(it=map$2char$phDatabase$ph_begin(self);!map$2char$phDatabase$ph_end(self);it=map$2char$phDatabase$ph_next(self)){
        memset(&default_value,0,sizeof(struct Database*));
        it2=((struct Database*)(__right_value0=map$2char$phDatabase$ph_at(self,it,(struct Database*)come_increment_ref_count(default_value))));
        hash=string_get_hash_key(((char*)it))%size;
        n=hash;
        while(1) {
            if(item_existance[n]) {
                n++;
                if(n>=size) {
                    n=0;
                }
                else if(n==hash) {
                    printf("unexpected error in map.rehash(1)\n");
                    stackframe();
                    exit(2);
                }
            }
            else {
                item_existance[n]=1;
                keys[n]=it;
                memset(&default_value_227,0,sizeof(struct Database*));
                items[n]=((struct Database*)(__right_value0=map$2char$phDatabase$ph_at(self,it,(struct Database*)come_increment_ref_count(default_value_227))));
                len++;
                come_call_finalizer(Database_finalize, default_value_227, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                break;
                come_call_finalizer(Database_finalize, default_value_227, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            }
        }
        come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
    come_free((char*)self->items);
    (self->item_existance = come_decrement_ref_count(self->item_existance, (void*)0, (void*)0, 0, 0, (void*)0));
    come_free((char*)self->keys);
    self->keys=keys;
    self->items=items;
    self->item_existance=item_existance;
    self->size=size;
    self->len=len;
}

static char* map$2char$phDatabase$ph_begin(struct map$2char$phDatabase$ph* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_225  ;
    if(self==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->key_list->it=self->key_list->head;
    if(self->key_list->it) {
        __result_obj__0 = self->key_list->it->item;
        return __result_obj__0;
    }
    memset(&result_225,0,sizeof(char*));
    __result_obj__0 = result_225;
    return __result_obj__0;
}

static _Bool map$2char$phDatabase$ph_end(struct map$2char$phDatabase$ph* self)
{
    return self==((void*)0)||self->key_list==((void*)0)||self->key_list->it==((void*)0);
}

static char* map$2char$phDatabase$ph_next(struct map$2char$phDatabase$ph* self)
{
    char* result  ;
    char* __result_obj__0  ;
    char* result_226  ;
    if(self==((void*)0)||self->key_list->it==((void*)0)) {
        memset(&result,0,sizeof(char*));
        __result_obj__0 = result;
        return __result_obj__0;
    }
    self->key_list->it=self->key_list->it->next;
    if(self->key_list->it) {
        __result_obj__0 = self->key_list->it->item;
        return __result_obj__0;
    }
    memset(&result_226,0,sizeof(char*));
    __result_obj__0 = result_226;
    return __result_obj__0;
}

static struct Database* map$2char$phDatabase$ph_at(struct map$2char$phDatabase$ph* self, char* key  , struct Database* default_value  )
{
    struct Database* __result_obj__0  ;
    unsigned int hash;
    unsigned int it;
    if(self==((void*)0)) {
        __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
        come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    hash=string_get_hash_key(((char*)key))%self->size;
    it=hash;
    while(1) {
        if(self->item_existance[it]) {
            if(string_equals(self->keys[it],key)) {
                __result_obj__0 = (struct Database*)come_increment_ref_count(self->items[it]);
                come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
            it++;
            if(it>=self->size) {
                it=0;
            }
            else if(it==hash) {
                __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
                come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
                return __result_obj__0;
            }
        }
        else {
            __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
            come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
            return __result_obj__0;
        }
    }
    __result_obj__0 = (struct Database*)come_increment_ref_count(default_value);
    come_call_finalizer(Database_finalize, default_value, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(Database_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static void sInfo_finalize(struct sInfo* self  )
{
    if(self!=((void*)0)&&self->current_db_name!=((void*)0)) {
        (self->current_db_name = come_decrement_ref_count(self->current_db_name, (void*)0, (void*)0, 0, 0, (void*)0));
    }
}

void come_push_stackframe(char* sname, int sline, int id)
{
    if(gNumComeStackFrame<128) {
        gComeStackFrameSName[gNumComeStackFrame]=sname;
        gComeStackFrameSLine[gNumComeStackFrame]=sline;
        gComeStackFrameID[gNumComeStackFrame]=id;
        gNumComeStackFrame++;
    }
}

void come_pop_stackframe()
{
    if(gNumComeStackFrame>0) {
        gNumComeStackFrame--;
    }
}

void come_save_stackframe(char* sname, int sline)
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    int i;
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 199, "struct buffer*"))));
    buffer_append_format(buf,"%s %d\n",sname,sline);
    for(i=gNumComeStackFrame-2;i>=0;i--){
        buffer_append_format(buf,"%s %d #%d\n",gComeStackFrameSName[i],gComeStackFrameSLine[i],gComeStackFrameID[i]);
    }
    if(gComeStackFrameBuffer) {
        free(gComeStackFrameBuffer);
    }
    gComeStackFrameBuffer=strdup(((char*)(__right_value0=buffer_to_string(buf))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
}

void stackframe()
{
    int i;
    for(i=gNumComeStackFrame-1;i>=0;i--){
        printf("%s %d #%d\n",gComeStackFrameSName[i],gComeStackFrameSLine[i],gComeStackFrameID[i]);
    }
}

char* come_get_stackframe()
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(gComeStackFrameBuffer))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

_Bool die(char* msg)
{
    perror(msg);
    stackframe();
    exit(4);
    return 0;
}

void come_heap_init(int come_debug)
{
    gComeDebugLib=come_debug;
    gComeStackFrameBuffer=((void*)0);
    memset(gComeStackFrameSName,0,sizeof(char*)*128);
    memset(gComeStackFrameSLine,0,sizeof(int)*128);
    memset(gComeStackFrameID,0,sizeof(int)*128);
    gAllocMem=((void*)0);
}

void come_heap_final()
{
    struct sMemHeader* it  ;
    int n;
    _Bool flag;
    int i;
    struct sMemHeaderTiny* it_235  ;
    int n_236;
    if(gComeStackFrameBuffer) {
        free(gComeStackFrameBuffer);
    }
    if(gComeDebugLib) {
        it=gAllocMem;
        n=0;
        while(it) {
            n++;
            flag=0;
            printf("#%d ",n);
            if(it->class_name) {
                printf("%p (%s): ",(char*)it+sizeof(struct sMemHeader)+sizeof(unsigned long)+sizeof(unsigned long),it->class_name);
            }
            for(i=0;i<16;i++){
                if(it->sname[i]) {
                    printf("%s %d #%d, ",it->sname[i],it->sline[i],it->id[i]);
                    flag=1;
                }
            }
            if(flag) {
                puts("");
            }
            it=it->next;
        }
        printf("%d memory leaks. %d alloc, %d free.\n",n,gNumAlloc,gNumFree);
    }
    else {
        it_235=(struct sMemHeaderTiny*)gAllocMem;
        n_236=0;
        while(it_235) {
            n_236++;
            if(it_235->class_name) {
                printf("#%d %p (%s) %s %d\n",n_236,(char*)it_235+sizeof(struct sMemHeader)+sizeof(unsigned long)+sizeof(unsigned long),it_235->class_name,it_235->sname,it_235->sline);
            }
            it_235=it_235->next;
        }
        if(n_236>0) {
            printf("%d memory leaks. %d alloc, %d free.If you require debugging, copmpile with -cg option\n",n_236,gNumAlloc,gNumFree);
        }
    }
}

void* alloc_from_pages(unsigned long size  )
{
    void* __result_obj__0;
    __result_obj__0 = calloc(1,size);
    return __result_obj__0;
}

void come_free_mem_of_heap_pool(void* mem)
{
    struct sMemHeader* it  ;
    struct sMemHeader* prev_it  ;
    struct sMemHeader* next_it  ;
    unsigned long size  ;
    struct sMemHeaderTiny* it_237  ;
    struct sMemHeaderTiny* prev_it_238  ;
    struct sMemHeaderTiny* next_it_239  ;
    unsigned long size_240  ;
    if(mem) {
        if(gComeDebugLib) {
            it=(struct sMemHeader*)((char*)mem-sizeof(struct sMemHeader));
            if(it->allocated!=177783) {
                return;
            }
            it->allocated=0;
            prev_it=it->prev;
            next_it=it->next;
            if(gAllocMem==it) {
                gAllocMem=next_it;
                if(gAllocMem) {
                    gAllocMem->prev=((void*)0);
                }
            }
            else {
                if(prev_it) {
                    prev_it->next=next_it;
                }
                if(next_it) {
                    next_it->prev=prev_it;
                }
            }
            size=it->size;
            free(it);
            gNumFree++;
        }
        else {
            it_237=(struct sMemHeaderTiny*)((char*)mem-sizeof(struct sMemHeaderTiny));
            if(it_237->allocated!=177783) {
                return;
            }
            it_237->allocated=0;
            prev_it_238=it_237->prev;
            next_it_239=it_237->next;
            if(gAllocMem==it_237) {
                gAllocMem=(struct sMemHeader*)next_it_239;
                if(gAllocMem) {
                    gAllocMem->prev=((void*)0);
                }
            }
            else {
                if(prev_it_238) {
                    prev_it_238->next=next_it_239;
                }
                if(next_it_239) {
                    next_it_239->prev=prev_it_238;
                }
            }
            size_240=it_237->size;
            free(it_237);
            gNumFree++;
        }
    }
}

void* come_alloc_mem_from_heap_pool(unsigned long size  , char* sname, int sline, char* class_name)
{
    unsigned long size2  ;
    void* result;
    struct sMemHeader* it  ;
    int i;
    int i_241;
    void* __result_obj__0;
    unsigned long size2_242  ;
    void* result_243;
    struct sMemHeaderTiny* it_244  ;
    memset(&i, 0, sizeof(i));
    memset(&i_241, 0, sizeof(i_241));
    if(gComeDebugLib) {
        size2=size+sizeof(struct sMemHeader);
        size2=(size2+7&~0x7);
        result=alloc_from_pages(size2);
        it=result;
        it->allocated=177783;
        it->size=size2;
        it->free_next=((void*)0);
        come_push_stackframe(sname,sline,0);
        if(gNumComeStackFrame<16) {
            for(i=0;i<gNumComeStackFrame;i++){
                it->sname[i]=gComeStackFrameSName[i];
                it->sline[i]=gComeStackFrameSLine[i];
                it->id[i]=gComeStackFrameID[i];
            }
        }
        else {
            for(i_241=0;i_241<16;i_241++){
                it->sname[i_241]=gComeStackFrameSName[gNumComeStackFrame-1-i_241];
                it->sline[i_241]=gComeStackFrameSLine[gNumComeStackFrame-1-i_241];
                it->id[i_241]=gComeStackFrameID[gNumComeStackFrame-1-i_241];
            }
        }
        come_pop_stackframe();
        it->next=gAllocMem;
        it->prev=((void*)0);
        it->class_name=class_name;
        if(gAllocMem) {
            gAllocMem->prev=it;
        }
        gAllocMem=it;
        gNumAlloc++;
        __result_obj__0 = (char*)result+sizeof(struct sMemHeader);
        return __result_obj__0;
    }
    else {
        size2_242=size+sizeof(struct sMemHeaderTiny);
        size2_242=(size2_242+7&~0x7);
        result_243=alloc_from_pages(size2_242);
        it_244=result_243;
        it_244->allocated=177783;
        it_244->class_name=class_name;
        it_244->sname=sname;
        it_244->sline=sline;
        it_244->size=size2_242;
        it_244->free_next=((void*)0);
        it_244->next=(struct sMemHeaderTiny*)gAllocMem;
        it_244->prev=((void*)0);
        if(gAllocMem) {
            ((struct sMemHeaderTiny*)gAllocMem)->prev=it_244;
        }
        gAllocMem=(struct sMemHeader*)it_244;
        gNumAlloc++;
        __result_obj__0 = (char*)result_243+sizeof(struct sMemHeaderTiny);
        return __result_obj__0;
    }
}

char* come_dynamic_typeof(void* mem)
{
    struct sMemHeader* it  ;
    char* __result_obj__0;
    struct sMemHeaderTiny* it_245  ;
    if(gComeDebugLib) {
        it=(struct sMemHeader*)((char*)mem-sizeof(unsigned long)-sizeof(unsigned long)-sizeof(struct sMemHeader));
        if(it->allocated!=177783) {
            printf("invalid heap object(%p)(1)\n",it);
            exit(2);
        }
        __result_obj__0 = it->class_name;
        return __result_obj__0;
    }
    else {
        it_245=(struct sMemHeaderTiny*)((char*)mem-sizeof(unsigned long)-sizeof(unsigned long)-sizeof(struct sMemHeaderTiny));
        if(it_245->allocated!=177783) {
            printf("invalid heap object(%p)(2)\n",it_245);
            exit(2);
        }
        __result_obj__0 = it_245->class_name;
        return __result_obj__0;
    }
}

void* come_calloc(unsigned long count  , unsigned long size  , char* sname, int sline, char* class_name)
{
    char* mem;
    unsigned long* ref_count  ;
    unsigned long* size2  ;
    void* __result_obj__0;
    mem=come_alloc_mem_from_heap_pool(sizeof(unsigned long)+sizeof(unsigned long)+count*size,sname,sline,class_name);
    ref_count=(unsigned long*)mem;
    *ref_count=0;
    size2=(unsigned long*)(mem+sizeof(unsigned long));
    *size2=size*count+sizeof(unsigned long)+sizeof(unsigned long);
    __result_obj__0 = mem+sizeof(unsigned long)+sizeof(unsigned long);
    return __result_obj__0;
}

void come_free(void* mem)
{
    unsigned long* ref_count  ;
    if(mem==((void*)0)) {
        return;
    }
    ref_count=(unsigned long*)((char*)mem-sizeof(unsigned long)-sizeof(unsigned long));
    come_free_mem_of_heap_pool((char*)ref_count);
}

void* come_memdup(void* block, char* sname, int sline, char* class_name)
{
    void* __result_obj__0;
    char* mem;
    unsigned long* size_p  ;
    unsigned long size  ;
    void* result;
    if(!block) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    mem=(char*)block-sizeof(unsigned long)-sizeof(unsigned long);
    size_p=(unsigned long*)(mem+sizeof(unsigned long));
    size=*size_p-sizeof(unsigned long)-sizeof(unsigned long);
    result=come_calloc(1,size,sname,sline,class_name);
    memcpy(result,block,size);
    __result_obj__0 = result;
    return __result_obj__0;
}

void* come_increment_ref_count(void* mem)
{
    void* __result_obj__0;
    unsigned long* ref_count  ;
    if(mem==((void*)0)) {
        __result_obj__0 = mem;
        return __result_obj__0;
    }
    ref_count=(unsigned long*)((char*)mem-sizeof(unsigned long)-sizeof(unsigned long));
    (*ref_count)++;
    __result_obj__0 = mem;
    return __result_obj__0;
}

void* come_print_ref_count(void* mem)
{
    void* __result_obj__0;
    unsigned long* ref_count  ;
    if(mem==((void*)0)) {
        __result_obj__0 = mem;
        return __result_obj__0;
    }
    ref_count=(unsigned long*)((char*)mem-sizeof(unsigned long)-sizeof(unsigned long));
    printf("ref_count %ld\n",*ref_count);
    __result_obj__0 = mem;
    return __result_obj__0;
}

int come_get_ref_count(void* mem)
{
    unsigned long* ref_count  ;
    if(mem==((void*)0)) {
        return 0;
    }
    ref_count=(unsigned long*)((char*)mem-sizeof(unsigned long)-sizeof(unsigned long));
    return *ref_count;
}

void* come_decrement_ref_count(void* mem, void* protocol_fun, void* protocol_obj, _Bool no_decrement, _Bool no_free, void* result_obj)
{
    void* __result_obj__0;
    long* ref_count;
    long count;
    void (*finalizer)(void*);
    if(result_obj) {
        if(mem==result_obj) {
            __result_obj__0 = mem;
            return __result_obj__0;
        }
    }
    if(mem==((void*)0)) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    ref_count=(long*)((char*)mem-sizeof(unsigned long)-sizeof(unsigned long));
    if(!no_decrement) {
        (*ref_count)--;
    }
    count=*ref_count;
    if(!no_free&&count<=0) {
        if(protocol_obj&&protocol_fun) {
            finalizer=protocol_fun;
            finalizer(protocol_obj);
            come_free(protocol_obj);
        }
        come_free(mem);
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    __result_obj__0 = mem;
    return __result_obj__0;
}

void come_call_finalizer(void* fun, void* mem, void* protocol_fun, void* protocol_obj, int call_finalizer_only, int no_decrement, int no_free, void* result_obj)
{
    void (*finalizer)(void*);
    void (*finalizer_246)(void*);
    void (*finalizer_247)(void*);
    long* ref_count;
    long count;
    void (*finalizer_248)(void*);
    void (*finalizer_249)(void*);
    void (*finalizer_250)(void*);
    if(result_obj) {
        if(mem==result_obj) {
            return;
        }
    }
    if(mem==((void*)0)) {
        return;
    }
    if(call_finalizer_only) {
        if(fun) {
            if(protocol_obj&&protocol_fun) {
                finalizer=protocol_fun;
                finalizer(protocol_obj);
            }
            finalizer_246=fun;
            finalizer_246(mem);
        }
        else {
            if(protocol_obj&&protocol_fun) {
                finalizer_247=protocol_fun;
                finalizer_247(protocol_obj);
            }
        }
    }
    else {
        ref_count=(long*)((char*)mem-sizeof(unsigned long)-sizeof(unsigned long));
        if(!no_decrement) {
            (*ref_count)--;
        }
        count=*ref_count;
        if(!no_free&&count<=0) {
            if(mem) {
                if(fun) {
                    if(protocol_obj&&protocol_fun) {
                        finalizer_248=protocol_fun;
                        finalizer_248(protocol_obj);
                        come_free(protocol_obj);
                    }
                    if(fun) {
                        finalizer_249=fun;
                        finalizer_249(mem);
                    }
                }
                else {
                    if(protocol_obj&&protocol_fun) {
                        finalizer_250=protocol_fun;
                        finalizer_250(protocol_obj);
                        come_free(protocol_obj);
                    }
                }
                come_free(mem);
            }
        }
    }
}

void xassert(char* msg, _Bool test)
{
    printf("%s...",msg);
    if(!test) {
        puts("false");
        exit(2);
    }
    puts("ok");
}

char* __builtin_string(char* str)
{
    char* __result_obj__0  ;
    int len;
    void* __right_value0 = (void*)0;
    char* result;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(str)+1;
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(len)), "/usr/local/include/neo-c.h", 834, "char*"));
    strncpy(result,str,len);
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

struct buffer* buffer_initialize(struct buffer* self  )
{
    void* __right_value0 = (void*)0;
    char* __dec_obj66;
    struct buffer* __result_obj__0  ;
    self->size=128;
    __dec_obj66=self->buf,
    self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3182, "char*"));
    __dec_obj66 = come_decrement_ref_count(__dec_obj66, (void*)0, (void*)0, 0,0, (void*)0);
    self->buf[0]=0;
    self->len=0;
    __result_obj__0 = (struct buffer*)come_increment_ref_count(self);
    come_call_finalizer(buffer_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

struct buffer* buffer_initialize_with_value(struct buffer* self  , char* mem, unsigned long size  )
{
    void* __right_value0 = (void*)0;
    char* __dec_obj67;
    struct buffer* __result_obj__0  ;
    self->size=128;
    __dec_obj67=self->buf,
    self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3192, "char*"));
    __dec_obj67 = come_decrement_ref_count(__dec_obj67, (void*)0, (void*)0, 0,0, (void*)0);
    self->buf[0]=0;
    self->len=0;
    buffer_append(self,mem,size);
    __result_obj__0 = (struct buffer*)come_increment_ref_count(self);
    come_call_finalizer(buffer_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

void buffer_finalize(struct buffer* self  )
{
    if(self&&self->buf) {
        (self->buf = come_decrement_ref_count(self->buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
}

struct buffer* buffer_clone(struct buffer* self  )
{
    struct buffer* __result_obj__0  ;
    void* __right_value0 = (void*)0;
    struct buffer* result  ;
    char* __dec_obj68;
    if(self==((void*)0)) {
        __result_obj__0 = (struct buffer*)come_increment_ref_count(((void*)0));
        come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    result=(struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3212, "struct buffer*"));
    result->size=self->size;
    __dec_obj68=result->buf,
    result->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3215, "char*"));
    __dec_obj68 = come_decrement_ref_count(__dec_obj68, (void*)0, (void*)0, 0,0, (void*)0);
    result->len=self->len;
    memcpy(result->buf,self->buf,self->len);
    __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

_Bool buffer_equals(struct buffer* left  , struct buffer* right  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    _Bool __result_obj__0;
    if(left==((void*)0)&&right==((void*)0)) {
        return 1;
    }
    else if(left==((void*)0)||right==((void*)0)) {
        return 0;
    }
    __result_obj__0 = string_equals(((char*)(__right_value0=buffer_to_string(left))),((char*)(__right_value1=buffer_to_string(right))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
    return __result_obj__0;
}

int buffer_length(struct buffer* self  )
{
    if(self==((void*)0)) {
        return 0;
    }
    return self->len;
}

void buffer_reset(struct buffer* self  )
{
    if(self==((void*)0)) {
        return;
    }
    self->buf[0]=0;
    self->len=0;
}

void buffer_trim(struct buffer* self  , int len)
{
    if(self==((void*)0)) {
        return;
    }
    self->len-=len;
    if(self->len>=0) {
        self->buf[self->len]=0;
    }
    else {
        self->len=0;
        self->buf[0]=0;
    }
}

struct buffer* buffer_append(struct buffer* self  , char* mem, unsigned long size  )
{
    struct buffer* __result_obj__0  ;
    void* __right_value0 = (void*)0;
    char* old_buf;
    int old_len;
    int new_size;
    char* __dec_obj69;
    if(self==((void*)0)||mem==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(self->len+size+1+1>=self->size) {
        old_buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3272, "char*"));
        memcpy(old_buf,self->buf,self->size);
        old_len=self->len;
        new_size=(self->size+size+1)*2;
        __dec_obj69=self->buf,
        self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(new_size)), "/usr/local/include/neo-c.h", 3277, "char*"));
        __dec_obj69 = come_decrement_ref_count(__dec_obj69, (void*)0, (void*)0, 0,0, (void*)0);
        memcpy(self->buf,old_buf,old_len);
        self->buf[old_len]=0;
        self->size=new_size;
        (old_buf = come_decrement_ref_count(old_buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    memcpy(self->buf+self->len,mem,size);
    self->len+=size;
    self->buf[self->len]=0;
    __result_obj__0 = self;
    return __result_obj__0;
}

struct buffer* buffer_append_char(struct buffer* self  , char c)
{
    struct buffer* __result_obj__0  ;
    void* __right_value0 = (void*)0;
    char* old_buf;
    int old_len;
    int new_size;
    char* __dec_obj70;
    if(self==((void*)0)) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    if(self->len+1+1+1>=self->size) {
        old_buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3296, "char*"));
        memcpy(old_buf,self->buf,self->size);
        old_len=self->len;
        new_size=(self->size+10+1)*2;
        __dec_obj70=self->buf,
        self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(new_size)), "/usr/local/include/neo-c.h", 3301, "char*"));
        __dec_obj70 = come_decrement_ref_count(__dec_obj70, (void*)0, (void*)0, 0,0, (void*)0);
        memcpy(self->buf,old_buf,old_len);
        self->buf[old_len]=0;
        self->size=new_size;
        (old_buf = come_decrement_ref_count(old_buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    self->buf[self->len]=c;
    self->len++;
    self->buf[self->len]=0;
    __result_obj__0 = self;
    return __result_obj__0;
}

struct buffer* buffer_append_str(struct buffer* self  , char* mem)
{
    struct buffer* __result_obj__0  ;
    int size;
    void* __right_value0 = (void*)0;
    char* old_buf;
    int old_len;
    int new_size;
    char* __dec_obj71;
    if(self==((void*)0)||mem==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    size=strlen(mem);
    if(self->len+size+1+1>=self->size) {
        old_buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3323, "char*"));
        memcpy(old_buf,self->buf,self->size);
        old_len=self->len;
        new_size=(self->size+size+1)*2;
        __dec_obj71=self->buf,
        self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(new_size)), "/usr/local/include/neo-c.h", 3327, "char*"));
        __dec_obj71 = come_decrement_ref_count(__dec_obj71, (void*)0, (void*)0, 0,0, (void*)0);
        memcpy(self->buf,old_buf,old_len);
        self->buf[old_len]=0;
        self->size=new_size;
        (old_buf = come_decrement_ref_count(old_buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    memcpy(self->buf+self->len,mem,size);
    self->len+=size;
    self->buf[self->len]=0;
    __result_obj__0 = self;
    return __result_obj__0;
}

struct buffer* buffer_append_format(struct buffer* self  , char* msg, ...)
{
    struct buffer* __result_obj__0  ;
    __builtin_va_list args  ;
    char* result;
    int len;
    void* __right_value0 = (void*)0;
    char* mem  ;
    int size;
    char* old_buf;
    int old_len;
    int new_size;
    char* __dec_obj72;
    memset(&result, 0, sizeof(result));
    if(self==((void*)0)||msg==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    __builtin_va_start(args,msg);
    len=vasprintf(&result,msg,args);
    __builtin_va_end(args);
    if(len<0) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    mem=(char*)come_increment_ref_count(__builtin_string(result));
    size=strlen(mem);
    if(self->len+size+1+1>=self->size) {
        old_buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3400, "char*"));
        memcpy(old_buf,self->buf,self->size);
        old_len=self->len;
        new_size=(self->size+size+1)*2;
        __dec_obj72=self->buf,
        self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(new_size)), "/usr/local/include/neo-c.h", 3404, "char*"));
        __dec_obj72 = come_decrement_ref_count(__dec_obj72, (void*)0, (void*)0, 0,0, (void*)0);
        memcpy(self->buf,old_buf,old_len);
        self->buf[old_len]=0;
        self->size=new_size;
        (old_buf = come_decrement_ref_count(old_buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    memcpy(self->buf+self->len,mem,size);
    self->len+=size;
    self->buf[self->len]=0;
    free(result);
    __result_obj__0 = self;
    (mem = come_decrement_ref_count(mem, (void*)0, (void*)0, 0, 0, (void*)0));
    return __result_obj__0;
}

struct buffer* buffer_append_nullterminated_str(struct buffer* self  , char* mem)
{
    struct buffer* __result_obj__0  ;
    int size;
    void* __right_value0 = (void*)0;
    char* old_buf;
    int old_len;
    int new_size;
    char* __dec_obj73;
    if(self==((void*)0)||mem==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    size=strlen(mem)+1;
    if(self->len+size+1+1+1>=self->size) {
        old_buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3427, "char*"));
        memcpy(old_buf,self->buf,self->size);
        old_len=self->len;
        new_size=(self->size+size+1)*2;
        __dec_obj73=self->buf,
        self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(new_size)), "/usr/local/include/neo-c.h", 3431, "char*"));
        __dec_obj73 = come_decrement_ref_count(__dec_obj73, (void*)0, (void*)0, 0,0, (void*)0);
        memcpy(self->buf,old_buf,old_len);
        self->buf[old_len]=0;
        self->size=new_size;
        (old_buf = come_decrement_ref_count(old_buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    memcpy(self->buf+self->len,mem,size);
    self->len+=size;
    self->buf[self->len]=0;
    self->len++;
    __result_obj__0 = self;
    return __result_obj__0;
}

struct buffer* buffer_append_int(struct buffer* self  , int value)
{
    struct buffer* __result_obj__0  ;
    int* mem;
    int size;
    void* __right_value0 = (void*)0;
    char* old_buf;
    int old_len;
    int new_size;
    char* __dec_obj74;
    if(self==((void*)0)) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    mem=&value;
    size=sizeof(int);
    if(self->len+size+1+1>=self->size) {
        old_buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3454, "char*"));
        memcpy(old_buf,self->buf,self->size);
        old_len=self->len;
        new_size=(self->size+size+1)*2;
        __dec_obj74=self->buf,
        self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(new_size)), "/usr/local/include/neo-c.h", 3458, "char*"));
        __dec_obj74 = come_decrement_ref_count(__dec_obj74, (void*)0, (void*)0, 0,0, (void*)0);
        memcpy(self->buf,old_buf,old_len);
        self->buf[old_len]=0;
        self->size=new_size;
        (old_buf = come_decrement_ref_count(old_buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    memcpy(self->buf+self->len,mem,size);
    self->len+=size;
    self->buf[self->len]=0;
    __result_obj__0 = self;
    return __result_obj__0;
}

struct buffer* buffer_append_long(struct buffer* self  , long value)
{
    struct buffer* __result_obj__0  ;
    long* mem;
    int size;
    void* __right_value0 = (void*)0;
    char* old_buf;
    int old_len;
    int new_size;
    char* __dec_obj75;
    if(self==((void*)0)) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    mem=&value;
    size=sizeof(long);
    if(self->len+size+1+1>=self->size) {
        old_buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3480, "char*"));
        memcpy(old_buf,self->buf,self->size);
        old_len=self->len;
        new_size=(self->size+size+1)*2;
        __dec_obj75=self->buf,
        self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(new_size)), "/usr/local/include/neo-c.h", 3484, "char*"));
        __dec_obj75 = come_decrement_ref_count(__dec_obj75, (void*)0, (void*)0, 0,0, (void*)0);
        memcpy(self->buf,old_buf,old_len);
        self->buf[old_len]=0;
        self->size=new_size;
        (old_buf = come_decrement_ref_count(old_buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    memcpy(self->buf+self->len,mem,size);
    self->len+=size;
    self->buf[self->len]=0;
    __result_obj__0 = self;
    return __result_obj__0;
}

struct buffer* buffer_append_short(struct buffer* self  , short value)
{
    struct buffer* __result_obj__0  ;
    short* mem;
    int size;
    void* __right_value0 = (void*)0;
    char* old_buf;
    int old_len;
    int new_size;
    char* __dec_obj76;
    if(self==((void*)0)) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    mem=&value;
    size=sizeof(short);
    if(self->len+size+1+1>=self->size) {
        old_buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3507, "char*"));
        memcpy(old_buf,self->buf,self->size);
        old_len=self->len;
        new_size=(self->size+size+1)*2;
        __dec_obj76=self->buf,
        self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(new_size)), "/usr/local/include/neo-c.h", 3511, "char*"));
        __dec_obj76 = come_decrement_ref_count(__dec_obj76, (void*)0, (void*)0, 0,0, (void*)0);
        memcpy(self->buf,old_buf,old_len);
        self->buf[old_len]=0;
        self->size=new_size;
        (old_buf = come_decrement_ref_count(old_buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    memcpy(self->buf+self->len,mem,size);
    self->len+=size;
    self->buf[self->len]=0;
    __result_obj__0 = self;
    return __result_obj__0;
}

struct buffer* buffer_alignment(struct buffer* self  )
{
    struct buffer* __result_obj__0  ;
    int len;
    void* __right_value0 = (void*)0;
    char* old_buf;
    int old_len;
    int new_size;
    char* __dec_obj77;
    int i;
    if(self==((void*)0)) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    len=self->len;
    len=(len+3)&~3;
    if(len>=self->size) {
        old_buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(self->size)), "/usr/local/include/neo-c.h", 3534, "char*"));
        memcpy(old_buf,self->buf,self->size);
        old_len=self->len;
        new_size=(self->size+1+1)*2;
        __dec_obj77=self->buf,
        self->buf=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(new_size)), "/usr/local/include/neo-c.h", 3538, "char*"));
        __dec_obj77 = come_decrement_ref_count(__dec_obj77, (void*)0, (void*)0, 0,0, (void*)0);
        memcpy(self->buf,old_buf,old_len);
        self->buf[old_len]=0;
        self->size=new_size;
        (old_buf = come_decrement_ref_count(old_buf, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    for(i=self->len;i<len;i++){
        self->buf[i]=0;
    }
    self->len=len;
    __result_obj__0 = self;
    return __result_obj__0;
}

int buffer_compare(struct buffer* left  , struct buffer* right  )
{
    if(left==((void*)0)&&right==((void*)0)) {
        return 0;
    }
    else if(left==((void*)0)) {
        return -1;
    }
    else if(right==((void*)0)) {
        return 1;
    }
    return strcmp(left->buf,right->buf);
}

struct buffer* charp_to_buffer(char* self)
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    struct buffer* __result_obj__0  ;
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3570, "struct buffer*"))));
    if(self==((void*)0)) {
        __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
        come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    buffer_append_str(result,self);
    __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

char* buffer_to_string(struct buffer* self  )
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(self->buf))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

unsigned char* buffer_head_pointer(struct buffer* self  )
{
    unsigned char* __result_obj__0;
    if(self==((void*)0)) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    __result_obj__0 = self->buf;
    return __result_obj__0;
}

struct buffer* chara_to_buffer(char* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    struct buffer* __result_obj__0  ;
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3600, "struct buffer*"))));
    if(self==((void*)0)) {
        __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
        come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    buffer_append(result,self,sizeof(char)*len);
    __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

struct buffer* charpa_to_buffer(char** self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    struct buffer* __result_obj__0  ;
    int i;
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3610, "struct buffer*"))));
    if(self==((void*)0)) {
        __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
        come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    for(i=0;i<len;i++){
        buffer_append(result,self[i],strlen(self[i]));
    }
    __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

struct buffer* shorta_to_buffer(short* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    struct buffer* __result_obj__0  ;
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3622, "struct buffer*"))));
    if(self==((void*)0)) {
        __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
        come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    buffer_append(result,(char*)self,sizeof(short)*len);
    __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

struct buffer* inta_to_buffer(int* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    struct buffer* __result_obj__0  ;
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3632, "struct buffer*"))));
    if(self==((void*)0)) {
        __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
        come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    buffer_append(result,(char*)self,sizeof(int)*len);
    __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

struct buffer* longa_to_buffer(long* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    struct buffer* __result_obj__0  ;
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3642, "struct buffer*"))));
    if(self==((void*)0)) {
        __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
        come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    buffer_append(result,(char*)self,sizeof(long)*len);
    __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

struct buffer* floata_to_buffer(float* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    struct buffer* __result_obj__0  ;
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3652, "struct buffer*"))));
    if(self==((void*)0)) {
        __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
        come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    buffer_append(result,(char*)self,sizeof(float)*len);
    __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

struct buffer* doublea_to_buffer(double* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    struct buffer* __result_obj__0  ;
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3662, "struct buffer*"))));
    if(self==((void*)0)) {
        __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
        come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    buffer_append(result,(char*)self,sizeof(double)*len);
    __result_obj__0 = (struct buffer*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

char* buffer_printable(struct buffer* self  )
{
    int len;
    void* __right_value0 = (void*)0;
    char* result  ;
    char* __result_obj__0  ;
    int n;
    int i;
    unsigned char c;
    len=self->len;
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(len*2+1)), "/usr/local/include/neo-c.h", 3673, "char*"));
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(result);
        (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    n=0;
    for(i=0;i<len;i++){
        c=self->buf[i];
        if((c>=0&&c<32)||c==127) {
            result[n++]=94;
            result[n++]=c+65-1;
        }
        else if(c>127) {
            result[n++]=63;
        }
        else {
            result[n++]=c;
        }
    }
    result[n]=0;
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

static struct list$1char$* list$1char$_initialize_with_values(struct list$1char$* self, int num_value, char* values)
{
    int i;
    struct list$1char$* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    for(i=0;i<num_value;i++){
        list$1char$_push_back(self,values[i]);
    }
    __result_obj__0 = (struct list$1char$*)come_increment_ref_count(self);
    come_call_finalizer(list$1char$$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1char$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1char$* list$1char$_push_back(struct list$1char$* self, char item)
{
    struct list$1char$* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1char$* litem;
    struct list_item$1char$* litem_251;
    struct list_item$1char$* litem_252;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1char$*)come_increment_ref_count(((struct list_item$1char$*)(__right_value0=(struct list_item$1char$*)come_calloc(1, sizeof(struct list_item$1char$)*(1), "/usr/local/include/neo-c.h", 1039, "struct list_item$1char$*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        litem->item=item;
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_251=(struct list_item$1char$*)come_increment_ref_count(((struct list_item$1char$*)(__right_value0=(struct list_item$1char$*)come_calloc(1, sizeof(struct list_item$1char$)*(1), "/usr/local/include/neo-c.h", 1049, "struct list_item$1char$*"))));
        litem_251->prev=self->head;
        litem_251->next=((void*)0);
        litem_251->item=item;
        self->tail=litem_251;
        self->head->next=litem_251;
    }
    else {
        litem_252=(struct list_item$1char$*)come_increment_ref_count(((struct list_item$1char$*)(__right_value0=(struct list_item$1char$*)come_calloc(1, sizeof(struct list_item$1char$)*(1), "/usr/local/include/neo-c.h", 1059, "struct list_item$1char$*"))));
        litem_252->prev=self->tail;
        litem_252->next=((void*)0);
        litem_252->item=item;
        self->tail->next=litem_252;
        self->tail=litem_252;
    }
    self->len++;
    __result_obj__0 = self;
    return __result_obj__0;
}

static void list$1char$$p_finalize(struct list$1char$* self)
{
    struct list_item$1char$* it;
    struct list_item$1char$* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1char$$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1char$$p_finalize(struct list_item$1char$* self)
{
}

struct list$1char$* chara_to_list(char* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1char$* __result_obj__0;
    __result_obj__0 = (struct list$1char$*)come_increment_ref_count(((struct list$1char$*)(__right_value1=list$1char$_initialize_with_values((struct list$1char$*)come_increment_ref_count((struct list$1char$*)come_calloc(1, sizeof(struct list$1char$)*(1), "/usr/local/include/neo-c.h", 3721, "struct list$1char$*")),len,self))));
    come_call_finalizer(list$1char$$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1char$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1char$p* list$1char$p_initialize_with_values(struct list$1char$p* self, int num_value, char** values)
{
    int i;
    struct list$1char$p* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    for(i=0;i<num_value;i++){
        list$1char$p_push_back(self,values[i]);
    }
    __result_obj__0 = (struct list$1char$p*)come_increment_ref_count(self);
    come_call_finalizer(list$1char$p$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1char$p$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1char$p* list$1char$p_push_back(struct list$1char$p* self, char* item)
{
    struct list$1char$p* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1char$p* litem;
    struct list_item$1char$p* litem_253;
    struct list_item$1char$p* litem_254;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1char$p*)come_increment_ref_count(((struct list_item$1char$p*)(__right_value0=(struct list_item$1char$p*)come_calloc(1, sizeof(struct list_item$1char$p)*(1), "/usr/local/include/neo-c.h", 1039, "struct list_item$1char$p*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        litem->item=item;
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_253=(struct list_item$1char$p*)come_increment_ref_count(((struct list_item$1char$p*)(__right_value0=(struct list_item$1char$p*)come_calloc(1, sizeof(struct list_item$1char$p)*(1), "/usr/local/include/neo-c.h", 1049, "struct list_item$1char$p*"))));
        litem_253->prev=self->head;
        litem_253->next=((void*)0);
        litem_253->item=item;
        self->tail=litem_253;
        self->head->next=litem_253;
    }
    else {
        litem_254=(struct list_item$1char$p*)come_increment_ref_count(((struct list_item$1char$p*)(__right_value0=(struct list_item$1char$p*)come_calloc(1, sizeof(struct list_item$1char$p)*(1), "/usr/local/include/neo-c.h", 1059, "struct list_item$1char$p*"))));
        litem_254->prev=self->tail;
        litem_254->next=((void*)0);
        litem_254->item=item;
        self->tail->next=litem_254;
        self->tail=litem_254;
    }
    self->len++;
    __result_obj__0 = self;
    return __result_obj__0;
}

static void list$1char$p$p_finalize(struct list$1char$p* self)
{
    struct list_item$1char$p* it;
    struct list_item$1char$p* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1char$p$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1char$p$p_finalize(struct list_item$1char$p* self)
{
}

struct list$1char$p* charpa_to_list(char** self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1char$p* __result_obj__0;
    __result_obj__0 = (struct list$1char$p*)come_increment_ref_count(((struct list$1char$p*)(__right_value1=list$1char$p_initialize_with_values((struct list$1char$p*)come_increment_ref_count((struct list$1char$p*)come_calloc(1, sizeof(struct list$1char$p)*(1), "/usr/local/include/neo-c.h", 3726, "struct list$1char$p*")),len,self))));
    come_call_finalizer(list$1char$p$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1char$p$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1short$* list$1short$_initialize_with_values(struct list$1short$* self, int num_value, short* values)
{
    int i;
    struct list$1short$* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    for(i=0;i<num_value;i++){
        list$1short$_push_back(self,values[i]);
    }
    __result_obj__0 = (struct list$1short$*)come_increment_ref_count(self);
    come_call_finalizer(list$1short$$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1short$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1short$* list$1short$_push_back(struct list$1short$* self, short item)
{
    struct list$1short$* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1short$* litem;
    struct list_item$1short$* litem_255;
    struct list_item$1short$* litem_256;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1short$*)come_increment_ref_count(((struct list_item$1short$*)(__right_value0=(struct list_item$1short$*)come_calloc(1, sizeof(struct list_item$1short$)*(1), "/usr/local/include/neo-c.h", 1039, "struct list_item$1short$*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        litem->item=item;
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_255=(struct list_item$1short$*)come_increment_ref_count(((struct list_item$1short$*)(__right_value0=(struct list_item$1short$*)come_calloc(1, sizeof(struct list_item$1short$)*(1), "/usr/local/include/neo-c.h", 1049, "struct list_item$1short$*"))));
        litem_255->prev=self->head;
        litem_255->next=((void*)0);
        litem_255->item=item;
        self->tail=litem_255;
        self->head->next=litem_255;
    }
    else {
        litem_256=(struct list_item$1short$*)come_increment_ref_count(((struct list_item$1short$*)(__right_value0=(struct list_item$1short$*)come_calloc(1, sizeof(struct list_item$1short$)*(1), "/usr/local/include/neo-c.h", 1059, "struct list_item$1short$*"))));
        litem_256->prev=self->tail;
        litem_256->next=((void*)0);
        litem_256->item=item;
        self->tail->next=litem_256;
        self->tail=litem_256;
    }
    self->len++;
    __result_obj__0 = self;
    return __result_obj__0;
}

static void list$1short$$p_finalize(struct list$1short$* self)
{
    struct list_item$1short$* it;
    struct list_item$1short$* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1short$$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1short$$p_finalize(struct list_item$1short$* self)
{
}

struct list$1short$* shorta_to_list(short* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1short$* __result_obj__0;
    __result_obj__0 = (struct list$1short$*)come_increment_ref_count(((struct list$1short$*)(__right_value1=list$1short$_initialize_with_values((struct list$1short$*)come_increment_ref_count((struct list$1short$*)come_calloc(1, sizeof(struct list$1short$)*(1), "/usr/local/include/neo-c.h", 3731, "struct list$1short$*")),len,self))));
    come_call_finalizer(list$1short$$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1short$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1int$* list$1int$_initialize_with_values(struct list$1int$* self, int num_value, int* values)
{
    int i;
    struct list$1int$* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    for(i=0;i<num_value;i++){
        list$1int$_push_back(self,values[i]);
    }
    __result_obj__0 = (struct list$1int$*)come_increment_ref_count(self);
    come_call_finalizer(list$1int$$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1int$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1int$* list$1int$_push_back(struct list$1int$* self, int item)
{
    struct list$1int$* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1int$* litem;
    struct list_item$1int$* litem_257;
    struct list_item$1int$* litem_258;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1int$*)come_increment_ref_count(((struct list_item$1int$*)(__right_value0=(struct list_item$1int$*)come_calloc(1, sizeof(struct list_item$1int$)*(1), "/usr/local/include/neo-c.h", 1039, "struct list_item$1int$*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        litem->item=item;
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_257=(struct list_item$1int$*)come_increment_ref_count(((struct list_item$1int$*)(__right_value0=(struct list_item$1int$*)come_calloc(1, sizeof(struct list_item$1int$)*(1), "/usr/local/include/neo-c.h", 1049, "struct list_item$1int$*"))));
        litem_257->prev=self->head;
        litem_257->next=((void*)0);
        litem_257->item=item;
        self->tail=litem_257;
        self->head->next=litem_257;
    }
    else {
        litem_258=(struct list_item$1int$*)come_increment_ref_count(((struct list_item$1int$*)(__right_value0=(struct list_item$1int$*)come_calloc(1, sizeof(struct list_item$1int$)*(1), "/usr/local/include/neo-c.h", 1059, "struct list_item$1int$*"))));
        litem_258->prev=self->tail;
        litem_258->next=((void*)0);
        litem_258->item=item;
        self->tail->next=litem_258;
        self->tail=litem_258;
    }
    self->len++;
    __result_obj__0 = self;
    return __result_obj__0;
}

static void list$1int$$p_finalize(struct list$1int$* self)
{
    struct list_item$1int$* it;
    struct list_item$1int$* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1int$$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1int$$p_finalize(struct list_item$1int$* self)
{
}

struct list$1int$* inta_to_list(int* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1int$* __result_obj__0;
    __result_obj__0 = (struct list$1int$*)come_increment_ref_count(((struct list$1int$*)(__right_value1=list$1int$_initialize_with_values((struct list$1int$*)come_increment_ref_count((struct list$1int$*)come_calloc(1, sizeof(struct list$1int$)*(1), "/usr/local/include/neo-c.h", 3736, "struct list$1int$*")),len,self))));
    come_call_finalizer(list$1int$$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1int$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1long$* list$1long$_initialize_with_values(struct list$1long$* self, int num_value, long* values)
{
    int i;
    struct list$1long$* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    for(i=0;i<num_value;i++){
        list$1long$_push_back(self,values[i]);
    }
    __result_obj__0 = (struct list$1long$*)come_increment_ref_count(self);
    come_call_finalizer(list$1long$$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1long$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1long$* list$1long$_push_back(struct list$1long$* self, long item)
{
    struct list$1long$* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1long$* litem;
    struct list_item$1long$* litem_259;
    struct list_item$1long$* litem_260;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1long$*)come_increment_ref_count(((struct list_item$1long$*)(__right_value0=(struct list_item$1long$*)come_calloc(1, sizeof(struct list_item$1long$)*(1), "/usr/local/include/neo-c.h", 1039, "struct list_item$1long$*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        litem->item=item;
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_259=(struct list_item$1long$*)come_increment_ref_count(((struct list_item$1long$*)(__right_value0=(struct list_item$1long$*)come_calloc(1, sizeof(struct list_item$1long$)*(1), "/usr/local/include/neo-c.h", 1049, "struct list_item$1long$*"))));
        litem_259->prev=self->head;
        litem_259->next=((void*)0);
        litem_259->item=item;
        self->tail=litem_259;
        self->head->next=litem_259;
    }
    else {
        litem_260=(struct list_item$1long$*)come_increment_ref_count(((struct list_item$1long$*)(__right_value0=(struct list_item$1long$*)come_calloc(1, sizeof(struct list_item$1long$)*(1), "/usr/local/include/neo-c.h", 1059, "struct list_item$1long$*"))));
        litem_260->prev=self->tail;
        litem_260->next=((void*)0);
        litem_260->item=item;
        self->tail->next=litem_260;
        self->tail=litem_260;
    }
    self->len++;
    __result_obj__0 = self;
    return __result_obj__0;
}

static void list$1long$$p_finalize(struct list$1long$* self)
{
    struct list_item$1long$* it;
    struct list_item$1long$* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1long$$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1long$$p_finalize(struct list_item$1long$* self)
{
}

struct list$1long$* longa_to_list(long* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1long$* __result_obj__0;
    __result_obj__0 = (struct list$1long$*)come_increment_ref_count(((struct list$1long$*)(__right_value1=list$1long$_initialize_with_values((struct list$1long$*)come_increment_ref_count((struct list$1long$*)come_calloc(1, sizeof(struct list$1long$)*(1), "/usr/local/include/neo-c.h", 3741, "struct list$1long$*")),len,self))));
    come_call_finalizer(list$1long$$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1long$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1float$* list$1float$_initialize_with_values(struct list$1float$* self, int num_value, float* values)
{
    int i;
    struct list$1float$* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    for(i=0;i<num_value;i++){
        list$1float$_push_back(self,values[i]);
    }
    __result_obj__0 = (struct list$1float$*)come_increment_ref_count(self);
    come_call_finalizer(list$1float$$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1float$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1float$* list$1float$_push_back(struct list$1float$* self, float item)
{
    struct list$1float$* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1float$* litem;
    struct list_item$1float$* litem_261;
    struct list_item$1float$* litem_262;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1float$*)come_increment_ref_count(((struct list_item$1float$*)(__right_value0=(struct list_item$1float$*)come_calloc(1, sizeof(struct list_item$1float$)*(1), "/usr/local/include/neo-c.h", 1039, "struct list_item$1float$*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        litem->item=item;
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_261=(struct list_item$1float$*)come_increment_ref_count(((struct list_item$1float$*)(__right_value0=(struct list_item$1float$*)come_calloc(1, sizeof(struct list_item$1float$)*(1), "/usr/local/include/neo-c.h", 1049, "struct list_item$1float$*"))));
        litem_261->prev=self->head;
        litem_261->next=((void*)0);
        litem_261->item=item;
        self->tail=litem_261;
        self->head->next=litem_261;
    }
    else {
        litem_262=(struct list_item$1float$*)come_increment_ref_count(((struct list_item$1float$*)(__right_value0=(struct list_item$1float$*)come_calloc(1, sizeof(struct list_item$1float$)*(1), "/usr/local/include/neo-c.h", 1059, "struct list_item$1float$*"))));
        litem_262->prev=self->tail;
        litem_262->next=((void*)0);
        litem_262->item=item;
        self->tail->next=litem_262;
        self->tail=litem_262;
    }
    self->len++;
    __result_obj__0 = self;
    return __result_obj__0;
}

static void list$1float$$p_finalize(struct list$1float$* self)
{
    struct list_item$1float$* it;
    struct list_item$1float$* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1float$$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1float$$p_finalize(struct list_item$1float$* self)
{
}

struct list$1float$* floata_to_list(float* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1float$* __result_obj__0;
    __result_obj__0 = (struct list$1float$*)come_increment_ref_count(((struct list$1float$*)(__right_value1=list$1float$_initialize_with_values((struct list$1float$*)come_increment_ref_count((struct list$1float$*)come_calloc(1, sizeof(struct list$1float$)*(1), "/usr/local/include/neo-c.h", 3746, "struct list$1float$*")),len,self))));
    come_call_finalizer(list$1float$$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1float$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1double$* list$1double$_initialize_with_values(struct list$1double$* self, int num_value, double* values)
{
    int i;
    struct list$1double$* __result_obj__0;
    self->head=((void*)0);
    self->tail=((void*)0);
    self->len=0;
    for(i=0;i<num_value;i++){
        list$1double$_push_back(self,values[i]);
    }
    __result_obj__0 = (struct list$1double$*)come_increment_ref_count(self);
    come_call_finalizer(list$1double$$p_finalize, self, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1double$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

static struct list$1double$* list$1double$_push_back(struct list$1double$* self, double item)
{
    struct list$1double$* __result_obj__0;
    void* __right_value0 = (void*)0;
    struct list_item$1double$* litem;
    struct list_item$1double$* litem_263;
    struct list_item$1double$* litem_264;
    if(self==((void*)0)) {
        __result_obj__0 = self;
        return __result_obj__0;
    }
    if(self->len==0) {
        litem=(struct list_item$1double$*)come_increment_ref_count(((struct list_item$1double$*)(__right_value0=(struct list_item$1double$*)come_calloc(1, sizeof(struct list_item$1double$)*(1), "/usr/local/include/neo-c.h", 1039, "struct list_item$1double$*"))));
        litem->prev=((void*)0);
        litem->next=((void*)0);
        litem->item=item;
        self->tail=litem;
        self->head=litem;
    }
    else if(self->len==1) {
        litem_263=(struct list_item$1double$*)come_increment_ref_count(((struct list_item$1double$*)(__right_value0=(struct list_item$1double$*)come_calloc(1, sizeof(struct list_item$1double$)*(1), "/usr/local/include/neo-c.h", 1049, "struct list_item$1double$*"))));
        litem_263->prev=self->head;
        litem_263->next=((void*)0);
        litem_263->item=item;
        self->tail=litem_263;
        self->head->next=litem_263;
    }
    else {
        litem_264=(struct list_item$1double$*)come_increment_ref_count(((struct list_item$1double$*)(__right_value0=(struct list_item$1double$*)come_calloc(1, sizeof(struct list_item$1double$)*(1), "/usr/local/include/neo-c.h", 1059, "struct list_item$1double$*"))));
        litem_264->prev=self->tail;
        litem_264->next=((void*)0);
        litem_264->item=item;
        self->tail->next=litem_264;
        self->tail=litem_264;
    }
    self->len++;
    __result_obj__0 = self;
    return __result_obj__0;
}

static void list$1double$$p_finalize(struct list$1double$* self)
{
    struct list_item$1double$* it;
    struct list_item$1double$* prev_it;
    if(self==((void*)0)) {
        return;
    }
    it=self->head;
    while(it!=((void*)0)) {
        prev_it=it;
        it=it->next;
        come_call_finalizer(list_item$1double$$p_finalize, prev_it, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    }
}

static void list_item$1double$$p_finalize(struct list_item$1double$* self)
{
}

struct list$1double$* doublea_to_list(double* self, unsigned long len  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1double$* __result_obj__0;
    __result_obj__0 = (struct list$1double$*)come_increment_ref_count(((struct list$1double$*)(__right_value1=list$1double$_initialize_with_values((struct list$1double$*)come_increment_ref_count((struct list$1double$*)come_calloc(1, sizeof(struct list$1double$)*(1), "/usr/local/include/neo-c.h", 3751, "struct list$1double$*")),len,self))));
    come_call_finalizer(list$1double$$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1double$$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

_Bool _Bool_equals(_Bool self, _Bool right)
{
    return self==right;
}

_Bool char_equals(char self, char right)
{
    return self==right;
}

_Bool short_equals(short self, short right)
{
    return self==right;
}

_Bool int_equals(int self, int right)
{
    return self==right;
}

_Bool long_equals(long self, long right)
{
    return self==right;
}

_Bool size_t_equals(unsigned long self  , unsigned long right  )
{
    return self==right;
}

_Bool float_equals(float self, float right)
{
    return self==right;
}

_Bool double_equals(double self, double right)
{
    return self==right;
}

_Bool _Bool_operator_equals(_Bool self, _Bool right)
{
    return self==right;
}

_Bool char_operator_equals(char self, char right)
{
    return self==right;
}

_Bool short_operator_equals(short self, short right)
{
    return self==right;
}

_Bool int_operator_equals(int self, int right)
{
    return self==right;
}

_Bool long_operator_equals(long self, long right)
{
    return self==right;
}

_Bool _Bool_operator_not_equals(_Bool self, _Bool right)
{
    return !(self==right);
}

_Bool char_operator_not_equals(char self, char right)
{
    return !(self==right);
}

_Bool short_operator_not_equals(short self, short right)
{
    return !(self==right);
}

_Bool int_operator_not_equals(int self, int right)
{
    return !(self==right);
}

_Bool long_operator_not_equals(long self, long right)
{
    return !(self==right);
}

_Bool charp_equals(char* self, char* right)
{
    if(self==((void*)0)&&right==((void*)0)) {
        return 1;
    }
    else if(self==((void*)0)||right==((void*)0)) {
        return 0;
    }
    return strcmp(self,right)==0;
}

_Bool string_equals(char* self, char* right)
{
    if(self==((void*)0)&&right==((void*)0)) {
        return 1;
    }
    else if(self==((void*)0)||right==((void*)0)) {
        return 0;
    }
    return strcmp(self,right)==0;
}

_Bool voidp_equals(void* self, void* right)
{
    return self==right;
}

_Bool _Boolp_equals(_Bool* self, _Bool* right)
{
    return *self==*right;
}

_Bool string_operator_equals(char* self, char* right)
{
    if(self==((void*)0)&&right==((void*)0)) {
        return 1;
    }
    else if(self==((void*)0)||right==((void*)0)) {
        return 0;
    }
    return strcmp(self,right)==0;
}

_Bool charp_operator_equals(char* self, char* right)
{
    if(self==((void*)0)&&right==((void*)0)) {
        return 1;
    }
    else if(self==((void*)0)||right==((void*)0)) {
        return 0;
    }
    return strcmp(self,right)==0;
}

_Bool voidp_operator_equals(char* self, char* right)
{
    return self==right;
}

_Bool voidp_operator_not_equals(char* self, char* right)
{
    return !charp_operator_equals(self,right);
}

_Bool string_operator_not_equals(char* self, char* right)
{
    if(self==((void*)0)&&right==((void*)0)) {
        return 0;
    }
    else if(self==((void*)0)||right==((void*)0)) {
        return 1;
    }
    return strcmp(self,right)!=0;
}

_Bool charp_operator_not_equals(char* self, char* right)
{
    if(self==((void*)0)&&right==((void*)0)) {
        return 0;
    }
    else if(self==((void*)0)||right==((void*)0)) {
        return 1;
    }
    return strcmp(self,right)!=0;
}

char* charp_operator_add(char* self, char* right)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    char* result;
    if(self==((void*)0)||right==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(self)+strlen(right);
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(len+1)), "/usr/local/include/neo-c.h", 3962, "char*"));
    strncpy(result,self,len+1);
    strncat(result,right,len+1);
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* string_operator_add(char* self, char* right)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    char* result;
    if(self==((void*)0)||right==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(self)+strlen(right);
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(len+1)), "/usr/local/include/neo-c.h", 3977, "char*"));
    strncpy(result,self,len+1);
    strncat(result,right,len+1);
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_operator_mult(char* self, int right)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    int i;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 3990, "struct buffer*"))));
    for(i=0;i<right;i++){
        buffer_append_str(buf,self);
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(buf))));
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* string_operator_mult(char* self, int right)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    int i;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 4004, "struct buffer*"))));
    for(i=0;i<right;i++){
        buffer_append_str(buf,self);
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(buf))));
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

_Bool charpa_contained(char** self, unsigned long len  , char* str)
{
    _Bool result;
    int i;
    result=0;
    if(self==((void*)0)) {
        return result;
    }
    for(i=0;i<len;i++){
        if(strncmp(self[i],str,strlen(self[i]))==0) {
            result=1;
            break;
        }
    }
    return result;
}

unsigned long shorta_length(short* self, unsigned long len  )
{
    return len;
}

unsigned long inta_length(int* self, unsigned long len  )
{
    return len;
}

unsigned long longa_length(long* self, unsigned long len  )
{
    return len;
}

unsigned long floata_length(float* self, unsigned long len  )
{
    return len;
}

unsigned long doublea_length(double* self, unsigned long len  )
{
    return len;
}

unsigned int _Bool_get_hash_key(_Bool value)
{
    return (int_get_hash_key(((int)value)));
}

unsigned int char_get_hash_key(char value)
{
    return value;
}

unsigned int short_get_hash_key(short int value)
{
    return value;
}

unsigned int int_get_hash_key(int value)
{
    return value;
}

unsigned int long_get_hash_key(long value)
{
    return value;
}

unsigned int size_t_get_hash_key(unsigned long value  )
{
    return value;
}

unsigned int float_get_hash_key(float value)
{
    return (unsigned int)value;
}

unsigned int double_get_hash_key(double value)
{
    return (unsigned int)value;
}

unsigned int charp_get_hash_key(char* value)
{
    int result;
    char* p;
    if(value==((void*)0)) {
        return 0;
    }
    result=0;
    p=value;
    while(*p) {
        result+=(*p);
        p++;
    }
    return result;
}

unsigned int string_get_hash_key(char* value)
{
    int result;
    char* p;
    if(value==((void*)0)) {
        return 0;
    }
    result=0;
    p=value;
    while(*p) {
        result+=(*p);
        p++;
    }
    return result;
}

unsigned int voidp_get_hash_key(void* value)
{
    return (int_get_hash_key(((int)value)));
}

_Bool _Bool_clone(_Bool self)
{
    return self;
}

char char_clone(char self)
{
    return self;
}

short int short_clone(short self)
{
    return self;
}

int int_clone(int self)
{
    return self;
}

long  int long_clone(long self)
{
    return self;
}

unsigned long size_t_clone(unsigned long self  )
{
    return self;
}

double double_clone(double self)
{
    return self;
}

float float_clone(float self)
{
    return self;
}

_Bool xisalpha(char c)
{
    _Bool result;
    result=(c>=97&&c<=122)||(c>=65&&c<=90);
    return result;
}

_Bool xisblank(char c)
{
    return c==32||c==9;
}

_Bool xisdigit(char c)
{
    return (c>=48&&c<=57);
}

_Bool xisspace(char c)
{
    return c==32||c==9||c==10||c==13||c==28||c==11;
}

_Bool xisalnum(char c)
{
    return xisalpha(c)||xisdigit(c);
}

_Bool xisascii(char c)
{
    _Bool result;
    result=(c>=32&&c<=126);
    return result;
}

_Bool xispunct(char c)
{
    return (c>=33&&c<=47)||(c>=58&&c<=64)||(c>=91&&c<=96)||(c>=123&&c<=126);
}

int string_length(char* str)
{
    if(str==((void*)0)) {
        return 0;
    }
    return strlen(str);
}

int charp_length(char* str)
{
    if(str==((void*)0)) {
        return 0;
    }
    return strlen(str);
}

int chara_length(char* str)
{
    if(str==((void*)0)) {
        return 0;
    }
    return strlen(str);
}

char* charp_reverse(char* str)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    char* result;
    int i;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(str);
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(len+1)), "/usr/local/include/neo-c.h", 4258, "char*"));
    for(i=0;i<len;i++){
        result[i]=str[len-i-1];
    }
    result[len]=0;
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* string_operator_load_range_element(char* str, int head, int tail)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    void* __right_value1 = (void*)0;
    char* result  ;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(str);
    if(head<0) {
        head+=len;
    }
    if(tail<0) {
        tail+=len+1;
    }
    if(head>tail) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value1=charp_reverse(((char*)(__right_value0=charp_substring(str,tail,head)))))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(head<0) {
        head=0;
    }
    if(tail>=len) {
        tail=len;
    }
    if(head==tail) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(tail-head+1<1) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(tail-head+1)), "/usr/local/include/neo-c.h", 4304, "char*"));
    memcpy(result,str+head,tail-head);
    result[tail-head]=0;
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_operator_load_range_element(char* str, int head, int tail)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    void* __right_value1 = (void*)0;
    char* result  ;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(str);
    if(head<0) {
        head+=len;
    }
    if(tail<0) {
        tail+=len+1;
    }
    if(head>tail) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value1=charp_reverse(((char*)(__right_value0=charp_substring(str,tail,head)))))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(head<0) {
        head=0;
    }
    if(tail>=len) {
        tail=len;
    }
    if(head==tail) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(tail-head+1<1) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(tail-head+1)), "/usr/local/include/neo-c.h", 4347, "char*"));
    memcpy(result,str+head,tail-head);
    result[tail-head]=0;
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_substring(char* str, int head, int tail)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    void* __right_value1 = (void*)0;
    char* result  ;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(str);
    if(head<0) {
        head+=len;
    }
    if(tail<0) {
        tail+=len+1;
    }
    if(head>tail) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value1=charp_reverse(((char*)(__right_value0=charp_substring(str,tail,head)))))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(head<0) {
        head=0;
    }
    if(tail>=len) {
        tail=len;
    }
    if(head==tail) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(tail-head+1<1) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(tail-head+1)), "/usr/local/include/neo-c.h", 4390, "char*"));
    memcpy(result,str+head,tail-head);
    result[tail-head]=0;
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* xsprintf(char* msg, ...)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __builtin_va_list args  ;
    char* result;
    int len;
    char* result2  ;
    memset(&result, 0, sizeof(result));
    if(msg==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __builtin_va_start(args,msg);
    len=vasprintf(&result,msg,args);
    __builtin_va_end(args);
    if(len<0) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result2=(char*)come_increment_ref_count(__builtin_string(result));
    free(result);
    __result_obj__0 = (char*)come_increment_ref_count(result2);
    (result2 = come_decrement_ref_count(result2, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_delete(char* str, int head, int tail)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    char* result;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(str);
    if(head>=len) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(str))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(strcmp(str,"")==0) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(str))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(head<0) {
        head+=len;
    }
    if(tail<0) {
        tail+=len+1;
    }
    if(head<0) {
        head=0;
    }
    if(tail<0) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(str))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(tail>=len) {
        tail=len;
    }
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(len-(tail-head)+1)), "/usr/local/include/neo-c.h", 4456, "char*"));
    memcpy(result,str,head);
    memcpy(result+head,str+tail,len-tail);
    result[len-(tail-head)]=0;
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

struct list$1char$ph* charp_split_char(char* self, char c)
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* __result_obj__0;
    struct list$1char$ph* result;
    struct buffer* str  ;
    int i;
    if(self==((void*)0)) {
        __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value1=list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 4469, "struct list$1char$ph*"))))));
        come_call_finalizer(list$1char$ph$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    result=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 4472, "struct list$1char$ph*"))));
    str=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 4474, "struct buffer*"))));
    for(i=0;i<charp_length(self);i++){
        if(self[i]==c) {
            list$1char$ph_push_back(result,(char*)come_increment_ref_count(__builtin_string(str->buf)));
            buffer_reset(str);
        }
        else {
            buffer_append_char(str,self[i]);
        }
    }
    if(buffer_length(str)!=0) {
        list$1char$ph_push_back(result,(char*)come_increment_ref_count(__builtin_string(str->buf)));
    }
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(result);
    come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, str, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

char* charp_xsprintf(char* self, char* msg, ...)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf(msg,self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* int_xsprintf(int self, char* msg, ...)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf(msg,self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_printable(char* str)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    char* result  ;
    int n;
    int i;
    char c;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=charp_length(str);
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(len*2+1)), "/usr/local/include/neo-c.h", 4508, "char*"));
    n=0;
    for(i=0;i<len;i++){
        c=str[i];
        if((c>=0&&c<32)||c==127) {
            result[n++]=94;
            result[n++]=c+65-1;
        }
        else {
            result[n++]=c;
        }
    }
    result[n]=0;
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* chara_printable(char* str)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=charp_printable(str))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_sub_plain(char* self, char* str, char* replace)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    char* p;
    char* p2;
    if(self==((void*)0)||str==((void*)0)||replace==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(self))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 4541, "struct buffer*"))));
    p=self;
    while(1) {
        p2=strstr(p,str);
        if(p2==((void*)0)) {
            p2=p;
            while(*p2) {
                p2++;
            }
            buffer_append(result,p,p2-p);
            break;
        }
        buffer_append(result,p,p2-p);
        buffer_append_str(result,replace);
        p=p2+strlen(str);
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(result))));
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* xbasename(char* path)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    char* p;
    if(path==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    p=path+strlen(path);
    while(p>=path) {
        if(*p==47) {
            break;
        }
        else {
            p--;
        }
    }
    if(p<path) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(path))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    else {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(p+1))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* xnoextname(char* path)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    char* path2  ;
    char* p;
    if(path==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    path2=(char*)come_increment_ref_count(xbasename(path));
    p=path2+strlen(path2);
    while(p>=path2) {
        if(*p==46) {
            break;
        }
        else {
            p--;
        }
    }
    if(p<path2) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(path2))));
        (path2 = come_decrement_ref_count(path2, (void*)0, (void*)0, 0, 0, (void*)0));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    else {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=charp_substring(path2,0,p-path2))));
        (path2 = come_decrement_ref_count(path2, (void*)0, (void*)0, 0, 0, (void*)0));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
    (path2 = come_decrement_ref_count(path2, (void*)0, (void*)0, 0, 0, (void*)0));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* xextname(char* path)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    char* p;
    if(path==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    p=path+strlen(path);
    while(p>=path) {
        if(*p==46) {
            break;
        }
        else {
            p--;
        }
    }
    if(p<path) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(path))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    else {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(p+1))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* _Bool_to_string(_Bool self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    if(self) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string("true"))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    else {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string("false"))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
}

char* char_to_string(char self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf("%c",self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* short_to_string(short self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf("%d",self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* int_to_string(int self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf("%d",self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* long_to_string(long self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf("%ld",self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* size_t_to_string(unsigned long self  )
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf("%ld",self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* float_to_string(float self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf("%f",self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* double_to_string(double self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf("%lf",self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* string_to_string(char* self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_to_string(char* self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int _Bool_compare(_Bool left, _Bool right)
{
    if(!left&&right) {
        return -1;
    }
    else if(left&&right) {
        return 0;
    }
    else if(!left&&!right) {
        return 0;
    }
    else {
        return 1;
    }
    return 0;
}

int char_compare(char left, char right)
{
    if(left<right) {
        return -1;
    }
    else if(left>right) {
        return 1;
    }
    else {
        return 0;
    }
    return 0;
}

int short_compare(short left, short right)
{
    if(left<right) {
        return -1;
    }
    else if(left>right) {
        return 1;
    }
    else {
        return 0;
    }
    return 0;
}

int int_compare(int left, int right)
{
    if(left<right) {
        return -1;
    }
    else if(left>right) {
        return 1;
    }
    else {
        return 0;
    }
    return 0;
}

int long_compare(long left, long right)
{
    if(left<right) {
        return -1;
    }
    else if(left>right) {
        return 1;
    }
    else {
        return 0;
    }
    return 0;
}

int size_t_compare(unsigned long left  , unsigned long right  )
{
    if(left<right) {
        return -1;
    }
    else if(left>right) {
        return 1;
    }
    else {
        return 0;
    }
    return 0;
}

int float_compare(float left, float right)
{
    if(left<right) {
        return -1;
    }
    else if(left>right) {
        return 1;
    }
    else {
        return 0;
    }
    return 0;
}

int double_compare(double left, double right)
{
    if(left<right) {
        return -1;
    }
    else if(left>right) {
        return 1;
    }
    else {
        return 0;
    }
    return 0;
}

int string_compare(char* left, char* right)
{
    if(left==((void*)0)&&right==((void*)0)) {
        return 0;
    }
    else if(left==((void*)0)) {
        return -1;
    }
    else if(right==((void*)0)) {
        return 1;
    }
    return strcmp(left,right);
}

int charp_compare(char* left, char* right)
{
    if(left==((void*)0)&&right==((void*)0)) {
        return 0;
    }
    else if(left==((void*)0)) {
        return -1;
    }
    else if(right==((void*)0)) {
        return 1;
    }
    return strcmp(left,right);
}

char* charp_puts(char* self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    puts(self);
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_print(char* self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    printf("%s",self);
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_printf(char* self, ...)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    char* msg2;
    __builtin_va_list args  ;
    memset(&msg2, 0, sizeof(msg2));
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __builtin_va_start(args,self);
    vasprintf(&msg2,self,args);
    __builtin_va_end(args);
    printf("%s",msg2);
    free(msg2);
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int int_printf(int self, char* msg)
{
    if(self==((void*)0)) {
        return self;
    }
    printf(msg,self);
    return self;
}

long long_printf(long self, char* msg)
{
    if(self==((void*)0)) {
        return self;
    }
    printf(msg,self);
    return self;
}

void int_times(int self, void* parent, void (*block)(void*,int))
{
    int i;
    for(i=0;i<self;i++){
        block(parent,i);
    }
}

static void match_context_finalize(struct anonymous_typeX25* self  )
{
}

int re_matchp_ex(struct re_program* pattern  , const char* text, int* matchlength, struct re_capture* captures  , int max_captures, _Bool ignore_case)
{
    struct re_program* program  ;
    struct regex_t* start  ;
    struct anonymous_typeX25 ctx  ;
    int __result_obj__0;
    memset(&ctx, 0, sizeof(ctx));
    *matchlength=0;
    if(pattern==0) {
        return -1;
    }
    program=(struct re_program*)pattern;
    start=program->start;
    if(start==0) {
        return -1;
    }
    ctx.base=text;
    ctx.captures=(((captures!=0&&max_captures>0))?(captures):(0));
    ctx.capture_capacity=(((captures!=0&&max_captures>0))?(max_captures):(0));
    if(ctx.capture_capacity>64) {
        ctx.capture_capacity=64;
    }
    ctx.total_groups=program->group_count;
    ctx.ignore_case=ignore_case;
    if(ctx.captures!=0) {
        clear_captures(&ctx);
    }
    if(start->type==(2)) {
        const char* end=matchpattern(start->next,text,&ctx);
        if(end!=0) {
            *matchlength=(int)(end-text);
            if(ctx.captures!=0) {
            }
            __result_obj__0 = 0;
            come_call_finalizer(match_context_finalize, (&ctx), (void*)0, (void*)0, 1, 0, 0, (void*)0);
            return __result_obj__0;
        }
        __result_obj__0 = -1;
        come_call_finalizer(match_context_finalize, (&ctx), (void*)0, (void*)0, 1, 0, 0, (void*)0);
        return __result_obj__0;
    }
    else {
        const char* cursor=text;
        while(1) {
            if(ctx.captures!=0) {
                clear_captures(&ctx);
            }
            const char* end_265=matchpattern(start,cursor,&ctx);
            if(end_265!=0) {
                if(*cursor==0&&cursor!=text) {
                    __result_obj__0 = -1;
                    come_call_finalizer(match_context_finalize, (&ctx), (void*)0, (void*)0, 1, 0, 0, (void*)0);
                    return __result_obj__0;
                }
                *matchlength=(int)(end_265-cursor);
                __result_obj__0 = (int)(cursor-text);
                come_call_finalizer(match_context_finalize, (&ctx), (void*)0, (void*)0, 1, 0, 0, (void*)0);
                return __result_obj__0;
            }
            if(*cursor==0) {
                break;
            }
            cursor+=1;
        }
    }
    __result_obj__0 = -1;
    come_call_finalizer(match_context_finalize, (&ctx), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    return __result_obj__0;
}

int re_matchp(struct re_program* pattern  , const char* text, int* matchlength, struct re_capture* captures  , int max_captures)
{
    return re_matchp_ex(pattern,text,matchlength,captures,max_captures,0);
}

int re_match(const char* pattern, const char* text, int* matchlength)
{
    return re_matchp(re_compile(pattern),text,matchlength,(struct re_capture*)0,0);
}

static void regex_program_t_finalize(struct re_program* self  )
{
}

static void compiler_state_finalize(struct anonymous_typeX24* self  )
{
}

struct re_program* re_compile(const char* pattern)
{
    static struct re_program program  ;
    struct anonymous_typeX24 state  ;
    int pos;
    struct regex_t* head  ;
    struct re_program* __result_obj__0  ;
    memset(&program, 0, sizeof(program));
    memset(&state, 0, sizeof(state));
    static struct regex_t re_compiled[64]  ;
    memset(&re_compiled, 0, sizeof(re_compiled));
    static unsigned char ccl_buf[40];
    memset(&ccl_buf, 0, sizeof(ccl_buf));
    state.pool=re_compiled;
    state.pool_capacity=64;
    state.pool_size=0;
    state.ccl_buf=ccl_buf;
    state.ccl_capacity=40;
    state.ccl_idx=1;
    state.group_count=0;
    if(state.ccl_capacity>0) {
        state.ccl_buf[0]=0;
    }
    pos=0;
    head=compile_sequence(&state,pattern,&pos,0);
    if((head==0)||(pattern[pos]!=0)) {
        __result_obj__0 = ((void*)0);
        come_call_finalizer(regex_program_t_finalize, (&program), (void*)0, (void*)0, 1, 0, 0, (void*)0);
        come_call_finalizer(compiler_state_finalize, (&state), (void*)0, (void*)0, 1, 0, 0, (void*)0);
        return __result_obj__0;
    }
    program.start=head;
    program.group_count=state.group_count;
    __result_obj__0 = (struct re_program*)&program;
    come_call_finalizer(regex_program_t_finalize, (&program), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    come_call_finalizer(compiler_state_finalize, (&state), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    return __result_obj__0;
}

void re_print(struct re_program* pattern  )
{
    struct re_program* program  ;
    if(pattern==0) {
        return;
    }
    program=(struct re_program*)pattern;
    if(program->start==0) {
        return;
    }
    re_print_internal(program->start,0);
}

void clear_captures(struct anonymous_typeX25* ctx  )
{
    int i;
    if((ctx->captures==0)||(ctx->capture_capacity<=0)) {
        return;
    }
    for(i=0;i<ctx->capture_capacity;++i){
        ctx->captures[i].start=-1;
        ctx->captures[i].length=0;
    }
}

void snapshot_captures(const struct anonymous_typeX25* ctx  , struct re_capture* buffer_  )
{
    if((ctx->captures==0)||(ctx->capture_capacity<=0)) {
        return;
    }
    memcpy(buffer_,ctx->captures,sizeof(struct re_capture)*ctx->capture_capacity);
}

void restore_captures(struct anonymous_typeX25* ctx  , const struct re_capture* buffer_  )
{
    if((ctx->captures==0)||(ctx->capture_capacity<=0)) {
        return;
    }
    memcpy(ctx->captures,buffer_,sizeof(struct re_capture)*ctx->capture_capacity);
}

struct regex_t* new_token(struct anonymous_typeX24* st  )
{
    struct regex_t* __result_obj__0  ;
    struct regex_t* token  ;
    if(st->pool_size>=st->pool_capacity) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    token=&st->pool[st->pool_size++];
    token->type=(0);
    token->u.ccl=0;
    token->next=0;
    token->u.group.first=0;
    token->u.group.last=0;
    token->u.group.id=0;
    __result_obj__0 = token;
    return __result_obj__0;
}

int append_token(struct regex_t** head  , struct regex_t** tail  , struct regex_t* token  )
{
    if(token==0) {
        return 0;
    }
    if(*head==0) {
        *head=token;
    }
    else {
        (*tail)->next=token;
    }
    *tail=token;
    return 1;
}

struct regex_t* compile_sequence(struct anonymous_typeX24* st  , const char* pattern, int* pos, int in_group)
{
    struct regex_t* head  ;
    struct regex_t* tail  ;
    char c;
    struct regex_t* token  ;
    struct regex_t* __result_obj__0  ;
    int buf_begin;
    int negated;
    struct regex_t* inner  ;
    struct regex_t* tail_266  ;
    struct regex_t* sentinel  ;
    head=(struct regex_t*)0;
    tail=(struct regex_t*)0;
    while(pattern[*pos]!=0) {
        c=pattern[*pos];
        if(in_group&&(c==41)) {
            break;
        }
        token=(struct regex_t*)0;
        switch (        c) {
            case 94:
            {
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=(2);
                (*pos)++;
            }
            break;
            case 36:
            {
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=(3);
                (*pos)++;
            }
            break;
            case 46:
            {
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=(1);
                (*pos)++;
            }
            break;
            case 42:
            {
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=(5);
                (*pos)++;
            }
            break;
            case 43:
            {
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=(6);
                (*pos)++;
            }
            break;
            case 63:
            {
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=(4);
                (*pos)++;
            }
            break;
            case 92:
            {
                (*pos)++;
                if(pattern[*pos]==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                switch (                pattern[*pos]) {
                    case 100:
                    token->type=(10);
                    break;
                    case 68:
                    token->type=(11);
                    break;
                    case 119:
                    token->type=(12);
                    break;
                    case 87:
                    token->type=(13);
                    break;
                    case 115:
                    token->type=(14);
                    break;
                    case 83:
                    token->type=(15);
                    break;
                    default:
                    {
                        token->type=(7);
                        token->u.ch=(unsigned char)pattern[*pos];
                    }
                    break;
                }
                (*pos)++;
            }
            break;
            case 91:
            {
                buf_begin=st->ccl_idx;
                negated=0;
                (*pos)++;
                if(pattern[*pos]==94) {
                    negated=1;
                    (*pos)++;
                    if(pattern[*pos]==0) {
                        __result_obj__0 = ((void*)0);
                        return __result_obj__0;
                    }
                }
                if(pattern[*pos]==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                while((pattern[*pos]!=0)&&(pattern[*pos]!=93)) {
                    if(pattern[*pos]==92) {
                        if(st->ccl_idx>=(st->ccl_capacity-1)) {
                            __result_obj__0 = ((void*)0);
                            return __result_obj__0;
                        }
                        st->ccl_buf[st->ccl_idx++]=92;
                        (*pos)++;
                        if(pattern[*pos]==0) {
                            __result_obj__0 = ((void*)0);
                            return __result_obj__0;
                        }
                    }
                    if(st->ccl_idx>=st->ccl_capacity) {
                        __result_obj__0 = ((void*)0);
                        return __result_obj__0;
                    }
                    st->ccl_buf[st->ccl_idx++]=(unsigned char)pattern[*pos];
                    (*pos)++;
                }
                if(pattern[*pos]!=93) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                if(st->ccl_idx>=st->ccl_capacity) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                st->ccl_buf[st->ccl_idx++]=0;
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=((negated)?((9)):((8)));
                token->u.ccl=&st->ccl_buf[buf_begin];
                (*pos)++;
            }
            break;
            case 40:
            {
                (*pos)++;
                inner=compile_sequence(st,pattern,pos,1);
                if(inner==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                if(pattern[*pos]!=41) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                tail_266=inner;
                while((tail_266!=0)&&(tail_266->type!=(0))) {
                    tail_266=tail_266->next;
                }
                if(tail_266==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=(16);
                token->u.group.first=inner;
                token->u.group.last=tail_266;
                token->u.group.id=++st->group_count;
                tail_266->type=(17);
                tail_266->u.group.first=token;
                (*pos)++;
            }
            break;
            case 41:
            {
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=(7);
                token->u.ch=(unsigned char)c;
                (*pos)++;
            }
            break;
            default:
            {
                token=new_token(st);
                if(token==0) {
                    __result_obj__0 = ((void*)0);
                    return __result_obj__0;
                }
                token->type=(7);
                token->u.ch=(unsigned char)c;
                (*pos)++;
            }
            break;
        }
        if(!append_token(&head,&tail,token)) {
            __result_obj__0 = ((void*)0);
            return __result_obj__0;
        }
    }
    sentinel=new_token(st);
    if(sentinel==0) {
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    sentinel->type=(0);
    sentinel->next=0;
    if(head==0) {
        head=sentinel;
    }
    else {
        tail->next=sentinel;
    }
    __result_obj__0 = head;
    return __result_obj__0;
}

const char* matchpattern(struct regex_t* pattern  , const char* text, struct anonymous_typeX25* ctx  )
{
    const char* __result_obj__0;
    struct regex_t* current  ;
    struct regex_t* next  ;
    struct regex_t* owner  ;
    int idx;
    int start;
    if(pattern==0) {
        __result_obj__0 = text;
        return __result_obj__0;
    }
    if(pattern->type==(0)) {
        __result_obj__0 = text;
        return __result_obj__0;
    }
    struct re_capture snapshot[64]  ;
    memset(&snapshot, 0, sizeof(snapshot));
    snapshot_captures(ctx,snapshot);
    current=pattern;
    const char* cursor=text;
    while(current!=0&&current->type!=(0)) {
        next=current->next;
        if(current->type==(17)) {
            owner=current->u.group.first;
            if((owner!=0)&&(owner->u.group.id>0)&&(ctx->captures!=0)) {
                idx=owner->u.group.id-1;
                if(idx<ctx->capture_capacity) {
                    start=ctx->captures[idx].start;
                    if(start>=0) {
                        ctx->captures[idx].length=(int)(cursor-ctx->base)-start;
                        if(ctx->captures[idx].length<0) {
                            ctx->captures[idx].length=0;
                        }
                    }
                }
            }
            current=current->next;
            continue;
        }
        if((next!=0)&&(next->type==(4))) {
            const char* result=matchquestion(current,next->next,cursor,ctx);
            if(result!=0) {
                __result_obj__0 = result;
                return __result_obj__0;
            }
            restore_captures(ctx,snapshot);
            __result_obj__0 = ((void*)0);
            return __result_obj__0;
        }
        else if((next!=0)&&(next->type==(5))) {
            const char* result_267=matchstar(current,next->next,cursor,ctx);
            if(result_267!=0) {
                __result_obj__0 = result_267;
                return __result_obj__0;
            }
            restore_captures(ctx,snapshot);
            __result_obj__0 = ((void*)0);
            return __result_obj__0;
        }
        else if((next!=0)&&(next->type==(6))) {
            const char* result_268=matchplus(current,next->next,cursor,ctx);
            if(result_268!=0) {
                __result_obj__0 = result_268;
                return __result_obj__0;
            }
            restore_captures(ctx,snapshot);
            __result_obj__0 = ((void*)0);
            return __result_obj__0;
        }
        else if(current->type==(16)) {
            const char* result_269=matchgroup(current,next,cursor,ctx);
            if(result_269!=0) {
                __result_obj__0 = result_269;
                return __result_obj__0;
            }
            restore_captures(ctx,snapshot);
            __result_obj__0 = ((void*)0);
            return __result_obj__0;
        }
        else if(current->type==(3)) {
            if(*cursor!=0) {
                restore_captures(ctx,snapshot);
                __result_obj__0 = ((void*)0);
                return __result_obj__0;
            }
            current=current->next;
        }
        else {
            const char* after=matchtoken(current,cursor,ctx);
            if(after==0) {
                restore_captures(ctx,snapshot);
                __result_obj__0 = ((void*)0);
                return __result_obj__0;
            }
            cursor=after;
            current=current->next;
        }
    }
    __result_obj__0 = cursor;
    return __result_obj__0;
}

const char* matchgroup(struct regex_t* token  , struct regex_t* rest  , const char* text, struct anonymous_typeX25* ctx  )
{
    struct regex_t* end_token  ;
    struct regex_t* saved_next  ;
    int idx;
    const char* __result_obj__0;
    struct re_capture snapshot_entry[64]  ;
    memset(&snapshot_entry, 0, sizeof(snapshot_entry));
    snapshot_captures(ctx,snapshot_entry);
    end_token=token->u.group.last;
    saved_next=((end_token!=0)?(end_token->next):(0));
    if(end_token!=0) {
        end_token->next=rest;
    }
    if(token->u.group.id>0&&ctx->captures!=0) {
        idx=token->u.group.id-1;
        if(idx<ctx->capture_capacity) {
            ctx->captures[idx].start=(int)(text-ctx->base);
            ctx->captures[idx].length=0;
        }
    }
    const char* result=matchpattern(token->u.group.first,text,ctx);
    if(end_token!=0) {
        end_token->next=saved_next;
    }
    if(result==0) {
        restore_captures(ctx,snapshot_entry);
    }
    __result_obj__0 = result;
    return __result_obj__0;
}

const char* matchstar(struct regex_t* token  , struct regex_t* rest  , const char* text, struct anonymous_typeX25* ctx  )
{
    const char* __result_obj__0;
    struct re_capture snapshot_entry[64]  ;
    memset(&snapshot_entry, 0, sizeof(snapshot_entry));
    snapshot_captures(ctx,snapshot_entry);
    const char* consume=matchtoken(token,text,ctx);
    while((consume!=0)&&(consume!=text)) {
        struct re_capture snapshot_after_token[64]  ;
        memset(&snapshot_after_token, 0, sizeof(snapshot_after_token));
        snapshot_captures(ctx,snapshot_after_token);
        const char* recursive=matchstar(token,rest,consume,ctx);
        if(recursive!=0) {
            __result_obj__0 = recursive;
            return __result_obj__0;
        }
        restore_captures(ctx,snapshot_after_token);
        consume=matchtoken(token,consume,ctx);
    }
    restore_captures(ctx,snapshot_entry);
    __result_obj__0 = matchpattern(rest,text,ctx);
    return __result_obj__0;
}

const char* matchplus(struct regex_t* token  , struct regex_t* rest  , const char* text, struct anonymous_typeX25* ctx  )
{
    const char* __result_obj__0;
    struct re_capture snapshot_entry[64]  ;
    memset(&snapshot_entry, 0, sizeof(snapshot_entry));
    snapshot_captures(ctx,snapshot_entry);
    const char* first=matchtoken(token,text,ctx);
    if((first==0)||(first==text)) {
        restore_captures(ctx,snapshot_entry);
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    const char* result=matchstar(token,rest,first,ctx);
    if(result!=0) {
        __result_obj__0 = result;
        return __result_obj__0;
    }
    restore_captures(ctx,snapshot_entry);
    __result_obj__0 = ((void*)0);
    return __result_obj__0;
}

const char* matchquestion(struct regex_t* token  , struct regex_t* rest  , const char* text, struct anonymous_typeX25* ctx  )
{
    const char* __result_obj__0;
    struct re_capture snapshot_entry[64]  ;
    memset(&snapshot_entry, 0, sizeof(snapshot_entry));
    snapshot_captures(ctx,snapshot_entry);
    const char* skipped=matchpattern(rest,text,ctx);
    if(skipped!=0) {
        __result_obj__0 = skipped;
        return __result_obj__0;
    }
    restore_captures(ctx,snapshot_entry);
    const char* consumed=matchtoken(token,text,ctx);
    if((consumed==0)||(consumed==text)) {
        restore_captures(ctx,snapshot_entry);
        __result_obj__0 = ((void*)0);
        return __result_obj__0;
    }
    const char* with=matchpattern(rest,consumed,ctx);
    if(with!=0) {
        __result_obj__0 = with;
        return __result_obj__0;
    }
    restore_captures(ctx,snapshot_entry);
    __result_obj__0 = ((void*)0);
    return __result_obj__0;
}

unsigned char re_fold_char(unsigned char c, _Bool ignore_case)
{
    if(ignore_case&&c>=65&&c<=90) {
        return (unsigned char)(c-65+97);
    }
    return c;
}

const char* matchtoken(struct regex_t* token  , const char* text, struct anonymous_typeX25* ctx  )
{
    const char* __result_obj__0;
    switch (    token->type) {
        case (1):
        __result_obj__0 = (((*text!=0&&matchdot(*text)))?(text+1):(0));
        return __result_obj__0;
        case (7):
        __result_obj__0 = (((*text!=0&&re_fold_char(token->u.ch,ctx->ignore_case)==re_fold_char((unsigned char)*text,ctx->ignore_case)))?(text+1):(0));
        return __result_obj__0;
        case (8):
        __result_obj__0 = (((*text!=0&&matchcharclass(*text,(const char*)token->u.ccl,ctx->ignore_case)))?(text+1):(0));
        return __result_obj__0;
        case (9):
        __result_obj__0 = (((*text!=0&&!matchcharclass(*text,(const char*)token->u.ccl,ctx->ignore_case)))?(text+1):(0));
        return __result_obj__0;
        case (10):
        __result_obj__0 = (((*text!=0&&matchdigit(*text)))?(text+1):(0));
        return __result_obj__0;
        case (11):
        __result_obj__0 = (((*text!=0&&!matchdigit(*text)))?(text+1):(0));
        return __result_obj__0;
        case (12):
        __result_obj__0 = (((*text!=0&&matchalphanum(*text)))?(text+1):(0));
        return __result_obj__0;
        case (13):
        __result_obj__0 = (((*text!=0&&!matchalphanum(*text)))?(text+1):(0));
        return __result_obj__0;
        case (14):
        __result_obj__0 = (((*text!=0&&matchwhitespace(*text)))?(text+1):(0));
        return __result_obj__0;
        case (15):
        __result_obj__0 = (((*text!=0&&!matchwhitespace(*text)))?(text+1):(0));
        return __result_obj__0;
        case (16):
        __result_obj__0 = matchgroup(token,(struct regex_t*)0,text,ctx);
        return __result_obj__0;
        case (2):
        __result_obj__0 = (((text==ctx->base))?(text):(0));
        return __result_obj__0;
        case (3):
        __result_obj__0 = (((*text==0))?(text):(0));
        return __result_obj__0;
        default:
        break;
    }
    __result_obj__0 = (const char*)0;
    return __result_obj__0;
}

int matchdigit(char c)
{
    return xisdigit((unsigned char)c);
}

int matchalpha(char c)
{
    return xisalpha((unsigned char)c);
}

int matchwhitespace(char c)
{
    return xisspace((unsigned char)c);
}

int matchalphanum(char c)
{
    return ((c==95)||matchalpha(c)||matchdigit(c));
}

int matchrange(char c, const char* str, _Bool ignore_case)
{
    unsigned char needle;
    unsigned char start;
    unsigned char end;
    needle=(unsigned char)c;
    start=(unsigned char)str[0];
    end=(unsigned char)str[2];
    if(ignore_case) {
        needle=re_fold_char(needle,1);
        start=re_fold_char(start,1);
        end=re_fold_char(end,1);
    }
    return ((needle!=45)&&(str[0]!=0)&&(str[0]!=45)&&(str[1]==45)&&(str[2]!=0)&&((needle>=start)&&(needle<=end)));
}

int matchdot(char c)
{
    return c!=10&&c!=13;
}

int ismetachar(char c)
{
    return ((c==115)||(c==83)||(c==119)||(c==87)||(c==100)||(c==68));
}

int matchmetachar(char c, const char* str)
{
    switch (    str[0]) {
        case 100:
        return matchdigit(c);
        case 68:
        return !matchdigit(c);
        case 119:
        return matchalphanum(c);
        case 87:
        return !matchalphanum(c);
        case 115:
        return matchwhitespace(c);
        case 83:
        return !matchwhitespace(c);
        default:
        return (c==str[0]);
    }
}

int matchcharclass(char c, const char* str, _Bool ignore_case)
{
    unsigned char needle;
    needle=re_fold_char((unsigned char)c,ignore_case);
    do {
        if(matchrange((char)needle,str,ignore_case)) {
            return 1;
        }
        else if(str[0]==92) {
            str+=1;
            if(matchmetachar((char)needle,str)) {
                return 1;
            }
            else if((needle==re_fold_char((unsigned char)str[0],ignore_case))&&!ismetachar((char)needle)) {
                return 1;
            }
        }
        else if(needle==re_fold_char((unsigned char)str[0],ignore_case)) {
            if(needle==45) {
                return ((str[-1]==0)||(str[1]==0));
            }
            else {
                return 1;
            }
        }
    } while(*str++!=0);
    return 0;
}

void re_print_internal(struct regex_t* pattern  , int depth)
{
    int i;
    const char* types[]={
    "RE_UNUSED", "RE_DOT", "RE_BEGIN", "RE_END", "RE_QUESTIONMARK", "RE_STAR", "RE_PLUS", "RE_CHAR",
    "RE_CHAR_CLASS", "RE_INV_CHAR_CLASS", "RE_DIGIT", "RE_NOT_DIGIT", "RE_ALPHA", "RE_NOT_ALPHA",
    "RE_WHITESPACE", "RE_NOT_WHITESPACE", "RE_GROUP", "RE_GROUP_END"
  };
    while(pattern!=0&&pattern->type!=(0)) {
        for(i=0;i<depth;++i){
            putchar(32);
        }
        printf("type: %s",types[pattern->type]);
        if((pattern->type==(8))||(pattern->type==(9))) {
            printf(" [");
            const unsigned char* ccl=pattern->u.ccl;
            while(*ccl!=0&&*ccl!=93) {
                printf("%c",*ccl);
                ++ccl;
            }
            printf("]");
        }
        else if(pattern->type==(7)) {
            printf(" '%c'",pattern->u.ch);
        }
        else if(pattern->type==(16)) {
            printf(" id=%d\n",pattern->u.group.id);
            re_print_internal(pattern->u.group.first,depth+2);
            pattern=pattern->next;
            continue;
        }
        printf("\n");
        pattern=pattern->next;
    }
}

int re_get_group_count(struct re_program* pattern  )
{
    struct re_program* program  ;
    if(pattern==0) {
        return 0;
    }
    program=(struct re_program*)pattern;
    return program->group_count;
}

int charp_index_regex(char* self, char* reg, int default_value, _Bool ignore_case)
{
    struct re_program* re  ;
    int result;
    int offset;
    int n;
    int result_270;
    int matchlength;
    int max_captures;
    int regex_result;
    if(self==((void*)0)||reg==((void*)0)) {
        return default_value;
    }
    re=re_compile(reg);
    if(re==((void*)0)) {
        return default_value;
    }
    result=default_value;
    offset=0;
    n=0;
    result_270=default_value;
    while(1) {
        matchlength=0;
        max_captures=8;
        struct re_capture captures[max_captures]  ;
        memset(&captures, 0, sizeof(captures));
        regex_result=re_matchp_ex(re,self,&matchlength,captures,max_captures,ignore_case);
        if(regex_result>=0) {
            result_270=regex_result;
            break;
        }
        {
            break;
        }
    }
    return result_270;
}

int charp_rindex_regex(char* self, char* reg, int default_value, _Bool ignore_case)
{
    struct re_program* re  ;
    int result;
    int offset;
    int n;
    void* __right_value0 = (void*)0;
    char* self2  ;
    int result_271;
    int matchlength;
    int max_captures;
    int regex_result;
    int __result_obj__0;
    if(self==((void*)0)||reg==((void*)0)) {
        return default_value;
    }
    re=re_compile(reg);
    if(re==((void*)0)) {
        return default_value;
    }
    result=default_value;
    offset=0;
    n=0;
    self2=(char*)come_increment_ref_count(charp_reverse(self));
    result_271=default_value;
    while(1) {
        matchlength=0;
        max_captures=8;
        struct re_capture captures[max_captures]  ;
        memset(&captures, 0, sizeof(captures));
        regex_result=re_matchp_ex(re,self2,&matchlength,captures,max_captures,ignore_case);
        if(regex_result>=0) {
            result_271=strlen(self)-matchlength;
            break;
        }
        {
            break;
        }
    }
    __result_obj__0 = result_271;
    (self2 = come_decrement_ref_count(self2, (void*)0, (void*)0, 0, 0, (void*)0));
    return __result_obj__0;
}

char* string_chomp(char* str)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    char* result  ;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(char*)come_increment_ref_count(__builtin_string(str));
    if(result[string_length(result)-1]==10) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=charp_substring(result,0,-2))));
        (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 0, (void*)0));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int string_rindex_regex(char* self, char* reg, int default_value, _Bool ignore_case)
{
    return charp_rindex_regex(self,reg,default_value,ignore_case);
}

int string_index_regex(char* self, char* reg, int default_value, _Bool ignore_case)
{
    return charp_index_regex(self,reg,default_value,ignore_case);
}

_Bool charp_match(char* self, char* reg, _Bool ignore_case)
{
    struct re_program* re  ;
    int offset;
    int n;
    int matchlength;
    int max_captures;
    int regex_result;
    _Bool __result_obj__0;
    if(self==((void*)0)||reg==((void*)0)) {
        return 0;
    }
    re=re_compile(reg);
    if(re==((void*)0)) {
        return 0;
    }
    offset=0;
    n=0;
    matchlength=0;
    max_captures=8;
    struct re_capture captures[max_captures]  ;
    memset(&captures, 0, sizeof(captures));
    regex_result=re_matchp_ex(re,self,&matchlength,captures,max_captures,ignore_case);
    if(regex_result>=0) {
        __result_obj__0 = 1;
        return __result_obj__0;
    }
    else {
        __result_obj__0 = 0;
        return __result_obj__0;
    }
}

struct list$1char$ph* charp_scan(char* self, char* reg, _Bool ignore_case)
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* __result_obj__0;
    struct list$1char$ph* result;
    struct re_program* re  ;
    int offset;
    int n;
    int group_count;
    int matchlength;
    int max_captures;
    int regex_result;
    char* str  ;
    int i;
    struct re_capture cp  ;
    char* match_string  ;
    if(self==((void*)0)||reg==((void*)0)) {
        __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value1=list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6361, "struct list$1char$ph*"))))));
        come_call_finalizer(list$1char$ph$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    result=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6363, "struct list$1char$ph*"))));
    re=re_compile(reg);
    if(re==((void*)0)) {
        __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value1=list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6368, "struct list$1char$ph*"))))));
        come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    offset=0;
    n=0;
    group_count=re_get_group_count(re);
    while(1) {
        matchlength=0;
        max_captures=8;
        struct re_capture captures[max_captures]  ;
        memset(&captures, 0, sizeof(captures));
        regex_result=re_matchp_ex(re,self+offset,&matchlength,captures,max_captures,ignore_case);
        if(regex_result>=0&&group_count==0) {
            str=(char*)come_increment_ref_count(charp_substring(self,offset+regex_result,offset+regex_result+matchlength));
            list$1char$ph_add(result,(char*)come_increment_ref_count(str));
            if(matchlength==0) {
                offset++;
            }
            else {
                offset=offset+regex_result+matchlength;
            }
            (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else if(regex_result>=0&&group_count>0) {
            for(i=0;i<group_count;i++){
                cp=captures[i];
                match_string=(char*)come_increment_ref_count(charp_substring((self+offset),cp.start,cp.start+cp.length));
                list$1char$ph_push_back(result,(char*)come_increment_ref_count(match_string));
                (match_string = come_decrement_ref_count(match_string, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            if(matchlength==0) {
                offset++;
            }
            else {
                offset=offset+regex_result+matchlength;
            }
        }
        else {
            break;
        }
    }
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(result);
    come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

struct list$1char$ph* charp_split(char* self, char* reg, _Bool ignore_case)
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* __result_obj__0;
    struct list$1char$ph* result;
    struct re_program* re  ;
    int offset;
    int n;
    int group_count;
    int matchlength;
    int max_captures;
    int regex_result;
    char* str  ;
    char* str_272  ;
    if(self==((void*)0)||reg==((void*)0)) {
        __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value1=list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6424, "struct list$1char$ph*"))))));
        come_call_finalizer(list$1char$ph$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    result=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6427, "struct list$1char$ph*"))));
    re=re_compile(reg);
    if(re==((void*)0)) {
        __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value1=list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6432, "struct list$1char$ph*"))))));
        come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    offset=0;
    n=0;
    group_count=re_get_group_count(re);
    while(1) {
        matchlength=0;
        max_captures=8;
        struct re_capture captures[max_captures]  ;
        memset(&captures, 0, sizeof(captures));
        regex_result=re_matchp_ex(re,self+offset,&matchlength,captures,max_captures,ignore_case);
        if(regex_result>=0&&group_count==0) {
            str=(char*)come_increment_ref_count(charp_substring(self,offset,offset+regex_result));
            list$1char$ph_add(result,(char*)come_increment_ref_count(str));
            if(matchlength==0) {
                offset++;
            }
            else {
                offset=offset+regex_result+matchlength;
            }
            (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else {
            break;
        }
    }
    if(offset<charp_length(self)) {
        str_272=(char*)come_increment_ref_count(charp_substring(self,offset,-1));
        list$1char$ph_push_back(result,(char*)come_increment_ref_count(str_272));
        (str_272 = come_decrement_ref_count(str_272, (void*)0, (void*)0, 0, 0, (void*)0));
    }
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(result);
    come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

char* string_sub(char* self, char* reg, char* replace, _Bool ignore_case)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=charp_sub(self,reg,replace,1,ignore_case))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

struct list$1char$ph* string_scan(char* self, char* reg, _Bool ignore_case)
{
    void* __right_value0 = (void*)0;
    struct list$1char$ph* __result_obj__0;
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value0=charp_scan(self,reg,ignore_case))));
    come_call_finalizer(list$1char$ph$p_finalize, __right_value0, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

struct list$1char$ph* string_split(char* self, char* reg, _Bool ignore_case)
{
    void* __right_value0 = (void*)0;
    struct list$1char$ph* __result_obj__0;
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value0=charp_split(self,reg,ignore_case))));
    come_call_finalizer(list$1char$ph$p_finalize, __right_value0, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

_Bool string_match(char* self, char* reg, _Bool ignore_case)
{
    return charp_match(self,reg,ignore_case);
}

char* charp_sub(char* self, char* reg, char* replace, _Bool global, _Bool ignore_case)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    struct re_program* re  ;
    int offset;
    int n;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    int group_count;
    int matchlength;
    int max_captures;
    int regex_result;
    char* str  ;
    char* str_273  ;
    char* str_274  ;
    if(self==((void*)0)||reg==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    re=re_compile(reg);
    if(re==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    offset=0;
    n=0;
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 6517, "struct buffer*"))));
    group_count=re_get_group_count(re);
    while(1) {
        matchlength=0;
        max_captures=8;
        struct re_capture captures[max_captures]  ;
        memset(&captures, 0, sizeof(captures));
        regex_result=re_matchp_ex(re,self+offset,&matchlength,captures,max_captures,ignore_case);
        if(regex_result>=0&&group_count==0) {
            str=(char*)come_increment_ref_count(charp_substring(self,offset,offset+regex_result));
            buffer_append_str(result,str);
            buffer_append_str(result,replace);
            if(matchlength==0) {
                offset++;
            }
            else {
                offset=offset+regex_result+matchlength;
            }
            if(!global) {
                str_273=(char*)come_increment_ref_count(charp_substring(self,offset,-1));
                buffer_append_str(result,str_273);
                (str_273 = come_decrement_ref_count(str_273, (void*)0, (void*)0, 0, 0, (void*)0));
                (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
                break;
                (str_273 = come_decrement_ref_count(str_273, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else {
            str_274=(char*)come_increment_ref_count(charp_substring(self,offset,-1));
            buffer_append_str(result,str_274);
            (str_274 = come_decrement_ref_count(str_274, (void*)0, (void*)0, 0, 0, (void*)0));
            break;
            (str_274 = come_decrement_ref_count(str_274, (void*)0, (void*)0, 0, 0, (void*)0));
        }
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(result))));
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_sub_block(char* self, char* reg, _Bool global, _Bool ignore_case, void* parent, char* (*block)(void*,char*,struct list$1char$ph*))
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    void* __right_value1 = (void*)0;
    struct buffer* result  ;
    struct re_program* re  ;
    int offset;
    int n;
    int group_count;
    int matchlength;
    int max_captures;
    int regex_result;
    char* str  ;
    struct list$1char$ph* group_strings;
    char* match_string  ;
    char* block_result  ;
    char* str_275  ;
    char* str_276  ;
    struct list$1char$ph* group_strings_277;
    int i;
    struct re_capture cp  ;
    char* match_string_278  ;
    char* match_string_279  ;
    char* block_result_280  ;
    char* str_281  ;
    if(self==((void*)0)||reg==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 6565, "struct buffer*"))));
    re=re_compile(reg);
    if(re==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    offset=0;
    n=0;
    group_count=re_get_group_count(re);
    while(1) {
        matchlength=0;
        max_captures=8;
        struct re_capture captures[max_captures]  ;
        memset(&captures, 0, sizeof(captures));
        regex_result=re_matchp_ex(re,self+offset,&matchlength,captures,max_captures,ignore_case);
        if(regex_result>=0&&group_count==0) {
            str=(char*)come_increment_ref_count(charp_substring(self,offset,offset+regex_result));
            buffer_append_str(result,str);
            group_strings=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6592, "struct list$1char$ph*"))));
            match_string=(char*)come_increment_ref_count(charp_substring(self,offset+regex_result,offset+regex_result+matchlength));
            block_result=(char*)come_increment_ref_count(block(parent,match_string,group_strings));
            buffer_append_str(result,block_result);
            if(matchlength==0) {
                offset++;
            }
            else {
                offset=offset+regex_result+matchlength;
            }
            if(!global) {
                str_275=(char*)come_increment_ref_count(charp_substring(self,offset,-1));
                buffer_append_str(result,str_275);
                (str_275 = come_decrement_ref_count(str_275, (void*)0, (void*)0, 0, 0, (void*)0));
                (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
                come_call_finalizer(list$1char$ph$p_finalize, group_strings, (void*)0, (void*)0, 0, 0, 0, (void*)0);
                (match_string = come_decrement_ref_count(match_string, (void*)0, (void*)0, 0, 0, (void*)0));
                (block_result = come_decrement_ref_count(block_result, (void*)0, (void*)0, 0, 0, (void*)0));
                break;
                (str_275 = come_decrement_ref_count(str_275, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
            come_call_finalizer(list$1char$ph$p_finalize, group_strings, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            (match_string = come_decrement_ref_count(match_string, (void*)0, (void*)0, 0, 0, (void*)0));
            (block_result = come_decrement_ref_count(block_result, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else if(regex_result>=0&&group_count>0) {
            str_276=(char*)come_increment_ref_count(charp_substring(self,offset,offset+regex_result));
            buffer_append_str(result,str_276);
            group_strings_277=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6620, "struct list$1char$ph*"))));
            for(i=0;i<group_count;i++){
                cp=captures[i];
                match_string_278=(char*)come_increment_ref_count(charp_substring((self+offset),cp.start,cp.start+cp.length));
                list$1char$ph_push_back(group_strings_277,(char*)come_increment_ref_count(match_string_278));
                (match_string_278 = come_decrement_ref_count(match_string_278, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            match_string_279=(char*)come_increment_ref_count(charp_substring(self,offset+regex_result,offset+regex_result+matchlength));
            block_result_280=(char*)come_increment_ref_count(block(parent,match_string_279,group_strings_277));
            buffer_append_str(result,block_result_280);
            if(matchlength==0) {
                offset++;
            }
            else {
                offset=offset+regex_result+matchlength;
            }
            (str_276 = come_decrement_ref_count(str_276, (void*)0, (void*)0, 0, 0, (void*)0));
            come_call_finalizer(list$1char$ph$p_finalize, group_strings_277, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            (match_string_279 = come_decrement_ref_count(match_string_279, (void*)0, (void*)0, 0, 0, (void*)0));
            (block_result_280 = come_decrement_ref_count(block_result_280, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else {
            str_281=(char*)come_increment_ref_count(charp_substring(self,offset,-1));
            buffer_append_str(result,str_281);
            (str_281 = come_decrement_ref_count(str_281, (void*)0, (void*)0, 0, 0, (void*)0));
            break;
            (str_281 = come_decrement_ref_count(str_281, (void*)0, (void*)0, 0, 0, (void*)0));
        }
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(result))));
    come_call_finalizer(buffer_finalize, result, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

struct list$1char$ph* charp_scan_block(char* self, char* reg, _Bool ignore_case, void* parent, char* (*block)(void*,char*,struct list$1char$ph*))
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* __result_obj__0;
    struct list$1char$ph* result;
    struct re_program* re  ;
    int offset;
    int n;
    int group_count;
    int matchlength;
    int max_captures;
    int regex_result;
    struct list$1char$ph* group_strings;
    char* match_string  ;
    char* block_result  ;
    struct list$1char$ph* group_strings_282;
    int i;
    struct re_capture cp  ;
    char* match_string_283  ;
    char* match_string_284  ;
    char* block_result_285  ;
    if(self==((void*)0)||reg==((void*)0)) {
        __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value1=list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6654, "struct list$1char$ph*"))))));
        come_call_finalizer(list$1char$ph$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    result=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6656, "struct list$1char$ph*"))));
    re=re_compile(reg);
    if(re==((void*)0)) {
        __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value1=list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6661, "struct list$1char$ph*"))))));
        come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    offset=0;
    n=0;
    group_count=re_get_group_count(re);
    while(1) {
        matchlength=0;
        max_captures=8;
        struct re_capture captures[max_captures]  ;
        memset(&captures, 0, sizeof(captures));
        regex_result=re_matchp_ex(re,self+offset,&matchlength,captures,max_captures,ignore_case);
        if(regex_result>=0&&group_count==0) {
            group_strings=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6679, "struct list$1char$ph*"))));
            match_string=(char*)come_increment_ref_count(charp_substring(self,offset+regex_result,offset+regex_result+matchlength));
            block_result=(char*)come_increment_ref_count(block(parent,match_string,group_strings));
            list$1char$ph_add(result,(char*)come_increment_ref_count(block_result));
            if(matchlength==0) {
                offset++;
            }
            else {
                offset=offset+regex_result+matchlength;
            }
            come_call_finalizer(list$1char$ph$p_finalize, group_strings, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            (match_string = come_decrement_ref_count(match_string, (void*)0, (void*)0, 0, 0, (void*)0));
            (block_result = come_decrement_ref_count(block_result, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else if(regex_result>=0&&group_count>0) {
            group_strings_282=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 6696, "struct list$1char$ph*"))));
            for(i=0;i<group_count;i++){
                cp=captures[i];
                match_string_283=(char*)come_increment_ref_count(charp_substring((self+offset),cp.start,cp.start+cp.length));
                list$1char$ph_push_back(group_strings_282,(char*)come_increment_ref_count(match_string_283));
                (match_string_283 = come_decrement_ref_count(match_string_283, (void*)0, (void*)0, 0, 0, (void*)0));
            }
            match_string_284=(char*)come_increment_ref_count(charp_substring(self,offset+regex_result,offset+regex_result+matchlength));
            block_result_285=(char*)come_increment_ref_count(block(parent,match_string_284,group_strings_282));
            list$1char$ph_add(result,(char*)come_increment_ref_count(block_result_285));
            if(matchlength==0) {
                offset++;
            }
            else {
                offset=offset+regex_result+matchlength;
            }
            come_call_finalizer(list$1char$ph$p_finalize, group_strings_282, (void*)0, (void*)0, 0, 0, 0, (void*)0);
            (match_string_284 = come_decrement_ref_count(match_string_284, (void*)0, (void*)0, 0, 0, (void*)0));
            (block_result_285 = come_decrement_ref_count(block_result_285, (void*)0, (void*)0, 0, 0, (void*)0));
        }
        else {
            break;
        }
    }
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(result);
    come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

char* string_sub_block(char* self, char* reg, _Bool global, _Bool ignore_case, void* parent, char* (*block)(void*,char*,struct list$1char$ph*))
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=charp_sub_block(self,reg,global,ignore_case,parent,block))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* __builtin_wstring(char* str)
{
    int* __result_obj__0  ;
    int len;
    void* __right_value0 = (void*)0;
    int* wstr  ;
    int ret;
    if(str==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(str);
    wstr=(int*)come_increment_ref_count((int*)come_calloc(1, sizeof(int)*(1*(len+1)), "/usr/local/include/neo-c.h", 6748, "int*"));
    ret=mbstowcs(wstr,str,len+1);
    wstr[ret]=0;
    if(ret<0) {
        wstr[0]=0;
    }
    __result_obj__0 = (int*)come_increment_ref_count(wstr);
    (wstr = come_decrement_ref_count(wstr, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int wchar_tp_length(int* str  )
{
    if(str==((void*)0)) {
        return 0;
    }
    return wcslen(str);
}

int wchar_ta_length(int* str  )
{
    if(str==((void*)0)) {
        return 0;
    }
    return wcslen(str);
}

int wstring_length(int* str  )
{
    return wchar_tp_length(str);
}

char* string_lower_case(char* str)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    char* result  ;
    int i;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(char*)come_increment_ref_count(__builtin_string(str));
    for(i=0;i<strlen(str);i++){
        if(str[i]>=65&&str[i]<=90) {
            result[i]=str[i]-65+97;
        }
    }
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* string_upper_case(char* str)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    char* result  ;
    int i;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(char*)come_increment_ref_count(__builtin_string(str));
    for(i=0;i<strlen(str);i++){
        if(str[i]>=97&&str[i]<=122) {
            result[i]=str[i]-97+65;
        }
    }
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* wchar_tp_substring(int* str  , int head, int tail)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    int len;
    int* result  ;
    if(str==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=wcslen(str);
    if(head<0) {
        head+=len;
    }
    if(tail<0) {
        tail+=len+1;
    }
    if(head>tail) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(head<0) {
        head=0;
    }
    if(tail>=len) {
        tail=len;
    }
    if(head>=len) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(head==tail) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(tail-head+1<1) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(int*)come_increment_ref_count((int*)come_calloc(1, sizeof(int)*(1*(tail-head+1)), "/usr/local/include/neo-c.h", 6850, "int*"));
    memcpy(result,str+head,sizeof(int)*(tail-head));
    result[tail-head]=0;
    __result_obj__0 = (int*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int charp_index_count(char* str, char* search_str, int count, int default_value)
{
    int n;
    int len;
    int i;
    int len2;
    int j;
    memset(&j, 0, sizeof(j));
    if(str==((void*)0)||search_str==((void*)0)) {
        return default_value;
    }
    n=0;
    len=strlen(str);
    for(i=0;i<len;i++){
        len2=strlen(search_str);
        for(j=0;j<len2;j++){
            if(str[i+j]!=search_str[j]) {
                break;
            }
        }
        if(j==len2) {
            n++;
            if(n==count) {
                return i;
            }
        }
    }
    return default_value;
}

int charp_rindex(char* str, char* search_str, int default_value)
{
    int len;
    char* p;
    if(str==((void*)0)||search_str==((void*)0)) {
        return default_value;
    }
    len=strlen(search_str);
    p=str+strlen(str)-len;
    while(p>=str) {
        if(strncmp(p,search_str,len)==0) {
            return p-str;
        }
        p--;
    }
    return default_value;
}

int charp_rindex_count(char* str, char* search_str, int count, int default_value)
{
    int len;
    char* p;
    int n;
    if(str==((void*)0)||search_str==((void*)0)) {
        return default_value;
    }
    len=strlen(search_str);
    p=str+strlen(str)-len;
    n=0;
    while(p>=str) {
        if(strncmp(p,search_str,len)==0) {
            n++;
            if(n==count) {
                return p-str;
            }
        }
        p--;
    }
    return default_value;
}

char* charp_strip(char* self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    char* result  ;
    int len;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(char*)come_increment_ref_count(__builtin_string(self));
    len=strlen(self);
    if(self[len-1]==10) {
        result[len-1]=0;
    }
    else if(self[len-1]==13) {
        result[len-1]=0;
    }
    else if(len>2&&self[len-2]==13&&self[len-1]==10) {
        result[len-2]=0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* wchar_tp_to_string(int* wstr  )
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    char* result  ;
    if(wstr==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=16*(wcslen(wstr)+1);
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(len)), "/usr/local/include/neo-c.h", 6963, "char*"));
    if(wcstombs(result,wstr,len)<0) {
        strncpy(result,"",len);
    }
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* wchar_ta_to_string(int* wstr  )
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    if(wstr==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=wchar_tp_to_string(wstr))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* charp_to_wstring(char* str)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    if(str==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(str))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* chara_to_wstring(char* str)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    if(str==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(str))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* wchar_tp_delete(int* str  , int head, int tail)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    int len;
    void* __right_value1 = (void*)0;
    int* sub_str  ;
    if(str==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=wcslen(str);
    if(len==0) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value1=string_to_wstring(((char*)(__right_value0=wchar_tp_to_string(str)))))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(head<0) {
        head+=len;
    }
    if(tail<0) {
        tail+=len+1;
    }
    if(head<0) {
        head=0;
    }
    if(tail<0) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value1=string_to_wstring(((char*)(__right_value0=wchar_tp_to_string(str)))))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(tail>=len) {
        tail=len;
    }
    sub_str=(int*)come_increment_ref_count(wchar_tp_substring(str,tail,-1));
    memcpy(str+head,sub_str,sizeof(int)*(wstring_length(sub_str)+1));
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value1=string_to_wstring(((char*)(__right_value0=wchar_tp_to_string(str)))))));
    (sub_str = come_decrement_ref_count(sub_str, (void*)0, (void*)0, 0, 0, (void*)0));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int wchar_tp_index(int* str  , int* search_str  , int default_value)
{
    int* head  ;
    if(str==((void*)0)||search_str==((void*)0)) {
        return default_value;
    }
    head=wcsstr(str,search_str);
    if(head==((void*)0)) {
        return default_value;
    }
    return head-str;
}

int wchar_tp_rindex(int* str  , int* search_str  , int default_value)
{
    int len;
    int* p  ;
    int len2;
    _Bool result;
    int i;
    memset(&i, 0, sizeof(i));
    if(str==((void*)0)||search_str==((void*)0)) {
        return default_value;
    }
    len=wcslen(search_str);
    p=str+wcslen(str)-len;
    while(p>=str) {
        len2=wcslen(p);
        result=1;
        for(i=0;i<len&&i<len2;i++){
            if(p[i]!=search_str[i]) {
                result=0;
            }
        }
        if(result) {
            return (p-str);
        }
        p--;
    }
    return default_value;
}

int* wchar_tp_reverse(int* str  )
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    int len;
    int* result  ;
    int i;
    if(str==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=wcslen(str);
    result=(int*)come_increment_ref_count((int*)come_calloc(1, sizeof(int)*(1*(len+1)), "/usr/local/include/neo-c.h", 7086, "int*"));
    for(i=0;i<len;i++){
        result[i]=str[len-i-1];
    }
    result[len]=0;
    __result_obj__0 = (int*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* wchar_tp_multiply(int* str  , int n)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    int len;
    int* result  ;
    int i;
    if(str==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=wcslen(str)*n+1;
    result=(int*)come_increment_ref_count((int*)come_calloc(1, sizeof(int)*(1*(len)), "/usr/local/include/neo-c.h", 7105, "int*"));
    result[0]=0;
    for(i=0;i<n;i++){
        wcscat(result,str);
    }
    __result_obj__0 = (int*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* wchar_tp_printable(int* str  )
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    int len;
    int* result  ;
    int n;
    int i;
    int c  ;
    if(str==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=wchar_tp_length(str);
    result=(int*)come_increment_ref_count((int*)come_calloc(1, sizeof(int)*(1*(len*2+1)), "/usr/local/include/neo-c.h", 7122, "int*"));
    n=0;
    for(i=0;i<len;i++){
        c=str[i];
        if((c>=0&&c<32)||c==127) {
            result[n++]=94;
            result[n++]=c+65-1;
        }
        else {
            result[n++]=c;
        }
    }
    result[n]=0;
    __result_obj__0 = (int*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int wchar_tp_compare(int* left  , int* right  )
{
    if(left==((void*)0)) {
        if(right==((void*)0)) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else if(right==((void*)0)) {
        if(left==((void*)0)) {
            return 0;
        }
        else {
            return -1;
        }
    }
    return wcscmp(left,right);
}

int wstring_compare(int* left  , int* right  )
{
    if(left==((void*)0)) {
        if(right==((void*)0)) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else if(right==((void*)0)) {
        if(left==((void*)0)) {
            return 0;
        }
        else {
            return -1;
        }
    }
    return wcscmp(left,right);
}

int* wchar_tp_operator_mult(int* str  , int n)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=wchar_tp_multiply(str,n))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* wstring_operator_mult(int* str  , int n)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=wchar_tp_multiply(str,n))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

_Bool wstring_operator_equals(int* left  , int* right  )
{
    return wcscmp(left,right)==0;
}

_Bool wstring_operator_not_equals(int* left  , int* right  )
{
    return wcscmp(left,right)!=0;
}

int* wchar_tp_operator_add(int* left  , int* right  )
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    int* result  ;
    if(left==((void*)0)||right==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(int*)come_increment_ref_count((int*)come_calloc(1, sizeof(int)*(1*(wcslen(left)+wcslen(right)+1)), "/usr/local/include/neo-c.h", 7230, "int*"));
    wcscpy(result,left);
    wcscat(result,right);
    __result_obj__0 = (int*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* wstring_operator_add(int* left  , int* right  )
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    int* result  ;
    if(left==((void*)0)||right==((void*)0)) {
        __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=__builtin_wstring(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=(int*)come_increment_ref_count((int*)come_calloc(1, sizeof(int)*(1*(wcslen(left)+wcslen(right)+1)), "/usr/local/include/neo-c.h", 7243, "int*"));
    wcscpy(result,left);
    wcscat(result,right);
    __result_obj__0 = (int*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int charp_index(char* str, char* search_str, int default_value)
{
    char* head;
    if(str==((void*)0)||search_str==((void*)0)) {
        return default_value;
    }
    head=strstr(str,search_str);
    if(head==((void*)0)) {
        return default_value;
    }
    return head-str;
}

char* charp_replace(char* self, int index, char c)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    if(self==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(self);
    if(strcmp(self,"")==0) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(self))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    if(index<0) {
        index+=len;
    }
    if(index>=len) {
        index=len-1;
    }
    if(index<0) {
        index=0;
    }
    self[index]=c;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_multiply(char* str, int n)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    int len;
    char* result;
    int i;
    if(str==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    len=strlen(str)*n+1;
    result=(char*)come_increment_ref_count((char*)come_calloc(1, sizeof(char)*(1*(len)), "/usr/local/include/neo-c.h", 7300, "char*"));
    result[0]=0;
    for(i=0;i<n;i++){
        strcat(result,str);
    }
    __result_obj__0 = (char*)come_increment_ref_count(result);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

struct list$1char$ph* charp_split_str(char* self, char* str)
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* __result_obj__0;
    struct list$1char$ph* result;
    struct buffer* buf  ;
    int i;
    if(self==((void*)0)||str==((void*)0)) {
        __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value1=list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 7314, "struct list$1char$ph*"))))));
        come_call_finalizer(list$1char$ph$p_finalize, __right_value1, (void*)0, (void*)0, 0, 1, 0, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    result=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 7316, "struct list$1char$ph*"))));
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 7318, "struct buffer*"))));
    for(i=0;i<charp_length(self);i++){
        if(strstr(self+i,str)==self+i) {
            list$1char$ph_push_back(result,(char*)come_increment_ref_count(__builtin_string(buf->buf)));
            buffer_reset(buf);
            i+=strlen(str)-1;
        }
        else {
            buffer_append_char(buf,self[i]);
        }
    }
    if(buffer_length(buf)!=0) {
        list$1char$ph_push_back(result,(char*)come_increment_ref_count(__builtin_string(buf->buf)));
    }
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(result);
    come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

unsigned int wchar_tp_get_hash_key(int* value  )
{
    int result;
    int* p  ;
    if(value==((void*)0)) {
        return 0;
    }
    result=0;
    p=value;
    while(*p) {
        result+=(*p);
        p++;
    }
    return result;
}

_Bool wstring_equals(int* left  , int* right  )
{
    if(left==((void*)0)&&right==((void*)0)) {
        return 1;
    }
    else if(left==((void*)0)||right==((void*)0)) {
        return 0;
    }
    return wcscmp(left,right)==0;
}

_Bool wchar_t_operator_equals(int left  , int right  )
{
    return left==right;
}

_Bool wchar_t_operator_not_equals(int left  , int right  )
{
    return left!=right;
}

unsigned int wchar_t_get_hash_key(int value  )
{
    return value;
}

_Bool wchar_t_equals(int left  , int right  )
{
    return left==right;
}

char* wchar_t_to_string(int wc  )
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=xsprintf("%ls",wc))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* xrealpath(char* path)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    char* result;
    char* result2  ;
    if(path==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    result=realpath(path,((void*)0));
    result2=(char*)come_increment_ref_count(__builtin_string(result));
    free(result);
    __result_obj__0 = (char*)come_increment_ref_count(result2);
    (result2 = come_decrement_ref_count(result2, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* xdirname(char* path)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    void* __right_value1 = (void*)0;
    if(path==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value1=__builtin_string(dirname(((char*)(__right_value0=__builtin_string(path))))))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

unsigned long xwcslen(int* wstr  )
{
    int* p  ;
    unsigned long len  ;
    if(wstr==((void*)0)) {
        return 0;
    }
    p=wstr;
    len=0;
    while(*p) {
        p++;
        len++;
    }
    return len;
}

int* wstring_substring(int* str  , int head, int tail)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=wchar_tp_substring(str,head,tail))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int string_index_count(char* str, char* search_str, int count, int default_value)
{
    return charp_index_count(str,search_str,count,default_value);
}

int string_rindex(char* str, char* search_str, int default_value)
{
    return charp_rindex(str,search_str,default_value);
}

int string_rindex_count(char* str, char* search_str, int count, int default_value)
{
    return charp_rindex_count(str,search_str,count,default_value);
}

char* string_strip(char* self)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=charp_strip(self))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* wstring_to_string(int* wstr  )
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=wchar_tp_to_string(wstr))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* int_to_wstring(int self)
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    int* __result_obj__0  ;
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value1=string_to_wstring(((char*)(__right_value0=xsprintf("%d",self)))))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__right_value1 = come_decrement_ref_count(__right_value1, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* wstring_delete(int* str  , int head, int tail)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=wchar_tp_delete(str,head,tail))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int wstring_index(int* str  , int* search_str  , int default_value)
{
    return wchar_tp_index(str,search_str,default_value);
}

int wstring_rindex(int* str  , int* search_str  , int default_value)
{
    return wchar_tp_rindex(str,search_str,default_value);
}

int* wstring_reverse(int* str  )
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=wchar_tp_reverse(str))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* wstring_multiply(int* str  , int n)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=wchar_tp_multiply(str,n))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int* wstring_printable(int* str  )
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=wchar_tp_printable(str))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

unsigned int wstring_get_hash_key(int* value  )
{
    return wchar_tp_get_hash_key(value);
}

int string_index(char* str, char* search_str, int default_value)
{
    return charp_index(str,search_str,default_value);
}

char* string_replace(char* self, int index, char c)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=charp_replace(self,index,c))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* string_multiply(char* str, int n)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=charp_multiply(str,n))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

struct list$1char$ph* string_split_str(char* self, char* str)
{
    void* __right_value0 = (void*)0;
    struct list$1char$ph* __result_obj__0;
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(((struct list$1char$ph*)(__right_value0=charp_split_str(self,str))));
    come_call_finalizer(list$1char$ph$p_finalize, __right_value0, (void*)0, (void*)0, 0, 1, 0, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

int* string_to_wstring(char* str)
{
    void* __right_value0 = (void*)0;
    int* __result_obj__0  ;
    __result_obj__0 = (int*)come_increment_ref_count(((int*)(__right_value0=charp_to_wstring(str))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

char* charp_chomp(char* str)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=string_chomp(str))));
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

_Bool wchar_tp_equals(int* left  , int* right  )
{
    return wcscmp(left,right)==0;
}

_Bool wchar_tp_operator_equals(int* left  , int* right  )
{
    return wcscmp(left,right)==0;
}

_Bool wchar_tp_operator_not_equals(int* left  , int* right  )
{
    return wcscmp(left,right)!=0;
}

char* FILE_read(struct _IO_FILE* f  )
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    int size;
    if(f==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 7569, "struct buffer*"))));
    while(1) {
        char buf2[8192];
        memset(&buf2, 0, sizeof(buf2));
        size=fread(buf2,1,8192,f);
        buffer_append(buf,buf2,size);
        if(size<8192) {
            break;
        }
    }
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(buf))));
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int FILE_write(struct _IO_FILE* f  , char* str)
{
    if(f==((void*)0)||str==((void*)0)) {
        return -1;
    }
    return fwrite(str,strlen(str),1,f);
}

int FILE_fclose(struct _IO_FILE* f  )
{
    int result;
    if(f==((void*)0)) {
        return -1;
    }
    result=fclose(f);
    if(result<0) {
        return result;
    }
    return result;
}

struct _IO_FILE* FILE_fprintf(struct _IO_FILE* f  , const char* msg, ...)
{
    struct _IO_FILE* __result_obj__0  ;
    __builtin_va_list args  ;
    int result;
    if(f==((void*)0)||msg==((void*)0)) {
        __result_obj__0 = f;
        return __result_obj__0;
    }
    char msg2[1024*2*2*2];
    memset(&msg2, 0, sizeof(msg2));
    __builtin_va_start(args,msg);
    vsnprintf(msg2,1024*2*2*2,msg,args);
    __builtin_va_end(args);
    result=fprintf(f,"%s",msg2);
    if(result<0) {
        __result_obj__0 = f;
        return __result_obj__0;
    }
    __result_obj__0 = f;
    return __result_obj__0;
}

int charp_write(char* self, char* file_name, _Bool append)
{
    struct _IO_FILE* f  ;
    int result;
    int result2;
    memset(&f, 0, sizeof(f));
    if(self==((void*)0)||file_name==((void*)0)) {
        return -1;
    }
    if(append) {
        f=fopen(file_name,"a");
    }
    else {
        f=fopen(file_name,"w");
    }
    if(f==((void*)0)) {
        return -1;
    }
    result=fwrite(self,strlen(self),1,f);
    if(result!=1) {
        return result;
    }
    result2=fclose(f);
    if(result2<0) {
        return result2;
    }
    return result;
}

char* charp_read(char* file_name)
{
    void* __right_value0 = (void*)0;
    char* __result_obj__0  ;
    struct _IO_FILE* f  ;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    int size;
    char* result  ;
    int result2;
    if(file_name==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    f=fopen(file_name,"r");
    if(f==((void*)0)) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c.h", 7676, "struct buffer*"))));
    while(1) {
        char buf2[8192];
        memset(&buf2, 0, sizeof(buf2));
        size=fread(buf2,1,8192,f);
        buffer_append(buf,buf2,size);
        if(size<8192) {
            break;
        }
    }
    result=(char*)come_increment_ref_count(buffer_to_string(buf));
    result2=fclose(f);
    if(result2<0) {
        __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=__builtin_string(""))));
        come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
        (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 0, (void*)0));
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
        return __result_obj__0;
    }
    __result_obj__0 = (char*)come_increment_ref_count(result);
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (result = come_decrement_ref_count(result, (void*)0, (void*)0, 0, 1, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

struct list$1char$ph* FILE_readlines(struct _IO_FILE* f  )
{
    void* __right_value0 = (void*)0;
    void* __right_value1 = (void*)0;
    struct list$1char$ph* result;
    struct list$1char$ph* __result_obj__0;
    result=(struct list$1char$ph*)come_increment_ref_count(list$1char$ph_initialize((struct list$1char$ph*)come_increment_ref_count((struct list$1char$ph*)come_calloc(1, sizeof(struct list$1char$ph)*(1), "/usr/local/include/neo-c.h", 7703, "struct list$1char$ph*"))));
    if(f==((void*)0)) {
        __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(result);
        come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
        return __result_obj__0;
    }
    while(1) {
        char buf[8192];
        memset(&buf, 0, sizeof(buf));
        if(fgets(buf,8192,f)==((void*)0)) {
            break;
        }
        list$1char$ph_push_back(result,(char*)come_increment_ref_count(__builtin_string(buf)));
    }
    __result_obj__0 = (struct list$1char$ph*)come_increment_ref_count(result);
    come_call_finalizer(list$1char$ph$p_finalize, result, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    come_call_finalizer(list$1char$ph$p_finalize, __result_obj__0, (void*)0, (void*)0, 0, 0, 1, (void*)0);
    return __result_obj__0;
}

_Bool xiswalpha(int c  )
{
    _Bool result;
    result=(c>=97&&c<=122)||(c>=65&&c<=90);
    return result;
}

_Bool xiswblank(int c  )
{
    return c==32||c==9;
}

_Bool xiswdigit(int c  )
{
    return (c>=48&&c<=57);
}

_Bool xiswalnum(int c  )
{
    return xiswalpha(c)||xiswdigit(c);
}

_Bool xiswascii(int c  )
{
    _Bool result;
    result=(c>=32&&c<=126);
    return result;
}

int socket_fd_write(int self  , char* str  )
{
    int __result_obj__0;
    __result_obj__0 = write(self,str,string_length(str));
    (str = come_decrement_ref_count(str, (void*)0, (void*)0, 0, 0, (void*)0));
    return __result_obj__0;
}

static void sockaddr_in_finalize(struct sockaddr_in* self  )
{
}

int server_socket(int port, int socket_family, int socket_type, int protocol, _Bool reuse, void* parent, void (*block)(void*,int,_Bool*,_Bool*))
{
    int sock  ;
    _Bool __exception_result_var_b1;
    int opt;
    void* __right_value0 = (void*)0;
    _Bool __exception_result_var_b2;
    struct sockaddr_in address  ;
    int addrlen;
    _Bool __exception_result_var_b3;
    _Bool __exception_result_var_b4;
    int new_socket  ;
    _Bool reconnection;
    _Bool break_;
    int __result_obj__0;
    memset(&address, 0, sizeof(address));
    sock=socket(socket_family,socket_type,protocol);
    if(sock<0) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 32, 0),__exception_result_var_b1=die("socket failed"), come_pop_stackframe(), __exception_result_var_b1);
    }
    if(reuse) {
        opt=1;
        if(setsockopt(sock,1,2,&opt,sizeof(opt))) {
            close(sock);
            (come_push_stackframe("/usr/local/include/neo-c-net.h", 39, 1),__exception_result_var_b2=die(((char*)(__right_value0=xsprintf("setsockopt")))), come_pop_stackframe(), __exception_result_var_b2);
            (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        }
    }
    address.sin_family=2;
    address.sin_addr.s_addr=((unsigned int)0x00000000);
    address.sin_port=htons(port);
    addrlen=sizeof(address);
    if(bind(sock,(struct sockaddr*)&address,sizeof(address))<0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 53, 2),__exception_result_var_b3=die(((char*)(__right_value0=xsprintf("Unable to bind")))), come_pop_stackframe(), __exception_result_var_b3);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    if(listen(sock,3)<0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 58, 3),__exception_result_var_b4=die(((char*)(__right_value0=xsprintf("Unable to listen")))), come_pop_stackframe(), __exception_result_var_b4);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    new_socket=accept(sock,(struct sockaddr*)&address,(unsigned int*)&addrlen);
    while(1) {
        reconnection=0;
        break_=0;
        block(parent,new_socket,&break_,&reconnection);
        if(reconnection) {
            close(new_socket);
            new_socket=accept(sock,(struct sockaddr*)&address,(unsigned int*)&addrlen);
        }
        if(break_) {
            break;
        }
    }
    close(new_socket);
    close(sock);
    __result_obj__0 = 0;
    come_call_finalizer(sockaddr_in_finalize, (&address), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    return __result_obj__0;
}

int client_socket(int port, char* address, void* parent, void (*block)(void*,int,_Bool*))
{
    int sock;
    struct sockaddr_in serv_addr  ;
    void* __right_value0 = (void*)0;
    _Bool __exception_result_var_b5;
    _Bool __exception_result_var_b6;
    _Bool __exception_result_var_b7;
    _Bool break_;
    _Bool break__286;
    int __result_obj__0;
    memset(&serv_addr, 0, sizeof(serv_addr));
    sock=0;
    if((sock=socket(2,(1),0))<0) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 91, 4),__exception_result_var_b5=die(((char*)(__right_value0=xsprintf("socket")))), come_pop_stackframe(), __exception_result_var_b5);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    serv_addr.sin_family=2;
    serv_addr.sin_port=htons(port);
    if(inet_pton(2,address,&serv_addr.sin_addr)<=0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 99, 5),__exception_result_var_b6=die(((char*)(__right_value0=xsprintf("Invalid address/ Address not supported")))), come_pop_stackframe(), __exception_result_var_b6);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    if(connect(sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))<0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 103, 6),__exception_result_var_b7=die(((char*)(__right_value0=xsprintf("Connection Failed")))), come_pop_stackframe(), __exception_result_var_b7);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    break_=0;
    while(1) {
        break__286=0;
        block(parent,sock,&break__286);
        if(break__286) {
            break;
        }
    }
    close(sock);
    __result_obj__0 = 0;
    come_call_finalizer(sockaddr_in_finalize, (&serv_addr), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    return __result_obj__0;
}

char* client_socket2(int port, char* data, char* address)
{
    int sock;
    struct sockaddr_in serv_addr  ;
    void* __right_value0 = (void*)0;
    _Bool __exception_result_var_b8;
    _Bool __exception_result_var_b9;
    _Bool __exception_result_var_b10;
    _Bool __exception_result_var_b11;
    void* __right_value1 = (void*)0;
    struct buffer* buf  ;
    int size;
    _Bool __exception_result_var_b12;
    char* __result_obj__0  ;
    memset(&serv_addr, 0, sizeof(serv_addr));
    sock=0;
    if((sock=socket(2,(1),0))<0) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 128, 7),__exception_result_var_b8=die(((char*)(__right_value0=xsprintf("Socket creation error")))), come_pop_stackframe(), __exception_result_var_b8);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    serv_addr.sin_family=2;
    serv_addr.sin_port=htons(port);
    if(inet_pton(2,address,&serv_addr.sin_addr)<=0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 136, 8),__exception_result_var_b9=die(((char*)(__right_value0=xsprintf("Invalid address/ Address not supported")))), come_pop_stackframe(), __exception_result_var_b9);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    if(connect(sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))<0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 140, 9),__exception_result_var_b10=die(((char*)(__right_value0=xsprintf("Connection Failed")))), come_pop_stackframe(), __exception_result_var_b10);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    if(write(sock,data,strlen(data))<0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 145, 10),__exception_result_var_b11=die(((char*)(__right_value0=xsprintf("Write Failed")))), come_pop_stackframe(), __exception_result_var_b11);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    buf=(struct buffer*)come_increment_ref_count(buffer_initialize((struct buffer*)come_increment_ref_count((struct buffer*)come_calloc(1, sizeof(struct buffer)*(1), "/usr/local/include/neo-c-net.h", 148, "struct buffer*"))));
    char buf2[1024]={ '\0' };
    size=read(sock,buf2,1024);
    if(size<0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 156, 11),__exception_result_var_b12=die(((char*)(__right_value0=xsprintf("Read Failed")))), come_pop_stackframe(), __exception_result_var_b12);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    buffer_append(buf,buf2,size);
    close(sock);
    __result_obj__0 = (char*)come_increment_ref_count(((char*)(__right_value0=buffer_to_string(buf))));
    come_call_finalizer(sockaddr_in_finalize, (&serv_addr), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    come_call_finalizer(buffer_finalize, buf, (void*)0, (void*)0, 0, 0, 0, (void*)0);
    (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    (__result_obj__0 = come_decrement_ref_count(__result_obj__0, (void*)0, (void*)0, 0, 1, (void*)0));
    return __result_obj__0;
}

int httpd_socket(int port, int socket_family, int socket_type, int protocol, _Bool reuse, void* parent, void (*block)(void*,int,_Bool*))
{
    int sock  ;
    _Bool __exception_result_var_b13;
    int opt;
    void* __right_value0 = (void*)0;
    _Bool __exception_result_var_b14;
    struct sockaddr_in address  ;
    int addrlen;
    _Bool __exception_result_var_b15;
    _Bool __exception_result_var_b16;
    int new_socket  ;
    _Bool break_;
    int __result_obj__0;
    memset(&address, 0, sizeof(address));
    sock=socket(socket_family,socket_type,protocol);
    if(sock<0) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 169, 12),__exception_result_var_b13=die("socket failed"), come_pop_stackframe(), __exception_result_var_b13);
    }
    if(reuse) {
        opt=1;
        if(setsockopt(sock,1,2,&opt,sizeof(opt))) {
            close(sock);
            (come_push_stackframe("/usr/local/include/neo-c-net.h", 176, 13),__exception_result_var_b14=die(((char*)(__right_value0=xsprintf("setsockpt failed")))), come_pop_stackframe(), __exception_result_var_b14);
            (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        }
    }
    address.sin_family=2;
    address.sin_addr.s_addr=((unsigned int)0x00000000);
    address.sin_port=htons(port);
    addrlen=sizeof(address);
    if(bind(sock,(struct sockaddr*)&address,sizeof(address))<0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 190, 14),__exception_result_var_b15=die(((char*)(__right_value0=xsprintf("Unable to bind")))), come_pop_stackframe(), __exception_result_var_b15);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    if(listen(sock,3)<0) {
        close(sock);
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 195, 15),__exception_result_var_b16=die(((char*)(__right_value0=xsprintf("Unable to listen")))), come_pop_stackframe(), __exception_result_var_b16);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    while(1) {
        new_socket=accept(sock,(struct sockaddr*)&address,(unsigned int*)&addrlen);
        break_=0;
        block(parent,new_socket,&break_);
        close(new_socket);
        if(break_) {
            break;
        }
    }
    close(sock);
    __result_obj__0 = 0;
    come_call_finalizer(sockaddr_in_finalize, (&address), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    return __result_obj__0;
}

void ERR_print_errors_fp(struct _IO_FILE* f  )
{
}

int httpsd_socket(int port, _Bool reuse, void* parent, void (*block)(void*,struct ssl_st*,_Bool*))
{
    int sock;
    struct ssl_ctx_st* ctx  ;
    const struct ssl_method_st* method  ;
    void* __right_value0 = (void*)0;
    _Bool __exception_result_var_b17;
    _Bool __exception_result_var_b18;
    _Bool __exception_result_var_b19;
    _Bool __exception_result_var_b20;
    struct sockaddr_in addr  ;
    _Bool __exception_result_var_b21;
    _Bool __exception_result_var_b22;
    struct sockaddr_in addr_287  ;
    unsigned int len  ;
    int client;
    _Bool __exception_result_var_b23;
    struct ssl_st* ssl  ;
    _Bool break_;
    int __result_obj__0;
    memset(&sock, 0, sizeof(sock));
    memset(&ctx, 0, sizeof(ctx));
    memset(&method, 0, sizeof(method));
    memset(&addr, 0, sizeof(addr));
    memset(&addr_287, 0, sizeof(addr_287));
    OPENSSL_init_ssl(0x00200000L|0x00000002L,((void*)0));
    OPENSSL_init_ssl(0,((void*)0));
    method=TLS_server_method();
    ctx=SSL_CTX_new(method);
    if(!ctx) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 241, 16),__exception_result_var_b17=die(((char*)(__right_value0=xsprintf("Unable to create SSL context")))), come_pop_stackframe(), __exception_result_var_b17);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    if(SSL_CTX_use_certificate_file(ctx,"cert.pem",1)<=0) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 246, 17),__exception_result_var_b18=die(((char*)(__right_value0=xsprintf("SSL_CTX_use_certificate_file")))), come_pop_stackframe(), __exception_result_var_b18);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    if(SSL_CTX_use_PrivateKey_file(ctx,"key.pem",1)<=0) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 251, 18),__exception_result_var_b19=die(((char*)(__right_value0=xsprintf("SSL_CTX_use_PrivateKey_file")))), come_pop_stackframe(), __exception_result_var_b19);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    sock=socket(2,(1),0);
    if(sock<0) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 256, 19),__exception_result_var_b20=die(((char*)(__right_value0=xsprintf("Unable to create socket")))), come_pop_stackframe(), __exception_result_var_b20);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    addr.sin_family=2;
    addr.sin_port=htons(port);
    addr.sin_addr.s_addr=((unsigned int)0x00000000);
    if(bind(sock,(struct sockaddr*)&addr,sizeof(addr))<0) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 265, 20),__exception_result_var_b21=die(((char*)(__right_value0=xsprintf("Unable to bind")))), come_pop_stackframe(), __exception_result_var_b21);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    if(listen(sock,1)<0) {
        (come_push_stackframe("/usr/local/include/neo-c-net.h", 269, 21),__exception_result_var_b22=die(((char*)(__right_value0=xsprintf("Unable to listen")))), come_pop_stackframe(), __exception_result_var_b22);
        (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
    }
    while(1) {
        len=sizeof(addr_287);
        client=accept(sock,(struct sockaddr*)&addr_287,&len);
        if(client<0) {
            (come_push_stackframe("/usr/local/include/neo-c-net.h", 278, 22),__exception_result_var_b23=die(((char*)(__right_value0=xsprintf("Unable to accept")))), come_pop_stackframe(), __exception_result_var_b23);
            (__right_value0 = come_decrement_ref_count(__right_value0, (void*)0, (void*)0, 1, 0, (void*)0));
        }
        ssl=SSL_new(ctx);
        SSL_set_fd(ssl,client);
        if(SSL_accept(ssl)<=0) {
            ERR_print_errors_fp(stdout);
        }
        else {
            break_=0;
            block(parent,ssl,&break_);
            if(break_) {
                come_call_finalizer(sockaddr_in_finalize, (&addr_287), (void*)0, (void*)0, 1, 0, 0, (void*)0);
                break;
            }
        }
        SSL_shutdown(ssl);
        SSL_free(ssl);
        close(client);
        come_call_finalizer(sockaddr_in_finalize, (&addr_287), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    }
    close(sock);
    SSL_CTX_free(ctx);
    while(0) {
        continue;
    }
    __result_obj__0 = 0;
    come_call_finalizer(sockaddr_in_finalize, (&addr), (void*)0, (void*)0, 1, 0, 0, (void*)0);
    return __result_obj__0;
}

