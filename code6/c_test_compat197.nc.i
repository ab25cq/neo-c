#line 1 "../code6/c_test_compat197.nc"
// C11 preprocessor diagnostic: GNU linemarker trailing non-numeric flag is invalid.
#line 1 "/usr/local/include/neo-c.h"
#line 3 "/usr/local/include/neo-c.h"

#line 6 "/usr/local/include/neo-c.h"

#line 8 "/usr/local/include/neo-c.h"

#line 14 "/usr/local/include/neo-c.h"

#line 16 "/usr/local/include/neo-c.h"

#line 18 "/usr/local/include/neo-c.h"

#line 20 "/usr/local/include/neo-c.h"
typedef char*% string;

#line 30 "/usr/local/include/neo-c.h"





#line 87 "/usr/local/include/neo-c.h"
    using C;
    
#line 1 "/usr/include/stdio.h"























#line 26 "/usr/include/stdio.h"

#line 1 "/usr/include/bits/libc-header-start.h"


























#line 30 "/usr/include/bits/libc-header-start.h"

#line 32 "/usr/include/bits/libc-header-start.h"

#line 1 "/usr/include/features.h"

















#line 20 "/usr/include/features.h"













































































































#line 158 "/usr/include/features.h"



#line 164 "/usr/include/features.h"








#line 177 "/usr/include/features.h"





#line 187 "/usr/include/features.h"


#line 190 "/usr/include/features.h"





#line 200 "/usr/include/features.h"


#line 207 "/usr/include/features.h"


#line 237 "/usr/include/features.h"



#line 244 "/usr/include/features.h"


#line 251 "/usr/include/features.h"


#line 258 "/usr/include/features.h"


#line 263 "/usr/include/features.h"


#line 268 "/usr/include/features.h"


#line 273 "/usr/include/features.h"

#line 286 "/usr/include/features.h"




#line 299 "/usr/include/features.h"

#line 313 "/usr/include/features.h"







#line 325 "/usr/include/features.h"

#line 329 "/usr/include/features.h"

#line 333 "/usr/include/features.h"

#line 337 "/usr/include/features.h"

#line 341 "/usr/include/features.h"

#line 349 "/usr/include/features.h"

#line 355 "/usr/include/features.h"

#line 381 "/usr/include/features.h"

#line 385 "/usr/include/features.h"

#line 389 "/usr/include/features.h"

#line 393 "/usr/include/features.h"

#line 1 "/usr/include/features-time64.h"



















#line 1 "/usr/include/bits/wordsize.h"


#line 10 "/usr/include/bits/wordsize.h"

#line 12 "/usr/include/bits/wordsize.h"

#line 14 "/usr/include/bits/wordsize.h"
#line 21 "/usr/include/features-time64.h"
#line 1 "/usr/include/bits/timesize.h"


















#line 1 "/usr/include/bits/wordsize.h"


#line 10 "/usr/include/bits/wordsize.h"

#line 12 "/usr/include/bits/wordsize.h"

#line 14 "/usr/include/bits/wordsize.h"
#line 20 "/usr/include/bits/timesize.h"

#line 25 "/usr/include/bits/timesize.h"
#line 22 "/usr/include/features-time64.h"

#line 39 "/usr/include/features-time64.h"
#line 395 "/usr/include/features.h"

#line 399 "/usr/include/features.h"

#line 403 "/usr/include/features.h"

#line 407 "/usr/include/features.h"

#line 411 "/usr/include/features.h"

#line 435 "/usr/include/features.h"





#line 445 "/usr/include/features.h"













#line 463 "/usr/include/features.h"






#line 474 "/usr/include/features.h"



#line 1 "/usr/include/stdc-predef.h"

















#line 20 "/usr/include/stdc-predef.h"
















#line 45 "/usr/include/stdc-predef.h"

#line 55 "/usr/include/stdc-predef.h"







#line 63 "/usr/include/stdc-predef.h"
#line 478 "/usr/include/features.h"







#line 487 "/usr/include/features.h"



#line 492 "/usr/include/features.h"

#line 494 "/usr/include/features.h"


#line 1 "/usr/include/sys/cdefs.h"


















#line 21 "/usr/include/sys/cdefs.h"


#line 26 "/usr/include/sys/cdefs.h"




#line 33 "/usr/include/sys/cdefs.h"


#line 37 "/usr/include/sys/cdefs.h"





#line 57 "/usr/include/sys/cdefs.h"

#line 59 "/usr/include/sys/cdefs.h"



#line 69 "/usr/include/sys/cdefs.h"






#line 97 "/usr/include/sys/cdefs.h"

#line 103 "/usr/include/sys/cdefs.h"

#line 118 "/usr/include/sys/cdefs.h"



#line 123 "/usr/include/sys/cdefs.h"




#line 129 "/usr/include/sys/cdefs.h"


#line 132 "/usr/include/sys/cdefs.h"



#line 142 "/usr/include/sys/cdefs.h"



#line 150 "/usr/include/sys/cdefs.h"


#line 154 "/usr/include/sys/cdefs.h"


#line 163 "/usr/include/sys/cdefs.h"

#line 286 "/usr/include/sys/cdefs.h"

#line 294 "/usr/include/sys/cdefs.h"





#line 317 "/usr/include/sys/cdefs.h"












#line 330 "/usr/include/sys/cdefs.h"

#line 341 "/usr/include/sys/cdefs.h"

#line 345 "/usr/include/sys/cdefs.h"

#line 349 "/usr/include/sys/cdefs.h"






#line 356 "/usr/include/sys/cdefs.h"




#line 363 "/usr/include/sys/cdefs.h"




#line 372 "/usr/include/sys/cdefs.h"



#line 380 "/usr/include/sys/cdefs.h"



#line 388 "/usr/include/sys/cdefs.h"




#line 397 "/usr/include/sys/cdefs.h"


#line 404 "/usr/include/sys/cdefs.h"

#line 410 "/usr/include/sys/cdefs.h"




#line 421 "/usr/include/sys/cdefs.h"


#line 428 "/usr/include/sys/cdefs.h"




#line 437 "/usr/include/sys/cdefs.h"







#line 449 "/usr/include/sys/cdefs.h"





#line 459 "/usr/include/sys/cdefs.h"





#line 474 "/usr/include/sys/cdefs.h"



#line 484 "/usr/include/sys/cdefs.h"



#line 498 "/usr/include/sys/cdefs.h"


#line 501 "/usr/include/sys/cdefs.h"



#line 510 "/usr/include/sys/cdefs.h"



#line 518 "/usr/include/sys/cdefs.h"










#line 537 "/usr/include/sys/cdefs.h"

#line 541 "/usr/include/sys/cdefs.h"



#line 548 "/usr/include/sys/cdefs.h"





#line 556 "/usr/include/sys/cdefs.h"




#line 567 "/usr/include/sys/cdefs.h"





#line 586 "/usr/include/sys/cdefs.h"

#line 594 "/usr/include/sys/cdefs.h"

#line 602 "/usr/include/sys/cdefs.h"

#line 611 "/usr/include/sys/cdefs.h"


#line 621 "/usr/include/sys/cdefs.h"

#line 625 "/usr/include/sys/cdefs.h"



#line 1 "/usr/include/bits/wordsize.h"


#line 10 "/usr/include/bits/wordsize.h"

#line 12 "/usr/include/bits/wordsize.h"

#line 14 "/usr/include/bits/wordsize.h"
#line 630 "/usr/include/sys/cdefs.h"
#line 1 "/usr/include/bits/long-double.h"



















#line 631 "/usr/include/sys/cdefs.h"
#line 632 "/usr/include/sys/cdefs.h"

#line 683 "/usr/include/sys/cdefs.h"






#line 695 "/usr/include/sys/cdefs.h"








#line 708 "/usr/include/sys/cdefs.h"

#line 735 "/usr/include/sys/cdefs.h"

#line 745 "/usr/include/sys/cdefs.h"



#line 753 "/usr/include/sys/cdefs.h"




#line 762 "/usr/include/sys/cdefs.h"
#line 499 "/usr/include/features.h"
#line 500 "/usr/include/features.h"



#line 507 "/usr/include/features.h"

#line 509 "/usr/include/features.h"


#line 514 "/usr/include/features.h"






#line 1 "/usr/include/gnu/stubs.h"





#line 1 "/usr/include/gnu/stubs-64.h"





#line 9 "/usr/include/gnu/stubs-64.h"
#line 11 "/usr/include/gnu/stubs.h"
#line 521 "/usr/include/features.h"

#line 34 "/usr/include/bits/libc-header-start.h"



#line 43 "/usr/include/bits/libc-header-start.h"























#line 84 "/usr/include/bits/libc-header-start.h"





#line 101 "/usr/include/bits/libc-header-start.h"


#line 29 "/usr/include/stdio.h"



#line 1 "/usr/lib/clang/21/include/stddef.h"





















#line 37 "/usr/lib/clang/21/include/stddef.h"

#line 80 "/usr/lib/clang/21/include/stddef.h"

#line 85 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_size_t.h"













#line 16 "/usr/lib/clang/21/include/__stddef_size_t.h"

typedef unsigned long size_t;
#line 88 "/usr/lib/clang/21/include/stddef.h"
#line 90 "/usr/lib/clang/21/include/stddef.h"

#line 95 "/usr/lib/clang/21/include/stddef.h"

#line 100 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_null.h"









#line 11 "/usr/lib/clang/21/include/__stddef_null.h"






#line 18 "/usr/lib/clang/21/include/__stddef_null.h"

#line 28 "/usr/lib/clang/21/include/__stddef_null.h"
#line 103 "/usr/lib/clang/21/include/stddef.h"
#line 105 "/usr/lib/clang/21/include/stddef.h"

#line 110 "/usr/lib/clang/21/include/stddef.h"

#line 115 "/usr/lib/clang/21/include/stddef.h"

#line 120 "/usr/lib/clang/21/include/stddef.h"

#line 125 "/usr/lib/clang/21/include/stddef.h"



#line 132 "/usr/lib/clang/21/include/stddef.h"
#line 35 "/usr/include/stdio.h"

#line 1 "/usr/lib/clang/21/include/stdarg.h"





















#line 45 "/usr/lib/clang/21/include/stdarg.h"

#line 1 "/usr/lib/clang/21/include/__stdarg___gnuc_va_list.h"









#line 12 "/usr/lib/clang/21/include/__stdarg___gnuc_va_list.h"
typedef __builtin_va_list __gnuc_va_list;
#line 48 "/usr/lib/clang/21/include/stdarg.h"
#line 50 "/usr/lib/clang/21/include/stdarg.h"

#line 55 "/usr/lib/clang/21/include/stdarg.h"

#line 60 "/usr/lib/clang/21/include/stdarg.h"

#line 65 "/usr/lib/clang/21/include/stdarg.h"

#line 70 "/usr/lib/clang/21/include/stdarg.h"
#line 38 "/usr/include/stdio.h"

#line 1 "/usr/include/bits/types.h"






















#line 25 "/usr/include/bits/types.h"

#line 1 "/usr/include/features.h"
















#line 27 "/usr/include/bits/types.h"
#line 1 "/usr/include/bits/wordsize.h"


#line 10 "/usr/include/bits/wordsize.h"

#line 12 "/usr/include/bits/wordsize.h"

#line 14 "/usr/include/bits/wordsize.h"
#line 28 "/usr/include/bits/types.h"
#line 1 "/usr/include/bits/timesize.h"


















#line 1 "/usr/include/bits/wordsize.h"


#line 10 "/usr/include/bits/wordsize.h"

#line 12 "/usr/include/bits/wordsize.h"

#line 14 "/usr/include/bits/wordsize.h"
#line 20 "/usr/include/bits/timesize.h"

#line 25 "/usr/include/bits/timesize.h"
#line 29 "/usr/include/bits/types.h"


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
#line 44 "/usr/include/bits/types.h"
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
#line 50 "/usr/include/bits/types.h"


typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;


#line 63 "/usr/include/bits/types.h"
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
#line 69 "/usr/include/bits/types.h"


#line 72 "/usr/include/bits/types.h"
typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
#line 78 "/usr/include/bits/types.h"































#line 136 "/usr/include/bits/types.h"

#line 1 "/usr/include/bits/typesizes.h"


















#line 22 "/usr/include/bits/typesizes.h"

#line 25 "/usr/include/bits/typesizes.h"





#line 37 "/usr/include/bits/typesizes.h"

#line 76 "/usr/include/bits/typesizes.h"

#line 78 "/usr/include/bits/typesizes.h"



#line 82 "/usr/include/bits/typesizes.h"


#line 85 "/usr/include/bits/typesizes.h"


#line 88 "/usr/include/bits/typesizes.h"


#line 91 "/usr/include/bits/typesizes.h"


#line 101 "/usr/include/bits/typesizes.h"


#line 104 "/usr/include/bits/typesizes.h"

#line 142 "/usr/include/bits/types.h"
#line 1 "/usr/include/bits/time64.h"


















#line 22 "/usr/include/bits/time64.h"

#line 25 "/usr/include/bits/time64.h"



#line 29 "/usr/include/bits/time64.h"

#line 35 "/usr/include/bits/time64.h"
#line 143 "/usr/include/bits/types.h"


typedef unsigned long int __dev_t;	
typedef unsigned int __uid_t;	
typedef unsigned int __gid_t;	
typedef unsigned long int __ino_t;	
typedef unsigned long int __ino64_t;	
typedef unsigned int __mode_t;	
typedef unsigned long int __nlink_t;	
typedef long int __off_t;	
typedef long int __off64_t;	
typedef int __pid_t;	
typedef struct __fsid_t { int __val[2]; } __fsid_t;	
typedef long int __clock_t;	
typedef unsigned long int __rlim_t;	
typedef unsigned long int __rlim64_t;	
typedef unsigned int __id_t;		
typedef long int __time_t;	
typedef unsigned int __useconds_t; 
typedef long int __suseconds_t; 
typedef long int __suseconds64_t;

typedef int __daddr_t;	
typedef int __key_t;	


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t; 


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;	
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;




#line 225 "/usr/include/bits/types.h"

#line 227 "/usr/include/bits/types.h"
#line 40 "/usr/include/stdio.h"
#line 1 "/usr/include/bits/types/__fpos_t.h"
#line 3 "/usr/include/bits/types/__fpos_t.h"

#line 1 "/usr/include/bits/types.h"





















#line 5 "/usr/include/bits/types/__fpos_t.h"
#line 1 "/usr/include/bits/types/__mbstate_t.h"
#line 3 "/usr/include/bits/types/__mbstate_t.h"





#line 11 "/usr/include/bits/types/__mbstate_t.h"


typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;		
} __mbstate_t;
#line 6 "/usr/include/bits/types/__fpos_t.h"




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
#line 41 "/usr/include/stdio.h"
#line 1 "/usr/include/bits/types/__fpos64_t.h"
#line 3 "/usr/include/bits/types/__fpos64_t.h"

#line 1 "/usr/include/bits/types.h"





















#line 5 "/usr/include/bits/types/__fpos64_t.h"
#line 1 "/usr/include/bits/types/__mbstate_t.h"
#line 6 "/usr/include/bits/types/__fpos64_t.h"




typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
#line 42 "/usr/include/stdio.h"
#line 1 "/usr/include/bits/types/__FILE.h"
#line 3 "/usr/include/bits/types/__FILE.h"

struct _IO_FILE;
typedef struct _IO_FILE __FILE;
#line 43 "/usr/include/stdio.h"
#line 1 "/usr/include/bits/types/FILE.h"
#line 3 "/usr/include/bits/types/FILE.h"

struct _IO_FILE;


typedef struct _IO_FILE FILE;
#line 44 "/usr/include/stdio.h"
#line 1 "/usr/include/bits/types/struct_FILE.h"


















#line 21 "/usr/include/bits/types/struct_FILE.h"





#line 29 "/usr/include/bits/types/struct_FILE.h"

#line 33 "/usr/include/bits/types/struct_FILE.h"

#line 1 "/usr/include/bits/types.h"





















#line 35 "/usr/include/bits/types/struct_FILE.h"
#line 1 "/usr/include/bits/wordsize.h"


#line 10 "/usr/include/bits/wordsize.h"

#line 12 "/usr/include/bits/wordsize.h"

#line 14 "/usr/include/bits/wordsize.h"
#line 36 "/usr/include/bits/types/struct_FILE.h"

struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;



#line 45 "/usr/include/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 47 "/usr/include/bits/types/struct_FILE.h"




struct _IO_FILE
{
  int _flags;		

  
  char *_IO_read_ptr;	
  char *_IO_read_end;	
  char *_IO_read_base;	
  char *_IO_write_base;	
  char *_IO_write_ptr;	
  char *_IO_write_end;	
  char *_IO_buf_base;	
  char *_IO_buf_end;	

  
  char *_IO_save_base; 
  char *_IO_backup_base;  
  char *_IO_save_end; 

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2:24;
  
  char _short_backupbuf[1];
  __off_t _old_offset; 

  
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;
#line 93 "/usr/include/bits/types/struct_FILE.h"
  __off64_t _offset;
  
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  struct _IO_FILE **_prevchain;
  int _mode;
#line 102 "/usr/include/bits/types/struct_FILE.h"
  int _unused3;
#line 104 "/usr/include/bits/types/struct_FILE.h"
  __uint64_t _total_written;
#line 108 "/usr/include/bits/types/struct_FILE.h"
  
  char _unused2[12 * sizeof (int) - 5 * sizeof (void *)];
};


#line 114 "/usr/include/bits/types/struct_FILE.h"

#line 116 "/usr/include/bits/types/struct_FILE.h"

#line 119 "/usr/include/bits/types/struct_FILE.h"

#line 122 "/usr/include/bits/types/struct_FILE.h"

#line 124 "/usr/include/bits/types/struct_FILE.h"

#line 45 "/usr/include/stdio.h"

#line 1 "/usr/include/bits/types/cookie_io_functions_t.h"

















#line 20 "/usr/include/bits/types/cookie_io_functions_t.h"

#line 1 "/usr/include/bits/types.h"





















#line 22 "/usr/include/bits/types/cookie_io_functions_t.h"





typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;		
  cookie_write_function_t *write;	
  cookie_seek_function_t *seek;		
  cookie_close_function_t *close;	
} cookie_io_functions_t;
#line 48 "/usr/include/stdio.h"
#line 49 "/usr/include/stdio.h"

#line 53 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 60 "/usr/include/stdio.h"

#line 64 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 71 "/usr/include/stdio.h"
typedef __off64_t off64_t;
#line 75 "/usr/include/stdio.h"

#line 78 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 82 "/usr/include/stdio.h"


#line 85 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 90 "/usr/include/stdio.h"
typedef __fpos64_t fpos64_t;
#line 92 "/usr/include/stdio.h"


#line 97 "/usr/include/stdio.h"



#line 101 "/usr/include/stdio.h"




#line 106 "/usr/include/stdio.h"




#line 117 "/usr/include/stdio.h"


#line 120 "/usr/include/stdio.h"

#line 123 "/usr/include/stdio.h"

#line 126 "/usr/include/stdio.h"



#line 1 "/usr/include/bits/stdio_lim.h"


















#line 21 "/usr/include/bits/stdio_lim.h"

#line 25 "/usr/include/bits/stdio_lim.h"

#line 27 "/usr/include/bits/stdio_lim.h"
#line 130 "/usr/include/stdio.h"

#line 137 "/usr/include/stdio.h"

#line 140 "/usr/include/stdio.h"


#line 143 "/usr/include/stdio.h"

#line 146 "/usr/include/stdio.h"



extern FILE *stdin;		
extern FILE *stdout;		
extern FILE *stderr;		

#line 156 "/usr/include/stdio.h"


extern int remove (const char *__filename) ;

extern int rename (const char *__old, const char *__new) ;

#line 163 "/usr/include/stdio.h"

extern int renameat (int __oldfd, const char *__old, int __newfd,
		     const char *__new) ;
#line 167 "/usr/include/stdio.h"

#line 169 "/usr/include/stdio.h"

#line 176 "/usr/include/stdio.h"



extern int renameat2 (int __oldfd, const char *__old, int __newfd,
		      const char *__new, unsigned int __flags) ;
#line 182 "/usr/include/stdio.h"





extern int fclose (FILE *__stream) ;

#line 191 "/usr/include/stdio.h"





#line 197 "/usr/include/stdio.h"
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__))  ;
#line 207 "/usr/include/stdio.h"

#line 209 "/usr/include/stdio.h"
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__))  ;
#line 212 "/usr/include/stdio.h"


extern char *tmpnam (char[20])  ;

#line 217 "/usr/include/stdio.h"


extern char *tmpnam_r (char __s[20])  ;
#line 221 "/usr/include/stdio.h"


#line 224 "/usr/include/stdio.h"







extern char *tempnam (const char *__dir, const char *__pfx)
    __attribute__ ((__malloc__))  ;
#line 234 "/usr/include/stdio.h"





extern int fflush (FILE *__stream);

#line 242 "/usr/include/stdio.h"






extern int fflush_unlocked (FILE *__stream);
#line 250 "/usr/include/stdio.h"

#line 252 "/usr/include/stdio.h"






extern int fcloseall (void);
#line 260 "/usr/include/stdio.h"


#line 263 "/usr/include/stdio.h"




extern FILE *fopen (const char *__restrict __filename,
		    const char *__restrict __modes)
  __attribute__ ((__malloc__))  ;




extern FILE *freopen (const char *__restrict __filename,
		      const char *__restrict __modes,
		      FILE *__restrict __stream)  ;
#line 292 "/usr/include/stdio.h"
extern FILE *fopen64 (const char *__restrict __filename,
		      const char *__restrict __modes)
  __attribute__ ((__malloc__))  ;
extern FILE *freopen64 (const char *__restrict __filename,
			const char *__restrict __modes,
			FILE *__restrict __stream)  ;
#line 299 "/usr/include/stdio.h"

#line 301 "/usr/include/stdio.h"

extern FILE *fdopen (int __fd, const char *__modes) 
  __attribute__ ((__malloc__))  ;
#line 305 "/usr/include/stdio.h"

#line 307 "/usr/include/stdio.h"


extern FILE *fopencookie (void *__restrict __magic_cookie,
			  const char *__restrict __modes,
			  cookie_io_functions_t __io_funcs) 
  __attribute__ ((__malloc__))  ;
#line 314 "/usr/include/stdio.h"

#line 316 "/usr/include/stdio.h"

extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
   __attribute__ ((__malloc__))  ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) 
  __attribute__ ((__malloc__))  ;

#line 334 "/usr/include/stdio.h"



extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) 
  ;



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
		    int __modes, size_t __n)  ;

#line 346 "/usr/include/stdio.h"


extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
		       size_t __size)  ;


extern void setlinebuf (FILE *__stream)  ;
#line 354 "/usr/include/stdio.h"






extern int fprintf (FILE *__restrict __stream,
		    const char *__restrict __format, ...) ;




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
		    const char *__restrict __format, ...) ;





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
		     __gnuc_va_list __arg) ;




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
		     __gnuc_va_list __arg) ;

#line 387 "/usr/include/stdio.h"

extern int snprintf (char *__restrict __s, size_t __maxlen,
		     const char *__restrict __format, ...)
      __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
		      const char *__restrict __format, __gnuc_va_list __arg)
      __attribute__ ((__format__ (__printf__, 3, 0)));
#line 396 "/usr/include/stdio.h"

#line 398 "/usr/include/stdio.h"


extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
		      __gnuc_va_list __arg)
      __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
		       const char *__restrict __fmt, ...)
      __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
		     const char *__restrict __fmt, ...)
      __attribute__ ((__format__ (__printf__, 2, 3))) ;
#line 410 "/usr/include/stdio.h"

#line 412 "/usr/include/stdio.h"

extern int vdprintf (int __fd, const char *__restrict __fmt,
		     __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
#line 419 "/usr/include/stdio.h"






extern int fscanf (FILE *__restrict __stream,
		   const char *__restrict __format, ...)  ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
		   const char *__restrict __format, ...) ;





#line 1 "/usr/include/bits/floatn.h"


















#line 21 "/usr/include/bits/floatn.h"

#line 1 "/usr/include/features.h"
















#line 23 "/usr/include/bits/floatn.h"








#line 36 "/usr/include/bits/floatn.h"



#line 44 "/usr/include/bits/floatn.h"




#line 49 "/usr/include/bits/floatn.h"





#line 55 "/usr/include/bits/floatn.h"

#line 57 "/usr/include/bits/floatn.h"



#line 68 "/usr/include/bits/floatn.h"


#line 80 "/usr/include/bits/floatn.h"


#line 117 "/usr/include/bits/floatn.h"

#line 119 "/usr/include/bits/floatn.h"

#line 1 "/usr/include/bits/floatn-common.h"



















#line 22 "/usr/include/bits/floatn-common.h"

#line 1 "/usr/include/features.h"
















#line 24 "/usr/include/bits/floatn-common.h"
#line 1 "/usr/include/bits/long-double.h"



















#line 25 "/usr/include/bits/floatn-common.h"









#line 39 "/usr/include/bits/floatn-common.h"













#line 58 "/usr/include/bits/floatn-common.h"





#line 64 "/usr/include/bits/floatn-common.h"




#line 73 "/usr/include/bits/floatn-common.h"

#line 75 "/usr/include/bits/floatn-common.h"




#line 87 "/usr/include/bits/floatn-common.h"

#line 95 "/usr/include/bits/floatn-common.h"

#line 107 "/usr/include/bits/floatn-common.h"

#line 115 "/usr/include/bits/floatn-common.h"

#line 127 "/usr/include/bits/floatn-common.h"

#line 135 "/usr/include/bits/floatn-common.h"


#line 145 "/usr/include/bits/floatn-common.h"

#line 153 "/usr/include/bits/floatn-common.h"

#line 165 "/usr/include/bits/floatn-common.h"

#line 173 "/usr/include/bits/floatn-common.h"

#line 185 "/usr/include/bits/floatn-common.h"

#line 193 "/usr/include/bits/floatn-common.h"


#line 209 "/usr/include/bits/floatn-common.h"

#line 211 "/usr/include/bits/floatn-common.h"

#line 213 "/usr/include/bits/floatn-common.h"
typedef float _Float32;
#line 215 "/usr/include/bits/floatn-common.h"

#line 222 "/usr/include/bits/floatn-common.h"

#line 224 "/usr/include/bits/floatn-common.h"

#line 226 "/usr/include/bits/floatn-common.h"








#line 248 "/usr/include/bits/floatn-common.h"

#line 250 "/usr/include/bits/floatn-common.h"
typedef double _Float64;
#line 252 "/usr/include/bits/floatn-common.h"

#line 259 "/usr/include/bits/floatn-common.h"

#line 261 "/usr/include/bits/floatn-common.h"

#line 263 "/usr/include/bits/floatn-common.h"

#line 265 "/usr/include/bits/floatn-common.h"

#line 267 "/usr/include/bits/floatn-common.h"
typedef double _Float32x;
#line 269 "/usr/include/bits/floatn-common.h"

#line 276 "/usr/include/bits/floatn-common.h"

#line 278 "/usr/include/bits/floatn-common.h"

#line 280 "/usr/include/bits/floatn-common.h"

#line 282 "/usr/include/bits/floatn-common.h"

#line 284 "/usr/include/bits/floatn-common.h"
typedef long double _Float64x;
#line 286 "/usr/include/bits/floatn-common.h"

#line 293 "/usr/include/bits/floatn-common.h"

#line 308 "/usr/include/bits/floatn-common.h"

#line 310 "/usr/include/bits/floatn-common.h"

#line 325 "/usr/include/bits/floatn-common.h"

#line 327 "/usr/include/bits/floatn-common.h"
#line 121 "/usr/include/bits/floatn.h"
#line 441 "/usr/include/stdio.h"
#line 453 "/usr/include/stdio.h"
extern int __isoc23_fscanf (FILE *__restrict __stream,
			    const char *__restrict __format, ...) 
  ;
extern int __isoc23_scanf (const char *__restrict __format, ...) ;
extern int __isoc23_sscanf (const char *__restrict __s,
			    const char *__restrict __format, ...) ;
#line 486 "/usr/include/stdio.h"

#line 488 "/usr/include/stdio.h"




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
		    __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0)))  ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
		    const char *__restrict __format, __gnuc_va_list __arg)
      __attribute__ ((__format__ (__scanf__, 2, 0)));


#line 526 "/usr/include/stdio.h"
extern int __isoc23_vfscanf (FILE *__restrict __s,
			     const char *__restrict __format,
			     __gnuc_va_list __arg)  ;
extern int __isoc23_vscanf (const char *__restrict __format,
			    __gnuc_va_list __arg) ;
extern int __isoc23_vsscanf (const char *__restrict __s,
			     const char *__restrict __format,
			     __gnuc_va_list __arg) ;
#line 569 "/usr/include/stdio.h"






extern int fgetc (FILE *__stream) ;
extern int getc (FILE *__stream) ;





extern int getchar (void);

#line 585 "/usr/include/stdio.h"




extern int getc_unlocked (FILE *__stream) ;
extern int getchar_unlocked (void);
#line 592 "/usr/include/stdio.h"

#line 594 "/usr/include/stdio.h"






extern int fgetc_unlocked (FILE *__stream) ;
#line 602 "/usr/include/stdio.h"






extern int fputc (int __c, FILE *__stream) ;
extern int putc (int __c, FILE *__stream) ;





extern int putchar (int __c);

#line 618 "/usr/include/stdio.h"






extern int fputc_unlocked (int __c, FILE *__stream) ;
#line 626 "/usr/include/stdio.h"

#line 628 "/usr/include/stdio.h"




extern int putc_unlocked (int __c, FILE *__stream) ;
extern int putchar_unlocked (int __c);
#line 635 "/usr/include/stdio.h"


#line 638 "/usr/include/stdio.h"

extern int getw (FILE *__stream) ;


extern int putw (int __w, FILE *__stream) ;
#line 644 "/usr/include/stdio.h"






extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
       ;

#line 665 "/usr/include/stdio.h"

#line 667 "/usr/include/stdio.h"






extern char *fgets_unlocked (char *__restrict __s, int __n,
			     FILE *__restrict __stream) 
     ;
#line 677 "/usr/include/stdio.h"


#line 680 "/usr/include/stdio.h"





extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream)  ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream)  ;


extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream)  ;
#line 697 "/usr/include/stdio.h"






extern int fputs (const char *__restrict __s, FILE *__restrict __stream)
  ;





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream) ;






extern size_t fread (void *__restrict __ptr, size_t __size,
		     size_t __n, FILE *__restrict __stream) 
  ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
		      size_t __n, FILE *__restrict __s) ;

#line 735 "/usr/include/stdio.h"






extern int fputs_unlocked (const char *__restrict __s,
			   FILE *__restrict __stream) ;
#line 744 "/usr/include/stdio.h"

#line 746 "/usr/include/stdio.h"






extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
			      size_t __n, FILE *__restrict __stream) 
  ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
			       size_t __n, FILE *__restrict __stream)
  ;
#line 759 "/usr/include/stdio.h"






extern int fseek (FILE *__stream, long int __off, int __whence)
  ;




extern long int ftell (FILE *__stream)  ;




extern void rewind (FILE *__stream) ;






#line 785 "/usr/include/stdio.h"




extern int fseeko (FILE *__stream, __off_t __off, int __whence)
  ;




extern __off_t ftello (FILE *__stream)  ;
#line 809 "/usr/include/stdio.h"

#line 811 "/usr/include/stdio.h"




extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos)
  ;




extern int fsetpos (FILE *__stream, const fpos_t *__pos) ;
#line 835 "/usr/include/stdio.h"

#line 837 "/usr/include/stdio.h"
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence)
  ;
extern __off64_t ftello64 (FILE *__stream)  ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos)
  ;
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos) ;
#line 844 "/usr/include/stdio.h"


extern void clearerr (FILE *__stream)  ;

extern int feof (FILE *__stream)   ;

extern int ferror (FILE *__stream)   ;

#line 853 "/usr/include/stdio.h"

extern void clearerr_unlocked (FILE *__stream)  ;
extern int feof_unlocked (FILE *__stream)   ;
extern int ferror_unlocked (FILE *__stream)   ;
#line 858 "/usr/include/stdio.h"






extern void perror (const char *__s) ;


#line 868 "/usr/include/stdio.h"

extern int fileno (FILE *__stream)   ;
#line 871 "/usr/include/stdio.h"

#line 873 "/usr/include/stdio.h"

extern int fileno_unlocked (FILE *__stream)   ;
#line 876 "/usr/include/stdio.h"


#line 879 "/usr/include/stdio.h"




extern int pclose (FILE *__stream) ;





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__))  ;

#line 893 "/usr/include/stdio.h"


#line 896 "/usr/include/stdio.h"

extern char *ctermid (char *__s) 
  ;
#line 900 "/usr/include/stdio.h"


#line 903 "/usr/include/stdio.h"

extern char *cuserid (char *__s)
  ;
#line 907 "/usr/include/stdio.h"


#line 910 "/usr/include/stdio.h"
struct obstack;			


extern int obstack_printf (struct obstack *__restrict __obstack,
			   const char *__restrict __format, ...)
      __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
			    const char *__restrict __format,
			    __gnuc_va_list __args)
      __attribute__ ((__format__ (__printf__, 2, 0)));
#line 921 "/usr/include/stdio.h"


#line 924 "/usr/include/stdio.h"



extern void flockfile (FILE *__stream)  ;



extern int ftrylockfile (FILE *__stream)   ;


extern void funlockfile (FILE *__stream)  ;
#line 936 "/usr/include/stdio.h"

#line 942 "/usr/include/stdio.h"



extern int __uflow (FILE *);
extern int __overflow (FILE *, int);

#line 952 "/usr/include/stdio.h"



#line 958 "/usr/include/stdio.h"



#line 968 "/usr/include/stdio.h"


#line 90 "/usr/local/include/neo-c.h"
#line 1 "/usr/include/stdlib.h"






















#line 24 "/usr/include/stdlib.h"

#line 1 "/usr/include/bits/libc-header-start.h"


























#line 30 "/usr/include/bits/libc-header-start.h"

#line 32 "/usr/include/bits/libc-header-start.h"

#line 1 "/usr/include/features.h"
















#line 34 "/usr/include/bits/libc-header-start.h"



#line 43 "/usr/include/bits/libc-header-start.h"























#line 84 "/usr/include/bits/libc-header-start.h"





#line 101 "/usr/include/bits/libc-header-start.h"


#line 27 "/usr/include/stdlib.h"


#line 1 "/usr/lib/clang/21/include/stddef.h"





















#line 37 "/usr/lib/clang/21/include/stddef.h"

#line 80 "/usr/lib/clang/21/include/stddef.h"

#line 85 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_size_t.h"












#line 88 "/usr/lib/clang/21/include/stddef.h"
#line 90 "/usr/lib/clang/21/include/stddef.h"

#line 95 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_wchar_t.h"









#line 11 "/usr/lib/clang/21/include/__stddef_wchar_t.h"





#line 18 "/usr/lib/clang/21/include/__stddef_wchar_t.h"

#line 22 "/usr/lib/clang/21/include/__stddef_wchar_t.h"

typedef int wchar_t;

#line 26 "/usr/lib/clang/21/include/__stddef_wchar_t.h"
#line 98 "/usr/lib/clang/21/include/stddef.h"
#line 100 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_null.h"









#line 11 "/usr/lib/clang/21/include/__stddef_null.h"






#line 18 "/usr/lib/clang/21/include/__stddef_null.h"

#line 28 "/usr/lib/clang/21/include/__stddef_null.h"
#line 103 "/usr/lib/clang/21/include/stddef.h"
#line 105 "/usr/lib/clang/21/include/stddef.h"

#line 110 "/usr/lib/clang/21/include/stddef.h"

#line 115 "/usr/lib/clang/21/include/stddef.h"

#line 120 "/usr/lib/clang/21/include/stddef.h"

#line 125 "/usr/lib/clang/21/include/stddef.h"



#line 132 "/usr/lib/clang/21/include/stddef.h"
#line 33 "/usr/include/stdlib.h"



#line 37 "/usr/include/stdlib.h"

#line 39 "/usr/include/stdlib.h"

#line 1 "/usr/include/bits/waitflags.h"


















#line 22 "/usr/include/bits/waitflags.h"



#line 27 "/usr/include/bits/waitflags.h"


#line 35 "/usr/include/bits/waitflags.h"

#line 37 "/usr/include/bits/waitflags.h"
#line 41 "/usr/include/stdlib.h"
#line 1 "/usr/include/bits/waitstatus.h"


















#line 22 "/usr/include/bits/waitstatus.h"






#line 29 "/usr/include/bits/waitstatus.h"


#line 32 "/usr/include/bits/waitstatus.h"


#line 35 "/usr/include/bits/waitstatus.h"


#line 38 "/usr/include/bits/waitstatus.h"


#line 41 "/usr/include/bits/waitstatus.h"


#line 44 "/usr/include/bits/waitstatus.h"



#line 50 "/usr/include/bits/waitstatus.h"


#line 53 "/usr/include/bits/waitstatus.h"

#line 42 "/usr/include/stdlib.h"


#line 54 "/usr/include/stdlib.h"


#line 1 "/usr/include/bits/floatn.h"

















#line 57 "/usr/include/stdlib.h"


typedef struct
  {
    int quot;			
    int rem;			
  } div_t;


#line 67 "/usr/include/stdlib.h"
typedef struct
  {
    long int quot;		
    long int rem;		
  } ldiv_t;
#line 74 "/usr/include/stdlib.h"

#line 76 "/usr/include/stdlib.h"

typedef struct
  {
    long long int quot;		
    long long int rem;		
  } lldiv_t;
#line 84 "/usr/include/stdlib.h"



#line 88 "/usr/include/stdlib.h"




#line 94 "/usr/include/stdlib.h"



#line 98 "/usr/include/stdlib.h"
extern size_t __ctype_get_mb_cur_max (void)  ;



extern double atof (const char *__nptr)
      __attribute__ ((__pure__))  ;

extern int atoi (const char *__nptr)
      __attribute__ ((__pure__))  ;

extern long int atol (const char *__nptr)
      __attribute__ ((__pure__))  ;

#line 112 "/usr/include/stdlib.h"

extern long long int atoll (const char *__nptr)
      __attribute__ ((__pure__))  ;
#line 116 "/usr/include/stdlib.h"


extern double strtod (const char *__restrict __nptr,
		      char **__restrict __endptr)
      ;

#line 123 "/usr/include/stdlib.h"

extern float strtof (const char *__restrict __nptr,
		     char **__restrict __endptr)  ;

extern long double strtold (const char *__restrict __nptr,
			    char **__restrict __endptr)
      ;
#line 131 "/usr/include/stdlib.h"



#line 139 "/usr/include/stdlib.h"

#line 141 "/usr/include/stdlib.h"
extern _Float32 strtof32 (const char *__restrict __nptr,
			  char **__restrict __endptr)
      ;
#line 145 "/usr/include/stdlib.h"

#line 147 "/usr/include/stdlib.h"
extern _Float64 strtof64 (const char *__restrict __nptr,
			  char **__restrict __endptr)
      ;
#line 151 "/usr/include/stdlib.h"

#line 157 "/usr/include/stdlib.h"

#line 159 "/usr/include/stdlib.h"
extern _Float32x strtof32x (const char *__restrict __nptr,
			    char **__restrict __endptr)
      ;
#line 163 "/usr/include/stdlib.h"

#line 165 "/usr/include/stdlib.h"
extern _Float64x strtof64x (const char *__restrict __nptr,
			    char **__restrict __endptr)
      ;
#line 169 "/usr/include/stdlib.h"

#line 175 "/usr/include/stdlib.h"


extern long int strtol (const char *__restrict __nptr,
			char **__restrict __endptr, int __base)
      ;

extern unsigned long int strtoul (const char *__restrict __nptr,
				  char **__restrict __endptr, int __base)
      ;

#line 186 "/usr/include/stdlib.h"


extern long long int strtoq (const char *__restrict __nptr,
			     char **__restrict __endptr, int __base)
      ;


extern unsigned long long int strtouq (const char *__restrict __nptr,
				       char **__restrict __endptr, int __base)
      ;
#line 197 "/usr/include/stdlib.h"

#line 199 "/usr/include/stdlib.h"


extern long long int strtoll (const char *__restrict __nptr,
			      char **__restrict __endptr, int __base)
      ;


extern unsigned long long int strtoull (const char *__restrict __nptr,
					char **__restrict __endptr, int __base)
      ;
#line 210 "/usr/include/stdlib.h"



#line 249 "/usr/include/stdlib.h"
extern long int __isoc23_strtol (const char *__restrict __nptr,
				 char **__restrict __endptr, int __base)
      ;
extern unsigned long int __isoc23_strtoul (const char *__restrict __nptr,
					   char **__restrict __endptr,
					   int __base)
      ;

extern long long int __isoc23_strtoll (const char *__restrict __nptr,
				       char **__restrict __endptr, int __base)
      ;

extern unsigned long long int __isoc23_strtoull (const char *__restrict __nptr,
						 char **__restrict __endptr,
						 int __base)
      ;
#line 275 "/usr/include/stdlib.h"


#line 278 "/usr/include/stdlib.h"
extern int strfromd (char *__dest, size_t __size, const char *__format,
		     double __f)
      ;

extern int strfromf (char *__dest, size_t __size, const char *__format,
		     float __f)
      ;

extern int strfroml (char *__dest, size_t __size, const char *__format,
		     long double __f)
      ;
#line 290 "/usr/include/stdlib.h"

#line 296 "/usr/include/stdlib.h"

#line 298 "/usr/include/stdlib.h"
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
		       _Float32 __f)
      ;
#line 302 "/usr/include/stdlib.h"

#line 304 "/usr/include/stdlib.h"
extern int strfromf64 (char *__dest, size_t __size, const char * __format,
		       _Float64 __f)
      ;
#line 308 "/usr/include/stdlib.h"

#line 314 "/usr/include/stdlib.h"

#line 316 "/usr/include/stdlib.h"
extern int strfromf32x (char *__dest, size_t __size, const char * __format,
			_Float32x __f)
      ;
#line 320 "/usr/include/stdlib.h"

#line 322 "/usr/include/stdlib.h"
extern int strfromf64x (char *__dest, size_t __size, const char * __format,
			_Float64x __f)
      ;
#line 326 "/usr/include/stdlib.h"

#line 332 "/usr/include/stdlib.h"


#line 335 "/usr/include/stdlib.h"



#line 1 "/usr/include/bits/types/locale_t.h"


















#line 21 "/usr/include/bits/types/locale_t.h"

#line 1 "/usr/include/bits/types/__locale_t.h"


















#line 21 "/usr/include/bits/types/__locale_t.h"






struct __locale_struct
{
  
  struct __locale_data *__locales[13]; 

  
  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;

  
  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
#line 23 "/usr/include/bits/types/locale_t.h"

typedef __locale_t locale_t;
#line 339 "/usr/include/stdlib.h"

extern long int strtol_l (const char *__restrict __nptr,
			  char **__restrict __endptr, int __base,
			  locale_t __loc)  ;

extern unsigned long int strtoul_l (const char *__restrict __nptr,
				    char **__restrict __endptr,
				    int __base, locale_t __loc)
      ;


extern long long int strtoll_l (const char *__restrict __nptr,
				char **__restrict __endptr, int __base,
				locale_t __loc)
      ;


extern unsigned long long int strtoull_l (const char *__restrict __nptr,
					  char **__restrict __endptr,
					  int __base, locale_t __loc)
      ;



#line 391 "/usr/include/stdlib.h"
extern long int __isoc23_strtol_l (const char *__restrict __nptr,
				   char **__restrict __endptr, int __base,
				   locale_t __loc)  ;
extern unsigned long int __isoc23_strtoul_l (const char *__restrict __nptr,
					     char **__restrict __endptr,
					     int __base, locale_t __loc)
      ;

extern long long int __isoc23_strtoll_l (const char *__restrict __nptr,
					 char **__restrict __endptr,
					 int __base, locale_t __loc)
      ;

extern unsigned long long int __isoc23_strtoull_l (const char *__restrict __nptr,
						   char **__restrict __endptr,
						   int __base, locale_t __loc)
      ;
#line 414 "/usr/include/stdlib.h"

extern double strtod_l (const char *__restrict __nptr,
			char **__restrict __endptr, locale_t __loc)
      ;

extern float strtof_l (const char *__restrict __nptr,
		       char **__restrict __endptr, locale_t __loc)
      ;

extern long double strtold_l (const char *__restrict __nptr,
			      char **__restrict __endptr,
			      locale_t __loc)
      ;

#line 434 "/usr/include/stdlib.h"

#line 436 "/usr/include/stdlib.h"
extern _Float32 strtof32_l (const char *__restrict __nptr,
			    char **__restrict __endptr,
			    locale_t __loc)
      ;
#line 441 "/usr/include/stdlib.h"

#line 443 "/usr/include/stdlib.h"
extern _Float64 strtof64_l (const char *__restrict __nptr,
			    char **__restrict __endptr,
			    locale_t __loc)
      ;
#line 448 "/usr/include/stdlib.h"

#line 455 "/usr/include/stdlib.h"

#line 457 "/usr/include/stdlib.h"
extern _Float32x strtof32x_l (const char *__restrict __nptr,
			      char **__restrict __endptr,
			      locale_t __loc)
      ;
#line 462 "/usr/include/stdlib.h"

#line 464 "/usr/include/stdlib.h"
extern _Float64x strtof64x_l (const char *__restrict __nptr,
			      char **__restrict __endptr,
			      locale_t __loc)
      ;
#line 469 "/usr/include/stdlib.h"

#line 477 "/usr/include/stdlib.h"


#line 499 "/usr/include/stdlib.h"


#line 502 "/usr/include/stdlib.h"



extern char *l64a (long int __n)  ;


extern long int a64l (const char *__s)
      __attribute__ ((__pure__))  ;

#line 512 "/usr/include/stdlib.h"

#line 1 "/usr/include/sys/types.h"





















#line 24 "/usr/include/sys/types.h"

#line 1 "/usr/include/features.h"
















#line 26 "/usr/include/sys/types.h"



#line 1 "/usr/include/bits/types.h"





















#line 30 "/usr/include/sys/types.h"

#line 33 "/usr/include/sys/types.h"
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
#line 42 "/usr/include/sys/types.h"
typedef __loff_t loff_t;
#line 44 "/usr/include/sys/types.h"

#line 47 "/usr/include/sys/types.h"
typedef __ino_t ino_t;
#line 54 "/usr/include/sys/types.h"
typedef __ino64_t ino64_t;
#line 57 "/usr/include/sys/types.h"

#line 59 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 62 "/usr/include/sys/types.h"

#line 64 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 67 "/usr/include/sys/types.h"

#line 69 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 72 "/usr/include/sys/types.h"

#line 74 "/usr/include/sys/types.h"
typedef __nlink_t nlink_t;
#line 77 "/usr/include/sys/types.h"

#line 79 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 82 "/usr/include/sys/types.h"

#line 95 "/usr/include/sys/types.h"

#line 97 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 100 "/usr/include/sys/types.h"

#line 102 "/usr/include/sys/types.h"
typedef __id_t id_t;
#line 105 "/usr/include/sys/types.h"

#line 110 "/usr/include/sys/types.h"

#line 113 "/usr/include/sys/types.h"
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
#line 118 "/usr/include/sys/types.h"

#line 120 "/usr/include/sys/types.h"
typedef __key_t key_t;
#line 123 "/usr/include/sys/types.h"

#line 1 "/usr/include/bits/types/clock_t.h"
#line 3 "/usr/include/bits/types/clock_t.h"

#line 1 "/usr/include/bits/types.h"





















#line 5 "/usr/include/bits/types/clock_t.h"


typedef __clock_t clock_t;
#line 126 "/usr/include/sys/types.h"
#line 1 "/usr/include/bits/types/clockid_t.h"
#line 3 "/usr/include/bits/types/clockid_t.h"

#line 1 "/usr/include/bits/types.h"





















#line 5 "/usr/include/bits/types/clockid_t.h"


typedef __clockid_t clockid_t;
#line 128 "/usr/include/sys/types.h"
#line 1 "/usr/include/bits/types/time_t.h"
#line 3 "/usr/include/bits/types/time_t.h"

#line 1 "/usr/include/bits/types.h"





















#line 5 "/usr/include/bits/types/time_t.h"


#line 10 "/usr/include/bits/types/time_t.h"
typedef __time_t time_t;
#line 12 "/usr/include/bits/types/time_t.h"
#line 129 "/usr/include/sys/types.h"
#line 1 "/usr/include/bits/types/timer_t.h"
#line 3 "/usr/include/bits/types/timer_t.h"

#line 1 "/usr/include/bits/types.h"





















#line 5 "/usr/include/bits/types/timer_t.h"


typedef __timer_t timer_t;
#line 130 "/usr/include/sys/types.h"

#line 133 "/usr/include/sys/types.h"
typedef __useconds_t useconds_t;
#line 137 "/usr/include/sys/types.h"
typedef __suseconds_t suseconds_t;
#line 141 "/usr/include/sys/types.h"

#line 1 "/usr/lib/clang/21/include/stddef.h"





















#line 37 "/usr/lib/clang/21/include/stddef.h"

#line 80 "/usr/lib/clang/21/include/stddef.h"

#line 85 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_size_t.h"












#line 88 "/usr/lib/clang/21/include/stddef.h"
#line 90 "/usr/lib/clang/21/include/stddef.h"

#line 95 "/usr/lib/clang/21/include/stddef.h"

#line 100 "/usr/lib/clang/21/include/stddef.h"

#line 105 "/usr/lib/clang/21/include/stddef.h"

#line 110 "/usr/lib/clang/21/include/stddef.h"

#line 115 "/usr/lib/clang/21/include/stddef.h"

#line 120 "/usr/lib/clang/21/include/stddef.h"

#line 125 "/usr/lib/clang/21/include/stddef.h"



#line 132 "/usr/lib/clang/21/include/stddef.h"
#line 144 "/usr/include/sys/types.h"

#line 146 "/usr/include/sys/types.h"

typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
#line 151 "/usr/include/sys/types.h"



#line 1 "/usr/include/bits/stdint-intn.h"


















#line 21 "/usr/include/bits/stdint-intn.h"

#line 1 "/usr/include/bits/types.h"





















#line 23 "/usr/include/bits/stdint-intn.h"

typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
#line 155 "/usr/include/sys/types.h"


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;

#line 163 "/usr/include/sys/types.h"
typedef int register_t __attribute__ ((__mode__ (__word__)));
#line 167 "/usr/include/sys/types.h"



#line 171 "/usr/include/sys/types.h"


#line 174 "/usr/include/sys/types.h"

#line 1 "/usr/include/endian.h"

















#line 20 "/usr/include/endian.h"

#line 1 "/usr/include/features.h"
















#line 22 "/usr/include/endian.h"


#line 1 "/usr/include/bits/endian.h"


















#line 21 "/usr/include/bits/endian.h"









#line 33 "/usr/include/bits/endian.h"


#line 1 "/usr/include/bits/endianness.h"
#line 3 "/usr/include/bits/endianness.h"

#line 7 "/usr/include/bits/endianness.h"


#line 10 "/usr/include/bits/endianness.h"
#line 36 "/usr/include/bits/endian.h"



#line 42 "/usr/include/bits/endian.h"

#line 48 "/usr/include/bits/endian.h"
#line 25 "/usr/include/endian.h"

#line 32 "/usr/include/endian.h"

#line 34 "/usr/include/endian.h"

#line 1 "/usr/include/bits/byteswap.h"


















#line 22 "/usr/include/bits/byteswap.h"

#line 25 "/usr/include/bits/byteswap.h"

#line 1 "/usr/include/features.h"
















#line 27 "/usr/include/bits/byteswap.h"
#line 1 "/usr/include/bits/types.h"





















#line 28 "/usr/include/bits/byteswap.h"


#line 31 "/usr/include/bits/byteswap.h"

static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{
#line 38 "/usr/include/bits/byteswap.h"
  return ((__uint16_t) ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));
#line 40 "/usr/include/bits/byteswap.h"
}


#line 44 "/usr/include/bits/byteswap.h"

static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{
#line 51 "/usr/include/bits/byteswap.h"
  return ((((__bsx) & 0xff000000u) >> 24) | (((__bsx) & 0x00ff0000u) >> 8)	   | (((__bsx) & 0x0000ff00u) << 8) | (((__bsx) & 0x000000ffu) << 24));
#line 53 "/usr/include/bits/byteswap.h"
}


#line 57 "/usr/include/bits/byteswap.h"

static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
#line 64 "/usr/include/bits/byteswap.h"
  return ((((__bsx) & 0xff00000000000000ull) >> 56)	   | (((__bsx) & 0x00ff000000000000ull) >> 40)	   | (((__bsx) & 0x0000ff0000000000ull) >> 24)	   | (((__bsx) & 0x000000ff00000000ull) >> 8)	   | (((__bsx) & 0x00000000ff000000ull) << 8)	   | (((__bsx) & 0x0000000000ff0000ull) << 24)	   | (((__bsx) & 0x000000000000ff00ull) << 40)	   | (((__bsx) & 0x00000000000000ffull) << 56));
#line 66 "/usr/include/bits/byteswap.h"
}
#line 36 "/usr/include/endian.h"
#line 1 "/usr/include/bits/uintn-identity.h"


















#line 22 "/usr/include/bits/uintn-identity.h"

#line 25 "/usr/include/bits/uintn-identity.h"

#line 1 "/usr/include/bits/types.h"





















#line 27 "/usr/include/bits/uintn-identity.h"





static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
#line 37 "/usr/include/endian.h"

#line 43 "/usr/include/endian.h"

#line 48 "/usr/include/endian.h"

#line 53 "/usr/include/endian.h"

#line 71 "/usr/include/endian.h"
#line 176 "/usr/include/sys/types.h"


#line 1 "/usr/include/sys/select.h"




















#line 23 "/usr/include/sys/select.h"

#line 1 "/usr/include/features.h"
















#line 25 "/usr/include/sys/select.h"


#line 1 "/usr/include/bits/types.h"





















#line 28 "/usr/include/sys/select.h"


#line 1 "/usr/include/bits/select.h"

















#line 21 "/usr/include/bits/select.h"



#line 31 "/usr/include/sys/select.h"


#line 1 "/usr/include/bits/types/sigset_t.h"
#line 3 "/usr/include/bits/types/sigset_t.h"

#line 1 "/usr/include/bits/types/__sigset_t.h"
#line 3 "/usr/include/bits/types/__sigset_t.h"

#line 5 "/usr/include/bits/types/__sigset_t.h"
typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
#line 5 "/usr/include/bits/types/sigset_t.h"


typedef __sigset_t sigset_t;
#line 34 "/usr/include/sys/select.h"


#line 1 "/usr/include/bits/types/time_t.h"
#line 37 "/usr/include/sys/select.h"
#line 1 "/usr/include/bits/types/struct_timeval.h"
#line 3 "/usr/include/bits/types/struct_timeval.h"

#line 1 "/usr/include/bits/types.h"





















#line 5 "/usr/include/bits/types/struct_timeval.h"



struct timeval
{
#line 14 "/usr/include/bits/types/struct_timeval.h"
  __time_t tv_sec;		
  __suseconds_t tv_usec;	
#line 17 "/usr/include/bits/types/struct_timeval.h"
};
#line 38 "/usr/include/sys/select.h"
#line 1 "/usr/include/bits/types/struct_timespec.h"

#line 4 "/usr/include/bits/types/struct_timespec.h"

#line 1 "/usr/include/bits/types.h"





















#line 6 "/usr/include/bits/types/struct_timespec.h"
#line 1 "/usr/include/bits/endian.h"

















#line 7 "/usr/include/bits/types/struct_timespec.h"
#line 1 "/usr/include/bits/types/time_t.h"
#line 8 "/usr/include/bits/types/struct_timespec.h"



struct timespec
{
#line 16 "/usr/include/bits/types/struct_timespec.h"
  __time_t tv_sec;		
#line 19 "/usr/include/bits/types/struct_timespec.h"
  __syscall_slong_t tv_nsec;	
#line 29 "/usr/include/bits/types/struct_timespec.h"
};
#line 40 "/usr/include/sys/select.h"
#line 41 "/usr/include/sys/select.h"

#line 46 "/usr/include/sys/select.h"



typedef long int __fd_mask;


#line 53 "/usr/include/sys/select.h"

#line 57 "/usr/include/sys/select.h"


typedef struct
  {
    

#line 64 "/usr/include/sys/select.h"
    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];
#line 70 "/usr/include/sys/select.h"
  } fd_set;


#line 74 "/usr/include/sys/select.h"

#line 76 "/usr/include/sys/select.h"

typedef __fd_mask fd_mask;


#line 82 "/usr/include/sys/select.h"



#line 89 "/usr/include/sys/select.h"












#line 102 "/usr/include/sys/select.h"
extern int select (int __nfds, fd_set *__restrict __readfds,
		   fd_set *__restrict __writefds,
		   fd_set *__restrict __exceptfds,
		   struct timeval *__restrict __timeout);
#line 118 "/usr/include/sys/select.h"

#line 120 "/usr/include/sys/select.h"






#line 127 "/usr/include/sys/select.h"
extern int pselect (int __nfds, fd_set *__restrict __readfds,
		    fd_set *__restrict __writefds,
		    fd_set *__restrict __exceptfds,
		    const struct timespec *__restrict __timeout,
		    const __sigset_t *__restrict __sigmask);
#line 146 "/usr/include/sys/select.h"



#line 152 "/usr/include/sys/select.h"


#line 179 "/usr/include/sys/types.h"
#line 180 "/usr/include/sys/types.h"


#line 183 "/usr/include/sys/types.h"
typedef __blksize_t blksize_t;
#line 186 "/usr/include/sys/types.h"


#line 190 "/usr/include/sys/types.h"
typedef __blkcnt_t blkcnt_t;	 
#line 194 "/usr/include/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t; 
#line 198 "/usr/include/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t; 
#line 215 "/usr/include/sys/types.h"

#line 217 "/usr/include/sys/types.h"
typedef __blkcnt64_t blkcnt64_t;     
typedef __fsblkcnt64_t fsblkcnt64_t; 
typedef __fsfilcnt64_t fsfilcnt64_t; 
#line 221 "/usr/include/sys/types.h"



#line 1 "/usr/include/bits/pthreadtypes.h"


















#line 21 "/usr/include/bits/pthreadtypes.h"


#line 1 "/usr/include/bits/thread-shared-types.h"


















#line 21 "/usr/include/bits/thread-shared-types.h"























#line 1 "/usr/include/bits/pthreadtypes-arch.h"

















#line 20 "/usr/include/bits/pthreadtypes-arch.h"

#line 1 "/usr/include/bits/wordsize.h"


#line 10 "/usr/include/bits/wordsize.h"

#line 12 "/usr/include/bits/wordsize.h"

#line 14 "/usr/include/bits/wordsize.h"
#line 22 "/usr/include/bits/pthreadtypes-arch.h"

#line 46 "/usr/include/bits/pthreadtypes-arch.h"

#line 49 "/usr/include/bits/pthreadtypes-arch.h"

#line 54 "/usr/include/bits/pthreadtypes-arch.h"
#line 45 "/usr/include/bits/thread-shared-types.h"

#line 1 "/usr/include/bits/atomic_wide_counter.h"


















#line 21 "/usr/include/bits/atomic_wide_counter.h"




typedef union
{
  unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
#line 47 "/usr/include/bits/thread-shared-types.h"




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;















#line 1 "/usr/include/bits/struct_mutex.h"


















#line 21 "/usr/include/bits/struct_mutex.h"

struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;
#line 28 "/usr/include/bits/struct_mutex.h"
  unsigned int __nusers;
#line 30 "/usr/include/bits/struct_mutex.h"
  

  int __kind;
#line 34 "/usr/include/bits/struct_mutex.h"
  short __spins;
  short __elision;
  __pthread_list_t __list;
#line 53 "/usr/include/bits/struct_mutex.h"
};

#line 60 "/usr/include/bits/struct_mutex.h"
#line 77 "/usr/include/bits/thread-shared-types.h"












#line 1 "/usr/include/bits/struct_rwlock.h"



















#line 22 "/usr/include/bits/struct_rwlock.h"

struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;
#line 32 "/usr/include/bits/struct_rwlock.h"
  int __cur_writer;
  int __shared;
  signed char __rwelision;
#line 39 "/usr/include/bits/struct_rwlock.h"
  unsigned char __pad1[7];
#line 42 "/usr/include/bits/struct_rwlock.h"
  unsigned long int __pad2;
  

  unsigned int __flags;
#line 55 "/usr/include/bits/struct_rwlock.h"
};

#line 62 "/usr/include/bits/struct_rwlock.h"
#line 90 "/usr/include/bits/thread-shared-types.h"




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_size[2] ;
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
  unsigned int __unused_initialized_1;
  unsigned int __unused_initialized_2;
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;

#line 115 "/usr/include/bits/thread-shared-types.h"
#line 24 "/usr/include/bits/pthreadtypes.h"



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int  pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};
#line 62 "/usr/include/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 65 "/usr/include/bits/pthreadtypes.h"


typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  long long int __align;
} pthread_cond_t;


#line 84 "/usr/include/bits/pthreadtypes.h"


typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;
#line 99 "/usr/include/bits/pthreadtypes.h"


#line 102 "/usr/include/bits/pthreadtypes.h"

typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
#line 120 "/usr/include/bits/pthreadtypes.h"
#line 226 "/usr/include/sys/types.h"
#line 227 "/usr/include/sys/types.h"


#line 515 "/usr/include/stdlib.h"






extern long int random (void) ;


extern void srandom (unsigned int __seed) ;





extern char *initstate (unsigned int __seed, char *__statebuf,
			size_t __statelen)  ;



extern char *setstate (char *__statebuf)  ;


#line 539 "/usr/include/stdlib.h"




struct random_data
  {
    int32_t *fptr;		
    int32_t *rptr;		
    int32_t *state;		
    int rand_type;		
    int rand_deg;		
    int rand_sep;		
    int32_t *end_ptr;		
  };

extern int random_r (struct random_data *__restrict __buf,
		     int32_t *__restrict __result)  ;

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
      ;

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
			size_t __statelen,
			struct random_data *__restrict __buf)
      ;

extern int setstate_r (char *__restrict __statebuf,
		       struct random_data *__restrict __buf)
      ;
#line 570 "/usr/include/stdlib.h"



extern int rand (void) ;

extern void srand (unsigned int __seed) ;

#line 578 "/usr/include/stdlib.h"

extern int rand_r (unsigned int *__seed) ;
#line 581 "/usr/include/stdlib.h"


#line 584 "/usr/include/stdlib.h"



extern double drand48 (void) ;
extern double erand48 (unsigned short int __xsubi[3])  ;


extern long int lrand48 (void) ;
extern long int nrand48 (unsigned short int __xsubi[3])
      ;


extern long int mrand48 (void) ;
extern long int jrand48 (unsigned short int __xsubi[3])
      ;


extern void srand48 (long int __seedval) ;
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
      ;
extern void lcong48 (unsigned short int __param[7])  ;

#line 607 "/usr/include/stdlib.h"



struct drand48_data
  {
    unsigned short int __x[3];	
    unsigned short int __old_x[3]; 
    unsigned short int __c;	
    unsigned short int __init;	
    unsigned long long int __a;	

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
		      double *__restrict __result)  ;
extern int erand48_r (unsigned short int __xsubi[3],
		      struct drand48_data *__restrict __buffer,
		      double *__restrict __result)  ;


extern int lrand48_r (struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
      ;
extern int nrand48_r (unsigned short int __xsubi[3],
		      struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
      ;


extern int mrand48_r (struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
      ;
extern int jrand48_r (unsigned short int __xsubi[3],
		      struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
      ;


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
      ;

extern int seed48_r (unsigned short int __seed16v[3],
		     struct drand48_data *__buffer)  ;

extern int lcong48_r (unsigned short int __param[7],
		      struct drand48_data *__buffer)
      ;


extern __uint32_t arc4random (void)
      ;


extern void arc4random_buf (void *__buf, size_t __size)
      ;



extern __uint32_t arc4random_uniform (__uint32_t __upper_bound)
      ;
#line 670 "/usr/include/stdlib.h"


extern void *malloc (size_t __size)  __attribute__ ((__malloc__))
      ;

extern void *calloc (size_t __nmemb, size_t __size)
      __attribute__ ((__malloc__))  ;






extern void *realloc (void *__ptr, size_t __size)
       ;


extern void free (void *__ptr) ;

#line 690 "/usr/include/stdlib.h"





extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
      
     
    ;


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
      ;
#line 704 "/usr/include/stdlib.h"

#line 1 "/usr/include/alloca.h"

















#line 20 "/usr/include/alloca.h"

#line 1 "/usr/include/features.h"
















#line 22 "/usr/include/alloca.h"

#line 1 "/usr/lib/clang/21/include/stddef.h"





















#line 37 "/usr/lib/clang/21/include/stddef.h"

#line 80 "/usr/lib/clang/21/include/stddef.h"

#line 85 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_size_t.h"












#line 88 "/usr/lib/clang/21/include/stddef.h"
#line 90 "/usr/lib/clang/21/include/stddef.h"

#line 95 "/usr/lib/clang/21/include/stddef.h"

#line 100 "/usr/lib/clang/21/include/stddef.h"

#line 105 "/usr/lib/clang/21/include/stddef.h"

#line 110 "/usr/lib/clang/21/include/stddef.h"

#line 115 "/usr/lib/clang/21/include/stddef.h"

#line 120 "/usr/lib/clang/21/include/stddef.h"

#line 125 "/usr/lib/clang/21/include/stddef.h"



#line 132 "/usr/lib/clang/21/include/stddef.h"
#line 25 "/usr/include/alloca.h"




#line 30 "/usr/include/alloca.h"


extern void *alloca (size_t __size) ;

#line 37 "/usr/include/alloca.h"


#line 707 "/usr/include/stdlib.h"
#line 708 "/usr/include/stdlib.h"

#line 710 "/usr/include/stdlib.h"

extern void *valloc (size_t __size)  __attribute__ ((__malloc__))
      ;
#line 714 "/usr/include/stdlib.h"

#line 716 "/usr/include/stdlib.h"

extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
       ;
#line 720 "/usr/include/stdlib.h"

#line 722 "/usr/include/stdlib.h"

extern void *aligned_alloc (size_t __alignment, size_t __size)
      __attribute__ ((__malloc__)) 
      ;
#line 727 "/usr/include/stdlib.h"


extern void abort (void)  __attribute__ ((__noreturn__)) ;



extern int atexit (void (*__func) (void))  ;

#line 736 "/usr/include/stdlib.h"

#line 741 "/usr/include/stdlib.h"
extern int at_quick_exit (void (*__func) (void))  ;
#line 744 "/usr/include/stdlib.h"

#line 746 "/usr/include/stdlib.h"


extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
      ;
#line 751 "/usr/include/stdlib.h"




extern void exit (int __status)  __attribute__ ((__noreturn__));

#line 758 "/usr/include/stdlib.h"



extern void quick_exit (int __status)  __attribute__ ((__noreturn__));
#line 763 "/usr/include/stdlib.h"

#line 765 "/usr/include/stdlib.h"


extern void _Exit (int __status)  __attribute__ ((__noreturn__));
#line 769 "/usr/include/stdlib.h"



extern char *getenv (const char *__name)   ;

#line 775 "/usr/include/stdlib.h"


extern char *secure_getenv (const char *__name)
       ;
#line 780 "/usr/include/stdlib.h"

#line 782 "/usr/include/stdlib.h"



extern int putenv (char *__string)  ;
#line 787 "/usr/include/stdlib.h"

#line 789 "/usr/include/stdlib.h"


extern int setenv (const char *__name, const char *__value, int __replace)
      ;


extern int unsetenv (const char *__name)  ;
#line 797 "/usr/include/stdlib.h"

#line 799 "/usr/include/stdlib.h"



extern int clearenv (void) ;
#line 804 "/usr/include/stdlib.h"


#line 807 "/usr/include/stdlib.h"





extern char *mktemp (char *__template)  ;
#line 814 "/usr/include/stdlib.h"

#line 816 "/usr/include/stdlib.h"








#line 825 "/usr/include/stdlib.h"
extern int mkstemp (char *__template)  ;
#line 835 "/usr/include/stdlib.h"
extern int mkstemp64 (char *__template)  ;
#line 838 "/usr/include/stdlib.h"

#line 840 "/usr/include/stdlib.h"






#line 847 "/usr/include/stdlib.h"
extern int mkstemps (char *__template, int __suffixlen)  ;
#line 857 "/usr/include/stdlib.h"
extern int mkstemps64 (char *__template, int __suffixlen)
      ;
#line 861 "/usr/include/stdlib.h"

#line 863 "/usr/include/stdlib.h"





extern char *mkdtemp (char *__template)   ;
#line 870 "/usr/include/stdlib.h"

#line 872 "/usr/include/stdlib.h"






#line 879 "/usr/include/stdlib.h"
extern int mkostemp (char *__template, int __flags)  ;
#line 889 "/usr/include/stdlib.h"
extern int mkostemp64 (char *__template, int __flags)  ;
#line 891 "/usr/include/stdlib.h"







#line 899 "/usr/include/stdlib.h"
extern int mkostemps (char *__template, int __suffixlen, int __flags)
      ;
#line 911 "/usr/include/stdlib.h"
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
      ;
#line 915 "/usr/include/stdlib.h"






extern int system (const char *__command) ;


#line 925 "/usr/include/stdlib.h"


extern char *canonicalize_file_name (const char *__name)
       __attribute__ ((__malloc__))
      ;
#line 931 "/usr/include/stdlib.h"

#line 933 "/usr/include/stdlib.h"





extern char *realpath (const char *__restrict __name,
		       char *__restrict __resolved)  ;
#line 941 "/usr/include/stdlib.h"



#line 946 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t) (const void *, const void *);

#line 949 "/usr/include/stdlib.h"
typedef __compar_fn_t comparison_fn_t;
#line 953 "/usr/include/stdlib.h"
typedef int (*__compar_d_fn_t) (const void *, const void *, void *);
#line 955 "/usr/include/stdlib.h"



extern void *bsearch (const void *__key, const void *__base,
		      size_t __nmemb, size_t __size, __compar_fn_t __compar)
      ;

#line 965 "/usr/include/stdlib.h"



extern void qsort (void *__base, size_t __nmemb, size_t __size,
		   __compar_fn_t __compar) ;
#line 971 "/usr/include/stdlib.h"
extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
		     __compar_d_fn_t __compar, void *__arg)
  ;
#line 975 "/usr/include/stdlib.h"



extern int abs (int __x)  __attribute__ ((__const__)) ;
extern long int labs (long int __x)  __attribute__ ((__const__)) ;

#line 982 "/usr/include/stdlib.h"
extern long long int llabs (long long int __x)
      __attribute__ ((__const__)) ;
#line 985 "/usr/include/stdlib.h"

#line 987 "/usr/include/stdlib.h"
extern unsigned int uabs (int __x)  __attribute__ ((__const__)) ;
extern unsigned long int ulabs (long int __x)  __attribute__ ((__const__)) ;
extern unsigned long long int ullabs (long long int __x)
      __attribute__ ((__const__)) ;
#line 992 "/usr/include/stdlib.h"




extern div_t div (int __numer, int __denom)
      __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
      __attribute__ ((__const__)) ;

#line 1002 "/usr/include/stdlib.h"
extern lldiv_t lldiv (long long int __numer,
				    long long int __denom)
      __attribute__ ((__const__)) ;
#line 1006 "/usr/include/stdlib.h"


#line 1009 "/usr/include/stdlib.h"






extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign)   ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign)   ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
       ;
#line 1030 "/usr/include/stdlib.h"

#line 1032 "/usr/include/stdlib.h"

extern char *qecvt (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign)
       ;
extern char *qfcvt (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign)
       ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
       ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign, char *__restrict __buf,
		   size_t __len)  ;
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign, char *__restrict __buf,
		   size_t __len)  ;

extern int qecvt_r (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign,
		    char *__restrict __buf, size_t __len)
      ;
extern int qfcvt_r (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign,
		    char *__restrict __buf, size_t __len)
      ;
#line 1061 "/usr/include/stdlib.h"




extern int mblen (const char *__s, size_t __n) ;


extern int mbtowc (wchar_t *__restrict __pwc,
		   const char *__restrict __s, size_t __n) ;


extern int wctomb (char *__s, wchar_t __wchar) ;



extern size_t mbstowcs (wchar_t *__restrict  __pwcs,
			const char *__restrict __s, size_t __n) 
    ;

extern size_t wcstombs (char *__restrict __s,
			const wchar_t *__restrict __pwcs, size_t __n)
     
  
  ;

#line 1087 "/usr/include/stdlib.h"




extern int rpmatch (const char *__response)   ;
#line 1093 "/usr/include/stdlib.h"


#line 1096 "/usr/include/stdlib.h"






extern int getsubopt (char **__restrict __optionp,
		      char *const *__restrict __tokens,
		      char **__restrict __valuep)
       ;
#line 1107 "/usr/include/stdlib.h"




#line 1112 "/usr/include/stdlib.h"

extern int posix_openpt (int __oflag) ;
#line 1115 "/usr/include/stdlib.h"

#line 1117 "/usr/include/stdlib.h"




extern int grantpt (int __fd) ;



extern int unlockpt (int __fd) ;




extern char *ptsname (int __fd)  ;
#line 1132 "/usr/include/stdlib.h"

#line 1134 "/usr/include/stdlib.h"



extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
       ;


extern int getpt (void);
#line 1143 "/usr/include/stdlib.h"

#line 1145 "/usr/include/stdlib.h"



extern int getloadavg (double __loadavg[], int __nelem)
      ;
#line 1151 "/usr/include/stdlib.h"

#line 1157 "/usr/include/stdlib.h"

#line 1 "/usr/include/bits/stdlib-float.h"


















#line 22 "/usr/include/bits/stdlib-float.h"
#line 1159 "/usr/include/stdlib.h"


#line 1164 "/usr/include/stdlib.h"

#line 1 "/usr/include/bits/floatn.h"

















#line 1166 "/usr/include/stdlib.h"
#line 1169 "/usr/include/stdlib.h"


#line 91 "/usr/local/include/neo-c.h"
#line 1 "/usr/include/string.h"





















#line 24 "/usr/include/string.h"

#line 1 "/usr/include/bits/libc-header-start.h"


























#line 30 "/usr/include/bits/libc-header-start.h"

#line 32 "/usr/include/bits/libc-header-start.h"

#line 1 "/usr/include/features.h"
















#line 34 "/usr/include/bits/libc-header-start.h"



#line 43 "/usr/include/bits/libc-header-start.h"























#line 84 "/usr/include/bits/libc-header-start.h"





#line 101 "/usr/include/bits/libc-header-start.h"


#line 27 "/usr/include/string.h"




#line 1 "/usr/lib/clang/21/include/stddef.h"





















#line 37 "/usr/lib/clang/21/include/stddef.h"

#line 80 "/usr/lib/clang/21/include/stddef.h"

#line 85 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_size_t.h"












#line 88 "/usr/lib/clang/21/include/stddef.h"
#line 90 "/usr/lib/clang/21/include/stddef.h"

#line 95 "/usr/lib/clang/21/include/stddef.h"

#line 100 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_null.h"









#line 11 "/usr/lib/clang/21/include/__stddef_null.h"






#line 18 "/usr/lib/clang/21/include/__stddef_null.h"

#line 28 "/usr/lib/clang/21/include/__stddef_null.h"
#line 103 "/usr/lib/clang/21/include/stddef.h"
#line 105 "/usr/lib/clang/21/include/stddef.h"

#line 110 "/usr/lib/clang/21/include/stddef.h"

#line 115 "/usr/lib/clang/21/include/stddef.h"

#line 120 "/usr/lib/clang/21/include/stddef.h"

#line 125 "/usr/lib/clang/21/include/stddef.h"



#line 132 "/usr/lib/clang/21/include/stddef.h"
#line 34 "/usr/include/string.h"


#line 39 "/usr/include/string.h"



extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
		     size_t __n)  ;


extern void *memmove (void *__dest, const void *__src, size_t __n)
      ;




#line 53 "/usr/include/string.h"
extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
		      int __c, size_t __n)
      ;
#line 57 "/usr/include/string.h"



extern void *memset (void *__s, int __c, size_t __n)  ;


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
      __attribute__ ((__pure__)) ;














extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
      __attribute__ ((__pure__)) ;


#line 106 "/usr/include/string.h"
extern void *memchr (const void *__s, int __c, size_t __n)
       __attribute__ ((__pure__)) ;
#line 109 "/usr/include/string.h"

#line 111 "/usr/include/string.h"


#line 119 "/usr/include/string.h"
extern void *rawmemchr (const void *__s, int __c)
      __attribute__ ((__pure__)) ;
#line 122 "/usr/include/string.h"


#line 132 "/usr/include/string.h"
extern void *memrchr (const void *__s, int __c, size_t __n)
       __attribute__ ((__pure__)) 
      ;
#line 137 "/usr/include/string.h"



extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
      ;

extern char *strncpy (char *__restrict __dest,
		      const char *__restrict __src, size_t __n)
      ;


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
      ;

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
		      size_t __n)  ;


extern int strcmp (const char *__s1, const char *__s2)
      __attribute__ ((__pure__)) ;

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
      __attribute__ ((__pure__)) ;


extern int strcoll (const char *__s1, const char *__s2)
      __attribute__ ((__pure__)) ;

extern size_t strxfrm (char *__restrict __dest,
		       const char *__restrict __src, size_t __n)
      ;

#line 170 "/usr/include/string.h"

#line 1 "/usr/include/bits/types/locale_t.h"

















#line 172 "/usr/include/string.h"


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
      __attribute__ ((__pure__)) ;


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
			 locale_t __l)  
     ;
#line 182 "/usr/include/string.h"

#line 184 "/usr/include/string.h"

extern char *strdup (const char *__s)
      __attribute__ ((__malloc__)) ;
#line 188 "/usr/include/string.h"




#line 193 "/usr/include/string.h"
extern char *strndup (const char *__string, size_t __n)
      __attribute__ ((__malloc__)) ;
#line 196 "/usr/include/string.h"

#line 198 "/usr/include/string.h"

#line 200 "/usr/include/string.h"


#line 204 "/usr/include/string.h"


#line 229 "/usr/include/string.h"
extern char *strchr (const char *__s, int __c)
      __attribute__ ((__pure__)) ;
#line 232 "/usr/include/string.h"

#line 256 "/usr/include/string.h"
extern char *strrchr (const char *__s, int __c)
      __attribute__ ((__pure__)) ;
#line 259 "/usr/include/string.h"

#line 261 "/usr/include/string.h"


#line 269 "/usr/include/string.h"
extern char *strchrnul (const char *__s, int __c)
      __attribute__ ((__pure__)) ;
#line 273 "/usr/include/string.h"



extern size_t strcspn (const char *__s, const char *__reject)
      __attribute__ ((__pure__)) ;


extern size_t strspn (const char *__s, const char *__accept)
      __attribute__ ((__pure__)) ;

#line 306 "/usr/include/string.h"
extern char *strpbrk (const char *__s, const char *__accept)
      __attribute__ ((__pure__)) ;
#line 309 "/usr/include/string.h"

#line 333 "/usr/include/string.h"
extern char *strstr (const char *__haystack, const char *__needle)
      __attribute__ ((__pure__)) ;
#line 336 "/usr/include/string.h"



extern char *strtok (char *__restrict __s, const char *__restrict __delim)
      ;



extern char *__strtok_r (char *__restrict __s,
			 const char *__restrict __delim,
			 char **__restrict __save_ptr)
      ;
#line 349 "/usr/include/string.h"
extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
		       char **__restrict __save_ptr)
      ;
#line 353 "/usr/include/string.h"

#line 355 "/usr/include/string.h"

#line 363 "/usr/include/string.h"
extern char *strcasestr (const char *__haystack, const char *__needle)
      __attribute__ ((__pure__)) ;
#line 367 "/usr/include/string.h"

#line 369 "/usr/include/string.h"



extern void *memmem (const void *__haystack, size_t __haystacklen,
		     const void *__needle, size_t __needlelen)
      __attribute__ ((__pure__)) 
    
    ;



extern void *__mempcpy (void *__restrict __dest,
			const void *__restrict __src, size_t __n)
      ;
extern void *mempcpy (void *__restrict __dest,
		      const void *__restrict __src, size_t __n)
      ;
#line 387 "/usr/include/string.h"



extern size_t strlen (const char *__s)
      __attribute__ ((__pure__)) ;

#line 394 "/usr/include/string.h"


extern size_t strnlen (const char *__string, size_t __maxlen)
      __attribute__ ((__pure__)) ;
#line 399 "/usr/include/string.h"



extern char *strerror (int __errnum) ;
#line 404 "/usr/include/string.h"







#line 425 "/usr/include/string.h"


extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
         ;
#line 430 "/usr/include/string.h"

#line 432 "/usr/include/string.h"

extern const char *strerrordesc_np (int __err) ;

extern const char *strerrorname_np (int __err) ;
#line 438 "/usr/include/string.h"

#line 440 "/usr/include/string.h"

extern char *strerror_l (int __errnum, locale_t __l) ;
#line 443 "/usr/include/string.h"

#line 1 "/usr/include/strings.h"

















#line 20 "/usr/include/strings.h"

#line 1 "/usr/include/features.h"
















#line 22 "/usr/include/strings.h"
#line 1 "/usr/lib/clang/21/include/stddef.h"





















#line 37 "/usr/lib/clang/21/include/stddef.h"

#line 80 "/usr/lib/clang/21/include/stddef.h"

#line 85 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_size_t.h"












#line 88 "/usr/lib/clang/21/include/stddef.h"
#line 90 "/usr/lib/clang/21/include/stddef.h"

#line 95 "/usr/lib/clang/21/include/stddef.h"

#line 100 "/usr/lib/clang/21/include/stddef.h"

#line 105 "/usr/lib/clang/21/include/stddef.h"

#line 110 "/usr/lib/clang/21/include/stddef.h"

#line 115 "/usr/lib/clang/21/include/stddef.h"

#line 120 "/usr/lib/clang/21/include/stddef.h"

#line 125 "/usr/lib/clang/21/include/stddef.h"



#line 132 "/usr/lib/clang/21/include/stddef.h"
#line 24 "/usr/include/strings.h"


#line 29 "/usr/include/strings.h"



#line 33 "/usr/include/strings.h"

extern int bcmp (const void *__s1, const void *__s2, size_t __n)
      __attribute__ ((__pure__)) ;


extern void bcopy (const void *__src, void *__dest, size_t __n)
   ;


extern void bzero (void *__s, size_t __n)  ;


#line 68 "/usr/include/strings.h"
extern char *index (const char *__s, int __c)
      __attribute__ ((__pure__)) ;
#line 71 "/usr/include/strings.h"


#line 96 "/usr/include/strings.h"
extern char *rindex (const char *__s, int __c)
      __attribute__ ((__pure__)) ;
#line 100 "/usr/include/strings.h"

#line 102 "/usr/include/strings.h"


extern int ffs (int __i)  __attribute__ ((__const__));
#line 106 "/usr/include/strings.h"



#line 110 "/usr/include/strings.h"
extern int ffsl (long int __l)  __attribute__ ((__const__));
extern int ffsll (long long int __ll)
      __attribute__ ((__const__));
#line 114 "/usr/include/strings.h"


extern int strcasecmp (const char *__s1, const char *__s2)
      __attribute__ ((__pure__)) ;


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
      __attribute__ ((__pure__)) ;

#line 124 "/usr/include/strings.h"

#line 1 "/usr/include/bits/types/locale_t.h"

















#line 126 "/usr/include/strings.h"


extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
      __attribute__ ((__pure__)) ;



extern int strncasecmp_l (const char *__s1, const char *__s2,
			  size_t __n, locale_t __loc)
      __attribute__ ((__pure__)) ;
#line 137 "/usr/include/strings.h"



#line 146 "/usr/include/strings.h"
#line 446 "/usr/include/string.h"



extern void explicit_bzero (void *__s, size_t __n)  
    ;



extern char *strsep (char **__restrict __stringp,
		     const char *__restrict __delim)
      ;
#line 458 "/usr/include/string.h"

#line 460 "/usr/include/string.h"

extern char *strsignal (int __sig) ;

#line 464 "/usr/include/string.h"

extern const char *sigabbrev_np (int __sig) ;


extern const char *sigdescr_np (int __sig) ;
#line 470 "/usr/include/string.h"


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
      ;
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
      ;



extern char *__stpncpy (char *__restrict __dest,
			const char *__restrict __src, size_t __n)
      ;
extern char *stpncpy (char *__restrict __dest,
		      const char *__restrict __src, size_t __n)
      ;
#line 486 "/usr/include/string.h"

#line 488 "/usr/include/string.h"

extern size_t strlcpy (char *__restrict __dest,
		       const char *__restrict __src, size_t __n)
    ;



extern size_t strlcat (char *__restrict __dest,
		       const char *__restrict __src, size_t __n)
     ;
#line 499 "/usr/include/string.h"

#line 501 "/usr/include/string.h"

extern int strverscmp (const char *__s1, const char *__s2)
      __attribute__ ((__pure__)) ;


extern char *strfry (char *__string)  ;


extern void *memfrob (void *__s, size_t __n)  
    ;

#line 513 "/usr/include/string.h"




#line 523 "/usr/include/string.h"
extern char *basename (const char *__filename)  ;
#line 527 "/usr/include/string.h"

#line 534 "/usr/include/string.h"


#line 92 "/usr/local/include/neo-c.h"
#line 1 "/usr/lib/clang/21/include/stdarg.h"





















#line 37 "/usr/lib/clang/21/include/stdarg.h"



#line 1 "/usr/lib/clang/21/include/__stdarg_header_macro.h"








#line 44 "/usr/lib/clang/21/include/stdarg.h"
#line 45 "/usr/lib/clang/21/include/stdarg.h"

#line 1 "/usr/lib/clang/21/include/__stdarg___gnuc_va_list.h"








#line 48 "/usr/lib/clang/21/include/stdarg.h"
#line 50 "/usr/lib/clang/21/include/stdarg.h"

#line 1 "/usr/lib/clang/21/include/__stdarg_va_list.h"









#line 12 "/usr/lib/clang/21/include/__stdarg_va_list.h"
typedef __builtin_va_list va_list;
#line 53 "/usr/lib/clang/21/include/stdarg.h"
#line 55 "/usr/lib/clang/21/include/stdarg.h"

#line 1 "/usr/lib/clang/21/include/__stdarg_va_arg.h"









#line 11 "/usr/lib/clang/21/include/__stdarg_va_arg.h"

#line 16 "/usr/lib/clang/21/include/__stdarg_va_arg.h"

#line 21 "/usr/lib/clang/21/include/__stdarg_va_arg.h"
#line 58 "/usr/lib/clang/21/include/stdarg.h"
#line 60 "/usr/lib/clang/21/include/stdarg.h"

#line 1 "/usr/lib/clang/21/include/__stdarg___va_copy.h"








#line 63 "/usr/lib/clang/21/include/stdarg.h"
#line 65 "/usr/lib/clang/21/include/stdarg.h"

#line 1 "/usr/lib/clang/21/include/__stdarg_va_copy.h"








#line 68 "/usr/lib/clang/21/include/stdarg.h"
#line 70 "/usr/lib/clang/21/include/stdarg.h"
#line 93 "/usr/local/include/neo-c.h"
#line 1 "/usr/include/limits.h"





















#line 24 "/usr/include/limits.h"

#line 1 "/usr/include/bits/libc-header-start.h"


























#line 30 "/usr/include/bits/libc-header-start.h"

#line 32 "/usr/include/bits/libc-header-start.h"

#line 1 "/usr/include/features.h"
















#line 34 "/usr/include/bits/libc-header-start.h"



#line 43 "/usr/include/bits/libc-header-start.h"























#line 84 "/usr/include/bits/libc-header-start.h"





#line 101 "/usr/include/bits/libc-header-start.h"


#line 27 "/usr/include/limits.h"





#line 33 "/usr/include/limits.h"




#line 114 "/usr/include/limits.h"

#line 116 "/usr/include/limits.h"

 




#line 123 "/usr/include/limits.h"

#line 1 "/usr/lib/clang/21/include/limits.h"







#line 10 "/usr/lib/clang/21/include/limits.h"

#line 14 "/usr/lib/clang/21/include/limits.h"



#line 20 "/usr/lib/clang/21/include/limits.h"



#line 26 "/usr/lib/clang/21/include/limits.h"



#line 41 "/usr/lib/clang/21/include/limits.h"

#line 45 "/usr/lib/clang/21/include/limits.h"


#line 51 "/usr/lib/clang/21/include/limits.h"

#line 56 "/usr/lib/clang/21/include/limits.h"

#line 65 "/usr/lib/clang/21/include/limits.h"

#line 69 "/usr/lib/clang/21/include/limits.h"

#line 71 "/usr/lib/clang/21/include/limits.h"


#line 89 "/usr/lib/clang/21/include/limits.h"

#line 97 "/usr/lib/clang/21/include/limits.h"




#line 102 "/usr/lib/clang/21/include/limits.h"

#line 106 "/usr/lib/clang/21/include/limits.h"

#line 111 "/usr/lib/clang/21/include/limits.h"






#line 118 "/usr/lib/clang/21/include/limits.h"

#line 122 "/usr/lib/clang/21/include/limits.h"

#line 127 "/usr/lib/clang/21/include/limits.h"
#line 125 "/usr/include/limits.h"
#line 126 "/usr/include/limits.h"




#line 141 "/usr/include/limits.h"




#line 180 "/usr/include/limits.h"




#line 192 "/usr/include/limits.h"

#line 194 "/usr/include/limits.h"

#line 1 "/usr/include/bits/posix1_lim.h"























#line 26 "/usr/include/bits/posix1_lim.h"

#line 1 "/usr/include/bits/wordsize.h"


#line 10 "/usr/include/bits/wordsize.h"

#line 12 "/usr/include/bits/wordsize.h"

#line 14 "/usr/include/bits/wordsize.h"
#line 28 "/usr/include/bits/posix1_lim.h"




#line 33 "/usr/include/bits/posix1_lim.h"


#line 36 "/usr/include/bits/posix1_lim.h"


#line 39 "/usr/include/bits/posix1_lim.h"


#line 46 "/usr/include/bits/posix1_lim.h"


#line 49 "/usr/include/bits/posix1_lim.h"



#line 53 "/usr/include/bits/posix1_lim.h"


#line 56 "/usr/include/bits/posix1_lim.h"


#line 59 "/usr/include/bits/posix1_lim.h"


#line 62 "/usr/include/bits/posix1_lim.h"



#line 66 "/usr/include/bits/posix1_lim.h"


#line 69 "/usr/include/bits/posix1_lim.h"


#line 72 "/usr/include/bits/posix1_lim.h"


#line 75 "/usr/include/bits/posix1_lim.h"


#line 82 "/usr/include/bits/posix1_lim.h"


#line 89 "/usr/include/bits/posix1_lim.h"

#line 91 "/usr/include/bits/posix1_lim.h"


#line 95 "/usr/include/bits/posix1_lim.h"


#line 98 "/usr/include/bits/posix1_lim.h"


#line 101 "/usr/include/bits/posix1_lim.h"



#line 105 "/usr/include/bits/posix1_lim.h"


#line 108 "/usr/include/bits/posix1_lim.h"


#line 111 "/usr/include/bits/posix1_lim.h"


#line 114 "/usr/include/bits/posix1_lim.h"


#line 117 "/usr/include/bits/posix1_lim.h"


#line 120 "/usr/include/bits/posix1_lim.h"


#line 123 "/usr/include/bits/posix1_lim.h"


#line 126 "/usr/include/bits/posix1_lim.h"



#line 130 "/usr/include/bits/posix1_lim.h"


#line 133 "/usr/include/bits/posix1_lim.h"


#line 136 "/usr/include/bits/posix1_lim.h"


#line 143 "/usr/include/bits/posix1_lim.h"

#line 145 "/usr/include/bits/posix1_lim.h"

#line 147 "/usr/include/bits/posix1_lim.h"



#line 151 "/usr/include/bits/posix1_lim.h"


#line 155 "/usr/include/bits/posix1_lim.h"


#line 158 "/usr/include/bits/posix1_lim.h"



#line 1 "/usr/include/bits/local_lim.h"























#line 36 "/usr/include/bits/local_lim.h"


#line 1 "/usr/include/linux/limits.h"

#line 4 "/usr/include/linux/limits.h"

#line 6 "/usr/include/linux/limits.h"

#line 18 "/usr/include/linux/limits.h"

#line 20 "/usr/include/linux/limits.h"
#line 39 "/usr/include/bits/local_lim.h"


#line 45 "/usr/include/bits/local_lim.h"

#line 50 "/usr/include/bits/local_lim.h"

#line 55 "/usr/include/bits/local_lim.h"

#line 60 "/usr/include/bits/local_lim.h"


#line 63 "/usr/include/bits/local_lim.h"

#line 65 "/usr/include/bits/local_lim.h"


#line 68 "/usr/include/bits/local_lim.h"

#line 70 "/usr/include/bits/local_lim.h"


#line 73 "/usr/include/bits/local_lim.h"

#line 75 "/usr/include/bits/local_lim.h"



#line 79 "/usr/include/bits/local_lim.h"


#line 1 "/usr/include/bits/pthread_stack_min-dynamic.h"


















#line 23 "/usr/include/bits/pthread_stack_min-dynamic.h"

extern long int __sysconf (int __name) ;
#line 82 "/usr/include/bits/local_lim.h"


#line 85 "/usr/include/bits/local_lim.h"


#line 88 "/usr/include/bits/local_lim.h"


#line 91 "/usr/include/bits/local_lim.h"


#line 94 "/usr/include/bits/local_lim.h"


#line 97 "/usr/include/bits/local_lim.h"

#line 162 "/usr/include/bits/posix1_lim.h"


#line 165 "/usr/include/bits/posix1_lim.h"



#line 174 "/usr/include/bits/posix1_lim.h"





#line 182 "/usr/include/bits/posix1_lim.h"
#line 196 "/usr/include/limits.h"
#line 197 "/usr/include/limits.h"

#line 1 "/usr/include/bits/posix2_lim.h"





















#line 24 "/usr/include/bits/posix2_lim.h"



#line 28 "/usr/include/bits/posix2_lim.h"


#line 31 "/usr/include/bits/posix2_lim.h"


#line 34 "/usr/include/bits/posix2_lim.h"


#line 37 "/usr/include/bits/posix2_lim.h"



#line 41 "/usr/include/bits/posix2_lim.h"



#line 45 "/usr/include/bits/posix2_lim.h"


#line 48 "/usr/include/bits/posix2_lim.h"



#line 52 "/usr/include/bits/posix2_lim.h"



#line 56 "/usr/include/bits/posix2_lim.h"






#line 86 "/usr/include/bits/posix2_lim.h"


#line 89 "/usr/include/bits/posix2_lim.h"
#line 200 "/usr/include/limits.h"
#line 201 "/usr/include/limits.h"

#line 1 "/usr/include/bits/xopen_lim.h"




























#line 31 "/usr/include/bits/xopen_lim.h"































#line 63 "/usr/include/bits/xopen_lim.h"

#line 1 "/usr/include/bits/uio_lim.h"


















#line 21 "/usr/include/bits/uio_lim.h"









#line 31 "/usr/include/bits/uio_lim.h"
#line 65 "/usr/include/bits/xopen_lim.h"
#line 70 "/usr/include/bits/xopen_lim.h"



#line 74 "/usr/include/bits/xopen_lim.h"


#line 77 "/usr/include/bits/xopen_lim.h"


#line 80 "/usr/include/bits/xopen_lim.h"



#line 86 "/usr/include/bits/xopen_lim.h"


#line 89 "/usr/include/bits/xopen_lim.h"


#line 92 "/usr/include/bits/xopen_lim.h"


#line 95 "/usr/include/bits/xopen_lim.h"



#line 123 "/usr/include/bits/xopen_lim.h"


#line 129 "/usr/include/bits/xopen_lim.h"

#line 147 "/usr/include/bits/xopen_lim.h"
#line 204 "/usr/include/limits.h"
#line 96 "/usr/local/include/neo-c.h"
#line 1 "/usr/include/locale.h"





















#line 24 "/usr/include/locale.h"

#line 1 "/usr/include/features.h"
















#line 26 "/usr/include/locale.h"

#line 1 "/usr/lib/clang/21/include/stddef.h"





















#line 37 "/usr/lib/clang/21/include/stddef.h"

#line 80 "/usr/lib/clang/21/include/stddef.h"

#line 85 "/usr/lib/clang/21/include/stddef.h"

#line 90 "/usr/lib/clang/21/include/stddef.h"

#line 95 "/usr/lib/clang/21/include/stddef.h"

#line 100 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_null.h"









#line 11 "/usr/lib/clang/21/include/__stddef_null.h"






#line 18 "/usr/lib/clang/21/include/__stddef_null.h"

#line 28 "/usr/lib/clang/21/include/__stddef_null.h"
#line 103 "/usr/lib/clang/21/include/stddef.h"
#line 105 "/usr/lib/clang/21/include/stddef.h"

#line 110 "/usr/lib/clang/21/include/stddef.h"

#line 115 "/usr/lib/clang/21/include/stddef.h"

#line 120 "/usr/lib/clang/21/include/stddef.h"

#line 125 "/usr/lib/clang/21/include/stddef.h"



#line 132 "/usr/lib/clang/21/include/stddef.h"
#line 29 "/usr/include/locale.h"
#line 1 "/usr/include/bits/locale.h"


















#line 22 "/usr/include/bits/locale.h"

#line 25 "/usr/include/bits/locale.h"

#line 39 "/usr/include/bits/locale.h"
#line 30 "/usr/include/locale.h"





#line 48 "/usr/include/locale.h"



struct lconv
{
  

  char *decimal_point;		
  char *thousands_sep;		
  




  char *grouping;

  

  

  char *int_curr_symbol;
  char *currency_symbol;	
  char *mon_decimal_point;	
  char *mon_thousands_sep;	
  char *mon_grouping;		
  char *positive_sign;		
  char *negative_sign;		
  char int_frac_digits;		
  char frac_digits;		
  
  char p_cs_precedes;
  
  char p_sep_by_space;
  
  char n_cs_precedes;
  
  char n_sep_by_space;
  





  char p_sign_posn;
  char n_sign_posn;
#line 94 "/usr/include/locale.h"
  
  char int_p_cs_precedes;
  
  char int_p_sep_by_space;
  
  char int_n_cs_precedes;
  
  char int_n_sep_by_space;
  





  char int_p_sign_posn;
  char int_n_sign_posn;
#line 118 "/usr/include/locale.h"
};



extern char *setlocale (int __category, const char *__locale) ;


extern struct lconv *localeconv (void) ;


#line 129 "/usr/include/locale.h"






#line 1 "/usr/include/bits/types/locale_t.h"

















#line 136 "/usr/include/locale.h"





extern locale_t newlocale (int __category_mask, const char *__locale,
			   locale_t __base) ;





#line 161 "/usr/include/locale.h"



extern locale_t duplocale (locale_t __dataset) ;



extern void freelocale (locale_t __dataset) ;






extern locale_t uselocale (locale_t __dataset) ;



#line 180 "/usr/include/locale.h"

#line 182 "/usr/include/locale.h"


#line 97 "/usr/local/include/neo-c.h"
#line 1 "/usr/include/errno.h"





















#line 24 "/usr/include/errno.h"

#line 1 "/usr/include/features.h"
















#line 26 "/usr/include/errno.h"


#line 1 "/usr/include/bits/errno.h"


















#line 21 "/usr/include/bits/errno.h"

#line 25 "/usr/include/bits/errno.h"

#line 1 "/usr/include/linux/errno.h"
#line 1 "/usr/include/asm/errno.h"
#line 1 "/usr/include/asm-generic/errno.h"

#line 4 "/usr/include/asm-generic/errno.h"

#line 1 "/usr/include/asm-generic/errno-base.h"

#line 4 "/usr/include/asm-generic/errno-base.h"

#line 39 "/usr/include/asm-generic/errno-base.h"
#line 6 "/usr/include/asm-generic/errno.h"

#line 10 "/usr/include/asm-generic/errno.h"








#line 19 "/usr/include/asm-generic/errno.h"

#line 39 "/usr/include/asm-generic/errno.h"

#line 41 "/usr/include/asm-generic/errno.h"

#line 106 "/usr/include/asm-generic/errno.h"

#line 114 "/usr/include/asm-generic/errno.h"


#line 118 "/usr/include/asm-generic/errno.h"

#line 120 "/usr/include/asm-generic/errno.h"

#line 122 "/usr/include/asm-generic/errno.h"
#line 2 "/usr/include/asm/errno.h"
#line 2 "/usr/include/linux/errno.h"
#line 27 "/usr/include/bits/errno.h"


#line 32 "/usr/include/bits/errno.h"

#line 36 "/usr/include/bits/errno.h"

#line 40 "/usr/include/bits/errno.h"

#line 44 "/usr/include/bits/errno.h"

#line 48 "/usr/include/bits/errno.h"

#line 52 "/usr/include/bits/errno.h"
#line 29 "/usr/include/errno.h"



#line 33 "/usr/include/errno.h"




extern int *__errno_location (void)  __attribute__ ((__const__));
#line 39 "/usr/include/errno.h"

#line 41 "/usr/include/errno.h"




extern char *program_invocation_name;
extern char *program_invocation_short_name;

#line 1 "/usr/include/bits/types/error_t.h"


















#line 21 "/usr/include/bits/types/error_t.h"

typedef int error_t;
#line 49 "/usr/include/errno.h"

#line 51 "/usr/include/errno.h"


#line 98 "/usr/local/include/neo-c.h"
#line 1 "/usr/include/assert.h"





















#line 33 "/usr/include/assert.h"

#line 1 "/usr/include/features.h"
















#line 36 "/usr/include/assert.h"

#line 42 "/usr/include/assert.h"






#line 63 "/usr/include/assert.h"




extern void __assert_fail (const char *__assertion, const char *__file,
			   unsigned int __line, const char *__function)
      __attribute__ ((__noreturn__)) ;


extern void __assert_perror_fail (int __errnum, const char *__file,
				  unsigned int __line, const char *__function)
      __attribute__ ((__noreturn__)) ;




extern void __assert (const char *__assertion, const char *__file, int __line)
      __attribute__ ((__noreturn__)) ;







#line 103 "/usr/include/assert.h"





#line 110 "/usr/include/assert.h"

#line 114 "/usr/include/assert.h"






#line 129 "/usr/include/assert.h"

#line 131 "/usr/include/assert.h"

#line 99 "/usr/local/include/neo-c.h"
#line 1 "/usr/lib/clang/21/include/stdbool.h"









#line 12 "/usr/lib/clang/21/include/stdbool.h"

#line 14 "/usr/lib/clang/21/include/stdbool.h"

#line 18 "/usr/lib/clang/21/include/stdbool.h"

#line 37 "/usr/lib/clang/21/include/stdbool.h"
#line 100 "/usr/local/include/neo-c.h"
    
#line 102 "/usr/local/include/neo-c.h"
    
    using neo-c;
    using unsafe;
#line 106 "/usr/local/include/neo-c.h"




struct buffer 
{
    char*% buf;
    int len;
    int size;
};

uniq buffer*% buffer*::initialize(buffer*% self);
uniq void buffer*::finalize(buffer* self);
uniq buffer*% buffer*::clone(buffer* self);
uniq _Bool buffer*::equals(buffer* left, buffer* right);
uniq buffer* buffer*::append_str(buffer* self, const char* mem);
uniq buffer* buffer*::append(buffer* self, const char* mem, size_t size);
uniq string xsprintf(const char* msg, ...);
uniq string char*::to_string(const char* self);
uniq string int::to_string(int self);
uniq unsigned int _Bool::get_hash_key(_Bool value);
uniq unsigned int _Bool::get_hash_key(_Bool value);
uniq unsigned int char::get_hash_key(char value);
uniq unsigned int short::get_hash_key(short int value);
uniq unsigned int int::get_hash_key(int value);
uniq unsigned int long::get_hash_key(long value);
uniq unsigned int size_t::get_hash_key(size_t value);
uniq unsigned int float::get_hash_key(float value);
uniq unsigned int double::get_hash_key(double value);
uniq unsigned int char*::get_hash_key(const char* value);
uniq unsigned int string::get_hash_key(char* value);
uniq unsigned int void*::get_hash_key(void* value);
uniq string char*::substring(const char* str, int head, int tail);
uniq buffer* buffer*::append_format(buffer* self, const char* msg, ...);
uniq string buffer*::to_string(buffer* self);
uniq string char*::to_string(const char* self);
uniq string double::to_string(double self);
uniq string float::to_string(float self);
uniq string size_t::to_string(size_t self);
uniq string long::to_string(long self);
uniq string int::to_string(int self);
uniq string short::to_string(short self);
uniq string char::to_string(char self);
uniq string _Bool::to_string(_Bool self);
uniq string _Bool::to_string(_Bool self);
uniq _Bool string::equals(char* self, const char* right);

#line 155 "/usr/local/include/neo-c.h"

struct neo_frame {
    void* stacktop;
    neo_frame *prev;
    char* fun_name;
};
    
using unsafe {
uniq __thread neo_frame* neo_current_frame = (void*)0;
}

uniq void stackframe()
{
    neo_frame *f = neo_current_frame;
    while(f) {
        char* fun_name = f->fun_name;
        
        printf("%s\n", fun_name);
        f = f->prev;
    }
}

uniq _Bool die(const char* msg)
{
    puts(msg);
    stackframe();
    exit(4);
    
    return false;
}




struct sMemHeader
{
    long size;
    long compiletime_size;
    int allocated;            
    struct sMemHeader* next;
    struct sMemHeader* prev;
    struct sMemHeader* free_next;
    
    char* fun_name[8];
    
    const char* class_name;
};

using unsafe {
uniq sMemHeader* gAllocMem = (void*)0;
}
    
uniq void come_heap_final()
{
    using unsafe;
    
    sMemHeader* it = gAllocMem;
    int n = 0;
    while(it) {
        n++;
        
        _Bool flag = false;
        printf("#%d ", n);
        if(it->class_name) {
            printf("%p (%s): ", (char*)it + sizeof(sMemHeader) + sizeof(size_t) + sizeof(size_t), it->class_name);
        }
        for(int i=0; i<8; i++) {
            if(it->fun_name[i]) {
                printf("%s, ", it->fun_name[i]);
                flag = true;
            }
        }
        if(flag) {
            puts("");
        }
        it = it->next;
    }
    if(n > 0) printf("%d memory leaks. %d alloc, %d free.\n", n, gNumAlloc, gNumFree);
}
    
uniq void* alloc_from_pages(size_t size)
{
    using unsafe; 
    
    return calloc(1, size);
}
    
uniq void come_free_mem_of_heap_pool(void* mem)
{
    using unsafe; 
    
    if(mem) {
        sMemHeader* it = (sMemHeader*)((char*)mem - sizeof(sMemHeader));
        
        if(it->allocated != 177783) {
            return;
        }
        
        it->allocated = 0;
        
        sMemHeader* prev_it = it->prev;
        sMemHeader* next_it = it->next;
        
        if(gAllocMem == it) {
            gAllocMem = next_it;
            
            if(gAllocMem) {
                gAllocMem->prev = null;
            }
        }
        else {
            if(prev_it) {
                prev_it->next = next_it;
            }
            if(next_it) {
                next_it->prev = prev_it;
            }
        }
        
        size_t size = it->size;
        
        free(it);
        
        gNumFree++;
    }
}

uniq void* come_alloc_mem_from_heap_pool(size_t compiletime_size, size_t size, const char* sname=null, int sline=0, const char* class_name="")
{
    using unsafe; 
    
    size_t size2 = size + sizeof(sMemHeader);
#line 290 "/usr/local/include/neo-c.h"
    size2 = (size2 + 7 & ~0x7);
#line 292 "/usr/local/include/neo-c.h"
    void* result = alloc_from_pages(size2);
    
    sMemHeader* it = result;
    
    it->allocated = 177783;
    
    it->compiletime_size = compiletime_size;
    it->size = size2;
    it->free_next = ((void*)0);
    
    int n = 0;
    neo_frame *f = neo_current_frame;
    while(f && n < 8) {
        char* fun_name = f->fun_name;
        
        it.fun_name[n] = fun_name;
        
        n++;
        f = f->prev;
    }
    
    it->next = gAllocMem;
    it->prev = null;
    
    it->class_name = class_name; 
    
    if(gAllocMem) {
        gAllocMem->prev = it;
    }
    
    gAllocMem = it;
    
    gNumAlloc++;
    
    return (char*)result + sizeof(sMemHeader);
}

uniq char* come_dynamic_typeof(void* mem)
{
    using unsafe; 
    
    sMemHeader* it = (sMemHeader*)((char*)mem - sizeof(size_t) - sizeof(size_t) - sizeof(sMemHeader));
    
    if(it->allocated != 177783) {
        printf("invalid heap object(%p)(1)\n", it);
        stackframe();
        exit(2);
    }
    
    return (char*)it->class_name;
}

uniq size_t dynamic_sizeof(void* mem)
{
    using unsafe; 
    
    sMemHeader* it = (sMemHeader*)((char*)mem - sizeof(size_t) - sizeof(size_t) - sizeof(sMemHeader));
    
    if(it->allocated != 177783) {
        printf("invalid heap object(%p)(1)\n", it);
        stackframe();
        exit(2);
    }
    size_t size = it->compiletime_size;
    
    return size;
}

uniq int gComeDebugLib = 0;

uniq int gNumAlloc = 0;
uniq int gNumFree = 0;

uniq void* come_calloc(size_t count, size_t size, const char* sname=null, int sline=0, const char* class_name="")
{
    using unsafe; 
    
    char* mem = come_alloc_mem_from_heap_pool(count*size, sizeof(size_t)+sizeof(size_t)+count*size, sname, sline, class_name);
    
    size_t* ref_count = (size_t*)mem;

    *ref_count = 0;
    
    size_t* size2 = (size_t*)(mem + sizeof(size_t));
    
    *size2 = size*count + sizeof(size_t) + sizeof(size_t);
    
    return mem + sizeof(size_t) + sizeof(size_t);
}

uniq void come_free(void* mem)
{
    using unsafe; 
    
    if(mem == ((void*)0)) {
        return;
    }
    
    size_t* ref_count = (size_t*)((char*)mem - sizeof(size_t) - sizeof(size_t));
    
    come_free_mem_of_heap_pool((char*)ref_count);
}

uniq void* come_memdup(void* block, const char* sname=null, int sline=0, const char* class_name=null)
{
    using unsafe; 
    
    if(!block) {
        return null;
    }

    char* mem = (char*)block - sizeof(size_t) - sizeof(size_t);
    
    size_t* size_p = (size_t*)(mem + sizeof(size_t));

    size_t size = *size_p - sizeof(size_t) - sizeof(size_t);
    
    void* result = come_calloc(1, size, sname, sline, class_name);

    memcpy(result, block, size);
    
    return result;
}

uniq void* come_increment_ref_count(void* mem)
{
    using unsafe; 
    
    if(mem == ((void*)0)) {
        return mem;
    }
    
    size_t* ref_count = (size_t*)((char*)mem - sizeof(size_t) - sizeof(size_t));
    
    (*ref_count)++;
    
    return mem;
}

uniq void* come_print_ref_count(void* mem)
{
    using unsafe; 
    
    if(mem == ((void*)0)) {
        return mem;
    }
    
    size_t* ref_count = (size_t*)((char*)mem - sizeof(size_t) - sizeof(size_t));
    
    printf("ref_count %ld\n", *ref_count);
    
    return mem;
}

uniq int come_get_ref_count(void* mem)
{
    using unsafe; 
    
    if(mem == ((void*)0)) {
        return 0;
    }
    
    size_t* ref_count = (size_t*)((char*)mem - sizeof(size_t) - sizeof(size_t));
    
    return *ref_count;
}

uniq void* come_decrement_ref_count(void* mem, void* protocol_fun, void* protocol_obj, _Bool no_decrement, _Bool no_free, void* result_obj)
{
    using unsafe; 
    
    if(result_obj) {
        if(mem == result_obj) {
            return mem;
        }
    }
    if(mem == ((void*)0)) {
        return ((void*)0);
    }
    
    long* ref_count = (long*)((char*)mem - sizeof(size_t) - sizeof(size_t));
    
    if(!no_decrement) {
        (*ref_count)--;
    }
    
    long count = *ref_count;
    if(!no_free && count <= 0) {
        if(protocol_obj && protocol_fun) {
            void (*finalizer)(void*) = (void (*)(void*))protocol_fun;
            finalizer(protocol_obj);
            
            come_free(protocol_obj);
        }
        come_free(mem);
        return ((void*)0);
    }
    
    return mem;
}

uniq void come_call_finalizer(void* fun, void* mem, void* protocol_fun, void* protocol_obj, int call_finalizer_only, int no_decrement, int no_free, void* result_obj)
{
    using unsafe;
    
    if(result_obj) {
        if(mem == result_obj) {
            return;
        }
    }
    if(mem == ((void*)0)) {
        return;
    }
    
    if(call_finalizer_only) {
        if(fun) {
            if(protocol_obj && protocol_fun) {
                void (*finalizer)(void*) = (void (*)(void*))protocol_fun;
                finalizer(protocol_obj);
            }
            void (*finalizer)(void*) = (void (*)(void*))fun;
            finalizer(mem);
        }
        else {
            if(protocol_obj && protocol_fun) {
                void (*finalizer)(void*) = (void (*)(void*))protocol_fun;
                finalizer(protocol_obj);
            }
        }
    }
    else {
        long* ref_count = (long*)((char*)mem - sizeof(size_t) - sizeof(size_t));
        
        if(!no_decrement) {
            (*ref_count)--;
        }
        
        long count = *ref_count;
        if(!no_free && count <= 0) {
            if(mem) {
                if(fun) {
                    if(protocol_obj && protocol_fun) {
                        void (*finalizer)(void*) = (void (*)(void*))protocol_fun;
                        finalizer(protocol_obj);
                        come_free(protocol_obj);
                    }
                    if(fun) {
                        void (*finalizer)(void*) = (void (*)(void*))fun;
                        finalizer(mem);
                    }
                }
                else {
                    if(protocol_obj && protocol_fun) {
                        void (*finalizer)(void*) = (void (*)(void*))protocol_fun;
                        finalizer(protocol_obj);
                        come_free(protocol_obj);
                    }
                }
                come_free(mem);
            }
        }
    }
}

uniq void xassert(const char* msg, _Bool test)
{
    printf("%s...", msg);
    if(!test) {
        puts("false");
        stackframe();
        exit(2);
    }
    puts("ok");
}
        
uniq void* come_null_checker(void* mem, const char* sname, int sline)
{
    if(mem) {
        return mem;
    }
    
    puts(s"null pointer exception \{sname} \{sline}");
    stackframe();
    exit(1);
}

uniq string __builtin_string(const char* str)
{
    if(str == null) {
        return null;
    }
    int len = strlen(str) + 1;
    
    char*% result = new char[len];

    strncpy(result, str, len);

    return result;
}

#line 608 "/usr/local/include/neo-c.h"




struct ref<T>
{
    T p;
    _Bool global;
    _Bool heap;
    _Bool local;
    
    void* stacktop;
};

impl ref<T>
{
    ref<T>*% initialize(ref<T>*% self, T p, _Bool global_, _Bool heap_, _Bool local_, void* stacktop) {
        if(!ispointer(T) || p == null) {
            puts(s"ref is pointer and not null");
            stackframe();
            exit(2);
        }
        self.p = p;
        self.global = global_;
        self.heap = heap_;
        self.local = local_;
        self.stacktop = stacktop;
        return self;
    }
    
    _norecord T unwrap(ref<T>* self) {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        if(self.local) {
            if(self.stacktop < neo_current_frame.stacktop) {
                puts("refferenced object is vanished");
                stackframe();
                exit(127);
            }
        }
        return self.p;
    }
    _norecord T] operator_derefference(ref<T>* self)
    {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        if(self.local) {
            if(self.stacktop < neo_current_frame.stacktop) {
                puts("refferenced object is vanished");
                stackframe();
                exit(127);
            }
        }
        
        return *self.p;
    }
}




struct optional<T>
{
    T p;
    _Bool global;
    _Bool heap;
    _Bool local;
    
    void* stacktop;
};

impl optional<T>
{
    optional<T>*% initialize(optional<T>*% self, T p, _Bool global_, _Bool heap_, _Bool local_, void* stacktop) {
        self.p = p;
        self.global = global_;
        self.heap = heap_;
        self.local = local_;
        self.stacktop = stacktop;
        return self;
    }
    
    _norecord T unwrap(optional<T>* self) {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        if(self.local) {
            if(self.stacktop < neo_current_frame.stacktop) {
                puts("refferenced object is vanished");
                stackframe();
                exit(127);
            }
        }
        if(ispointer(T) && self.p == (void*)0) {
            puts("null pointer exception");
            stackframe();
            exit(2);
        }
        return self.p;
    }
    _norecord T] operator_derefference(optional<T>* self)
    {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception");
            stackframe();
            exit(2);
        }
        
        if(self.local) {
            if(self.stacktop < neo_current_frame.stacktop) {
                puts("refferenced object is vanished");
                stackframe();
                exit(127);
            }
        }
        if(ispointer(T) && self.p == (void*)0) {
            puts("null pointer exception");
            stackframe();
            exit(2);
        }
        
        T p = self.p;
        
        return *p;
    }
}





#line 759 "/usr/local/include/neo-c.h"




struct span<T> {
    char* memory;
    T^ p;
    size_t len;
    _Bool local;
    void* stacktop;
};

impl span<T>
{
    span<T>*% initialize(span<T>*% self, void*& refference, void* head, size_t len) {
        using unsafe; 
        
        if(!ispointer(T)) {
            puts("invalid span");
            stackframe();
            exit(2);
        }
        self.memory = (char*)head;
        
        self.p = (T^)head;
        self.len = len;
        self.local = refference\.local;
        self.stacktop = refference\.stacktop;
        
        return self;
    }
    _norecord T^ unwrap(span<T>* self) {
        using unsafe; 
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        if(self->local) {
            if(self->stacktop < neo_current_frame.stacktop) {
                puts("refferenced object is vanished");
                stackframe();
                exit(127);
            }
        }
        if(sizeof(T]) > self.len) {
            puts("invalid span. len is few");
            stackframe();
            exit(2);
        }
        if(self.p >= (char*)self.memory + self.len) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        if(self.p < (char*)self.memory) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        
        return (T^)self.p;
    }
    
    _norecord span<T>* operator_plus_plus(span<T>* self) {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        self.p++;
        
        return self;
    }
    _norecord span<T>* operator_plus_equal(span<T>* self, size_t value) {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        self.p += value;
        
        return self;
    }
    
    _norecord span<T>* operator_minus_minus(span<T>* self) {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        self.p--;
        
        return self;
    }
    
    _norecord span<T>* operator_minus_equal(span<T>* self, size_t value) {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        self.p -= value;
        
        return self;
    }
    
    _norecord T^ operator_add(span<T>* self, size_t rvalue) {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        T^ result = self.p + rvalue;
        
        return result;
    }
    
    _norecord T^ operator_sub(span<T>* self, size_t rvalue) {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        T^ result = self.p - rvalue;
        
        return result;
    }
    
    _norecord T]^ operator_derefference(span<T>* self) {
        using unsafe;
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        if(self->local) {
            if(self->stacktop < neo_current_frame.stacktop) {
                puts("refferenced object is vanished");
                stackframe();
                exit(127);
            }
        }
        
        T^ p = self.p;
        
        if(sizeof(T]) > self.len) {
            puts("invalid span. len is few");
            stackframe();
            exit(2);
        }
        if(self.p >= (char*)self.memory + self.len) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        if(self.p < (char*)self.memory) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        
        return *p;
    }
    _norecord void operator_store_element(span<T>* self, int position, T^] item) {
        using unsafe; 
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        if(self->local) {
            if(self->stacktop < neo_current_frame.stacktop) {
                puts("refferenced object is vanished");
                stackframe();
                exit(127);
            }
        }
        if(sizeof(T]) > self.len) {
            puts("invalid span. len is few");
            stackframe();
            exit(2);
        }
        if(self.p + position >= (char*)self.memory + self.len) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        if(self.p + position < (char*)self.memory) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        
        T^ p = self.p;
        
        p\[position] = item;
    }
    _norecord T^] operator_load_element(span<T>* self, int position) {
        using unsafe; 
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        if(self->local) {
            if(self->stacktop < neo_current_frame.stacktop) {
                puts("refferenced object is vanished");
                stackframe();
                exit(127);
            }
        }
        if(sizeof(T]) > self.len) {
            puts("invalid span. len is few");
            stackframe();
            exit(2);
        }
        if(self.p + position >= (char*)self.memory + self.len) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        if(self.p + position < (char*)self.memory) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        
        T^ p = self.p;
        
        return p\[position];
    }
    
    _norecord string to_string(span<T>* self) {
        using unsafe; 
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        return s"head \{self.memory} p \{self.p} len \{self.len}";
    }
    _norecord int len(span<T>* self) {
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        return self.len;
    }
    _norecord int memcmp(span<T>* self, void* mem, size_t len) {
        using unsafe; 
        
        if(self == null) {
            puts("null pointer exception. self is null");
            stackframe();
            exit(2);
        }
        
        if(self->local) {
            if(self->stacktop < neo_current_frame.stacktop) {
                puts("refferenced object is vanished");
                stackframe();
                exit(127);
            }
        }
        if(sizeof(T]) > self.len) {
            puts("invalid span. len is few");
            stackframe();
            exit(2);
        }
        if((char*)self.p >= (char*)self.memory + self.len) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        if((char*)self.p + len >= (char*)self.memory + self.len) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        if(self.p < (char*)self.memory) {
            puts("out of range of span");
            stackframe();
            exit(1);
        }
        
        return memcmp((void*)self.p, mem, len);
    }
}




struct rawptr<T> {
    T* p;
};

impl rawptr<T>
{
    rawptr<T>*% initialize(rawptr<T>*% self, void* memory)
    {
        self.p = memory;
        
        return self;
    }
    
    T* unwrap(rawptr<T>* self) {
        return self.p;
    }
    
    rawptr<T>* operator_plus_plus(rawptr<T>* self) {
        using unsafe;
        
        self.p++;
        
        return self;
    }
    rawptr<T>* operator_plus_equal(rawptr<T>* self, size_t value) {
        using unsafe;
        
        self.p += value;
        
        return self;
    }
    
    rawptr<T>* operator_minus_minus(rawptr<T>* self) {
        using unsafe;
        
        self.p--;
        
        return self;
    }
    
    rawptr<T>* operator_minus_equal(rawptr<T>* self, size_t value) {
        using unsafe;
        
        self.p -= value;
        
        return self;
    }
    
    T^ operator_add(rawptr<T>* self, size_t rvalue) {
        using unsafe;
        
        T^ result = self.p + rvalue;
        
        return result;
    }
    
    T^ operator_sub(rawptr<T>* self, size_t rvalue) {
        using unsafe;
        
        T^ result = self.p - rvalue;
        
        return result;
    }
    
    T^ operator_derefference(rawptr<T>* self) {
        using unsafe;
        
        T*^ p = self.p;
        
        return *p;
    }
    void operator_store_element(rawptr<T>* self, int position, T] item) {
        using unsafe; 
        
        T*^ p = self.p;
        
        p\[position] = item;
    }
    T^ operator_load_element(rawptr<T>* self, int position) {
        using unsafe; 
        
        T*^ p = self.p;
        
        return p\[position];
    }
    
    string to_string(rawptr<T>* self) {
        using unsafe; 
        
        return s"head \{self.memory} p";
    }
}




struct list_item<T>
{
    T item;
    list_item<T>* prev;
    list_item<T>* next;
};

struct list<T>
{
    list_item<T>* head;
    list_item<T>* tail;
    int len;

    list_item<T>* it;
};

impl list <T>
{
    list<T>*% initialize(list<T>*% self) {
        self.head = null;
        self.tail = null;
        self.len = 0;

        return self;
    }
    list<T>*% initialize_with_values(list<T>*% self, int num_value, T^* values) 
    {
        self.head = null;
        self.tail = null;
        self.len = 0;
        
        for(int i=0; i<num_value; i++) {
            self.push_back(dummy_heap values[i]);
        }

        return self;
    }
    void finalize(list<T>* self) {
        if(self == null) return;
        
        list_item<T>* it = self.head;
        while(it != null) {
            var prev_it = it;
            it = it.next;
            delete prev_it;
        }
    }
    list<T>*% clone(list<T>* self) {
        if(self == null) {
            return null;
        }
        var result = new list<T>();

        list_item<T>* it = self.head;
        while(it != null) {
            if(isheap(T)) {
                result.add(clone it.item);
            }
            else {
                result.add(dummy_heap dupe it.item);
            }

            it = it.next;
        }

        return result;
    }
    list<T>* add(list<T>* self, T item)
    {
        if(self == null) return self;
        
        if(self.len == 0) {
            list_item<T>* litem = borrow gc_inc(new list_item<T>);
            
            litem.prev = null;
            litem.next = null;
            litem.item = item;
            
            self.tail = litem;
            self.head = litem;
        }
        else if(self.len == 1) {
            list_item<T>* litem = borrow gc_inc(new list_item<T>);

            litem.prev = self.head;
            litem.next = null;
            litem.item = item;
            
            self.tail = litem;
            self.head.next = litem;
        }
        else {
            list_item<T>* litem = borrow gc_inc(new list_item<T>);

            litem.prev = self.tail;
            litem.next = null;
            litem.item = item;
            
            self.tail.next = litem;
            self.tail = litem;
        }

        self.len++;
        
        return self;
    }
    T pop_front(list<T>* self) {
        T result;

        if(self == null) { return result; }
        
        if(self.len == 1) {
            result = self.head.item;
            
            list_item<T>* litem = self.head;
            self.head = null;
            self.tail = null;
            
            delete borrow litem;
            
            self.len--;
        }
        else if(self.len == 2) {
            list_item<T>* litem = self.head;
            
            result = self.head.item;
            
            self.head = self.head.next;
            self.head.prev = null;
            self.head.next = null;
            self.tail = self.head;
            
            delete borrow litem;
            
            self.len--;
        }
        else if(self.len >= 3) {
            list_item<T>* litem = self.head;
            
            result = self.head.item;
            
            self.head = litem.next;
            self.head.prev = null;
            
            delete borrow litem;
            
            self.len--;
        }
        return result;
    }
    list<T>* push_back(list<T>* self, T item)
    {
        if(self == null) {
            return self;
        }
        
        if(self.len == 0) {
            list_item<T>* litem = borrow gc_inc(new list_item<T>);
            
            litem.prev = null;
            litem.next = null;
            litem.item = item;
            
            self.tail = litem;
            self.head = litem;
        }
        else if(self.len == 1) {
            list_item<T>* litem = borrow gc_inc(new list_item<T>);

            litem.prev = self.head;
            litem.next = null;
            litem.item = item;
            
            self.tail = litem;
            self.head.next = litem;
        }
        else {
            list_item<T>* litem = borrow gc_inc(new list_item<T>);

            litem.prev = self.tail;
            litem.next = null;
            litem.item = item;
            
            self.tail.next = litem;
            self.tail = litem;
        }

        self.len++;
        
        return self;
    }
    
    string to_string(list<T>* self)
    {
        if(self == null) {
            return string("");
        }
        
        buffer*% result = new buffer();
        
        result.append_str("[");
        list_item<T>* it = self.head;
        int i = 0;
        while(it != null) {
            result.append_str(it.item.to_string());
            it = it.next;
            
            i++;
            
            if(i != self.length()) {
                result.append_str(",");
            }
        }
        
        result.append_str("]");
        
        return result.to_string();
    }
    
    T^ begin(list<T>* self) {
        using unsafe;
        
        if(self == null) {
            T^` result;
            memset(&result, 0, sizeof(T));
            return result;
        }
        self.it = self.head;

        if(self.it) {
            return self.it.item;
        }
        
        T^` result;
        memset(&result, 0, sizeof(T));
        return result;
    }

    T^ next(list<T>* self) {
        using unsafe;
        
        if(self == null || self.it == null) {
            T^` result;
            memset(&result, 0, sizeof(T));
            return result;
        }
        
        self.it = self.it.next;

        if(self.it) {
            return self.it.item;
        }
        
        T^` result;
        memset(&result, 0, sizeof(T));
        return result;
    }

    _Bool end(list<T>* self) {
        return self == null || self.it == null;
    }
    list<T>* each(list<T>* self, void* parent, void (*block)(void*, T,int,_Bool*)) 
    {
        if(self == null) {
            return null;
        }
        
        list_item<T>* it = self.head;
        int i = 0;
        while(it != null) {
            _Bool end_flag = false;
            block(parent, it.item, i, &end_flag);

            if(end_flag == true) {
                break;
            }
            it = it.next;
            i++;
        }
        
        return self;
    }
    T item(list<T>* self, int position, T^ default_value) 
    {
        if(self == null) {
            return dummy_heap default_value;
        }
        
        if(position < 0) {
            position += self.len;
        }

        list_item<T>* it = self.head;
        var i = 0;
        while(it != null) {
            if(position == i) {
                return it.item;
            }
            it = it.next;
            i++;
        };

        return dummy_heap default_value;
    }

    int length(list<T>* self)
    {
        if(self == null) {
            return 0;
        }
        return self.len;
    }
    
    list<T>* insert(list<T>* self, int position, T item)
    {
        using unsafe;
        
        if(self == null) {
            return null;
        }
        if(position < 0) {
            position += self.len + 1;
        }
        if(position < 0) {
            position = 0;
        }
        if(self.len == 0 || position >= self.len) {
            int len = self.len;
            for(int i=0; i<position-len; i++) {
                T^` default_value;
                memset(&default_value, 0, sizeof(T));
                self.push_back(default_value);
            }
            self.push_back(item);
            return self;
        }

        if(position == 0) {
            list_item<T>* litem = borrow gc_inc(new list_item<T>);

            litem.prev = null;
            litem.next = self.head;
            litem.item = item;
            
            self.head.prev = litem;
            self.head = litem;

            self.len++;
        }
        else if(self.len == 1) {
            var litem = borrow gc_inc(new list_item<T>);

            litem.prev = self.head;
            litem.next = self.tail;
            litem.item = item;
            
            self.tail.prev = litem;
            self.head.next = litem;

            self.len++;
        }
        else {
            list_item<T>* it = self.head;
            int i = 0;
            while(it != null) {
                if(position == i) {
                    list_item<T>* litem = borrow gc_inc(new list_item<T>);

                    litem.prev = it.prev;
                    litem.next = it;
                    litem.item = item;

                    it.prev.next = litem;
                    it.prev = litem;

                    self.len++;
                }

                it = it.next;
                i++;
            }
        }
        
        return self;
    }
    list<T>* reset(list<T>* self) {
        if(self == null) {
            return self;
        }
        
        list_item<T>* it = self.head;
        while(it != null) {
            var prev_it = it;
            it = it.next;
            delete prev_it;
        }

        self.head = null;
        self.tail = null;

        self.len = 0;
        
        return self;
    }
    list<T>* remove(list<T>* self, T^ item, _Bool by_pointer=false) {
        if(self == null) {
            return self;
        }
        
        int it2 = 0;
        list_item<T>* it = self.head;
        while(it != null) {
            if((!by_pointer && it.item.equals(item)) || (by_pointer && it.item == item)) {
                self.delete(it2, it2+1);
                break;
            }
            it2++;
            
            it = it.next;
        }
        
        return self;
    }
    list<T>* delete(list<T>* self, int head, int tail)
    {
        if(self == null) {
            return self;
        }
        
        if(head < 0) {
            head += self.len;
        }
        if(tail < 0) {
            tail += self.len + 1;
        }

        if(head > tail) {
            int tmp = tail;
            tail = head;
            head = tmp;
        }

        if(head < 0) {
            head = 0;
        }

        if(tail > self.len) {
            tail = self.len;
        }
        
        if(head >= self.len) {
            return self;
        }

        if(head == tail) {
            return self;
        }
        
        if(head == 0 && tail == self.len) 
        {
            self.reset();
        }
        else if(head == 0) {
            list_item<T>* it = self.head;
            int i = 0;
            while(it != null) {
                if(i < tail) {
                    list_item<T>* prev_it = it;

                    it = it.next;
                    i++;

                    delete prev_it;

                    self.len--;
                }
                else if(i == tail) {
                    self.head = it;
                    self.head.prev = null;
                    break;
                }
                else {
                    it = it.next;
                    i++;
                }
            }
        }
        else if(tail == self.len) {
            list_item<T>* it = self.head;
            int i = 0;
            while(it != null) {
                if(i == head) {
                    self.tail = it.prev;
                    self.tail.next = null;
                }

                if(i >= head) {
                    list_item<T>* prev_it = it;

                    it = it.next;
                    i++;

                    delete prev_it;

                    self.len--;
                }
                else {
                    it = it.next;
                    i++;
                }
            }
        }
        else {
            list_item<T>* it = self.head;

            list_item<T>* head_prev_it = null;
            list_item<T>* tail_it = null;


            int i = 0;
            while(it != null) {
                if(i == head) {
                    head_prev_it = it.prev;
                }
                if(i == tail) {
                    tail_it = it;
                }

                if(i >= head && i < tail) 
                {
                    list_item<T>* prev_it = it;

                    it = it.next;
                    i++;

                    delete prev_it;

                    self.len--;
                }
                else {
                    it = it.next;
                    i++;
                }
            }

            if(head_prev_it != null) {
                head_prev_it.next = tail_it;
            }
            if(tail_it != null) {
                tail_it.prev = head_prev_it;
            }
        }
        
        return self;
    }
    list<T>* replace(list<T>* self, int position, T item)
    {
        using unsafe; 
        
        if(self == null) {
            return self;
        }
        
        if(position < 0) {
            position += self.len;
        }
        if(position < 0) {
            position = 0;
        }
        
        if(self.len == 0 || position >= self.len) {
            int len = self.len;
            for(int i=0; i<position-len; i++) {
                T^` default_value;
                memset(&default_value, 0, sizeof(T));
                self.push_back(default_value);
            }
            self.push_back(item);
            return self;
        }

        list_item<T>* it = self.head;
        int i = 0;
        while(it != null) {
            if(position == i) {
                it.item = item;
                break;
            }
            it = it.next;
            i++;
        }
        
        return self;
    }

    int find(list<T>* self, T^ item, int default_value, _Bool by_pointer=false) {
        if(self == null) {
            return default_value;
        }
        
        int it2 = 0;
        list_item<T>* it = self.head;
        while(it != null) {
            if((!by_pointer && it.item.equals(item)) || (by_pointer && it.item == item)) {
                return it2;
            }
            it2++;
            
            it = it.next;
        }

        return default_value;
    }
    _Bool equals(list<T>* left, list<T>* right)
    {
        if(left == null && right == null) {
            return true;
        }
        else if(left == null || right == null) {
            return false;
        }
        
        if(left.len != right.len) {
            return false;
        }

        list_item<T>* it = left.head;
        list_item<T>* it2 = right.head;

        while(it != null) {
            if(!it.item.equals(it2.item)) {
                return false;
            }

            it = it.next;
            it2 = it2.next;
        }

        return true;
    }
    list<T>*% sublist(list<T>* self, int begin, int tail) {
        if(self == null) {
            return self;
        }
        
        list<T>*% result = new list<T>.initialize();

        if(begin < 0) {
            begin += self.len;
        }

        if(tail < 0) {
            tail += self.len + 1;
        }

        if(begin < 0) {
            begin = 0;
        }
        
        if(begin >= self.len) {
            return new list<T>();
        }

        if(tail >= self.len) {
            tail = self.len;
        }

        list_item<T>* it = self.head;
        int i = 0;
        while(it != null) {
            if(i >= begin && i < tail) {
                result.push_back(it.item);
            }
            it = it.next;
            i++;
        };

        return result;
    }
    void operator_store_element(list<T>* self, int position, T item) {
        self.replace(position, item);
    }
    T operator_load_element(list<T>* self, int position) {
        using unsafe;
        
        if(self == null) {
            T^` default_value;
            memset(&default_value, 0, sizeof(T));
            return default_value;
        }
        
        if(position < 0) {
            position += self.len;
        }
        
        list_item<T>* it = self.head;
        var i = 0;
        while(it != null) {
            if(position == i) {
                return it.item;
            }
            it = it.next;
            i++;
        };

        T^` default_value;
        memset(&default_value, 0, sizeof(T));
        return default_value;
    }
    list<T>*% operator_load_range_element(list<T>* self, int begin, int tail) {
        list<T>*% result = new list<T>.initialize();
        
        if(self == null) {
            return result;
        }

        if(begin < 0) {
            begin += self.len;
        }

        if(tail < 0) {
            tail += self.len + 1;
        }

        if(begin < 0) {
            begin = 0;
        }

        if(tail >= self.len) {
            tail = self.len;
        }
        
        if(begin >= self.len) {
            return result;
        }

        list_item<T>* it = self.head;
        int i = 0;
        while(it != null) {
            if(i >= begin && i < tail) {
                result.push_back(it.item);
            }
            it = it.next;
            i++;
        };

        return result;
    }
    _Bool operator_equals(list<T>* left, list<T>* right) 
    {
        if(left == null && right == null) {
            return true;
        }
        else if(left == null || right == null) {
            return false;
        }
        
        if(left.len != right.len) {
            return false;
        }

        list_item<T>* it = left.head;
        list_item<T>* it2 = right.head;

        while(it != null) {
            if(!(it.item === it2.item)) {
                return false;
            }

            it = it.next;
            it2 = it2.next;
        }

        return true;
    }
    _Bool operator_not_equals(list<T>* left, list<T>* right) {
        return !left.operator_equals(right);
    }
    _Bool contained(list<T>* self, T^ item, _Bool by_pointer=false) {
        if(self == null) {
            return false;
        }
        
        for(var it = self.begin(); !self.end(); it = self.next()) {
            if((!by_pointer && it.equals(item)) || (by_pointer && it == item)) {
                return true;
            }
        }
        
        return false;
    }
    list<T>*% merge_list_with_lambda(list<T>* left, list<T>* right, int (*compare)(T^,T^)) {
        var result = new list<T>.initialize();

        list_item<T>* it = left.head;
        list_item<T>* it2= right.head;

        while(true) {
            if(it && it2) {
                if(it.item == null) {
                    it = it.next;
                }
                else if(it2.item == null) {
                    it2 = it2.next;
                }
                else if(compare(it.item, it2.item) <= 0) 
                {
                    if(isheap(T)) {
                        result.push_back(clone it.item);
                    }
                    else {
                        result.push_back(dummy_heap dupe it.item);
                    }

                    it = it.next;
                }
                else {
                    if(isheap(T)) {
                        result.push_back(clone it2.item);
                    }
                    else {
                        result.push_back(dummy_heap dupe it2.item);
                    }


                    it2 = it2.next;
                }
            }

            if(it == null) {
                if(it2 != null) {
                    while(it2 != null) {
                        if(isheap(T)) {
                            result.push_back(clone it2.item);
                        }
                        else {
                            result.push_back(dummy_heap dupe it2.item);
                        }

                        it2 = it2.next;
                    }
                }
                break;
            }
            else if(it2 == null) {
                if(it != null) {
                    while(it != null) {
                        if(isheap(T)) {
                            result.push_back(clone it.item);
                        }
                        else {
                            result.push_back(dummy_heap dupe it.item);
                        }

                        it = it.next;
                    }
                }
                break;
            }
        }

        return result;
    }
    list<T>*% merge_sort_with_lambda(list<T>* self, int (*compare)(T^,T^)) {
        if(self.head == null) {
            return clone self;
        }
        if(self.head.next == null) {
            return clone self;
        }

        var list1 = new list<T>.initialize();
        var list2 = new list<T>.initialize();

        list_item<T>* it = self.head;

        while(true) {
            list1.push_back(dupe it.item);
            list2.push_back(dupe it.next.item);

            if(it.next.next == null) {
                break;
            }

            it = it.next.next;

            if(it.next == null) {
                if(isheap(T)) {
                    list1.push_back(clone it.item);
                }
                else {
                    list1.push_back(dummy_heap dupe it.item);
                }
                break;
            }
        }
        
        var left_list = list1.merge_sort_with_lambda(compare);
        var right_list = list2.merge_sort_with_lambda(compare);
        
        return left_list.merge_list_with_lambda(right_list, compare);
    }
    list<T>*% sort_with_lambda(list<T>* self, int (*compare)(T^,T^)) {
        if(self == null) {
            return new list<T>();
        }
        return self.merge_sort_with_lambda(compare);
    }
    list<T>*% sort(list<T>* self) {
        if(self == null) {
            return new list<T>();
        }
        return self.merge_sort_with_lambda(int lambda(T^ left, T^ right) { return left.compare(right); });
    }
    
    template<R> list<R>*% map(list<T>* self, void* parent, R (*block)(void*, T))
    {
        if(self == null) {
            return new list<R>();
        }
        var result = new list<R>.initialize();

        list_item<T>* it = self.head;
        while(it != null) {
            R item = block(parent, it.item);
            result.push_back(item);

            it = it.next;
        }

        return result;
    }
    list<T>*% reverse(list<T>* self) {
        list<T>%* result = new list<T>();
        
        if(self == null) { 
            return result;
        }

        list_item<T>* it = self.tail;
        while(it != null) {
            result.push_back(dupe it.item);
            it = it.prev;
        };

        return result;
    }
    list<T>*% uniq(list<T>* self, _Bool by_pointer=false) {
        list<T>*% result = new list<T>.initialize();
        
        if(self == null) {
            return result;
        }

        if(self.length() > 0) {
            T item_before = self.head.item;

            result.push_back(dupe item_before);

            list_item<T>* it = self.head;
            it = it.next;
            while(it != null) {
                if(!((!by_pointer && it.item.equals(item_before)) || (by_pointer && it.item == item_before))) {
                    result.push_back(dupe it.item);
                }

                item_before = it.item;
                
                it = it.next;
            }
        }

        return result;
    }
    list<T>*% filter(list<T>* self, void* parent, _Bool (*block)(void*, T))
    {
        list<T>*% result = new list<T>();
        
        if(self == null) {
            return result;
        }

        list_item<T>* it = self.head;
        while(it != null) {
            if(block(parent, it.item)) {
                result.push_back(dupe it.item);
            }

            it = it.next;
        }

        return result;
    } 
    
    list<T>*% operator_add(list<T>*% left, list<T>*% right) {
        list<T>*% result = new list<T>();
        
        if(left == null || right == null) {
            return result;
        }

        list_item<T>* it = left.head;
        while(it != null) {
            result.push_back(dupe it.item);

            it = it.next;
        }

        it = right.head;
        while(it != null) {
            result.push_back(dupe it.item);

            it = it.next;
        }

        return result;
    }
    list<T>*% operator_mult(list<T>* left, int right) {
        list<T>*% result = new list<T>();
        
        if(left == null) {
            return result;
        }

        for(int i=0; i<right; i++) {
            list_item<T>* it = left.head;
            while(it != null) {
                result.push_back(dupe it.item);
    
                it = it.next;
            }
        }

        return result;
    }
    string join(list<T>* self, const char* sep=" ") {
        if(self == null) {
            return string("");
        }
        
        buffer*% buf = new buffer();
        
        int n = 0;
        for(var it = self.begin(); !self.end(); it = self.next()) {
            buf.append_str(it);
            
            if(n < self.length()-1) {
                buf.append_str(sep);
            }
            
            n++;
        }
        
        return buf.to_string();
    }
}





struct vector<T> 
{
    T^* items;
    int len;
    int size;

    int it;
};

impl vector<T> 
{
    vector<T>*% initialize(vector<T>*% self) 
    {
        self.size = 16;
        self.len = 0;
        self.items = borrow new T[self.size];
        
        return self;
    }
    vector<T>*% initialize_with_values(vector<T>*% self, int num_value, T^* values) 
    {
        using unsafe;
        
        self.size = num_value;
        self.len = num_value;
        self.items = borrow new T[self.size];
        
        memcpy(self.items, values, sizeof(T)*self.size);
        
        return self;
    }

    vector<T>*% clone(vector<T>* self)
    {
        using unsafe;
        
        vector<T>*% result = new vector<T>;

        result.len = self.len;
        result.size = self.size;
        result.it = 0;
        result.items = borrow new T[result.size];
        
        if(isheap(T)) {
            for(int i=0; i<self.len; i++) 
            {
                result.items[i] = borrow clone self.items[i];
            }
        }
        else {
            for(int i=0; i<self.len; i++) 
            {
                result.items[i] = self.items[i];
            }
        }

        return result;
    }

    void finalize(vector<T>* self)
    {
        using unsafe;
        
        if(isheap(T)) {
            for(int i=0; i<self.len; i++) 
            {
                delete borrow self.items[i];
            }
        }
        if(self && self.items) {
            come_free((char*)self.items);
        }
    }
    
    vector<T>*% operator_add(vector<T>* left, vector<T>* right) {
        using unsafe;
        
        vector<T>*% result = new vector<T>.initialize();
        
        foreach(it, left) {
            if(isheap(T)) {
                result.push_back(clone it);
            }
            else {
                result.push_back(dummy_heap it);
            }
        }
        
        foreach(it, right) {
            if(isheap(T)) {
                result.push_back(clone it);
            }
            else {
                result.push_back(dummy_heap it);
            }
        }
        
        return result;
    }
    vector<T>*% operator_mult(vector<T>* left, int n) {
        using unsafe;
        
        vector<T>*% result = new vector<T>.initialize();
        
        for(int i=0; i<n; i++) {
            foreach(it, left) {
                if(isheap(T)) {
                    result.push_back(clone it);
                }
                else {
                    result.push_back(dummy_heap it);
                }
            }
        }
        
        return result;
    }
    _Bool operator_equals(vector<T>* left, vector<T>* right) {
        return left.equals(right);
    }
    _Bool operator_not_equals(vector<T>* left, vector<T>* right) {
        return !left.equals(right);
    }
    void operator_store_element(vector<T>* self, int index, T item) {
        self.replace(index, item);
    }
    
    vector<T>* add(vector<T>* self, T` item) {
        using unsafe;
        
        if(self.len == self.size) {
            auto new_size = self.size * 2;
            auto items = self.items;

            self.items = come_calloc(1, sizeof(T)*new_size);

            int i;
            for(i=0; i<self.size; i++) {
                self.items[i] = items[i];
            }

            self.size = new_size;

            come_free((char*)items);
        }

        self.items[self.len] = dummy_heap item;
        self.len++;
        
        return self;
    }

    T item(vector<T>* self, int index, T default_value) 
    {
        using unsafe;
        
        if(index < 0) {
            index += self.len;
        }

        if(index >= 0 && index < self.len)
        {
            return self.items[index];
        }

        return default_value;
    }


    _Bool equals(vector<T>* left, vector<T>* right)
    {
        using unsafe;
        
        if(left.len != right.len) {
            return false;
        }

        for(int i=0; i<left.len; i++) {
            if(!(left.items[i].equals(right.items[i])))
            {
                return false;
            }
        }

        return true;
    }
    
    void replace(vector<T>* self, int index, T value)
    {
        using unsafe;
        
        if(index < 0) {
            index += self.len;
        }

        if(index >= 0 && index < self.len)
        {
            if(isheap(T)) {
                delete borrow self.items[index];
            }

            self.items[index] = value;
        }
    }
    
    int find(vector<T>* self, T^ item, int default_value) {
        using unsafe;
        
        int it2 = 0;
        foreach(it, self) {
            if(it.equals(item)) {
                return it2;
            }
            it2++;
        }

        return default_value;
    }

    int length(vector<T>* self)
    {
        using unsafe;
        
        return self.len;
    }
    
    int alloc_size(vector<T>* self)
    {
        using unsafe;
        
        return sizeof(T) * self.len;
    }

    void reset(vector<T>* self) {
        using unsafe;
        
        if(isheap(T)) {
            for(int i=0; i<self.len; i++) 
            {
                delete borrow self.items[i];
            }
        }
        come_free((char*)self.items);
        
        self.size = 16;
        self.len = 0;
        self.items = borrow new T[self.size];
        
        self.len = 0;
    }

    T^ begin(vector<T>* self) {
        using unsafe;
        
        self.it = 0;

        T^` default_value;
        return self.item(0, default_value);
    }

    T^ next(vector<T>* self) {
        using unsafe;
        
        self.it++;

        T^` default_value;
        return self.item(self.it, default_value);
    }

    _Bool end(vector<T>* self) {
        using unsafe;
        
        return self.it >= self.len;
    }
    
    T operator_load_element(vector<T>* self, int position) {
        using unsafe;
        
        T^` default_value;
        memset(&default_value, 0, sizeof(T));
        
        return self.item(position, default_value);
    }
    vector<T>*% operator_load_range_element(vector<T>* self, int begin, int tail) {
        vector<T>*% result = new vector<T>.initialize();
        
        if(self == null) {
            return result;
        }

        if(begin < 0) {
            begin += self.len;
        }

        if(tail < 0) {
            tail += self.len + 1;
        }

        if(begin < 0) {
            begin = 0;
        }

        if(begin >= self.len) {
            return result;
        }

        if(tail >= self.len) {
            tail = self.len;
        }

        for(int i=begin; i<tail; i++) {
            if(isheap(T)) {
                result.add(clone self.items[i]);
            }
            else {
                result.add(dummy_heap self.items[i]);
            }
        }

        return result;
    }
    vector<T>*% operator_load_range(vector<T>* self, int begin, int tail) {
        return self.operator_load_range_element(begin, tail);
    }
    void operator_store_element(list<T>* self, int position, T item) {
        self.replace(position, item);
    }
    
    vector<T>* quick_sort(vector<T>* self, int left, int right, int (*compare)(T,T)) {
        int l_hold = left;
        int r_hold = right;

        T^ pivot = self.items[left];
        int pivot_num = left;

        while(left < right) {
            while((compare(self.items[right], pivot) >= 0) && (left < right)) {
                right--;
            }

            if(left != right) {
                self.items[left] = self.items[right];
                left++;
            }

            while((compare(self.items[left], pivot) <= 0) && (left < right)) {
                left++;
            }

            if(left != right) {
                self.items[right] = self.items[left];
                right--;
            }
        }

        self.items[left] = pivot;

        pivot_num = left;

        int left2 = l_hold;
        int right2 = r_hold;

        if(left2 < pivot_num) {
            self.quick_sort(left2, pivot_num-1, compare);
        }

        if(right2 > pivot_num) {
            self.quick_sort(pivot_num+1, right2, compare);
        }

        return self;
    }
    vector<T>* sort_with_lambda(vector<T>* self, int (*compare)(T^, T^)) {
        return self.quick_sort(0, self.length()-1, fun);
    }
    vector<T>* sort(vector<T>* self) {
        return self.quick_sort(0, self.length()-1, int lambda(T^ left, T^ right) { return left.compare(right); });
    }
    string to_string(vector<T>* self)
    {
        if(self == null) {
            return string("");
        }
        
        buffer*% result = new buffer();
        
        result.append_str("v[");
        int i;
        foreach(it, self) {
            result.append_str(it.to_string());
            
            i++;
            
            if(i != self.length()) {
                result.append_str(",");
            }
        }
        
        result.append_str("]");
        
        return result.to_string();
    }
}




struct map<T, T2>
{
    T*^ keys;
    _Bool* item_existance;
    T2*^ items;
    int size;
    int len;
    
    list<T>*% key_list;

    int it;
};

#line 2658 "/usr/local/include/neo-c.h"

impl map <T, T2>
{
    map<T,T2>*% initialize(map<T,T2>*% self) {
        using unsafe;
        
        self.keys = borrow gc_inc(new T[128]);
        self.items = borrow gc_inc(new T2[128]);
        self.item_existance = borrow gc_inc(new _Bool[128]);

        for(int i=0; i<128; i++)
        {
            self.item_existance[i] = false;
        }

        self.size = 128;
        self.len = 0;
        
        self.key_list = new list<T>();

        self.it = 0;

        return self;
    }
    map<T,T2>*% initialize_with_values(map<T,T2>*% self, int num_keys, T^* keys, T2^* values) 
    {
        using unsafe;
        
        self.keys = borrow gc_inc(new T[128]);
        self.items = borrow gc_inc(new T2[128]);
        self.item_existance = borrow gc_inc(new _Bool[128]);

        for(int i=0; i<128; i++)
        {
            self.item_existance[i] = false;
        }

        self.size = 128;
        self.len = 0;

        self.it = 0;
        
        self.key_list = new list<T>();
        
        for(int i=0; i<num_keys; i++) {
            self.insert(dummy_heap keys\[i], dummy_heap values[i]);
        }

        return self;
    }
    void finalize(map<T,T2>* self) {
        using unsafe;
        
        for(int i=0; i<self.size; i++) {
            if(self.item_existance[i]) {
                if(isheap(T2)) {
                    delete self.items\[i];
                }
            }
        }
        come_free((char*)self.items);

        for(int i=0; i<self.size; i++) {
            if(self.item_existance[i]) {
                if(isheap(T)) {
                    delete self.keys\[i];
                }
            }
        }
        come_free((char*)self.keys);
        
        delete borrow self.key_list;

        delete borrow self.item_existance;
    }
    map<T, T2>*% clone(map<T, T2>* self)
    {
        using unsafe;
        
        if(self == null) {
            return null;
        }
        
        var result = new map<T,T2>();
        
        result.key_list = new list<T>();

        for(var it = self.begin(); !self.end(); it = self.next()) {
            T2^` default_value;
            memset(&default_value, 0, sizeof(T2));
            
            var it2 = self.at(it, default_value);

            if(isheap(T) && isheap(T2)) {
                result.put(clone it, clone it2);
            }
            else if(isheap(T)) {
                result.put(clone it, dummy_heap dupe it2);
            }
            else if(isheap(T2)) {
                result.put(dummy_heap dupe it, clone it2);
            }
            else {
                result.put(dummy_heap dupe it, dummy_heap dupe it2);
            }
        }

        return result;
    }
    
    string to_string(map<T,T2>* self)
    {
        using unsafe;
        
        if(self == null) {
            return string("");
        }
        
        buffer*% result = new buffer();
        
        result.append_str("[");
        
        list_item<T>* it = self.key_list.head;
        while(it) {
            T2^` default_value;
            memset(&default_value, 0, sizeof(T2));
            T2^ it2 = self.at(it.item, default_value);
            
            result.append_str(it.item.to_string());
            result.append_str("^");
            result.append_str(it2.to_string());
            
            it = it.next;
            
            if(it != null) {
                result.append_str(",");
            }
        }
        
        result.append_str("]");
        
        return result.to_string();
    }
    
    T2 at(map<T, T2>* self, T^ key, T2 default_value, _Bool by_pointer=false) {
        using unsafe;
        
        if(self == null) {
            return default_value;
        }
        
        unsigned int hash = ((T)key).get_hash_key() % self.size;
        unsigned int it = hash;
        
        while(true) {
            if(self.item_existance[it])
            {
                if((!by_pointer && self.keys\[it].equals(key)) || (by_pointer && self.keys\[it] == key))
                {
                    return dummy_heap self.items\[it];
                }

                it++;

                if(it >= self.size) {
                    it = 0;
                }
                else if(it == hash) {
                    return default_value;
                }
            }
            else {
                return default_value;
            }
        }

        return default_value;
    }
    map<T,T2>* remove(map<T, T2>* self, T key, _Bool by_pointer=false) {
        using unsafe;
        
        if(self == null) {
            return self;
        }
        
        unsigned int hash = ((T)key).get_hash_key() % self.size;
        unsigned int it = hash;
        
        while(true) {
            if(self.item_existance[it])
            {
                if((!by_pointer && self.keys\[it].equals(key)) || (by_pointer && self.keys\[it] == key))
                {
                    self.key_list.remove(self.keys\[it]);
                    
                    self.item_existance[it] = false;
                    if(isheap(T)) {
                        delete borrow self.keys\[it];
                    }
                    self.keys\[it] = null;
   
                    if(isheap(T2)) {
                        delete borrow self.items\[it];
                    }
                    memset(self.items + it, 0, sizeof(T2));
                    
                    self.len--;
                    break;
                }

                it++;

                if(it >= self.size) {
                    it = 0;
                }
                else if(it == hash) {
                    break;
                }
            }
            else {
                break;
            }
        }
        
        return self;
    }
    int length(map<T, T2>* self) {
        if(self == null) {
            return 0;
        }
        return self.len;
    }
    
    T^ begin(map<T, T2>* self) {
        using unsafe;
        
        if(self == null) {
            T`^ result;
            memset(&result, 0, sizeof(T));
            return result;
        }
        self.key_list.it = self.key_list.head;

        if(self.key_list.it) {
            return self.key_list.it.item;
        }
        
        T`^ result;
        memset(&result, 0, sizeof(T));
        return result;
    }

    T^ next(map<T, T2>* self) {
        using unsafe;
        
        if(self == null || self.key_list.it == null) {
            T`^ result;
            memset(&result, 0, sizeof(T));
            return result;
        }
        self.key_list.it = self.key_list.it.next;

        if(self.key_list.it) {
            return self.key_list.it.item;
        }
        
        T`^ result;
        memset(&result, 0, sizeof(T));
        return result;
    }

    _Bool end(map<T, T2>* self) {
        return self == null || self.key_list == null || self.key_list.it == null;
    }
    
    void rehash(map<T,T2>* self) {
        using unsafe;
        
        int size = self.size * 10;
        T^* keys = borrow gc_inc(new T[size]);
        T2^* items = borrow gc_inc(new T2[size]);
        _Bool* item_existance = borrow gc_inc(new _Bool[size]);

        int len = 0;

        for(var it = self.begin(); !self.end(); it = self.next()) {
            T2`^ default_value;
            memset(&default_value, 0, sizeof(T2));
            T2`^ it2 = borrow self.at(it, default_value);
            unsigned int hash = ((T)it).get_hash_key() % size;
            int n = hash;

            while(true) {
                if(item_existance[n])
                {
                    n++;

                    if(n >= size) {
                        n = 0;
                    }
                    else if(n == hash) {
                        printf("unexpected error in map.rehash(1)\n");
                        stackframe();
                        exit(2);
                    }
                }
                else {
                    item_existance[n] = true;
                    keys\[n] = it;
                    T2` default_value;
                    memset(&default_value, 0, sizeof(T2));
                    items\[n] = borrow self.at(it, default_value);

                    len++;
                    break;
                }
            }
        }

        come_free((char*)self.items);
        delete borrow self.item_existance;
        come_free((char*)self.keys);

        self.keys = keys;
        self.items = items;
        self.item_existance = item_existance;

        self.size = size;
        self.len = len;
    }

    void show_map(map<T, T2>* self) {
        using unsafe;
        
        if(self == null) {
            return;
        }
        
        for(var it = self.begin(); !self.end(); it = self.next()) {
            puts("key " + it.to_string());
            
            T2^` default_value;
            memset(&default_value, 0, sizeof(T2));
            
            var item = self.at(it, default_value);
            if(item) {
                puts("item " + item.to_string());
            }
        }
    }
    
    map<T,T2>* insert(map<T,T2>* self, T key, T2 item, _Bool by_pointer=false) {
        using unsafe; 
        
        if(self == null) {
            return self;
        }
        
        if(self.len*10 >= self.size) {
            self.rehash();
        }
        unsigned int hash = ((T)key).get_hash_key() % self.size;
        unsigned int it = hash;
        
        while(true) {
            if(self.item_existance[it])
            {
                if((!by_pointer && self.keys\[it].equals(key)) || (by_pointer && self.keys\[it] == key)) 
                {
                    if(isheap(T)) {
                        self.key_list.remove(self.keys\[it]);
                        delete self.keys\[it];
                        self.keys\[it] = borrow gc_inc(key);
                    }
                    else {
                        self.key_list.remove(self.keys\[it]);
                        self.keys\[it] = borrow key;
                    }
                    if(isheap(T2)) {
                        delete self.items\[it];
                        self.items\[it] = borrow gc_inc(item);
                    }
                    else {
                        self.items\[it] = borrow item;
                    }
                    break;
                }

                it++;

                if(it >= self.size) {
                    it = 0;
                }
                else if(it == hash) {
                    printf("unexpected error in map.insert\n");
                    stackframe();
                    exit(2);
                }
            }
            else {
                self.item_existance[it] = true;
                if(isheap(T)) {
                    self.keys\[it] = borrow gc_inc(key);
                }
                else {
                    self.keys\[it] = borrow key;
                }
                if(isheap(T2)) {
                    self.items\[it] = borrow gc_inc(item);
                }
                else {
                    self.items\[it] = borrow item;
                }

                self.len++;

                break;
            }
        }
        
        _Bool same_key_exist = false;
        for(var it2 = self.key_list.begin(); !self.key_list.end(); it2 = self.key_list.next()) {
            if((!by_pointer && it2.equals(key)) || (by_pointer && it2 == key)) {
                same_key_exist = true;
            }
        }
        
        if(!same_key_exist) {
            self.key_list.push_back(key);
        }
        
        return self;
    }
    map<T,T2>* put(map<T,T2>* self, T key, T2 item, _Bool by_pointer=false) {
        using unsafe;
        
        if(self == null) {
            return self;
        }
        
        if(self.len*2 >= self.size) {
            self.rehash();
        }
        unsigned int hash = ((T)key).get_hash_key() % self.size;
        int it = hash;

        while(true) {
            if(self.item_existance[it])
            {
                if((!by_pointer && self.keys\[it].equals(key)) || (by_pointer && self.keys\[it] == key))
                {
                    if(isheap(T)) {
                        delete self.keys\[it];
                        self.key_list.remove(self.keys\[it]);
                        self.keys\[it] = borrow gc_inc(key);
                    }
                    else {
                        self.key_list.remove(self.keys\[it]);
                        self.keys\[it] = borrow key;
                    }
                    if(isheap(T2)) {
                        delete self.items\[it];
                        self.items\[it] = borrow gc_inc(item);
                    }
                    else {
                        self.items\[it] = borrow item;
                    }
                    break;
                }

                it++;

                if(it >= self.size) {
                    it = 0;
                }
                else if(it == hash) {
                    printf("unexpected error in map.insert\n");
                    stackframe();
                    exit(2);
                }
            }
            else {
                self.item_existance[it] = true;
                if(isheap(T)) {
                    self.keys\[it] = borrow gc_inc(key);
                }
                else {
                    self.keys\[it] = borrow key;
                }
                if(isheap(T2)) {
                    self.items\[it] = borrow gc_inc(item);
                }
                else {
                    self.items\[it] = borrow item;
                }

                self.len++;

                break;
            }
        }
        
        _Bool same_key_exist = false;
        for(var it2 = self.key_list.begin(); !self.key_list.end(); it2 = self.key_list.next()) {
            if((!by_pointer && it2.equals(key)) || (by_pointer && it2 == key)) {
                same_key_exist = true;
            }
        }
        
        if(!same_key_exist) {
            self.key_list.push_back(key);
        }
        
        return self;
    }
    T2 operator_load_element(map<T, T2>* self, T^ key) {
        using unsafe;
        
        T2^` default_value;
        memset(&default_value, 0, sizeof(T2));
        
        if(self == null) {
            return default_value;
        }
        
        unsigned int hash = ((T)key).get_hash_key() % self.size;
        unsigned int it = hash;
        
        while(true) {
            if(self.item_existance[it])
            {
                if(self.keys\[it].equals(key))
                {
                    return dummy_heap self.items\[it];
                }

                it++;

                if(it >= self.size) {
                    it = 0;
                }
                else if(it == hash) {
                    return default_value;
                }
            }
            else {
                return default_value;
            }
        }

        return default_value;
    }
    
    void operator_store_element(map<T, T2>* self, T key, T2 item) {
        if(self == null) {
            return ;
        }
        self.insert(key, item);
    }
    
    _Bool equals(map<T, T2>* left, map<T, T2>* right)
    {
        using unsafe;
        
        if(left == null && right == null) {
            return true;
        }
        else if(left == null || right == null) {
            return false;
        }
        
        if(left.len != right.len) {
            return false;
        }

        int n = 0;
        _Bool result = true;
        for(var it = left.key_list.begin(); !left.key_list.end(); it = left.key_list.next()) {
            T^` default_value;
            memset(&default_value, 0, sizeof(T));
            T it2 = right.key_list.item(n, default_value);
            
            if(it.equals(it2)) {
                T2^` default_value2;
                memset(&default_value2, 0, sizeof(T2));
                T2 item = left.at(it, default_value2);
                T2 item2 = right.at(it2, default_value2);
                
                if(!item.equals(item2)) {
                    result = false;
                }
            }
            else {
                result = false;
            }
            
            n++;
        }

        return result;
    }
    
    _Bool operator_equals(map<T, T2>* left, map<T,T2>* right) {
        using unsafe;
        
        if(left == null && right == null) {
            return true;
        }
        else if(left == null || right == null) {
            return false;
        }
        if(left.len != right.len) {
            return false;
        }

        int n = 0;
        _Bool result = true;
        for(var it = left.key_list.begin(); !left.key_list.end(); it = left.key_list.next()) {
            T^` default_value;
            memset(&default_value, 0, sizeof(T));
            T^ it2 = right.key_list.item(n, default_value);
            
            if(it === it2) {
                T2^` default_value2;
                memset(&default_value2, 0, sizeof(T2));
                T2^ item = left.at(it, default_value2);
                T2^ item2 = right.at(it2, default_value2);
                
                if(!(item === item2)) {
                    result = false;
                }
            }
            else {
                result = false;
            }
            
            n++;
        }

        return result;
    }
    
    _Bool operator_not_equals(map<T, T2>* left, map<T,T2>* right) {
        if(left == null && right == null) {
            return false;
        }
        else if(left == null || right == null) {
            return true;
        }
        
        return !(left.operator_equals(right));
    }
    
    _Bool find(map<T, T2>* self, T^ key, _Bool by_pointer=false) {
        using unsafe;
        
        if(self == null) {
            return false;
        }
        
        unsigned int hash = ((T)key).get_hash_key() % self.size;
        int it = hash;

        while(true) {
            if(self.item_existance[it])
            {
                if((!by_pointer && self.keys\[it].equals(key)) || (by_pointer && self.keys\[it] == key))
                {
                    return true;
                }

                it++;

                if(it >= self.size) {
                    it = 0;
                }
                else if(it == hash) {
                    return false;
                }
            }
            else {
                return false;
            }
        }

        return false;
    }
    map<T,T2>*% operator_add(map<T,T2>* left, map<T,T2>* right) {
        using unsafe;
        
        map<T,T2>*% result = new map<T,T2>();
        
        if(left == null || right == null) {
            return result;
        }

        int n = 0;
        for(var it = left.key_list.begin(); !left.key_list.end(); it = left.key_list.next()) {
            T2^` default_value;
            memset(&default_value, 0, sizeof(T2));
            T2 it2 = left.at(it, default_value);
            
            if(isheap(T) && isheap(T2)) {
                result.insert(clone it, clone it2);
            }
            else if(isheap(T)) {
                result.insert(clone it, dummy_heap dupe it2);
            }
            else if(isheap(T2)) {
                result.insert(dummy_heap dupe it, clone it2);
            }
            else {
                result.insert(dummy_heap dupe it, dummy_heap dupe it2);
            }
            n++;
        }

        n=0;
        for(var it = right.key_list.begin(); !right.key_list.end(); it = right.key_list.next()) {
            T2^` default_value;
            memset(&default_value, 0, sizeof(T2));
            T2 it2 = left.at(it, default_value);
            
            if(isheap(T) && isheap(T2)) {
                result.insert(clone it, clone it2);
            }
            else if(isheap(T)) {
                result.insert(clone it, dummy_heap dupe it2);
            }
            else if(isheap(T2)) {
                result.insert(dummy_heap dupe it, clone it2);
            }
            else {
                result.insert(dummy_heap dupe it, dummy_heap dupe it2);
            }
            n++;
        }

        return result;
    }
    map<T,T2>*% operator_mult(map<T,T2>* left, int right) {
        using unsafe;
        
        map<T,T2>*% result = new map<T,T2>();
        
        if(left == null || right == null) {
            return result;
        }

        for(int i=0; i<right; i++ ) {
            int n = 0;
            for(var it = left.key_list.begin(); !left.key_list.end(); it = left.key_list.next()) {
                T2^` default_value;
                memset(&default_value, 0, sizeof(T2));
                
                T2 it2 = left.at(it, default_value);
                
                if(isheap(T) && isheap(T2)) {
                    result.insert(clone it, clone it2);
                }
                else if(isheap(T)) {
                    result.insert(clone it, dummy_heap dupe it2);
                }
                else if(isheap(T2)) {
                    result.insert(dummy_heap dupe it, clone it2);
                }
                else {
                    result.insert(dummy_heap dupe it, dummy_heap dupe it2);
                }
                n++;
            }
        }

        return result;
    }
    list<T>*% keys(map<T, T2>* self) {
        var result = new list<T>();
        
        if(self == null) {
            return result;
        }
        
        for(var it = self.key_list.begin(); !self.key_list.end(); it = self.key_list.next()) {
            if(isheap(T)) {
                result.push_back(clone it);
            }
            else {
                result.push_back(dummy_heap dupe it);
            }
        }
        
        return result;
    }
    
    list<T2>*% values(map<T, T2>* self) {
        using unsafe;
        
        var result = new list<T2>();
        
        if(self == null) {
            return result;
        }
        
        for(var it = self.key_list.begin(); !self.key_list.end(); it = self.key_list.next()) { 
            T2^` default_value;
            memset(&default_value, 0, sizeof(T2));
        
            var it2 = self.at(it, default_value);
            
            if(isheap(T2)) {
                result.push_back(clone it2);
            }
            else {
                result.push_back(dummy_heap dupe it2);
            }
        }
        
        return result;
    }
}




struct tuple1<T>
{
    T v1;
};

impl tuple1 <T>
{
    tuple1<T>*% initialize(tuple1<T>*% self, T v1)
    {
        self.v1 = v1;
        
        return self;
    }
    
    _Bool equals(tuple1<T>* self, tuple1<T>* right)
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!self.v1.equals(right.v1)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_equals(tuple1<T>* self, tuple1<T>* right) 
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!(self.v1 === right.v1)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_not_equals(tuple1<T>* left, tuple1<T>* right) {
        return !left.operator_equals(right);
    }
    
    string to_string(tuple1<T>* self)
    {
        if(self == null) {
            return string("");
        }
        return "(" + self.v1.to_string() + ")";
    }
}

struct tuple2<T, T2>
{
    T v1;
    T2 v2;
};

impl tuple2 <T, T2>
{
    tuple2<T, T2>*% initialize(tuple2<T, T2>*% self, T v1, T2 v2)
    {
        self.v1 = v1;
        self.v2 = v2;
        
        return self;
    }
    
    string to_string(tuple2<T, T2>* self)
    {
        if(self == null) {
            return string("");
        }
        return "(" + self.v1.to_string() + "," + self.v2.to_string() + ")";
    }
    _Bool equals(tuple2<T,T2>* self, tuple2<T,T2>* right)
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!self.v1.equals(right.v1)) {
            return false;
        }
        if(!self.v2.equals(right.v2)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_equals(tuple2<T,T2>* self, tuple2<T,T2>* right) 
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!(self.v1 === right.v1)) {
            return false;
        }
        if(!(self.v2 === right.v2)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_not_equals(tuple2<T,T2>* left, tuple2<T,T2>* right) {
        return !left.operator_equals(right);
    }
    
    
    T unwrap(tuple2<T,T2>* self) {
        if(self.v2 == true) {
            puts("exception");
            stackframe();
            exit(2);
        }
        
        return self.v1;
    }
}


struct tuple3<T, T2, T3>
{
    T v1;
    T2 v2;
    T3 v3;
};

impl tuple3 <T, T2, T3>
{
    tuple3<T, T2, T3>*% initialize(tuple3<T, T2, T3>*% self, T v1, T2 v2, T3 v3)
    {
        self.v1 = v1;
        self.v2 = v2;
        self.v3 = v3;
        
        return self;
    }
    
    string to_string(tuple3<T, T2, T3>* self)
    {
        if(self == null) {
            return string("");
        }
        return "(" + self.v1.to_string() + "," + self.v2.to_string() + "," + self.v3.to_string() + ")";
    }
    _Bool equals(tuple3<T,T2,T3>* self, tuple3<T,T2,T3>* right)
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!self.v1.equals(right.v1)) {
            return false;
        }
        if(!self.v2.equals(right.v2)) {
            return false;
        }
        if(!self.v3.equals(right.v3)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_equals(tuple3<T,T2,T3>* self, tuple3<T,T2,T3>* right) 
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!(self.v1 === right.v1)) {
            return false;
        }
        if(!(self.v2 === right.v2)) {
            return false;
        }
        if(!(self.v3 === right.v3)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_not_equals(tuple3<T,T2,T3>* left, tuple3<T,T2,T3>* right) {
        return !left.operator_equals(right);
    }
}

struct tuple4<T, T2, T3, T4>
{
    T v1;
    T2 v2;
    T3 v3;
    T4 v4;
};

impl tuple4 <T, T2, T3, T4>
{
    tuple4<T, T2, T3, T4>*% initialize(tuple4<T, T2, T3, T4>*% self, T v1, T2 v2, T3 v3, T4 v4)
    {
        self.v1 = v1;
        self.v2 = v2;
        self.v3 = v3;
        self.v4 = v4;
        
        return self;
    }
    
    string to_string(tuple4<T, T2, T3, T4>* self)
    {
        if(self == null) {
            return string("");
        }
        return "(" + self.v1.to_string() + "," + self.v2.to_string() + "," + self.v3.to_string() + "," + self.v4.to_string() + ")";
    }
    _Bool equals(tuple4<T,T2,T3,T4>* self, tuple4<T,T2,T3,T4>* right)
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!self.v1.equals(right.v1)) {
            return false;
        }
        if(!self.v2.equals(right.v2)) {
            return false;
        }
        if(!self.v3.equals(right.v3)) {
            return false;
        }
        if(!self.v4.equals(right.v4)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_equals(tuple4<T,T2,T3,T4>* self, tuple4<T,T2,T3,T4>* right) 
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!(self.v1 === right.v1)) {
            return false;
        }
        if(!(self.v2 === right.v2)) {
            return false;
        }
        if(!(self.v3 === right.v3)) {
            return false;
        }
        if(!(self.v4 === right.v4)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_not_equals(tuple4<T,T2,T3,T4>* left, tuple4<T,T2,T3,T4>* right) {
        return !left.operator_equals(right);
    }
}

struct tuple5<T, T2, T3, T4, T5>
{
    T v1;
    T2 v2;
    T3 v3;
    T4 v4;
    T5 v5;
};

impl tuple5 <T, T2, T3, T4, T5>
{
    tuple5<T, T2, T3, T4, T5>*% initialize(tuple5<T, T2, T3, T4, T5>*% self, T v1, T2 v2, T3 v3, T4 v4, T5 v5)
    {
        self.v1 = v1;
        self.v2 = v2;
        self.v3 = v3;
        self.v4 = v4;
        self.v5 = v5;
        
        return self;
    }
    
    string to_string(tuple5<T, T2, T3, T4, T5>* self)
    {
        if(self == null) {
            return string("");
        }
        return "(" + self.v1.to_string() + "," + self.v2.to_string() + "," + self.v3.to_string() + "," + self.v4.to_string() + "," + self.v5.to_string() + ")";
    }
    _Bool equals(tuple5<T,T2,T3,T4,T5>* self, tuple5<T,T2,T3,T4,T5>* right)
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!self.v1.equals(right.v1)) {
            return false;
        }
        if(!self.v2.equals(right.v2)) {
            return false;
        }
        if(!self.v3.equals(right.v3)) {
            return false;
        }
        if(!self.v4.equals(right.v4)) {
            return false;
        }
        if(!self.v5.equals(right.v5)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_equals(tuple5<T,T2,T3,T4,T5>* self, tuple5<T,T2,T3,T4,T5>* right) 
    {
        if(self == null && right == null) {
            return true;
        }
        else if(self == null || right == null) {
            return false;
        }
        if(!(self.v1 === right.v1)) {
            return false;
        }
        if(!(self.v2 === right.v2)) {
            return false;
        }
        if(!(self.v3 === right.v3)) {
            return false;
        }
        if(!(self.v4 === right.v4)) {
            return false;
        }
        if(!(self.v5 === right.v5)) {
            return false;
        }
        
        return true;
    }
    _Bool operator_not_equals(tuple5<T,T2,T3,T4,T5>* left, tuple5<T,T2,T3,T4,T5>* right) {
        return !left.operator_equals(right);
    }
}




uniq buffer*% buffer*::initialize(buffer*% self) 
{
    self.size = 128;
    self.buf = new char[self.size];
    self.buf[0] = '\0';
    self.len = 0;

    return self;
}

uniq buffer*% buffer*::initialize_with_value(buffer*% self, const char* mem, size_t size) 
{
    self.size = 128;
    self.buf = new char[self.size];
    self.buf[0] = '\0';
    self.len = 0;
    
    self.append(mem, size);

    return self;
}

uniq void buffer*::finalize(buffer* self)
{
    if(self && self.buf) delete borrow self.buf;
}

uniq buffer*% buffer*::clone(buffer* self)
{
    if(self == null) {
        return null;
    }
    
    var result = new buffer;
    
    result.size = self.size;
    result.buf = new char[self.size];
    result.len = self.len;
    memcpy(result.buf, self.buf, self.len);
    
    return result;
}

uniq _Bool buffer*::equals(buffer* left, buffer* right)
{
    if(left == null && right == null) {
        return true;
    }
    else if(left == null || right == null) {
        return false;
    }
    
    return left.to_string().equals(right.to_string());
}

uniq int buffer*::length(buffer* self) 
{
    if(self == null) {
        return 0;
    }
    return self.len;
}

uniq void buffer*::reset(buffer* self)
{
    if(self == null) {
        return;
    }
    self.buf[0] = '\0';
    self.len = 0;
}

uniq void buffer*::trim(buffer* self, int len)
{
    if(self == null) {
        return;
    }
    self.len -= len;
    if(self.len >= 0) {
        self.buf[self.len] = '\0';
    }
    else {
        self.len = 0;
        self.buf[0] = '\0';
    }
}

uniq buffer* buffer*::append(buffer* self, const char* mem, size_t size)
{
    if(self == null || mem == null) {
        return self;
    }
    if(self.len + size + 1 + 1 >= self.size) {
        char*% old_buf = new char[self.size];
        memcpy(old_buf, self.buf, self.size);
        int old_len = self.len;
        
        int new_size = (self.size + size + 1) * 2;
        self.buf = new char[new_size];
        memcpy(self.buf, old_buf, old_len);
        self.buf[old_len] = '\0';
        self.size = new_size;
    }

    memcpy(self.buf + self.len, mem, size);
    self.len += size;
    self.buf[self.len] = '\0';
    
    return self;
}

uniq buffer* buffer*::append_char(buffer* self, char c)
{
    if(self == null) {
        return null;
    }
    if(self.len + 1 + 1 + 1 >= self.size) {
        char*% old_buf = new char[self.size];
        memcpy(old_buf, self.buf, self.size);
        int old_len = self.len;
        
        int new_size = (self.size + 10 + 1) * 2;
        self.buf = new char[new_size];
        memcpy(self.buf, old_buf, old_len);
        self.buf[old_len] = '\0';
        self.size = new_size;
    }

    self.buf[self.len] = c;
    self.len++;

    self.buf[self.len] = '\0';
    
    return self;
}

uniq buffer* buffer*::append_str(buffer* self, const char* mem)
{
    if(self == null || mem == null) {
        return self;
    }
    
    int size = strlen(mem);
    if(self.len + size + 1 + 1 >= self.size) {
        char*% old_buf = new char[self.size];
        memcpy(old_buf, self.buf, self.size);
        int old_len = self.len;
        int new_size = (self.size + size + 1) * 2;
        self.buf = new char[new_size];
        memcpy(self.buf, old_buf, old_len);
        self.buf[old_len] = '\0';
        self.size = new_size;
    }

    memcpy(self.buf + self.len, mem, size);
    self.len += size;
    self.buf[self.len] = '\0';
    
    return self;
}

#line 4048 "/usr/local/include/neo-c.h"
    uniq buffer* buffer*::append_format(buffer* self, const char* msg, ...)
    {
        if(self == null || msg == null) {
            return self;
        }
        
        va_list` args;
        __builtin_va_start(args, msg);
        char* result;
        int len = vasprintf(&result, msg, args);
        __builtin_va_end(args);
        
        if(len < 0) {
            return self;
        }
        
        string mem = string(result);
        
        int size = strlen(mem);
        if(self.len + size + 1 + 1 >= self.size) {
            char*% old_buf = new char[self.size];
            memcpy(old_buf, self.buf, self.size);
            int old_len = self.len;
            int new_size = (self.size + size + 1) * 2;
            self.buf = new char[new_size];
            memcpy(self.buf, old_buf, old_len);
            self.buf[old_len] = '\0';
            self.size = new_size;
        }
    
        memcpy(self.buf + self.len, mem, size);
        self.len += size;
        self.buf[self.len] = '\0';
        
        free(result);
        
        return self;
    }
#line 4087 "/usr/local/include/neo-c.h"

uniq buffer* buffer*::append_nullterminated_str(buffer* self, const char* mem)
{
    if(self == null || mem == null) {
        return self;
    }
    int size = strlen(mem) + 1;
    if(self.len + size + 1 + 1 + 1 >= self.size) {
        char*% old_buf = new char[self.size];
        memcpy(old_buf, self.buf, self.size);
        int old_len = self.len;
        int new_size = (self.size + size + 1) * 2;
        self.buf = new char[new_size];
        memcpy(self.buf, old_buf, old_len);
        self.buf[old_len] = '\0';
        self.size = new_size;
    }

    memcpy(self.buf + self.len, mem, size);
    self.len += size;
    self.buf[self.len] = '\0';
    self.len++;
    
    return self;
}

uniq buffer* buffer*::append_int(buffer* self, int value) 
{
    if(self == null) {
        return null;
    }
    int* mem = &value;
    int size = sizeof(int);
    
    if(self.len + size + 1 + 1 >= self.size) {
        char*% old_buf = new char[self.size];
        memcpy(old_buf, self.buf, self.size);
        int old_len = self.len;
        int new_size = (self.size + size + 1) * 2;
        self.buf = new char[new_size];
        memcpy(self.buf, old_buf, old_len);
        self.buf[old_len] = '\0';
        self.size = new_size;
    }

    memcpy(self.buf + self.len, mem, size);
    self.len += size;
    self.buf[self.len] = '\0';
    
    return self;
}

uniq buffer* buffer*::append_long(buffer* self, long value) 
{
    if(self == null) {
        return null;
    }
    long* mem = &value;
    int size = sizeof(long);
    
    if(self.len + size + 1 + 1 >= self.size) {
        char*% old_buf = new char[self.size];
        memcpy(old_buf, self.buf, self.size);
        int old_len = self.len;
        int new_size = (self.size + size + 1) * 2;
        self.buf = new char[new_size];
        memcpy(self.buf, old_buf, old_len);
        self.buf[old_len] = '\0';
        self.size = new_size;
    }

    memcpy(self.buf + self.len, mem, size);
    self.len += size;
    self.buf[self.len] = '\0';
    
    return self;
}

uniq buffer* buffer*::append_short(buffer* self, short value) 
{
    if(self == null) {
        return null;
    }
    
    short* mem = &value;
    int size = sizeof(short);
    
    if(self.len + size + 1 + 1 >= self.size) {
        char*% old_buf = new char[self.size];
        memcpy(old_buf, self.buf, self.size);
        int old_len = self.len;
        int new_size = (self.size + size + 1) * 2;
        self.buf = new char[new_size];
        memcpy(self.buf, old_buf, old_len);
        self.buf[old_len] = '\0';
        self.size = new_size;
    }

    memcpy(self.buf + self.len, mem, size);
    self.len += size;
    self.buf[self.len] = '\0';
    
    return self;
}

uniq buffer* buffer*::alignment(buffer* self) 
{
    if(self == null) {
        return null;
    }
    
    int len = self.len;
    len = (len + 3) & ~3;
    
    if(len >= self.size) {
        char*% old_buf = new char[self.size];
        memcpy(old_buf, self.buf, self.size);
        int old_len = self.len;
        int new_size = (self.size + 1 + 1) * 2;
        self.buf = new char[new_size];
        memcpy(self.buf, old_buf, old_len);
        self.buf[old_len] = '\0';
        self.size = new_size;
    }

    for(int i=self.len; i<len; i++) {
        self.buf[i] = '\0';
    }
    
    self.len = len;
    
    return self;
}

uniq int buffer*::compare(buffer* left, buffer* right) 
{
    if(left == null && right == null) {
        return 0;
    }
    else if(left == null) {
        return -1;
    }
    else if(right == null) {
        return 1;
    }
    
    return strcmp(left.buf, right.buf);
}

uniq buffer*% char*::to_buffer(const char* self) 
{
    var result = new buffer.initialize();
    
    if(self == null) {
        return result;
    }

    result.append_str(self);

    return result;
}

uniq string buffer*::to_string(buffer* self)
{
    if(self == null) {
        return string("");
    }
    
    return string(self.buf);
}

uniq unsigned char* buffer*::head_pointer(buffer* self)
{
    if(self == null) {
        return null;
    }
    return (unsigned char*)self.buf;
}

uniq buffer*% char[]::to_buffer(char* self, size_t len) 
{
    var result = new buffer();
    if(self == null) {
        return result;
    }
    result.append(self, sizeof(char)*len);
    return result;
}

uniq buffer*% char*[]::to_buffer(char** self, size_t len) 
{
    var result = new buffer();
    if(self == null) {
        return result;
    }
    for(int i=0; i<len; i++) {
        result.append(self[i], strlen(self[i]));
    }
    return result;
}

uniq buffer*% short[]::to_buffer(short* self, size_t len) 
{
    var result = new buffer();
    if(self == null) {
        return result;
    }
    result.append((char*)self, sizeof(short)*len);
    return result;
}

uniq buffer*% int[]::to_buffer(int* self, size_t len) 
{
    var result = new buffer();
    if(self == null) {
        return result;
    }
    result.append((char*)self, sizeof(int)*len);
    return result;
}

uniq buffer*% long[]::to_buffer(long* self, size_t len) 
{
    var result = new buffer();
    if(self == null) {
        return result;
    }
    result.append((char*)self, sizeof(long)*len);
    return result;
}

uniq buffer*% float[]::to_buffer(float* self, size_t len) 
{
    var result = new buffer();
    if(self == null) {
        return result;
    }
    result.append((char*)self, sizeof(float)*len);
    return result;
}

uniq buffer*% double[]::to_buffer(double* self, size_t len) 
{
    var result = new buffer();
    if(self == null) {
        return result;
    }
    result.append((char*)self, sizeof(double)*len);
    return result;
}

uniq string buffer*::printable(buffer* self)
{
    int len = self.len;
    string result = new char[len*2+1];
    
    if(self == null) {
        return result;
    }

    int n = 0;
    for(int i=0; i<len; i++) {
        unsigned char c = self.buf[i];

        if((c >= 0 && c < ' ') 
            || c == 127)
        {
            result[n++] = '^';
            result[n++] = c + 'A' - 1;
        }
        else if(c > 127) {
            result[n++] = '?';
        }
        else {
            result[n++] = c;
        }
    }

    result[n] = '\0'

    return result;
}

impl list <T>
{
    buffer*% to_buffer(list<T>* self) {
        var result = new buffer();
        if(self == null) {
            return result;
        }
        for(var it = self.begin(); !self.end(); it = self.next()) {
            result.append((char*)&it, sizeof(T));
        }
        return result;
    }
}







uniq list<char>*% char[]::to_list(char* self, size_t len) 
{
    return new list<char>.initialize_with_values(len, self);
}

uniq list<char*>*% char*[]::to_list(char** self, size_t len) 
{
    return new list<char*>.initialize_with_values(len, self);
}

uniq list<short>*% short[]::to_list(short* self, size_t len) 
{
    return new list<short>.initialize_with_values(len, self);
}

uniq list<int>*% int[]::to_list(int* self, size_t len) 
{
    return new list<int>.initialize_with_values(len, self);
}

uniq list<long>*% long[]::to_list(long* self, size_t len) 
{
    return new list<long>.initialize_with_values(len, self);
}

uniq list<float>*% float[]::to_list(float* self, size_t len) 
{
    return new list<float>.initialize_with_values(len, self);
}

uniq list<double>*% double[]::to_list(double* self, size_t len) 
{
    return new list<double>.initialize_with_values(len, self);
}




uniq _Bool _Bool::equals(_Bool self, _Bool right) 
{
    return self == right;
}

uniq _Bool _Bool::equals(_Bool self, _Bool right) 
{
    return self == right;
}

uniq _Bool char::equals(char self, char right) 
{
    return self == right;
}

uniq _Bool short::equals(short self, short right) 
{
    return self == right;
}

uniq _Bool int::equals(int self, int right) 
{
    return self == right;
}

uniq _Bool long::equals(long self, long right) 
{
    return self == right;
}

uniq _Bool size_t::equals(size_t self, size_t right) 
{
    return self == right;
}

uniq _Bool float::equals(float self, float right) 
{
    return self == right;
}

uniq _Bool double::equals(double self, double right) 
{
    return self == right;
}

uniq _Bool _Bool::operator_equals(_Bool self, _Bool right)
{
    return self == right;
}

uniq _Bool _Bool::operator_equals(_Bool self, _Bool right)
{
    return self == right;
}

uniq _Bool char::operator_equals(char self, char right)
{
    return self == right;
}

uniq _Bool short::operator_equals(short self, short right)
{
    return self == right;
}

uniq _Bool int::operator_equals(int self, int right)
{
    return self == right;
}

uniq _Bool long::operator_equals(long self, long right)
{
    return self == right;
}

uniq _Bool _Bool::operator_not_equals(_Bool self, _Bool right)
{
    return !(self == right);
}

uniq _Bool _Bool::operator_not_equals(_Bool self, _Bool right)
{
    return !(self == right);
}

uniq _Bool char::operator_not_equals(char self, char right)
{
    return !(self == right);
}

uniq _Bool short::operator_not_equals(short self, short right)
{
    return !(self == right);
}

uniq _Bool int::operator_not_equals(int self, int right)
{
    return !(self == right);
}

uniq _Bool long::operator_not_equals(long self, long right)
{
    return !(self == right);
}

uniq _Bool char*::equals(const char* self, const char* right) 
{
    if(self == null && right == null) {
        return true;
    }
    else if(self == null || right == null) {
        return false;
    }
    
    return strcmp(self, right) == 0;
}

uniq _Bool string::equals(char* self, const char* right) 
{
    if(self == null && right == null) {
        return true;
    }
    else if(self == null || right == null) {
        return false;
    }
    
    return strcmp(self, right) == 0;
}

uniq _Bool void*::equals(void* self, void* right) 
{
    return self == right;
}

uniq _Bool _Bool*::equals(_Bool* self, _Bool* right) 
{
    return *self == *right;
}

uniq _Bool string::operator_equals(char* self, const char* right) 
{
    if(self == null && right == null) {
        return true;
    }
    else if(self == null || right == null) {
        return false;
    }
    
    return strcmp(self, right) == 0;
}

uniq _Bool char*::operator_equals(const char* self, const char* right) 
{
    if(self == null && right == null) {
        return true;
    }
    else if(self == null || right == null) {
        return false;
    }
    
    return strcmp(self, right) == 0;
}

uniq _Bool char[]::operator_equals(char* self, const char* right) 
{
    if(self == null && right == null) {
        return true;
    }
    else if(self == null || right == null) {
        return false;
    }
    
    return strcmp(self, right) == 0;
}

uniq _Bool void*::operator_equals(const char* self, const char* right) 
{
    return self == right;
}

uniq _Bool void*::operator_not_equals(const char* self, const char* right) 
{
    return !self.operator_equals(right);
}

uniq _Bool string::operator_not_equals(char* self, const char* right) 
{
    if(self == null && right == null) {
        return false;
    }
    else if(self == null || right == null) {
        return true;
    }
    
    return strcmp(self, right) != 0;
}

uniq _Bool char*::operator_not_equals(const char* self, const char* right) 
{
    if(self == null && right == null) {
        return false;
    }
    else if(self == null || right == null) {
        return true;
    }
    
    return strcmp(self, right) != 0;
}

uniq _Bool char[]::operator_not_equals(char* self, const char* right) 
{
    if(self == null && right == null) {
        return false;
    }
    else if(self == null || right == null) {
        return true;
    }
    
    return strcmp(self, right) != 0;
}


uniq string char*::operator_add(const char* self, const char* right) 
{
    if(self == null || right == null) {
        return string("");
    }
    int len = strlen(self) + strlen(right);
   
    char*% result = new char[len+1];
    
    strncpy(result, self, len+1);
    strncat(result, right, len+1);
    
    return result;
}

uniq string string::operator_add(char* self, const char* right) 
{
    if(self == null || right == null) {
        return string("");
    }
    int len = strlen(self) + strlen(right);
   
    char*% result = new char[len+1];
    
    strncpy(result, self, len+1);
    strncat(result, right, len+1);
    
    return result;
}

uniq string char*::operator_mult(const char* self, int right) 
{
    if(self == null) {
        return string("");
    }
    var buf = new buffer();
    
    for(int i=0; i<right; i++) {
        buf.append_str(self);
    }
    
    return buf.to_string();
}

uniq string string::operator_mult(const char* self, int right) 
{
    if(self == null) {
        return string("");
    }
    var buf = new buffer();
    
    for(int i=0; i<right; i++) {
        buf.append_str(self);
    }
    
    return buf.to_string();
}

uniq size_t char[]::length(const char* self, size_t len) 
{
    return len;
}

uniq _Bool char*[]::contained(const char* self[], size_t len, const char* str) 
{
    _Bool result = false;
    if(self == null) {
        return result;
    }
    for(int i=0; i<len; i++) {
        if(strncmp(self[i], str, strlen(self[i])) == 0) {
            result = true;
            break;
        }
    }
    return result;
}

uniq size_t short[]::length(short* self, size_t len) 
{
    return len;
}

uniq size_t int[]::length(int* self, size_t len) 
{
    return len;
}

uniq size_t long[]::length(long* self, size_t len) 
{
    return len;
}

uniq size_t float[]::length(float* self, size_t len) 
{
    return len;
}

uniq size_t double[]::length(double* self, size_t len) 
{
    return len;
}




uniq unsigned int _Bool::get_hash_key(_Bool value)
{
    return (((int)value).get_hash_key());
}

uniq unsigned int _Bool::get_hash_key(_Bool value)
{
    return (((int)value).get_hash_key());
}

uniq unsigned int char::get_hash_key(char value)
{
    return value;
}

uniq unsigned int short::get_hash_key(short int value)
{
    return value;
}

uniq unsigned int int::get_hash_key(int value)
{
    return value;
}

uniq unsigned int long::get_hash_key(long value)
{
    return value;
}

uniq unsigned int size_t::get_hash_key(size_t value)
{
    return value;
}

uniq unsigned int float::get_hash_key(float value)
{
    return (unsigned int)value;
}

uniq unsigned int double::get_hash_key(double value)
{
    return (unsigned int)value;
}

uniq unsigned int char*::get_hash_key(const char* value)
{
    if(value == null) {
        return 0;
    }
    int result = 0;
    const char* p = value;
    while(*p) {
        result += (*p);
        p++;
    }
    return result;
}

uniq unsigned int string::get_hash_key(char* value)
{
    if(value == null) {
        return 0;
    }
    int result = 0;
    char* p = value;
    while(*p) {
        result += (*p);
        p++;
    }
    return result;
}

uniq unsigned int void*::get_hash_key(void* value)
{
    return (((int)value).get_hash_key());
}




uniq _Bool _Bool::clone(_Bool self)
{
    return self;
}

uniq _Bool _Bool::clone(_Bool self)
{
    return self;
}

uniq char char::clone(char self)
{
    return self;
}

uniq short int short::clone(short self)
{
    return self;
}

uniq int int::clone(int self)
{
    return self;
}

uniq long int long::clone(long self)
{
    return self;
}

uniq size_t size_t::clone(size_t self)
{
    return self;
}

uniq double double::clone(double self)
{
    return self;
}

uniq float float::clone(float self)
{
    return self;
}





uniq _Bool xisalpha(char c)
{
    _Bool result = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
    return result;
}

uniq _Bool xisblank(char c)
{
    return c == ' ' || c == '\t';
}

uniq _Bool xisdigit(char c)
{
    return (c >= '0' && c <= '9');
}

uniq _Bool xisspace(char c)
{
    return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == 28 || c == 11;
}

uniq _Bool xisalnum(char c)
{
    return xisalpha(c) || xisdigit(c);
}

uniq _Bool xisascii(char c)
{
    _Bool result = (c >= ' ' && c <= '~');
    return result;
}

uniq _Bool xispunct(char c) {
    return (c >= '!' && c <= '/') || (c >= ':' && c <= '@') || (c >= '[' && c <= '`') || (c >= '{' && c <= '~');
 }




uniq int string::length(const char* str)
{
    if(str == null) {
        return 0;
    }
    return strlen(str);
}

uniq int char*::length(const char* str) {
    if(str == null) {
        return 0;
    }
    return strlen(str);
}

uniq int char[]::length(const char* str) {
    if(str == null) {
        return 0;
    }
    return strlen(str);
}

uniq string char*::reverse(const char* str) 
{
    if(str == null) {
        return string("");
    }
    int len = strlen(str);
    char*% result = new char[len + 1];

    for(int i=0; i<len; i++) {
        result[i] = str[len-i-1];
    }

    result[len] = '\0';

    return result;
}

uniq string string::operator_load_range_element(char* str, int head, int tail)
{
    if(str == null) {
        return string("");
    }

    int len = strlen(str);

    if(head < 0) {
        head += len;
    }
    if(tail < 0) {
        tail += len + 1;
    }

    if(head > tail) {
        return str.substring(tail, head).reverse();
    }

    if(head < 0) {
        head = 0;
    }

    if(tail >= len) {
        tail = len;
    }

    if(head == tail) {
        return string("");
    }

    if(tail-head+1 < 1) {
        return string("");
    }

    string result = new char[tail-head+1];

    memcpy(result, str + head, tail-head);
    result[tail-head] = '\0';

    return result;
}

uniq string char*::operator_load_range_element(char* str, int head, int tail)
{
    if(str == null) {
        return string("");
    }

    int len = strlen(str);

    if(head < 0) {
        head += len;
    }
    if(tail < 0) {
        tail += len + 1;
    }

    if(head > tail) {
        return str.substring(tail, head).reverse();
    }

    if(head < 0) {
        head = 0;
    }

    if(tail >= len) {
        tail = len;
    }

    if(head == tail) {
        return string("");
    }

    if(tail-head+1 < 1) {
        return string("");
    }

    string result = new char[tail-head+1];

    memcpy(result, str + head, tail-head);
    result[tail-head] = '\0';

    return result;
}

uniq string char*::substring(const char* str, int head, int tail)
{
    if(str == null) {
        return string("");
    }

    int len = strlen(str);

    if(head < 0) {
        head += len;
    }
    if(tail < 0) {
        tail += len + 1;
    }

    if(head > tail) {
        return str.substring(tail, head).reverse();
    }

    if(head < 0) {
        head = 0;
    }

    if(tail >= len) {
        tail = len;
    }

    if(head == tail) {
        return string("");
    }

    if(tail-head+1 < 1) {
        return string("");
    }

    string result = new char[tail-head+1];

    memcpy(result, str + head, tail-head);
    result[tail-head] = '\0';

    return result;
}

uniq string xsprintf(const char* msg, ...)
{
    if(msg == null) {
        return string("");
    }
    va_list` args;
    __builtin_va_start(args, msg);
    char* result;
    int len = vasprintf(&result, msg, args);
    __builtin_va_end(args);
    
    if(len < 0) {
        return string("");
    }
    
    string result2 = string(result);
    
    free(result);
    
    return result2;
}

uniq string char*::delete(char* str, int head, int tail) 
{
    if(str == null) {
        return string("");
    }
    
    int len = strlen(str);
    
    if(head >= len) {
        return string(str);
    }

    if(strcmp(str, "") == 0) {
        return string(str);
    }
    
    if(head < 0) {
       head += len;
    }
    
    if(tail < 0) {
       tail += len + 1;
    }

    if(head < 0) {
        head = 0;
    }

    if(tail < 0) {
        return string(str);
    }

    if(tail >= len) {
        tail = len;
    }
    
    char*% result = new char[len-(tail-head)+1];
    
    memcpy(result, str, head);
    memcpy(result + head, str + tail, len-tail);
    
    result[len -(tail-head)] = '\0';

    return result;
}

uniq list<string>*% char*::split_char(char* self, char c) 
{
    if(self == null) {
        return new list<string>();
    }
    
    var result = new list<string>.initialize();

    var str = new buffer.initialize();

    for(int i=0; i<self.length(); i++) {
        if(self[i] == c) {
            result.push_back(string(str.buf));
            str.reset();
        }
        else {
            str.append_char(self[i]);
        }
    }
    if(str.length() != 0) {
        result.push_back(string(str.buf));
    }

    return result;
}

uniq string char*::xsprintf(char* self, const char* msg, ...)
{
    return xsprintf(msg, self);
}

uniq string int::xsprintf(int self, const char* msg, ...)
{
    return xsprintf(msg, self);
}


uniq string char*::printable(char* str)
{
    if(str == null) { return string(""); }
    
    int len = str.length();
    string result = new char[len*2+1];

    int n = 0;
    for(int i=0; i<len; i++) {
        char c = str[i];

        if((c >= 0 && c < ' ') 
            || c == 127)
        {
            result[n++] = '^';
            result[n++] = c + 'A' - 1;
        }
        else {
            result[n++] = c;
        }
    }

    result[n] = '\0'

    return result;
}

uniq string char[]::printable(char* str)
{
    return char*::printable(str);
}

uniq string char*::sub_plain(char* self, char* str, char* replace)
{
    if(self == null || str == null || replace == null) {
        return string(self);
    }

    var result = new buffer.initialize();
    
    char* p = self;
    
    while(true) {
        char* p2 = strstr(p, str);
        
        if(p2 == null) {
            p2 = p;
            while(*p2) {
                p2++;
            }
            result.append(p, p2 - p);
            break;
        }
        
        result.append(p, p2 - p);
        result.append_str(replace);
        
        p = p2 + strlen(str);
    }

    return result.to_string();
}




uniq string xbasename(char* path)
{
    if(path == null) {
        return string("");
    }
    char* p = path + strlen(path);
    
    while(p >= path) {
        if(*p == '/') {
            break;
        }
        else {
            p--;
        }
    }
    
    if(p < path) {
        return string(path);
    }
    else {
        return string(p+1);  
    }
    
    return string("");
}

uniq string xnoextname(char* path)
{
    if(path == null) {
        return string("");
    }
    string path2 = xbasename(path);
    
    char* p = path2 + strlen(path2);
    
    while(p >= path2) {
        if(*p == '.') {
            break;
        }
        else {
            p--;
        }
    }
    
    if(p < path2) {
        return string(path2);
    }
    else {
        return path2.substring(0, p - path2);
    }
    
    return string("");
}

uniq string xextname(char* path)
{
    if(path == null) {
        return string("");
    }
    char* p = path + strlen(path);
    
    while(p >= path) {
        if(*p == '.') {
            break;
        }
        else {
            p--;
        }
    }
    
    if(p < path) {
        return string(path);
    }
    else {
        return string(p+1);  
    }
    
    return string("");
}




uniq string _Bool::to_string(_Bool self)
{
    if(self) {
        return string("true");
    }
    else {
        return string("false");
    }
}

uniq string _Bool::to_string(_Bool self)
{
    if(self) {
        return string("true");
    }
    else {
        return string("false");
    }
}

uniq string char::to_string(char self)
{
    return xsprintf("%c", self);
}

uniq string short::to_string(short self)
{
    return xsprintf("%d", self);
}

uniq string int::to_string(int self)
{
    return xsprintf("%d", self);
}

uniq string long::to_string(long self)
{
    return xsprintf("%ld", self);
}

uniq string size_t::to_string(size_t self)
{
    return xsprintf("%ld", self);
}

uniq string float::to_string(float self)
{
    return xsprintf("%f", self);
}

uniq string double::to_string(double self)
{
    return xsprintf("%lf", self);
}

uniq string string::to_string(char* self)
{
    if(self == null) {
        return string("");
    }
    return string(self);
}

uniq string char*::to_string(const char* self)
{
    if(self == null) {
        return string("");
    }
    return string(self);
}




uniq int _Bool::compare(_Bool left, _Bool right)
{
    if(!left && right) {
        return -1;
    }
    else if(left && right) {
        return 0;
    }
    else if(!left && !right) {
        return 0;
    }
    else {
        return 1;
    }
    
    return 0;
}

uniq int _Bool::compare(_Bool left, _Bool right)
{
    if(!left && right) {
        return -1;
    }
    else if(left && right) {
        return 0;
    }
    else if(!left && !right) {
        return 0;
    }
    else {
        return 1;
    }
    
    return 0;
}

uniq int char::compare(char left, char right) 
{
    if(left < right) {
        return -1;
    }
    else if(left > right) {
        return 1;
    }
    else {
        return 0;
    }
    
    return 0;
}

uniq int short::compare(short left, short right) 
{
    if(left < right) {
        return -1;
    }
    else if(left > right) {
        return 1;
    }
    else {
        return 0;
    }
    
    return 0;
}

uniq int int::compare(int left, int right) 
{
    if(left < right) {
        return -1;
    }
    else if(left > right) {
        return 1;
    }
    else {
        return 0;
    }
    
    return 0;
}

uniq int long::compare(long left, long right) 
{
    if(left < right) {
        return -1;
    }
    else if(left > right) {
        return 1;
    }
    else {
        return 0;
    }
    
    return 0;
}

uniq int size_t::compare(size_t left, size_t right) 
{
    if(left < right) {
        return -1;
    }
    else if(left > right) {
        return 1;
    }
    else {
        return 0;
    }
    
    return 0;
}

uniq int float::compare(float left, float right) 
{
    if(left < right) {
        return -1;
    }
    else if(left > right) {
        return 1;
    }
    else {
        return 0;
    }
    
    return 0;
}

uniq int double::compare(double left, double right) 
{
    if(left < right) {
        return -1;
    }
    else if(left > right) {
        return 1;
    }
    else {
        return 0;
    }
    
    return 0;
}

uniq int string::compare(char* left, char* right) 
{
    if(left == null && right == null) {
        return 0;
    }
    else if(left == null) {
        return -1;
    }
    else if(right == null) {
        return 1;
    }
    
    return strcmp(left,right);
}

uniq int char*::compare(char* left, char* right) 
{
    if(left == null && right == null) {
        return 0;
    }
    else if(left == null) {
        return -1;
    }
    else if(right == null) {
        return 1;
    }
    
    return strcmp(left,right);
}




uniq string char*::puts(char* self)
{
    if(self == null) {
        return string("");
    }
    puts(self);
    
    return string(self);
}

uniq string char*::print(char* self)
{
    if(self == null) {
        return string("");
    }
    printf("%s", self);
    
    return string(self);
}

#line 5637 "/usr/local/include/neo-c.h"
    uniq string char*::printf(char* self, ...)
    {
        if(self == null) {
            return string("");
        }
        char* msg2;
    
        va_list` args;
        __builtin_va_start(args, self);
        vasprintf(&msg2,self,args);
        __builtin_va_end(args);
        
        printf("%s", msg2);
    
        free(msg2);
        
        return string(self);
    }
#line 5656 "/usr/local/include/neo-c.h"

uniq int int::printf(int self, char* msg)
{
    if(self == null) {
        return self;
    }
    printf(msg, self);
    
    return self;
}

uniq long long::printf(long self, char* msg)
{
    if(self == null) {
        return self;
    }
    printf(msg, self);
    
    return self;
}

uniq void int::times(int self, void* parent, void (*block)(void* parent, int it))
{
    for(int i = 0; i < self; i++) {
        block(parent, i);
    }
}
































#line 5716 "/usr/local/include/neo-c.h"

#line 5719 "/usr/local/include/neo-c.h"


struct re_program;
typedef struct re_program* re_t;


typedef struct re_capture
{
  int start;
  int length;
} re_capture;




#line 5737 "/usr/local/include/neo-c.h"

enum
{
  RE_UNUSED,
  RE_DOT,
  RE_BEGIN,
  RE_END,
  RE_QUESTIONMARK,
  RE_STAR,
  RE_PLUS,
  RE_CHAR,
  RE_CHAR_CLASS,
  RE_INV_CHAR_CLASS,
  RE_DIGIT,
  RE_NOT_DIGIT,
  RE_ALPHA,
  RE_NOT_ALPHA,
  RE_WHITESPACE,
  RE_NOT_WHITESPACE,
  RE_GROUP,
  RE_GROUP_END
};


typedef struct regex_t regex_t;

struct regex_t
{
  unsigned char type;   
  union
  {
    unsigned char  ch;      
    unsigned char* ccl;     
    struct
    {
      regex_t* first;       
      regex_t* last;        
      int      id;          
    } group;
  } u;
  regex_t* next;            
};


typedef struct re_program
{
  regex_t*       start;
  int            group_count;
} regex_program_t;


typedef struct
{
  regex_t*        pool;
  int             pool_capacity;
  int             pool_size;
  unsigned char*  ccl_buf;
  int             ccl_capacity;
  int             ccl_idx;
  int             group_count;
} compiler_state;


typedef struct
{
  const char* base;
  re_capture* captures;
  int         capture_capacity;   
  int         total_groups;       
  _Bool        ignore_case;
} match_context;




uniq int re_matchp_ex(re_t pattern, const char* text, int* matchlength, re_capture* captures, int max_captures, _Bool ignore_case)
{
  *matchlength = 0;
  if (pattern == 0)
  {
    return -1;
  }

  regex_program_t* program = (regex_program_t*) pattern;
  regex_t* start = program->start;
  if (start == 0)
  {
    return -1;
  }

  match_context ctx;
  ctx.base = text;
  ctx.captures = (captures != 0 && max_captures > 0) ? captures : 0;
  ctx.capture_capacity = (captures != 0 && max_captures > 0) ? max_captures : 0;
  if (ctx.capture_capacity > 64)
  {
    ctx.capture_capacity = 64;
  }
  ctx.total_groups = program->group_count;
  ctx.ignore_case = ignore_case;

  if (ctx.captures != 0)
  {
    clear_captures(&ctx);
  }

  if (start->type == RE_BEGIN)
  {
    const char* end = matchpattern(start->next, text, &ctx);
    if (end != 0)
    {
      *matchlength = (int)(end - text);
      if (ctx.captures != 0)
      {
        
      }
      return 0;
    }
    return -1;
  }
  else
  {
    const char* cursor = text;
    while (1)
    {
      if (ctx.captures != 0)
      {
        clear_captures(&ctx);
      }
      const char* end = matchpattern(start, cursor, &ctx);
      if (end != 0)
      {
        if (*cursor == '\0' && cursor != text)
        {
          return -1; 
        }
        *matchlength = (int)(end - cursor);
        return (int)(cursor - text);
      }

      if (*cursor == '\0')
      {
        break;
      }
      cursor += 1;
    }
  }

  return -1;
}

uniq int re_matchp(re_t pattern, const char* text, int* matchlength, re_capture* captures, int max_captures)
{
  return re_matchp_ex(pattern, text, matchlength, captures, max_captures, false);
}

uniq int re_match(const char* pattern, const char* text, int* matchlength)
{
  return re_matchp(re_compile(pattern), text, matchlength, (re_capture*)0, 0);
}

uniq re_t re_compile(const char* pattern)
{
  static regex_t        re_compiled[64];
  static unsigned char  ccl_buf[40];
  static regex_program_t program;

  compiler_state state;
  state.pool = re_compiled;
  state.pool_capacity = 64;
  state.pool_size = 0;
  state.ccl_buf = ccl_buf;
  state.ccl_capacity = 40;
  state.ccl_idx = 1; 
  state.group_count = 0;

  if (state.ccl_capacity > 0)
  {
    state.ccl_buf[0] = 0;
  }

  int pos = 0;
  regex_t* head = compile_sequence(&state, pattern, &pos, 0);
  if ((head == 0) || (pattern[pos] != '\0'))
  {
    return ((void*)0);
  }

  program.start = head;
  program.group_count = state.group_count;
  return (re_t) &program;
}


uniq void re_print(re_t pattern)
{
  if (pattern == 0)
  {
    return;
  }

  regex_program_t* program = (regex_program_t*) pattern;
  if (program->start == 0)
  {
    return;
  }

  re_print_internal(program->start, 0);
}



uniq void clear_captures(match_context* ctx)
{
  if ((ctx->captures == 0) || (ctx->capture_capacity <= 0))
  {
    return;
  }

  for (int i = 0; i < ctx->capture_capacity; ++i)
  {
    ctx->captures[i].start = -1;
    ctx->captures[i].length = 0;
  }
}

uniq void snapshot_captures(const match_context* ctx, re_capture* buffer_)
{
  if ((ctx->captures == 0) || (ctx->capture_capacity <= 0))
  {
    return;
  }

  memcpy(buffer_, ctx->captures, sizeof(re_capture) * ctx->capture_capacity);
}

uniq void restore_captures(match_context* ctx, const re_capture* buffer_)
{
  if ((ctx->captures == 0) || (ctx->capture_capacity <= 0))
  {
    return;
  }

  memcpy(ctx->captures, buffer_, sizeof(re_capture) * ctx->capture_capacity);
}


uniq regex_t* new_token(compiler_state* st)
{
  if (st->pool_size >= st->pool_capacity)
  {
    return ((void*)0);
  }

  regex_t* token = &st->pool[st->pool_size++];
  token->type = RE_UNUSED;
  token->u.ccl = ((void*)0);
  token->next = ((void*)0);
  token->u.group.first = ((void*)0);
  token->u.group.last = ((void*)0);
  token->u.group.id = 0;
  return token;
}

uniq int append_token(regex_t** head, regex_t** tail, regex_t* token)
{
  if (token == 0)
  {
    return 0;
  }

  if (*head == 0)
  {
    *head = token;
  }
  else
  {
    (*tail)->next = token;
  }
  *tail = token;
  return 1;
}

uniq regex_t* compile_sequence(compiler_state* st, const char* pattern, int* pos, int in_group)
{
  regex_t* head = (regex_t*)0;
  regex_t* tail = (regex_t*)0;

  while (pattern[*pos] != '\0')
  {
    char c = pattern[*pos];

    if (in_group && (c == ')'))
    {
      break;
    }

    regex_t* token = (regex_t*)0;

    switch (c)
    {
      case '^':
      {
        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = RE_BEGIN;
        (*pos)++;
      } break;

      case '$':
      {
        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = RE_END;
        (*pos)++;
      } break;

      case '.':
      {
        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = RE_DOT;
        (*pos)++;
      } break;

      case '*':
      {
        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = RE_STAR;
        (*pos)++;
      } break;

      case '+':
      {
        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = RE_PLUS;
        (*pos)++;
      } break;

      case '?':
      {
        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = RE_QUESTIONMARK;
        (*pos)++;
      } break;

      case '\\':
      {
        (*pos)++;
        if (pattern[*pos] == '\0')
        {
          return ((void*)0);
        }

        token = new_token(st);
        if (token == 0) return ((void*)0);

        switch (pattern[*pos])
        {
          case 'd': token->type = RE_DIGIT;          break;
          case 'D': token->type = RE_NOT_DIGIT;      break;
          case 'w': token->type = RE_ALPHA;          break;
          case 'W': token->type = RE_NOT_ALPHA;      break;
          case 's': token->type = RE_WHITESPACE;     break;
          case 'S': token->type = RE_NOT_WHITESPACE; break;
          default:
          {
            token->type = RE_CHAR;
            token->u.ch = (unsigned char)pattern[*pos];
          } break;
        }
        (*pos)++;
      } break;

      case '[':
      {
        int buf_begin = st->ccl_idx;
        int negated = 0;
        (*pos)++;

        if (pattern[*pos] == '^')
        {
          negated = 1;
          (*pos)++;
          if (pattern[*pos] == '\0')
          {
            return ((void*)0);
          }
        }

        if (pattern[*pos] == '\0')
        {
          return ((void*)0);
        }

        while ((pattern[*pos] != '\0') && (pattern[*pos] != ']'))
        {
          if (pattern[*pos] == '\\')
          {
            if (st->ccl_idx >= (st->ccl_capacity - 1))
            {
              return ((void*)0);
            }
            st->ccl_buf[st->ccl_idx++] = '\\';
            (*pos)++;
            if (pattern[*pos] == '\0')
            {
              return ((void*)0);
            }
          }

          if (st->ccl_idx >= st->ccl_capacity)
          {
            return ((void*)0);
          }
          st->ccl_buf[st->ccl_idx++] = (unsigned char)pattern[*pos];
          (*pos)++;
        }

        if (pattern[*pos] != ']')
        {
          return ((void*)0);
        }

        if (st->ccl_idx >= st->ccl_capacity)
        {
          return ((void*)0);
        }
        st->ccl_buf[st->ccl_idx++] = 0;

        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = negated ? RE_INV_CHAR_CLASS : RE_CHAR_CLASS;
        token->u.ccl = &st->ccl_buf[buf_begin];

        (*pos)++;
      } break;

      case '(':
      {
        (*pos)++;
        regex_t* inner = compile_sequence(st, pattern, pos, 1);
        if (inner == 0)
        {
          return ((void*)0);
        }
        if (pattern[*pos] != ')')
        {
          return ((void*)0);
        }

        regex_t* tail = inner;
        while ((tail != 0) && (tail->type != RE_UNUSED))
        {
          tail = tail->next;
        }
        if (tail == 0)
        {
          return ((void*)0);
        }

        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = RE_GROUP;
        token->u.group.first = inner;
        token->u.group.last = tail;
        token->u.group.id = ++st->group_count;

        tail->type = RE_GROUP_END;
        tail->u.group.first = token;

        (*pos)++;
      } break;

      case ')':
      {
        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = RE_CHAR;
        token->u.ch = (unsigned char)c;
        (*pos)++;
      } break;

      default:
      {
        token = new_token(st);
        if (token == 0) return ((void*)0);
        token->type = RE_CHAR;
        token->u.ch = (unsigned char)c;
        (*pos)++;
      } break;
    }

    if (!append_token(&head, &tail, token))
    {
      return ((void*)0);
    }
  }

  regex_t* sentinel = new_token(st);
  if (sentinel == 0)
  {
    return ((void*)0);
  }
  sentinel->type = RE_UNUSED;
  sentinel->next = ((void*)0);

  if (head == 0)
  {
    head = sentinel;
  }
  else
  {
    tail->next = sentinel;
  }

  return head;
}

uniq const char* matchpattern(regex_t* pattern, const char* text, match_context* ctx)
{
  if (pattern == 0)
  {
    return text;
  }

  if (pattern->type == RE_UNUSED)
  {
    return text;
  }

  re_capture snapshot[64];
  snapshot_captures(ctx, snapshot);

  regex_t* current = pattern;
  const char* cursor = text;

  while (current != 0 && current->type != RE_UNUSED)
  {
    regex_t* next = current->next;

    if (current->type == RE_GROUP_END)
    {
      regex_t* owner = current->u.group.first;
      if ((owner != 0) && (owner->u.group.id > 0) && (ctx->captures != 0))
      {
        int idx = owner->u.group.id - 1;
        if (idx < ctx->capture_capacity)
        {
          int start = ctx->captures[idx].start;
          if (start >= 0)
          {
            ctx->captures[idx].length = (int)(cursor - ctx->base) - start;
            if (ctx->captures[idx].length < 0)
            {
              ctx->captures[idx].length = 0;
            }
          }
        }
      }
      current = current->next;
      continue;
    }

    if ((next != 0) && (next->type == RE_QUESTIONMARK))
    {
      const char* result = matchquestion(current, next->next, cursor, ctx);
      if (result != 0)
      {
        return result;
      }
      restore_captures(ctx, snapshot);
      return ((void*)0);
    }
    else if ((next != 0) && (next->type == RE_STAR))
    {
      const char* result = matchstar(current, next->next, cursor, ctx);
      if (result != 0)
      {
        return result;
      }
      restore_captures(ctx, snapshot);
      return ((void*)0);
    }
    else if ((next != 0) && (next->type == RE_PLUS))
    {
      const char* result = matchplus(current, next->next, cursor, ctx);
      if (result != 0)
      {
        return result;
      }
      restore_captures(ctx, snapshot);
      return ((void*)0);
    }
    else if (current->type == RE_GROUP)
    {
      const char* result = matchgroup(current, next, cursor, ctx);
      if (result != 0)
      {
        return result;
      }
      restore_captures(ctx, snapshot);
      return ((void*)0);
    }
    else if (current->type == RE_END)
    {
      if (*cursor != '\0')
      {
        restore_captures(ctx, snapshot);
        return ((void*)0);
      }
      current = current->next;
    }
    else
    {
      const char* after = matchtoken(current, cursor, ctx);
      if (after == 0)
      {
        restore_captures(ctx, snapshot);
        return ((void*)0);
      }
      cursor = after;
      current = current->next;
    }
  }

  return cursor;
}

uniq const char* matchgroup(regex_t* token, regex_t* rest, const char* text, match_context* ctx)
{
  re_capture snapshot_entry[64];
  snapshot_captures(ctx, snapshot_entry);

  regex_t* end_token = token->u.group.last;
  regex_t* saved_next = end_token != 0 ? end_token->next : 0;
  if (end_token != 0)
  {
    end_token->next = rest;
  }

  if (token->u.group.id > 0 && ctx->captures != 0)
  {
    int idx = token->u.group.id - 1;
    if (idx < ctx->capture_capacity)
    {
      ctx->captures[idx].start = (int)(text - ctx->base);
      ctx->captures[idx].length = 0;
    }
  }

  const char* result = matchpattern(token->u.group.first, text, ctx);

  if (end_token != 0)
  {
    end_token->next = saved_next;
  }

  if (result == 0)
  {
    restore_captures(ctx, snapshot_entry);
  }

  return result;
}

uniq const char* matchstar(regex_t* token, regex_t* rest, const char* text, match_context* ctx)
{
  re_capture snapshot_entry[64];
  snapshot_captures(ctx, snapshot_entry);

  const char* consume = matchtoken(token, text, ctx);
  while ((consume != 0) && (consume != text))
  {
    re_capture snapshot_after_token[64];
    snapshot_captures(ctx, snapshot_after_token);

    const char* recursive = matchstar(token, rest, consume, ctx);
    if (recursive != 0)
    {
      return recursive;
    }

    restore_captures(ctx, snapshot_after_token);
    consume = matchtoken(token, consume, ctx);
  }

  restore_captures(ctx, snapshot_entry);
  return matchpattern(rest, text, ctx);
}

uniq const char* matchplus(regex_t* token, regex_t* rest, const char* text, match_context* ctx)
{
  re_capture snapshot_entry[64];
  snapshot_captures(ctx, snapshot_entry);

  const char* first = matchtoken(token, text, ctx);
  if ((first == 0) || (first == text))
  {
    restore_captures(ctx, snapshot_entry);
    return ((void*)0);
  }

  const char* result = matchstar(token, rest, first, ctx);
  if (result != 0)
  {
    return result;
  }

  restore_captures(ctx, snapshot_entry);
  return ((void*)0);
}

uniq const char* matchquestion(regex_t* token, regex_t* rest, const char* text, match_context* ctx)
{
  re_capture snapshot_entry[64];
  snapshot_captures(ctx, snapshot_entry);

  const char* skipped = matchpattern(rest, text, ctx);
  if (skipped != 0)
  {
    return skipped;
  }

  restore_captures(ctx, snapshot_entry);

  const char* consumed = matchtoken(token, text, ctx);
  if ((consumed == 0) || (consumed == text))
  {
    restore_captures(ctx, snapshot_entry);
    return ((void*)0);
  }

  const char* with = matchpattern(rest, consumed, ctx);
  if (with != 0)
  {
    return with;
  }

  restore_captures(ctx, snapshot_entry);
  return ((void*)0);
}

uniq unsigned char re_fold_char(unsigned char c, _Bool ignore_case)
{
  if (ignore_case && c >= 'A' && c <= 'Z')
  {
    return (unsigned char)(c - 'A' + 'a');
  }
  return c;
}

uniq const char* matchtoken(regex_t* token, const char* text, match_context* ctx)
{
  switch (token->type)
  {
    case RE_DOT:
      return (*text != '\0' && matchdot(*text)) ? text + 1 : 0;

    case RE_CHAR:
      return (*text != '\0'
        && re_fold_char(token->u.ch, ctx->ignore_case) == re_fold_char((unsigned char)*text, ctx->ignore_case))
        ? text + 1 : 0;

    case RE_CHAR_CLASS:
      return (*text != '\0' && matchcharclass(*text, (const char*)token->u.ccl, ctx->ignore_case)) ? text + 1 : 0;

    case RE_INV_CHAR_CLASS:
      return (*text != '\0' && !matchcharclass(*text, (const char*)token->u.ccl, ctx->ignore_case)) ? text + 1 : 0;

    case RE_DIGIT:
      return (*text != '\0' && matchdigit(*text)) ? text + 1 : 0;

    case RE_NOT_DIGIT:
      return (*text != '\0' && !matchdigit(*text)) ? text + 1 : 0;

    case RE_ALPHA:
      return (*text != '\0' && matchalphanum(*text)) ? text + 1 : 0;

    case RE_NOT_ALPHA:
      return (*text != '\0' && !matchalphanum(*text)) ? text + 1 : 0;

    case RE_WHITESPACE:
      return (*text != '\0' && matchwhitespace(*text)) ? text + 1 : 0;

    case RE_NOT_WHITESPACE:
      return (*text != '\0' && !matchwhitespace(*text)) ? text + 1 : 0;

    case RE_GROUP:
      return matchgroup(token, (regex_t*)0, text, ctx);

    case RE_BEGIN:
      return (text == ctx->base) ? text : 0;

    case RE_END:
      return (*text == '\0') ? text : 0;

    default:
      break;
  }

  return (const char*)0;
}


uniq int matchdigit(char c)
{
  return xisdigit((unsigned char)c);
}
uniq int matchalpha(char c)
{
  return xisalpha((unsigned char)c);
}
uniq int matchwhitespace(char c)
{
  return xisspace((unsigned char)c);
}
uniq int matchalphanum(char c)
{
  return ((c == '_') || matchalpha(c) || matchdigit(c));
}
uniq int matchrange(char c, const char* str, _Bool ignore_case)
{
  unsigned char needle = (unsigned char)c;
  unsigned char start = (unsigned char)str[0];
  unsigned char end = (unsigned char)str[2];
  if (ignore_case)
  {
    needle = re_fold_char(needle, true);
    start = re_fold_char(start, true);
    end = re_fold_char(end, true);
  }
  return (    (needle != '-')
           && (str[0] != '\0')
           && (str[0] != '-')
           && (str[1] == '-')
           && (str[2] != '\0')
           && (    (needle >= start)
                && (needle <= end)));
}
uniq int matchdot(char c)
{
#line 6586 "/usr/local/include/neo-c.h"
  return c != '\n' && c != '\r';
#line 6588 "/usr/local/include/neo-c.h"
}
uniq int ismetachar(char c)
{
  return ((c == 's') || (c == 'S') || (c == 'w') || (c == 'W') || (c == 'd') || (c == 'D'));
}

uniq int matchmetachar(char c, const char* str)
{
  switch (str[0])
  {
    case 'd': return  matchdigit(c);
    case 'D': return !matchdigit(c);
    case 'w': return  matchalphanum(c);
    case 'W': return !matchalphanum(c);
    case 's': return  matchwhitespace(c);
    case 'S': return !matchwhitespace(c);
    default:  return (c == str[0]);
  }
}

uniq int matchcharclass(char c, const char* str, _Bool ignore_case)
{
  unsigned char needle = re_fold_char((unsigned char)c, ignore_case);
  do
  {
    if (matchrange((char)needle, str, ignore_case))
    {
      return 1;
    }
    else if (str[0] == '\\')
    {
      str += 1;
      if (matchmetachar((char)needle, str))
      {
        return 1;
      }
      else if ((needle == re_fold_char((unsigned char)str[0], ignore_case)) && !ismetachar((char)needle))
      {
        return 1;
      }
    }
    else if (needle == re_fold_char((unsigned char)str[0], ignore_case))
    {
      if (needle == '-')
      {
        return ((str[-1] == '\0') || (str[1] == '\0'));
      }
      else
      {
        return 1;
      }
    }
  }
  while (*str++ != '\0');

  return 0;
}

uniq void re_print_internal(regex_t* pattern, int depth)
{
  const char* types[] =
  {
    "RE_UNUSED", "RE_DOT", "RE_BEGIN", "RE_END", "RE_QUESTIONMARK", "RE_STAR", "RE_PLUS", "RE_CHAR",
    "RE_CHAR_CLASS", "RE_INV_CHAR_CLASS", "RE_DIGIT", "RE_NOT_DIGIT", "RE_ALPHA", "RE_NOT_ALPHA",
    "RE_WHITESPACE", "RE_NOT_WHITESPACE", "RE_GROUP", "RE_GROUP_END"
  };

  while (pattern != 0 && pattern->type != RE_UNUSED)
  {
    for (int i = 0; i < depth; ++i)
    {
      putchar(' ');
    }
    printf("type: %s", types[pattern->type]);

    if ((pattern->type == RE_CHAR_CLASS) || (pattern->type == RE_INV_CHAR_CLASS))
    {
      printf(" [");
      const unsigned char* ccl = pattern->u.ccl;
      while (*ccl != '\0' && *ccl != ']')
      {
        printf("%c", *ccl);
        ++ccl;
      }
      printf("]");
    }
    else if (pattern->type == RE_CHAR)
    {
      printf(" '%c'", pattern->u.ch);
    }
    else if (pattern->type == RE_GROUP)
    {
      printf(" id=%d\n", pattern->u.group.id);
      re_print_internal(pattern->u.group.first, depth + 2);
      pattern = pattern->next;
      continue;
    }

    printf("\n");
    pattern = pattern->next;
  }
}

uniq int re_get_group_count(re_t pattern)
{
  if (pattern == 0)
  {
    return 0;
  }

  regex_program_t* program = (regex_program_t*) pattern;
  return program->group_count;
}

#line 6705 "/usr/local/include/neo-c.h"

uniq string string::lower_case(const char* str)
{
    if(str == null) {
        return string("");
    }
    
    string result = string(str);
    for(int i=0; i<strlen(str); i++) {
        if(str[i] >= 'A' && str[i] <= 'Z') {
            result[i] = str[i] - 'A' + 'a';
        }
    }
    
    return result;
}

uniq string string::upper_case(const char* str)
{
    if(str == null) {
        return string("");
    }
    
    string result = string(str);
    for(int i=0; i<strlen(str); i++) {
        if(str[i] >= 'a' && str[i] <= 'z') {
            result[i] = str[i] - 'a' + 'A';
        }
    }
    
    return result;
}

uniq int char*::index_regex(const char* self, const char* reg, int default_value, _Bool ignore_case=false)
{
    if(self == null || reg == null) {
        return default_value;
    }
    
    re_t re = re_compile(reg);
    
    if(re == ((void*)0)) {
        return default_value;
    }
    
    int result = default_value;
    
    int offset = 0;

    int n = 0;
    
    int result = default_value;

    while(true) {
        int matchlength = 0;
        int max_captures = 8;
        re_capture captures[max_captures];
        int regex_result = re_matchp_ex(re, self, &matchlength, captures, max_captures, ignore_case);

        
        if(regex_result >= 0) 
        {
            result = regex_result;
            break;
        }
        
        {
            break;
        }
    }

    return result;
}

uniq int char*::rindex(const char* str, const char* search_str, int default_value)
{
    if(str == null || search_str == null) {
        return default_value;
    }
    
    int len = strlen(search_str);
    char* p = str + strlen(str) - len;

    while(p >= str) {
        if(strncmp(p, search_str, len) == 0) {
            return p - str;
        }

        p--;
    }

    return default_value;
}

uniq int char*::rindex_regex(const char* self, const char* reg, int default_value, _Bool ignore_case=false)
{
    if(self == null || reg == null) {
        return default_value;
    }
    
    re_t re = re_compile(reg);
    
    if(re == ((void*)0)) {
        return default_value;
    }
    
    int result = default_value;
    
    int offset = 0;

    int n = 0;
    
    string self2 = self.reverse();

    int result = default_value;

    while(true) {
        int matchlength = 0;
        int max_captures = 8;
        re_capture captures[max_captures];
        int regex_result = re_matchp_ex(re, self2, &matchlength, captures, max_captures, ignore_case);

        
        if(regex_result >= 0) 
        {
            result = strlen(self) -matchlength;
            break;
        }
        
        {
            break;
        }
    }

    return result;
}

uniq string char*::strip(const char* self)
{
    if(self == null) {
        return string("");
    }
    string result = string(self);
    
    int len = strlen(self);
    
    if(self[len-1] == '\n') {
        result[len-1] = '\0';
    }
    else if(self[len-1] == '\r') {
        result[len-1] = '\0';
    }
    else if(len > 2 && self[len-2] == '\r' && self[len-1] == '\n') {
        result[len-2] = '\0';
    }
    
    return result;
}

uniq int char*::index(const char* str, const char* search_str, int default_value)
{
    if(str == null || search_str == null) {
        return default_value;
    }
    
    char* head = strstr(str, search_str);

    if(head == null) {
        return default_value;
    }

    return head - str;
}

uniq string string::chomp(const char* str)
{
    if(str == null) {
        return string("");
    }
    string result = string(str);
    
    if(result[result.length()-1] == '\n') {
        return result.substring(0, -2);
    }
    
    return result;
}

#line 6894 "/usr/local/include/neo-c.h"
    uniq string xrealpath(const char* path)
    {
        if(path == null) {
            return string("");
        }
        char* result = realpath(path, null);
    
        string result2 = string(result);
    
        free(result);
    
        return result2;
    }
#line 6908 "/usr/local/include/neo-c.h"

uniq string char*::replace(char* self, int index, char c)
{
    if(self == null) {
        return string("");
    }
    
    int len = strlen(self);

    if(strcmp(self, "") == 0) {
        return string(self);
    }
    
    if(index < 0) {
       index += len;
    }

    if(index >= len) {
        index = len-1;
    }

    if(index < 0) {
        index = 0;
    }
    
    self[index] = c;
    
    return string(self);
}

uniq string char*::multiply(char* str, int n)
{
    if(str == null) {
        return string("");
    }
    
    int len = strlen(str) * n + 1;

    char*% result = new char[len];

    result[0] = '\0';

    for(int i=0; i<n; i++) {
        strncat(result, str, len);
    }

    return result;
}

uniq list<string>*% char*::split_str(const char* self, const char* str) 
{
    if(self == null || str == null) {
        return new list<string>();
    }
    
    var result = new list<string>.initialize();

    var buf = new buffer.initialize();

    for(int i=0; i<self.length(); i++) {
        if(strstr(self + i, str) == self + i) {
            result.push_back(string(buf.buf));
            buf.reset();
            i += strlen(str)-1;
        }
        else {
            buf.append_char(self[i]);
        }
    }
    if(buf.length() != 0) {
        result.push_back(string(buf.buf));
    }

    return result;
}

uniq int string::rindex(char* str, const char* search_str, int default_value=-1) 
{
    return char*::rindex(str, search_str, default_value);
}

uniq int string::rindex_regex(char* self, const char* reg, int default_value=-1, _Bool ignore_case=false)
{
    return char*::rindex_regex(self, reg, default_value, ignore_case);
}

uniq string string::strip(const char* self)
{
    return char*::strip(self);
}

uniq int string::index(char* str, const char* search_str, int default_value=-1)
{
    return char*::index(str, search_str, default_value);
}

uniq int string::index_regex(char* self, const char* reg, int default_value=-1, _Bool ignore_case=false)
{
    return char*::index_regex(self, reg, default_value, ignore_case);
}

uniq string string::replace(char* self, int index, char c)
{
    return char*::replace(self, index, c);
}

uniq string string::multiply(char* str, int n)
{
    return char*::multiply(str, n);
}

uniq _Bool char*::match(char* self, const char* reg, _Bool ignore_case=false)
{
    if(self == null || reg == null) {
        return false;
    }
    
    re_t re = re_compile(reg);
    
    if(re == ((void*)0)) {
        return false;
    }
    
    int offset = 0;

    int n = 0;
    
    int matchlength = 0;
    int max_captures = 8;
    re_capture captures[max_captures];
    int regex_result = re_matchp_ex(re, self, &matchlength, captures, max_captures, ignore_case);

    
    if(regex_result >= 0)
    {
        return true;
    }
    
    else
    {
        return false;
    }
}

uniq list<string>*% char*::scan(const char* self, const char* reg, _Bool ignore_case=false)
{
    if(self == null || reg == null) {
        return new list<string>();
    }
    var result = new list<string>();
    
    re_t re = re_compile(reg);
    
    if(re == ((void*)0)) {
        return new list<string>();
    }
    
    int offset = 0;

    int n = 0;
    
    int group_count = re_get_group_count(re);

    while(true) {
        int matchlength = 0;
        int max_captures = 8;
        re_capture captures[max_captures];
        int regex_result = re_matchp_ex(re, self + offset, &matchlength, captures, max_captures, ignore_case);

        
        if(regex_result >= 0 && group_count == 0)
        {
            string str = self.substring(offset + regex_result, offset + regex_result + matchlength);

            result.add(str);
            
            if(matchlength == 0) {
                offset++;
            }
            else {
                offset = offset + regex_result + matchlength;
            }
        }
        
        else if(regex_result >= 0 && group_count > 0) {
            for(int i=0; i<group_count; i++) {
                re_capture* cp = &captures[i];
                var match_string = (self + offset).substring(cp->start, cp->start + cp->length);
                result.push_back(match_string);
            }
            
            if(matchlength == 0) {
                offset++;
            }
            else {
                offset = offset + regex_result + matchlength;
            }
        }
        
        else {
            break;
        }
    }

    return result;
}

uniq list<string>*% char*::split(const char* self, const char* reg, _Bool ignore_case=false)
{
    if(self == null || reg == null) {
        return new list<string>();
    }
    
    var result = new list<string>();
    
    re_t re = re_compile(reg);
    
    if(re == ((void*)0)) {
        return new list<string>();
    }
    
    int offset = 0;

    int n = 0;
    
    int group_count = re_get_group_count(re);

    while(true) {
        int matchlength = 0;
        int max_captures = 8;
        re_capture captures[max_captures];
        int regex_result = re_matchp_ex(re, self + offset, &matchlength, captures, max_captures, ignore_case);

        
        if(regex_result >= 0 && group_count == 0)
        {
            string str = self.substring(offset, offset + regex_result);

            result.add(str);
            
            if(matchlength == 0) {
                offset++;
            }
            else {
                offset = offset + regex_result + matchlength;
            }
        }
        
        else
        {
            break;
        }
    }

    if(offset < self.length()) {
        string str = self.substring(offset, -1);
        result.push_back(str);
    }

    return result;
}

uniq string string::sub(char* self, const char* reg, const char* replace, _Bool ignore_case=false)
{
    return char*::sub(self, reg, replace, true, ignore_case);
}

uniq list<string>*% string::split_str(char* self, const char* str)
{
    return char*::split_str(self, str);
}

uniq list<string>*% string::scan(char* self, const char* reg, _Bool ignore_case=false)
{
    return char*::scan(self, reg, ignore_case);
}

uniq list<string>*% string::split(char* self, const char* reg, _Bool ignore_case=false)
{
    return char*::split(self, reg, ignore_case);
}

uniq _Bool string::match(char* self, const char* reg, _Bool ignore_case=false)
{
    return char*::match(self, reg, ignore_case);
}

uniq string char*::sub(char* self, const char* reg, const char* replace, _Bool global=true, _Bool ignore_case=false)
{
    if(self == null || reg == null) {
        return string("");
    }
    
    re_t re = re_compile(reg);
    
    if(re == ((void*)0)) {
        return string("");
    }
    
    int offset = 0;

    int n = 0;
    
    var result = new buffer.initialize();
    
    int group_count = re_get_group_count(re);

    while(true) {
        int matchlength = 0;
        int max_captures = 8;
        re_capture captures[max_captures];
        int regex_result = re_matchp_ex(re, self + offset, &matchlength, captures, max_captures, ignore_case);

        
        if(regex_result >= 0 && group_count == 0)
        {
            string str = self.substring(offset, offset + regex_result);

            result.append_str(str);
            result.append_str(replace);
            
            if(matchlength == 0) {
                offset++;
            }
            else {
                offset = offset + regex_result + matchlength;
            }
            
            if(!global) {
                string str = self.substring(offset, -1);
                result.append_str(str);
                break;
            }
        }
        
        else {
            string str = self.substring(offset, -1);
            result.append_str(str);
            break;
        }
    }

    return result.to_string();
}

uniq string char*::sub_block(char* self, const char* reg, _Bool global=true, _Bool ignore_case=false, void* parent, string (*block)(void* parent, char* match_string, list<string>* group_strings))
{
    if(self == null || reg == null) {
        return string("");
    }
    
    var result = new buffer();
    
    re_t re = re_compile(reg);
    
    if(re == ((void*)0)) {
        return string("");
    }
    
    int offset = 0;

    int n = 0;
    
    int group_count = re_get_group_count(re);

    while(true) {
        int matchlength = 0;
        int max_captures = 8;
        re_capture captures[max_captures];
        int regex_result = re_matchp_ex(re, self + offset, &matchlength, captures, max_captures, ignore_case);

        
        if(regex_result >= 0 && group_count == 0)
        {
            string str = self.substring(offset, offset + regex_result);

            result.append_str(str);
            
            list<string>*% group_strings = new list<string>.initialize();
            
            string match_string = self.substring(offset + regex_result, offset + regex_result + matchlength);
            
            string block_result = block(parent, match_string, group_strings);
            
            result.append_str(block_result);
            
            if(matchlength == 0) {
                offset++;
            }
            else {
                offset = offset + regex_result + matchlength;
            }
            
            if(!global) {
                string str = self.substring(offset, -1);
                result.append_str(str);
                break;
            }
        }

        
        else if(regex_result >= 0 && group_count > 0) {
            string str = self.substring(offset, offset + regex_result);

            result.append_str(str);

            list<string>*% group_strings = new list<string>.initialize();

            for(int i=0; i<group_count; i++) {
                re_capture* cp = &captures[i];
                var match_string = (self + offset).substring(cp->start, cp->start + cp->length);
                group_strings.push_back(match_string);
            }
            
            string match_string = self.substring(offset + regex_result, offset + regex_result + matchlength);
            
            string block_result = block(parent, match_string, group_strings);
            
            result.append_str(block_result);
            
            if(matchlength == 0) {
                offset++;
            }
            else {
                offset = offset + regex_result + matchlength;
            }
        }
        
        else {
            string str = self.substring(offset, -1);
            result.append_str(str);
            break;
        }
    }
    return result.to_string();
}

uniq list<string>*% char*::scan_block(const char* self, const char* reg, _Bool ignore_case=false, void* parent, string (*block)(void* parent, char* match_string, list<string>* group_strings))
{
    if(self == null || reg == null) {
        return new list<string>();
    }
    var result = new list<string>();
    
    re_t re = re_compile(reg);
    
    if(re == ((void*)0)) {
        return new list<string>();
    }
    
    int offset = 0;

    int n = 0;
    
    int group_count = re_get_group_count(re);

    while(true) {
        int matchlength = 0;
        int max_captures = 8;
        re_capture captures[max_captures];
        int regex_result = re_matchp_ex(re, self + offset, &matchlength, captures, max_captures, ignore_case);

        
        if(regex_result >= 0 && group_count == 0)
        {
            list<string>*% group_strings = new list<string>.initialize();
            
            string match_string = self.substring(offset + regex_result, offset + regex_result + matchlength);
            
            string block_result = block(parent, match_string, group_strings);
            
            result.add(block_result);
            
            if(matchlength == 0) {
                offset++;
            }
            else {
                offset = offset + regex_result + matchlength;
            }
        }
        
        else if(regex_result >= 0 && group_count > 0) {
            list<string>*% group_strings = new list<string>.initialize();

            for(int i=0; i<group_count; i++) {
                re_capture* cp = &captures[i];
                var match_string = (self + offset).substring(cp->start, cp->start + cp->length);
                group_strings.push_back(match_string);
            }
            
            string match_string = self.substring(offset + regex_result, offset + regex_result + matchlength);
            
            string block_result = block(parent, match_string, group_strings);
            
            result.add(block_result);
            
            if(matchlength == 0) {
                offset++;
            }
            else {
                offset = offset + regex_result + matchlength;
            }
        }
        
        else {
            break;
        }
    }

    return result;
}

uniq string string::sub_block(char* self, const char* reg, _Bool global=true, _Bool ignore_case=false, void* parent, string (*block)(void* parent, char* match_string, list<string>* group_strings))
{
    return char*::sub_block(self, reg, global, ignore_case, parent, block);
}

#line 7428 "/usr/local/include/neo-c.h"

#line 1 "/usr/include/wchar.h"






















#line 25 "/usr/include/wchar.h"

#line 1 "/usr/include/bits/libc-header-start.h"


























#line 30 "/usr/include/bits/libc-header-start.h"

#line 32 "/usr/include/bits/libc-header-start.h"

#line 1 "/usr/include/features.h"
















#line 34 "/usr/include/bits/libc-header-start.h"



#line 43 "/usr/include/bits/libc-header-start.h"























#line 84 "/usr/include/bits/libc-header-start.h"





#line 101 "/usr/include/bits/libc-header-start.h"


#line 28 "/usr/include/wchar.h"


#line 1 "/usr/include/bits/floatn.h"

















#line 31 "/usr/include/wchar.h"

#line 1 "/usr/lib/clang/21/include/stddef.h"





















#line 37 "/usr/lib/clang/21/include/stddef.h"

#line 80 "/usr/lib/clang/21/include/stddef.h"

#line 85 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_size_t.h"












#line 88 "/usr/lib/clang/21/include/stddef.h"
#line 90 "/usr/lib/clang/21/include/stddef.h"

#line 95 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_wchar_t.h"









#line 11 "/usr/lib/clang/21/include/__stddef_wchar_t.h"





#line 26 "/usr/lib/clang/21/include/__stddef_wchar_t.h"
#line 98 "/usr/lib/clang/21/include/stddef.h"
#line 100 "/usr/lib/clang/21/include/stddef.h"

#line 1 "/usr/lib/clang/21/include/__stddef_null.h"









#line 11 "/usr/lib/clang/21/include/__stddef_null.h"






#line 18 "/usr/lib/clang/21/include/__stddef_null.h"

#line 28 "/usr/lib/clang/21/include/__stddef_null.h"
#line 103 "/usr/lib/clang/21/include/stddef.h"
#line 105 "/usr/lib/clang/21/include/stddef.h"

#line 110 "/usr/lib/clang/21/include/stddef.h"

#line 115 "/usr/lib/clang/21/include/stddef.h"

#line 120 "/usr/lib/clang/21/include/stddef.h"

#line 125 "/usr/lib/clang/21/include/stddef.h"



#line 132 "/usr/lib/clang/21/include/stddef.h"
#line 36 "/usr/include/wchar.h"

#line 1 "/usr/lib/clang/21/include/stdarg.h"





















#line 45 "/usr/lib/clang/21/include/stdarg.h"

#line 1 "/usr/lib/clang/21/include/__stdarg___gnuc_va_list.h"








#line 48 "/usr/lib/clang/21/include/stdarg.h"
#line 50 "/usr/lib/clang/21/include/stdarg.h"

#line 55 "/usr/lib/clang/21/include/stdarg.h"

#line 60 "/usr/lib/clang/21/include/stdarg.h"

#line 65 "/usr/lib/clang/21/include/stdarg.h"

#line 70 "/usr/lib/clang/21/include/stdarg.h"
#line 39 "/usr/include/wchar.h"

#line 50 "/usr/include/wchar.h"

#line 1 "/usr/include/bits/wchar.h"


















#line 21 "/usr/include/bits/wchar.h"












#line 40 "/usr/include/bits/wchar.h"

#line 48 "/usr/include/bits/wchar.h"
#line 52 "/usr/include/wchar.h"
#line 1 "/usr/include/bits/types/wint_t.h"
#line 3 "/usr/include/bits/types/wint_t.h"






#line 11 "/usr/include/bits/types/wint_t.h"





#line 19 "/usr/include/bits/types/wint_t.h"

typedef unsigned int wint_t;
#line 53 "/usr/include/wchar.h"
#line 1 "/usr/include/bits/types/mbstate_t.h"
#line 3 "/usr/include/bits/types/mbstate_t.h"

#line 1 "/usr/include/bits/types/__mbstate_t.h"
#line 5 "/usr/include/bits/types/mbstate_t.h"

typedef __mbstate_t mbstate_t;
#line 54 "/usr/include/wchar.h"
#line 1 "/usr/include/bits/types/__FILE.h"
#line 55 "/usr/include/wchar.h"

#line 1 "/usr/include/bits/types/FILE.h"
#line 58 "/usr/include/wchar.h"
#line 1 "/usr/include/bits/types/locale_t.h"

















#line 61 "/usr/include/wchar.h"
#line 62 "/usr/include/wchar.h"


#line 67 "/usr/include/wchar.h"

#line 69 "/usr/include/wchar.h"

#line 73 "/usr/include/wchar.h"

#line 77 "/usr/include/wchar.h"








#line 88 "/usr/include/wchar.h"





struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
			const wchar_t *__restrict __src)
      ;


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
			 const wchar_t *__restrict __src, size_t __n)
      ;

#line 107 "/usr/include/wchar.h"

extern size_t wcslcpy (wchar_t *__restrict __dest,
		       const wchar_t *__restrict __src, size_t __n)
    ;



extern size_t wcslcat (wchar_t *__restrict __dest,
		       const wchar_t *__restrict __src, size_t __n)
     ;
#line 118 "/usr/include/wchar.h"


extern wchar_t *wcscat (wchar_t *__restrict __dest,
			const wchar_t *__restrict __src)
      ;

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
			 const wchar_t *__restrict __src, size_t __n)
      ;


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
      __attribute__ ((__pure__)) ;

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
      __attribute__ ((__pure__)) ;

#line 136 "/usr/include/wchar.h"

extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) ;


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
			size_t __n) ;



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
			 locale_t __loc) ;

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
			  size_t __n, locale_t __loc) ;
#line 151 "/usr/include/wchar.h"



extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) ;



extern size_t wcsxfrm (wchar_t *__restrict __s1,
		       const wchar_t *__restrict __s2, size_t __n) ;

#line 162 "/usr/include/wchar.h"





extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
		      locale_t __loc) ;




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
			 size_t __n, locale_t __loc) ;


extern wchar_t *wcsdup (const wchar_t *__s) 
  __attribute__ ((__malloc__)) ;
#line 180 "/usr/include/wchar.h"


#line 188 "/usr/include/wchar.h"
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
      __attribute__ ((__pure__));
#line 191 "/usr/include/wchar.h"

#line 198 "/usr/include/wchar.h"
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
      __attribute__ ((__pure__));
#line 201 "/usr/include/wchar.h"

#line 203 "/usr/include/wchar.h"


extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
      __attribute__ ((__pure__));
#line 208 "/usr/include/wchar.h"



extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
      __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
      __attribute__ ((__pure__));

#line 225 "/usr/include/wchar.h"
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
      __attribute__ ((__pure__));
#line 228 "/usr/include/wchar.h"

#line 236 "/usr/include/wchar.h"
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
      __attribute__ ((__pure__));
#line 239 "/usr/include/wchar.h"


extern wchar_t *wcstok (wchar_t *__restrict __s,
			const wchar_t *__restrict __delim,
			wchar_t **__restrict __ptr) ;


extern size_t wcslen (const wchar_t *__s)  __attribute__ ((__pure__));

#line 249 "/usr/include/wchar.h"

#line 257 "/usr/include/wchar.h"
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
      __attribute__ ((__pure__));
#line 261 "/usr/include/wchar.h"

#line 263 "/usr/include/wchar.h"

extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
      __attribute__ ((__pure__));
#line 267 "/usr/include/wchar.h"



#line 277 "/usr/include/wchar.h"
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
      __attribute__ ((__pure__));
#line 280 "/usr/include/wchar.h"


extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
      __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
			 const wchar_t *__restrict __s2, size_t __n) ;



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     ;


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) ;

#line 298 "/usr/include/wchar.h"


extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
			  const wchar_t *__restrict __s2, size_t __n)
     ;
#line 304 "/usr/include/wchar.h"




extern wint_t btowc (int __c) ;



extern int wctob (wint_t __c) ;



extern int mbsinit (const mbstate_t *__ps)  __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
		       const char *__restrict __s, size_t __n,
		       mbstate_t *__restrict __p) ;


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
		       mbstate_t *__restrict __ps) ;


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
			mbstate_t *__restrict __ps) ;
extern size_t mbrlen (const char *__restrict __s, size_t __n,
		      mbstate_t *__restrict __ps) ;

#line 358 "/usr/include/wchar.h"



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
			 const char **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) ;



extern size_t wcsrtombs (char *__restrict __dst,
			 const wchar_t **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) ;


#line 373 "/usr/include/wchar.h"


extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
			  const char **__restrict __src, size_t __nmc,
			  size_t __len, mbstate_t *__restrict __ps) ;



extern size_t wcsnrtombs (char *__restrict __dst,
			  const wchar_t **__restrict __src,
			  size_t __nwc, size_t __len,
			  mbstate_t *__restrict __ps) ;
#line 386 "/usr/include/wchar.h"



#line 390 "/usr/include/wchar.h"

extern int wcwidth (wchar_t __c) ;



extern int wcswidth (const wchar_t *__s, size_t __n) ;
#line 397 "/usr/include/wchar.h"




extern double wcstod (const wchar_t *__restrict __nptr,
		      wchar_t **__restrict __endptr) ;

#line 405 "/usr/include/wchar.h"

extern float wcstof (const wchar_t *__restrict __nptr,
		     wchar_t **__restrict __endptr) ;
extern long double wcstold (const wchar_t *__restrict __nptr,
			    wchar_t **__restrict __endptr) ;
#line 411 "/usr/include/wchar.h"

#line 413 "/usr/include/wchar.h"


#line 419 "/usr/include/wchar.h"

#line 421 "/usr/include/wchar.h"
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
			  wchar_t **__restrict __endptr) ;
#line 424 "/usr/include/wchar.h"

#line 426 "/usr/include/wchar.h"
extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
			  wchar_t **__restrict __endptr) ;
#line 429 "/usr/include/wchar.h"

#line 434 "/usr/include/wchar.h"

#line 436 "/usr/include/wchar.h"
extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
			    wchar_t **__restrict __endptr) ;
#line 439 "/usr/include/wchar.h"

#line 441 "/usr/include/wchar.h"
extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
			    wchar_t **__restrict __endptr) ;
#line 444 "/usr/include/wchar.h"

#line 450 "/usr/include/wchar.h"




extern long int wcstol (const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, int __base) ;



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
				  wchar_t **__restrict __endptr, int __base)
     ;

#line 464 "/usr/include/wchar.h"



extern long long int wcstoll (const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr, int __base)
     ;




extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
					wchar_t **__restrict __endptr,
					int __base) ;
#line 478 "/usr/include/wchar.h"

#line 480 "/usr/include/wchar.h"



extern long long int wcstoq (const wchar_t *__restrict __nptr,
			     wchar_t **__restrict __endptr, int __base)
     ;




extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
				       wchar_t **__restrict __endptr,
				       int __base) ;
#line 494 "/usr/include/wchar.h"



#line 528 "/usr/include/wchar.h"
extern long int __isoc23_wcstol (const wchar_t *__restrict __nptr,
				 wchar_t **__restrict __endptr, int __base)
     ;
extern unsigned long int __isoc23_wcstoul (const wchar_t *__restrict __nptr,
					   wchar_t **__restrict __endptr,
					   int __base)
     ;

extern long long int __isoc23_wcstoll (const wchar_t *__restrict __nptr,
				       wchar_t **__restrict __endptr,
				       int __base)
     ;

extern unsigned long long int __isoc23_wcstoull (const wchar_t *__restrict __nptr,
						 wchar_t **__restrict __endptr,
						 int __base)
     ;
#line 555 "/usr/include/wchar.h"

#line 557 "/usr/include/wchar.h"



extern long int wcstol_l (const wchar_t *__restrict __nptr,
			  wchar_t **__restrict __endptr, int __base,
			  locale_t __loc) ;

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
				    wchar_t **__restrict __endptr,
				    int __base, locale_t __loc) ;


extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
				wchar_t **__restrict __endptr,
				int __base, locale_t __loc) ;


extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
					  wchar_t **__restrict __endptr,
					  int __base, locale_t __loc)
     ;



#line 605 "/usr/include/wchar.h"
extern long int __isoc23_wcstol_l (const wchar_t *__restrict __nptr,
				   wchar_t **__restrict __endptr, int __base,
				   locale_t __loc) ;
extern unsigned long int __isoc23_wcstoul_l (const wchar_t *__restrict __nptr,
					     wchar_t **__restrict __endptr,
					     int __base, locale_t __loc)
     ;

extern long long int __isoc23_wcstoll_l (const wchar_t *__restrict __nptr,
					 wchar_t **__restrict __endptr,
					 int __base, locale_t __loc)
     ;

extern unsigned long long int __isoc23_wcstoull_l (const wchar_t *__restrict __nptr,
						   wchar_t **__restrict __endptr,
						   int __base, locale_t __loc)
     ;
#line 628 "/usr/include/wchar.h"

extern double wcstod_l (const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, locale_t __loc)
     ;

extern float wcstof_l (const wchar_t *__restrict __nptr,
		       wchar_t **__restrict __endptr, locale_t __loc)
     ;

extern long double wcstold_l (const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr,
			      locale_t __loc) ;

#line 646 "/usr/include/wchar.h"

#line 648 "/usr/include/wchar.h"
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
			    wchar_t **__restrict __endptr,
			    locale_t __loc) ;
#line 652 "/usr/include/wchar.h"

#line 654 "/usr/include/wchar.h"
extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
			    wchar_t **__restrict __endptr,
			    locale_t __loc) ;
#line 658 "/usr/include/wchar.h"

#line 664 "/usr/include/wchar.h"

#line 666 "/usr/include/wchar.h"
extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr,
			      locale_t __loc) ;
#line 670 "/usr/include/wchar.h"

#line 672 "/usr/include/wchar.h"
extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr,
			      locale_t __loc) ;
#line 676 "/usr/include/wchar.h"

#line 683 "/usr/include/wchar.h"


#line 686 "/usr/include/wchar.h"


extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
			const wchar_t *__restrict __src) ;



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
			 const wchar_t *__restrict __src, size_t __n)
     ;
#line 697 "/usr/include/wchar.h"




#line 714 "/usr/include/wchar.h"



extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) 
  __attribute__ ((__malloc__)) ;
#line 720 "/usr/include/wchar.h"

#line 722 "/usr/include/wchar.h"


extern int fwide (__FILE *__fp, int __mode) ;






extern int fwprintf (__FILE *__restrict __stream,
		     const wchar_t *__restrict __format, ...)
     ;




extern int wprintf (const wchar_t *__restrict __format, ...)
     ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
		     const wchar_t *__restrict __format, ...)
      ;





extern int vfwprintf (__FILE *__restrict __s,
		      const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
     ;




extern int vwprintf (const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
		      const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
      ;






extern int fwscanf (__FILE *__restrict __stream,
		    const wchar_t *__restrict __format, ...)
     ;




extern int wscanf (const wchar_t *__restrict __format, ...)
     ;

extern int swscanf (const wchar_t *__restrict __s,
		    const wchar_t *__restrict __format, ...)
      ;





#line 805 "/usr/include/wchar.h"
extern int __isoc23_fwscanf (__FILE *__restrict __stream,
			     const wchar_t *__restrict __format, ...);
extern int __isoc23_wscanf (const wchar_t *__restrict __format, ...);
extern int __isoc23_swscanf (const wchar_t *__restrict __s,
			     const wchar_t *__restrict __format, ...)
     ;
#line 841 "/usr/include/wchar.h"

#line 843 "/usr/include/wchar.h"

#line 845 "/usr/include/wchar.h"




extern int vfwscanf (__FILE *__restrict __s,
		     const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     ;




extern int vwscanf (const wchar_t *__restrict __format,
		    __gnuc_va_list __arg)
     ;

extern int vswscanf (const wchar_t *__restrict __s,
		     const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
      ;


#line 882 "/usr/include/wchar.h"
extern int __isoc23_vfwscanf (__FILE *__restrict __s,
			      const wchar_t *__restrict __format,
			      __gnuc_va_list __arg);
extern int __isoc23_vwscanf (const wchar_t *__restrict __format,
			     __gnuc_va_list __arg);
extern int __isoc23_vswscanf (const wchar_t *__restrict __s,
			      const wchar_t *__restrict __format,
			      __gnuc_va_list __arg) ;
#line 922 "/usr/include/wchar.h"

#line 924 "/usr/include/wchar.h"






extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
			__FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
		   __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);


#line 978 "/usr/include/wchar.h"







extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);








extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);








extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
				 __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
			    __FILE *__restrict __stream);
#line 1033 "/usr/include/wchar.h"





extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
			const wchar_t *__restrict __format,
			const struct tm *__restrict __tp) ;

#line 1043 "/usr/include/wchar.h"


extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
			  const wchar_t *__restrict __format,
			  const struct tm *__restrict __tp,
			  locale_t __loc) ;
#line 1050 "/usr/include/wchar.h"


#line 1056 "/usr/include/wchar.h"



#line 1062 "/usr/include/wchar.h"

#line 1067 "/usr/include/wchar.h"


#line 7431 "/usr/local/include/neo-c.h"
#line 1 "/usr/include/libgen.h"

















#line 20 "/usr/include/libgen.h"

#line 1 "/usr/include/features.h"
















#line 22 "/usr/include/libgen.h"




extern char *dirname (char *__path) ;







extern char *__xpg_basename (char *__path) ;
#line 36 "/usr/include/libgen.h"


#line 7432 "/usr/local/include/neo-c.h"
    
    typedef wchar_t*% wstring;
    
    uniq wstring __builtin_wstring(const char* str)
    {
        if(str == null) {
            return null;
        }
        int len = strlen(str);
    
        wstring wstr = new wchar_t[len+1];
    
        int ret = mbstowcs(wstr, str, len+1);
        wstr[ret] = '\0';
    
        if(ret < 0) {
            wstr[0] = 0;
        }
    
        return wstr;
    }
    
    uniq int wchar_t*::length(const wchar_t* str)
    {
        if(str == null) {
            return 0;
        }
        return wcslen(str);
    }
    
    uniq int wchar_t[]::length(const wchar_t* str)
    {
        if(str == null) {
            return 0;
        }
        return wcslen(str);
    }
    
    uniq int wstring::length(const wchar_t* str)
    {
        return wchar_t*::length(str);
    }
    
    uniq string string::lower_case(char* str)
    {
        if(str == null) {
            return string("");
        }
        string result = string(str);
        for(int i=0; i<strlen(str); i++) {
            if(str[i] >= 'A' && str[i] <= 'Z') {
                result[i] = str[i] - 'A' + 'a';
            }
        }
        
        return result;
    }
    
    uniq string string::upper_case(char* str)
    {
        if(str == null) {
            return string("");
        }
        string result = string(str);
        for(int i=0; i<strlen(str); i++) {
            if(str[i] >= 'a' && str[i] <= 'z') {
                result[i] = str[i] - 'a' + 'A';
            }
        }
        
        return result;
    }
    
    uniq wstring wchar_t*::substring(const wchar_t* str, int head, int tail)
    {
        if(str == null) {
            return wstring("");
        }
    
        int len = wcslen(str);
    
        if(head < 0) {
            head += len;
        }
        if(tail < 0) {
            tail += len + 1;
        }
    
        if(head > tail) {
            return wstring("");
        }
    
        if(head < 0) {
            head = 0;
        }
    
        if(tail >= len) {
            tail = len;
        }
        
        if(head >= len) {
            return wstring("");
        }
    
        if(head == tail) {
            return wstring("");
        }
    
        if(tail-head+1 < 1) {
            return wstring("");
        }
    
        wstring result = new wchar_t[tail-head+1];
    
        memcpy(result, str + head, sizeof(wchar_t)*(tail-head));
        result[tail-head] = '\0';
    
        return result;
    }
    
    uniq int char*::index_count(const char* str, const char* search_str, int count, int default_value)
    {
        if(str == null || search_str == null) {
            return default_value;
        }
        
        int n = 0;
        int len = strlen(str);
        for(int i=0; i<len; i++) {
            int len2 = strlen(search_str);
            int j;
            for(j=0; j<len2; j++) {
                if(str[i+j] != search_str[j]) {
                    break;
                }
            }
            
            if(j == len2) {
                n++;
                
                if(n == count) {
                    return i;
                }
            }
        }
        
        return default_value;
    }
    
    
    uniq int char*::rindex(const char* str, const char* search_str, int default_value)
    {
        if(str == null || search_str == null) {
            return default_value;
        }
        int len = strlen(search_str);
        char* p = (char*)(str + strlen(str) - len);
    
        while(p >= str) {
            if(strncmp(p, search_str, len) == 0) {
                return p - str;
            }
    
            p--;
        }
    
        return default_value;
    }
    
    
    uniq int char*::rindex_count(const char* str, const char* search_str, int count, int default_value)
    {
        if(str == null || search_str == null) {
            return default_value;
        }
        int len = strlen(search_str);
        const char* p = (char*)str + strlen(str) - len;
        
        int n = 0;
    
        while(p >= str) {
            if(strncmp(p, search_str, len) == 0) {
                n++;
                if(n == count) {
                    return p - str;
                }
            }
    
            p--;
        }
    
        return default_value;
    }
    
    uniq string char*::strip(const char* self)
    {
        if(self == null) {
            return string("");
        }
        
        string result = string(self);
        
        int len = strlen(self);
        
        if(self[len-1] == '\n') {
            result[len-1] = '\0';
        }
        else if(self[len-1] == '\r') {
            result[len-1] = '\0';
        }
        else if(len > 2 && self[len-2] == '\r' && self[len-1] == '\n') {
            result[len-2] = '\0';
        }
        
        return result;
    }
    
    uniq string wchar_t*::to_string(const wchar_t* wstr)
    {
        if(wstr == null) {
            return string("");
        }
        
        int len = 16*(wcslen(wstr)+1);
    
        string result = new char[len];
    
        if(wcstombs(result, wstr, len) < 0) 
        {
            strncpy(result, "", len);
        }
    
        return result;
    }
    
    uniq string wchar_t[]::to_string(const wchar_t* wstr)
    {
        if(wstr == null) {
            return string("");
        }
        return wchar_t*::to_string(wstr);
    }
    
    uniq wstring char*::to_wstring(const char* str)
    {
        if(str == null) {
            return wstring("");
        }
        return wstring(str);
    }
    
    uniq wstring char[]::to_wstring(char* str)
    {
        if(str == null) {
            return wstring("");
        }
        return wstring(str);
    }
    
uniq wstring wchar_t*::delete(wchar_t* str, int head, int tail) 
    {
        if(str == null) {
            return wstring("");
        }
        int len = wcslen(str);
    
        if(len == 0) {
            return str.to_string().to_wstring();
        }
        
        if(head < 0) {
           head += len;
        }
        
        if(tail < 0) {
           tail += len + 1;
        }
    
        if(head < 0) {
            head = 0;
        }
    
        if(tail < 0) {
            return str.to_string().to_wstring();
        }
    
        if(tail >= len) {
            tail = len;
        }
        
        wstring sub_str = str.substring(tail, -1);
    
        memcpy(str + head, sub_str, sizeof(wchar_t)*(sub_str.length()+1));
    
        return str.to_string().to_wstring();
    }
    
    uniq int wchar_t*::index(const wchar_t* str, const wchar_t* search_str, int default_value)
    {
        if(str == null || search_str == null) {
            return default_value;
        }
        
        wchar_t* head = wcsstr(str, search_str);
    
        if(head == null) {
            return default_value;
        }
    
        return head - str;
    }
    
    uniq int wchar_t*::rindex(const wchar_t* str, const wchar_t* search_str, int default_value)
    {
        if(str == null || search_str == null) {
            return default_value;
        }
        
        int len = wcslen(search_str);
    
        wchar_t* p = (wchar_t*)str + wcslen(str) - len;
    
        while(p >= str) {
            int len2 = wcslen(p);
            _Bool result = true;
            int i;
            for(i=0; i<len && i < len2; i++) {
                if(p[i] != search_str[i]) {
                    result = false;
                }
            }
            if(result) {
                return (p - str);
            }
    
            p--;
        }
    
        return default_value;
    }
    
    uniq wstring wchar_t*::reverse(const wchar_t* str) 
    {
        if(str == null) {
            return wstring("");
        }
        
        int len = wcslen(str);
        wstring result = new wchar_t[len + 1];
    
        for(int i=0; i<len; i++) {
            result[i] = str[len-i-1];
        }
    
        result[len] = '\0';
    
        return result;
    }
    
    uniq wstring wchar_t*::multiply(const wchar_t* str, int n)
    {
        if(str == null) {
            return wstring("");
        }
        
        int len = wcslen(str) * n + 1;
    
        wstring result = new wchar_t[len];
    
        result[0] = '\0';
    
        for(int i=0; i<n; i++) {
            wcscat(result, str);
        }
    
        return result;
    }
    
    uniq wstring wchar_t*::printable(const wchar_t* str)
    {
        if(str == null) {
            return wstring("");
        }
        int len = str.length();
        wstring result = new wchar_t[len*2+1];
    
        int n = 0;
        for(int i=0; i<len; i++) {
            wchar_t c = str[i];
    
            if((c >= 0 && c < ' ') 
                || c == 127)
            {
                result[n++] = '^';
                result[n++] = c + 'A' - 1;
            }
            else {
                result[n++] = c;
            }
        }
    
        result[n] = '\0'
    
        return result;
    }
    
    
    uniq int wchar_t*::compare(const wchar_t* left, wchar_t* right)
    {
        if(left == null) {
            if(right == null) {
                return 0;
            }
            else {
                return 1;
            }
        }
        else if(right == null) {
            if(left == null) {
                return 0;
            }
            else {
                return -1;
            }
        }
        return wcscmp(left, right);
    }
    
    uniq int wstring::compare(const wchar_t* left, const wchar_t* right)
    {
        if(left == null) {
            if(right == null) {
                return 0;
            }
            else {
                return 1;
            }
        }
        else if(right == null) {
            if(left == null) {
                return 0;
            }
            else {
                return -1;
            }
        }
        return wcscmp(left, right);
    }
    
    
    uniq _Bool wchar_t*::equals(const wchar_t left, wchar_t right)
    {
        return left == right;
    }
    
    
    uniq wstring wchar_t*::operator_mult(const wchar_t* str, int n)
    {
        return wchar_t*::multiply(str, n);
    }
    
    uniq wstring wstring::operator_mult(const wchar_t* str, int n)
    {
        return wchar_t*::multiply(str, n);
    }
    
    uniq _Bool wchar_t*::operator_equals(const wchar_t* left, const wchar_t* right)
    {
        return wcscmp(left, right) == 0;
    }
    
    uniq _Bool wstring::operator_equals(const wchar_t* left, const wchar_t* right)
    {
        return wcscmp(left, right) == 0;
    }
    
    uniq _Bool wchar_t*::operator_not_equals(const wchar_t* left, const wchar_t* right)
    {
        return wcscmp(left, right) != 0;
    }
    
    uniq _Bool wstring::operator_not_equals(const wchar_t* left, const wchar_t* right)
    {
        return wcscmp(left, right) != 0;
    }
    
    
    uniq wstring wchar_t*::operator_add(const wchar_t* left, const wchar_t* right)
    {
        if(left == null || right == null) {
            return wstring("");
        }
        wchar_t*% result = new wchar_t[wcslen(left) + wcslen(right) + 1];
        
        wcscpy(result, left);
        wcscat(result, right);
        
        return result;
    }
    
    uniq wstring wstring::operator_add(const wchar_t* left, const wchar_t* right)
    {
        if(left == null || right == null) {
            return wstring("");
        }
        wchar_t*% result = new wchar_t[wcslen(left) + wcslen(right) + 1];
        
        wcscpy(result, left);
        wcscat(result, right);
        
        return result;
    }
    
    uniq int char*::index(const char* str, const char* search_str, int default_value)
    {
        if(str == null || search_str == null) {
            return default_value;
        }
        char* head = strstr(str, search_str);
    
        if(head == null) {
            return default_value;
        }
    
        return head - str;
    }
    
    uniq string char*::replace(char* self, int index, char c)
    {
        if(self == null) {
            return string("");
        }
        int len = strlen(self);
    
        if(strcmp(self, "") == 0) {
            return string(self);
        }
        
        if(index < 0) {
           index += len;
        }
    
        if(index >= len) {
            index = len-1;
        }
    
        if(index < 0) {
            index = 0;
        }
        
        self[index] = c;
        
        return string(self);
    }
    
    uniq string char*::multiply(const char* str, int n)
    {
        if(str == null) {
            return string("");
        }
        int len = strlen(str) * n + 1;
    
        char*% result = new char[len];
    
        result[0] = '\0';
    
        for(int i=0; i<n; i++) {
            strcat(result, str);
        }
    
        return result;
    }
    
    uniq list<string>*% char*::split_str(const char* self, const char* str) 
    {
        if(self == null || str == null) {
            return new list<string>();
        }
        var result = new list<string>.initialize();
    
        var buf = new buffer.initialize();
    
        for(int i=0; i<self.length(); i++) {
            if(strstr(self + i, str) == self + i) {
                result.push_back(string(buf.buf));
                buf.reset();
                i += strlen(str)-1;
            }
            else {
                buf.append_char(self[i]);
            }
        }
        if(buf.length() != 0) {
            result.push_back(string(buf.buf));
        }
    
        return result;
    }
    
    uniq unsigned int wchar_t*::get_hash_key(const wchar_t* value)
    {
        if(value == null) {
            return 0;
        }
        int result = 0;
        wchar_t* p = (wchar_t*)value;
        while(*p) {
            result += (*p);
            p++;
        }
        return result;
    }
    
    uniq _Bool wchar_t*::equals(const wchar_t* left, const wchar_t* right)
    {
        if(left == null && right == null) {
            return true;
        }
        else if(left == null || right == null) {
            return false;
        }
        return wcscmp(left, right) == 0;
    }
    
    uniq _Bool wstring::equals(const wchar_t* left, const wchar_t* right)
    {
        if(left == null && right == null) {
            return true;
        }
        else if(left == null || right == null) {
            return false;
        }
        return wcscmp(left, right) == 0;
    }
    
    
    uniq _Bool wchar_t::operator_equals(wchar_t left, wchar_t right)
    {
        return left == right;
    }
    
    uniq _Bool wchar_t::operator_not_equals(wchar_t left, wchar_t right)
    {
        return left != right;
    }
    
    uniq unsigned int wchar_t::get_hash_key(wchar_t value)
    {
        return value;
    }
    
    uniq _Bool wchar_t::equals(wchar_t left, wchar_t right)
    {
        return left == right;
    }
    
    uniq string wchar_t::to_string(wchar_t wc)
    {
        return xsprintf("%ls", wc);
    }
    
    uniq string xrealpath(const char* path)
    {
        if(path == null) {
            return string("");
        }
        char* result = realpath(path, null);
    
        string result2 = string(result);
    
        free(result);
    
        return result2;
    }
    
    uniq string xdirname(const char* path)
    {
        if(path == null) {
            return string("");
        }
        return string(dirname(string(path)));
    }
    
    uniq size_t xwcslen(const wchar_t* wstr)
    {
        if(wstr == null) {
            return 0;
        }
        wchar_t* p = (wchar_t*)wstr;
        
        size_t len = 0;
        while(*p) {
            p++;
            len++;
        }
        
        return len;
    }
    
    uniq wstring wstring::substring(const wchar_t* str, int head, int tail) 
    {
        return wchar_t*::substring(str, head, tail);
    }
    
    uniq int string::index_count(const char* str, const char* search_str, int count=1, int default_value=-1)
    {
        return char*::index_count(str, search_str, count, default_value);
    }
    
    
    uniq int string::rindex(const char* str, const char* search_str, int default_value=-1) 
    {
        return char*::rindex(str, search_str, default_value);
    }
    
    uniq int string::rindex_count(const char* str, const char* search_str, int count=1, int default_value=-1)
    {
        return char*::rindex_count(str, search_str, count, default_value);
    }
    
    uniq string string::strip(const char* self)
    {
        return char*::strip(self);
    }
    
    uniq wstring string::to_wstring(const char* str)
    {
        return char*::to_wstring(str);
    }
    
    uniq string wstring::to_string(const wchar_t* wstr)
    {
        return wchar_t*::to_string(wstr);
    }
    
    uniq wstring int::to_wstring(int self)
    {
        return xsprintf("%d", self).to_wstring();
    }
    
uniq wstring wstring::delete(wchar_t* str, int head, int tail)
    {
        return wchar_t*::delete(str, head, tail);
    }
    
    uniq int wstring::index(const wchar_t* str, const wchar_t* search_str, int default_value=1)
    {
        return wchar_t*::index(str, search_str, default_value);
    }
    
    uniq int wstring::rindex(const wchar_t* str, const wchar_t* search_str, int default_value=-1)
    {
        return wchar_t*::rindex(str, search_str, default_value);
    }
    
    uniq wstring wstring::reverse(const wchar_t* str)
    {
        return wchar_t*::reverse(str);
    }
    
    uniq wstring wstring::multiply(const wchar_t* str, int n)
    {
        return wchar_t*::multiply(str, n);
    }
    
    uniq wstring wstring::printable(const wchar_t* str)
    {
        return wchar_t*::printable(str);
    }
    
    uniq unsigned int wstring::get_hash_key(const wchar_t* value)
    {
        return wchar_t*::get_hash_key(value);
    }
    
    
    uniq int string::index(const char* str, const char* search_str, int default_value=-1)
    {
        return char*::index(str, search_str, default_value);
    }
    
    uniq string string::replace(char* self, int index, char c)
    {
        return char*::replace(self, index, c);
    }
    
    uniq string string::multiply(const char* str, int n)
    {
        return char*::multiply(str, n);
    }
    
    uniq list<string>*% string::split_str(const char* self, const char* str)
    {
        return char*::split_str(self, str);
    }
    
    uniq wstring string::to_wstring(const char* str)
    {
        return char*::to_wstring(str);
    }
    
    uniq string char*::chomp(const char* str)
    {
        return string::chomp(str);
    }
    
    uniq _Bool wchar_t*::equals(const wchar_t* left, const wchar_t* right)
    {
        return wcscmp(left, right) == 0;
    }
    
    uniq _Bool wchar_t*::operator_equals(const wchar_t* left, const wchar_t* right)
    {
        return wcscmp(left, right) == 0;
    }
    
    uniq _Bool wchar_t*::operator_not_equals(const wchar_t* left, const wchar_t* right)
    {
        return wcscmp(left, right) != 0;
    }
#line 8253 "/usr/local/include/neo-c.h"




#line 8258 "/usr/local/include/neo-c.h"
    uniq buffer*% FILE*::read(FILE* f)
    {
        if(f == null) {
            return b"";
        }
        buffer*% buf = new buffer.initialize();
        
        while(1) {
            char buf2[8192];
            
            int size = fread(buf2, 1, 8192, f);
            
            buf.append(buf2, size);
    
            if(size < 8192) {
                break;
            }
        }
        
        return buf;
    }
    
    uniq int FILE*::write(FILE* f, const char* str)
    {
        if(f == null || str == null) {
            return -1;
        }
        
        return fwrite(str, strlen(str), 1, f);
    }
    
    uniq int FILE*::fclose(FILE* f) 
    {
        if(f == null) {
            return -1;
        }
        
        int result = fclose(f);
        
        if(result < 0) {
            return result;
        }
        
        return result;
    }
    
    uniq FILE* FILE*::fprintf(FILE* f, const char* msg, ...)
    {
        if(f == null || msg == null) {
            return f;
        }
        char msg2[1024*2*2*2];
    
        va_list` args;
        __builtin_va_start(args, msg);
        vsnprintf(msg2, 1024*2*2*2, msg, args);
        __builtin_va_end(args);
    
        int result = fprintf(f, "%s", msg2);
        
        if(result < 0) {
            return f;
        }
        
        return f;
    }
    
    uniq int char*::write(const char* self, const char* file_name, _Bool append=false) 
    {
        if(self == null || file_name == null) {
            return -1;
        }
        
        FILE* f;
        if(append) {
           f = fopen(file_name, "a");
        }
        else {
           f = fopen(file_name, "w");
        }
        
        if(f == ((void*)0)) {
            return -1;
        }
        
        int result = fwrite(self, strlen(self), 1, f);
        
        if(result != 1) {
            return result;
        }
        
        int result2 = fclose(f)
        
        if(result2 < 0) {
            return result2;
        }
        
        return result;
    }
    
    uniq buffer*% char*::read(const char* file_name) 
    {
        if(file_name == null) {
            return b"";
        }
        
        FILE* f = fopen(file_name, "r");
        
        if(f == ((void*)0)) {
            return b"";
        }
        
        buffer*% buf = new buffer.initialize();
        
        while(1) {
            char buf2[8192];
            
            int size = fread(buf2, 1, 8192, f);
            
            buf.append(buf2, size);
    
            if(size < 8192) {
                break;
            }
        }
        
        int result2 = fclose(f)
        
        if(result2 < 0) {
            return b"";
        }
        
        return buf;
    }
    
    uniq list<string>*% FILE*::readlines(FILE* f)
    {
        list<string>*% result = new list<string>.initialize();
        
        if(f == null) {
            return result;
        }
        
        while(1) {
            char buf[8192];
            
            if(fgets(buf, 8192, f) == ((void*)0)) {
                break;
            }
            
            result.push_back(string(buf));
        }
        
        return result;
    }
    
    uniq _Bool xiswalpha(wchar_t c)
    {
        _Bool result = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
        return result;
    }
    
    uniq _Bool xiswblank(wchar_t c)
    {
        return c == ' ' || c == '\t';
    }
    
    uniq _Bool xiswdigit(wchar_t c)
    {
        return (c >= '0' && c <= '9');
    }
    
    uniq _Bool xiswalnum(wchar_t c)
    {
        return xiswalpha(c) || xiswdigit(c);
    }
    
    uniq _Bool xiswascii(wchar_t c)
    {
        _Bool result = (c >= ' ' && c <= '~');
        return result;
    }
#line 8441 "/usr/local/include/neo-c.h"
#line 3 "../code6/c_test_compat197.nc"
